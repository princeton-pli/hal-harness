[{"article": "---\ntags:\n  - Translated\ne_maxx_link: intersecting_segments\n---\n\n# Search for a pair of intersecting segments\n\nGiven $n$ line segments on the plane. It is required to check whether at least two of them intersect with each other.\nIf the answer is yes, then print this pair of intersecting segments; it is enough to choose any of them among several answers.\n\nThe naive solution algorithm is to iterate over all pairs of segments in $O(n^2)$ and check for each pair whether they intersect or not. This article describes an algorithm with the runtime time $O(n \\log n)$, which is based on the **sweep line algorithm**.\n\n## Algorithm\n\nLet's draw a vertical line $x = -\\infty$ mentally and start moving this line to the right.\nIn the course of its movement, this line will meet with segments, and at each time a segment intersect with our line it intersects in exactly one point (we will assume that there are no vertical segments).\n\n<center>![sweep line and line segment intersection](sweep_line_1.png)</center>\n\nThus, for each segment, at some point in time, its point will appear on the sweep line, then with the movement of the line, this point will move, and finally, at some point, the segment will disappear from the line.\n\nWe are interested in the **relative order of the segments** along the vertical.\nNamely, we will store a list of segments crossing the sweep line at a given time, where the segments will be sorted by their $y$-coordinate on the sweep line.\n\n<center>![relative order of the segments across sweep line](sweep_line_2.png)</center>\n\nThis order is interesting because intersecting segments will have the same $y$-coordinate at least at one time:\n\n<center>![intersection point having same y-coordinate](sweep_line_3.png)</center>\n\nWe formulate key statements:\n\n  - To find an intersecting pair, it is sufficient to consider **only adjacent segments** at each fixed position of the sweep line.\n  - It is enough to consider the sweep line not in all possible real positions $(-\\infty \\ldots +\\infty)$, but **only in those positions when new segments appear or old ones disappear**. In other words, it is enough to limit yourself only to the positions equal to the abscissas of the end points of the segments.\n  - When a new line segment appears, it is enough to **insert** it to the desired location in the list obtained for the previous sweep line. We should only check for the intersection of the **added segment with its immediate neighbors in the list above and below**.\n  - If the segment disappears, it is enough to **remove** it from the current list. After that, it is necessary **check for the intersection of the upper and lower neighbors in the list**.\n  - Other changes in the sequence of segments in the list, except for those described, do not exist. No other intersection checks are required.\n\nTo understand the truth of these statements, the following remarks are sufficient:\n\n  - Two disjoint segments never change their **relative order**.<br>\n    In fact, if one segment was first higher than the other, and then became lower, then between these two moments there was an intersection of these two segments.\n  - Two non-intersecting segments also cannot have the same $y$-coordinates.\n  - From this it follows that at the moment of the segment appearance we can find the position for this segment in the queue, and we will not have to rearrange this segment in the queue any more: **its order relative to other segments in the queue will not change**.\n  - Two intersecting segments at the moment of their intersection point will be neighbors of each other in the queue.\n  - Therefore, for finding pairs of intersecting line segments is sufficient to check the intersection of all and only those pairs of segments that sometime during the movement of the sweep line at least once were neighbors to each other. <br>\n    It is easy to notice that it is enough only to check the added segment with its upper and lower neighbors, as well as when removing the segment \u2014 its upper and lower neighbors (which after removal will become neighbors of each other).<br>\n  - It should be noted that at a fixed position of the sweep line, we must **first add all the segments** that start at this x-coordinate, and only **then remove all the segments** that end here.<br>\n    Thus, we do not miss the intersection of segments on the vertex: i.e. such cases when two segments have a common vertex.\n  - Note that **vertical segments** do not actually affect the correctness of the algorithm.<br>\n    These segments are distinguished by the fact that they appear and disappear at the same time. However, due to the previous comment, we know that all segments will be added to the queue first, and only then they will be deleted. Therefore, if the vertical segment intersects with some other segment opened at that moment (including the vertical one), it will be detected.<br>\n    **In what place of the queue to place vertical segments?** After all, a vertical segment does not have one specific $y$-coordinate, it extends for an entire segment along the $y$-coordinate. However, it is easy to understand that any coordinate from this segment can be taken as a $y$-coordinate.\n\nThus, the entire algorithm will perform no more than $2n$ tests on the intersection of a pair of segments, and will perform $O(n)$ operations with a queue of segments ($O(1)$ operations at the time of appearance and disappearance of each segment).\n\nThe final **asymptotic behavior of the algorithm** is thus $O(n \\log n)$.\n\n## Implementation\n\nWe present the full implementation of the described algorithm:\n\n```cpp\nconst double EPS = 1E-9;\n\nstruct pt {\n    double x, y;\n};\n\nstruct seg {\n    pt p, q;\n    int id;\n\n    double get_y(double x) const {\n        if (abs(p.x - q.x) < EPS)\n            return p.y;\n        return p.y + (q.y - p.y) * (x - p.x) / (q.x - p.x);\n    }\n};\n\nbool intersect1d(double l1, double r1, double l2, double r2) {\n    if (l1 > r1)\n        swap(l1, r1);\n    if (l2 > r2)\n        swap(l2, r2);\n    return max(l1, l2) <= min(r1, r2) + EPS;\n}\n\nint vec(const pt& a, const pt& b, const pt& c) {\n    double s = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    return abs(s) < EPS ? 0 : s > 0 ? +1 : -1;\n}\n\nbool intersect(const seg& a, const seg& b)\n{\n    return intersect1d(a.p.x, a.q.x, b.p.x, b.q.x) &&\n           intersect1d(a.p.y, a.q.y, b.p.y, b.q.y) &&\n           vec(a.p, a.q, b.p) * vec(a.p, a.q, b.q) <= 0 &&\n           vec(b.p, b.q, a.p) * vec(b.p, b.q, a.q) <= 0;\n}\n\nbool operator<(const seg& a, const seg& b)\n{\n    double x = max(min(a.p.x, a.q.x), min(b.p.x, b.q.x));\n    return a.get_y(x) < b.get_y(x) - EPS;\n}\n\nstruct event {\n    double x;\n    int tp, id;\n\n    event() {}\n    event(double x, int tp, int id) : x(x), tp(tp), id(id) {}\n\n    bool operator<(const event& e) const {\n        if (abs(x - e.x) > EPS)\n            return x < e.x;\n        return tp > e.tp;\n    }\n};\n\nset<seg> s;\nvector<set<seg>::iterator> where;\n\nset<seg>::iterator prev(set<seg>::iterator it) {\n    return it == s.begin() ? s.end() : --it;\n}\n\nset<seg>::iterator next(set<seg>::iterator it) {\n    return ++it;\n}\n\npair<int, int> solve(const vector<seg>& a) {\n    int n = (int)a.size();\n    vector<event> e;\n    for (int i = 0; i < n; ++i) {\n        e.push_back(event(min(a[i].p.x, a[i].q.x), +1, i));\n        e.push_back(event(max(a[i].p.x, a[i].q.x), -1, i));\n    }\n    sort(e.begin(), e.end());\n\n    s.clear();\n    where.resize(a.size());\n    for (size_t i = 0; i < e.size(); ++i) {\n        int id = e[i].id;\n        if (e[i].tp == +1) {\n            set<seg>::iterator nxt = s.lower_bound(a[id]), prv = prev(nxt);\n            if (nxt != s.end() && intersect(*nxt, a[id]))\n                return make_pair(nxt->id, id);\n            if (prv != s.end() && intersect(*prv, a[id]))\n                return make_pair(prv->id, id);\n            where[id] = s.insert(nxt, a[id]);\n        } else {\n            set<seg>::iterator nxt = next(where[id]), prv = prev(where[id]);\n            if (nxt != s.end() && prv != s.end() && intersect(*nxt, *prv))\n                return make_pair(prv->id, nxt->id);\n            s.erase(where[id]);\n        }\n    }\n\n    return make_pair(-1, -1);\n}\n```\n\nThe main function here is `solve()`, which returns the number of found intersecting segments, or $(-1, -1)$, if there are no intersections.\n\nChecking for the intersection of two segments is carried out by the `intersect ()` function, using an **algorithm based on the oriented area of the triangle**.\n\nThe queue of segments is the global variable `s`, a `set<event>`. Iterators that specify the position of each segment in the queue (for convenient removal of segments from the queue) are stored in the global array `where`.\n\nTwo auxiliary functions `prev()` and `next()` are also introduced, which return iterators to the previous and next elements (or `end()`, if one does not exist).\n\nThe constant `EPS` denotes the error of comparing two real numbers (it is mainly used when checking two segments for intersection).\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: intersecting_segments\n---\n\n# Search for a pair of intersecting segments\n\nGiven $n$ line segments on the plane. It is required to check whether at least two of them intersect with each other.\nIf the answer is yes, then print this pair of intersecting segments; it is enough to choose any of them among several answers.\n\nThe naive solution algorithm is to iterate over all pairs of segments in $O(n^2)$ and check for each pair whether they intersect or not. This article describes an algorithm with the runtime time $O(n \\log n)$, which is based on the **sweep line algorithm**.\n\n## Algorithm\n\nLet's draw a vertical line $x = -\\infty$ mentally and start moving this line to the right.\nIn the course of its movement, this line will meet with segments, and at each time a segment intersect with our line it intersects in exactly one point (we will assume that there are no vertical segments).\n\n<center>![sweep line and line segment intersection](sweep_line_1.png)</center>\n\nThus, for each segment, at some point in time, its point will appear on the sweep line, then with the movement of the line, this point will move, and finally, at some point, the segment will disappear from the line.\n\nWe are interested in the **relative order of the segments** along the vertical.\nNamely, we will store a list of segments crossing the sweep line at a given time, where the segments will be sorted by their $y$-coordinate on the sweep line.\n\n<center>![relative order of the segments across sweep line](sweep_line_2.png)</center>\n\nThis order is interesting because intersecting segments will have the same $y$-coordinate at least at one time:\n\n<center>![intersection point having same y-coordinate](sweep_line_3.png)</center>\n\nWe formulate key statements:\n\n  - To find an intersecting pair, it is sufficient to consider **only adjacent segments** at each fixed position of the sweep line.\n  - It is enough to consider the sweep line not in all possible real positions $(-\\infty \\ldots +\\infty)$, but **only in those positions when new segments appear or old ones disappear**. In other words, it is enough to limit yourself only to the positions equal to the abscissas of the end points of the segments.\n  - When a new line segment appears, it is enough to **insert** it to the desired location in the list obtained for the previous sweep line. We should only check for the intersection of the **added segment with its immediate neighbors in the list above and below**.\n  - If the segment disappears, it is enough to **remove** it from the current list. After that, it is necessary **check for the intersection of the upper and lower neighbors in the list**.\n  - Other changes in the sequence of segments in the list, except for those described, do not exist. No other intersection checks are required.\n\nTo understand the truth of these statements, the following remarks are sufficient:\n\n  - Two disjoint segments never change their **relative order**.<br>\n    In fact, if one segment was first higher than the other, and then became lower, then between these two moments there was an intersection of these two segments.\n  - Two non-intersecting segments also cannot have the same $y$-coordinates.\n  - From this it follows that at the moment of the segment appearance we can find the position for this segment in the queue, and we will not have to rearrange this segment in the queue any more: **its order relative to other segments in the queue will not change**.\n  - Two intersecting segments at the moment of their intersection point will be neighbors of each other in the queue.\n  - Therefore, for finding pairs of intersecting line segments is sufficient to check the intersection of all and only those pairs of segments that sometime during the movement of the sweep line at least once were neighbors to each other. <br>\n    It is easy to notice that it is enough only to check the added segment with its upper and lower neighbors, as well as when removing the segment \u2014 its upper and lower neighbors (which after removal will become neighbors of each other).<br>\n  - It should be noted that at a fixed position of the sweep line, we must **first add all the segments** that start at this x-coordinate, and only **then remove all the segments** that end here.<br>\n    Thus, we do not miss the intersection of segments on the vertex: i.e. such cases when two segments have a common vertex.\n  - Note that **vertical segments** do not actually affect the correctness of the algorithm.<br>\n    These segments are distinguished by the fact that they appear and disappear at the same time. However, due to the previous comment, we know that all segments will be added to the queue first, and only then they will be deleted. Therefore, if the vertical segment intersects with some other segment opened at that moment (including the vertical one), it will be detected.<br>\n    **In what place of the queue to place vertical segments?** After all, a vertical segment does not have one specific $y$-coordinate, it extends for an entire segment along the $y$-coordinate. However, it is easy to understand that any coordinate from this segment can be taken as a $y$-coordinate.\n\nThus, the entire algorithm will perform no more than $2n$ tests on the intersection of a pair of segments, and will perform $O(n)$ operations with a queue of segments ($O(1)$ operations at the time of appearance and disappearance of each segment).\n\nThe final **asymptotic behavior of the algorithm** is thus $O(n \\log n)$.\n\n## Implementation\n\nWe present the full implementation of the described algorithm:\n\n```cpp\nconst double EPS = 1E-9;\n\nstruct pt {\n    double x, y;\n};\n\nstruct seg {\n    pt p, q;\n    int id;\n\n    double get_y(double x) const {\n        if (abs(p.x - q.x) < EPS)\n            return p.y;\n        return p.y + (q.y - p.y) * (x - p.x) / (q.x - p.x);\n    }\n};\n\nbool intersect1d(double l1, double r1, double l2, double r2) {\n    if (l1 > r1)\n        swap(l1, r1);\n    if (l2 > r2)\n        swap(l2, r2);\n    return max(l1, l2) <= min(r1, r2) + EPS;\n}\n\nint vec(const pt& a, const pt& b, const pt& c) {\n    double s = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    return abs(s) < EPS ? 0 : s > 0 ? +1 : -1;\n}\n\nbool intersect(const seg& a, const seg& b)\n{\n    return intersect1d(a.p.x, a.q.x, b.p.x, b.q.x) &&\n           intersect1d(a.p.y, a.q.y, b.p.y, b.q.y) &&\n           vec(a.p, a.q, b.p) * vec(a.p, a.q, b.q) <= 0 &&\n           vec(b.p, b.q, a.p) * vec(b.p, b.q, a.q) <= 0;\n}\n\nbool operator<(const seg& a, const seg& b)\n{\n    double x = max(min(a.p.x, a.q.x), min(b.p.x, b.q.x));\n    return a.get_y(x) < b.get_y(x) - EPS;\n}\n\nstruct event {\n    double x;\n    int tp, id;\n\n    event() {}\n    event(double x, int tp, int id) : x(x), tp(tp), id(id) {}\n\n    bool operator<(const event& e) const {\n        if (abs(x - e.x) > EPS)\n            return x < e.x;\n        return tp > e.tp;\n    }\n};\n\nset<seg> s;\nvector<set<seg>::iterator> where;\n\nset<seg>::iterator prev(set<seg>::iterator it) {\n    return it == s.begin() ? s.end() : --it;\n}\n\nset<seg>::iterator next(set<seg>::iterator it) {\n    return ++it;\n}\n\npair<int, int> solve(const vector<seg>& a) {\n    int n = (int)a.size();\n    vector<event> e;\n    for (int i = 0; i < n; ++i) {\n        e.push_back(event(min(a[i].p.x, a[i].q.x), +1, i));\n        e.push_back(event(max(a[i].p.x, a[i].q.x), -1, i));\n    }\n    sort(e.begin(), e.end());\n\n    s.clear();\n    where.resize(a.size());\n    for (size_t i = 0; i < e.size(); ++i) {\n        int id = e[i].id;\n        if (e[i].tp == +1) {\n            set<seg>::iterator nxt = s.lower_bound(a[id]), prv = prev(nxt);\n            if (nxt != s.end() && intersect(*nxt, a[id]))\n                return make_pair(nxt->id, id);\n            if (prv != s.end() && intersect(*prv, a[id]))\n                return make_pair(prv->id, id);\n            where[id] = s.insert(nxt, a[id]);\n        } else {\n            set<seg>::iterator nxt = next(where[id]), prv = prev(where[id]);\n            if (nxt != s.end() && prv != s.end() && intersect(*nxt, *prv))\n                return make_pair(prv->id, nxt->id);\n            s.erase(where[id]);\n        }\n    }\n\n    return make_pair(-1, -1);\n}\n```\n\nThe main function here is `solve()`, which returns the number of found intersecting segments, or $(-1, -1)$, if there are no intersections.\n\nChecking for the intersection of two segments is carried out by the `intersect ()` function, using an **algorithm based on the oriented area of the triangle**.\n\nThe queue of segments is the global variable `s`, a `set<event>`. Iterators that specify the position of each segment in the queue (for convenient removal of segments from the queue) are stored in the global array `where`.\n\nTwo auxiliary functions `prev()` and `next()` are also introduced, which return iterators to the previous and next elements (or `end()`, if one does not exist).\n\nThe constant `EPS` denotes the error of comparing two real numbers (it is mainly used when checking two segments for intersection).\n\n## Problems\n * [TIMUS 1469 No Smoking!](https://acm.timus.ru/problem.aspx?space=1&num=1469)\n", "problem_ids": [], "title": "Search for a pair of intersecting segments"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: segments_intersection_checking\n---\n\n# Check if two segments intersect\n\nYou are given two segments $(a, b)$ and $(c, d)$.\nYou have to check if they intersect.\nOf course, you may find their intersection and check if it isn't empty, but this can't be done in integers for segments with integer coordinates.\nThe approach described here can work in integers.\n\n## Algorithm\n\nFirstly, consider the case when the segments are part of the same line.\nIn this case it is sufficient to check if their projections on $Ox$ and $Oy$ intersect.\nIn the other case $a$ and $b$ must not lie on the same side of line $(c, d)$, and $c$ and $d$ must not lie on the same side of line $(a, b)$.\nIt can be checked with a couple of cross products.\n\n## Implementation\n\nThe given algorithm is implemented for integer points. Of course, it can be easily modified to work with doubles.\n\n```{.cpp file=check-segments-inter}\nstruct pt {\n    long long x, y;\n    pt() {}\n    pt(long long _x, long long _y) : x(_x), y(_y) {}\n    pt operator-(const pt& p) const { return pt(x - p.x, y - p.y); }\n    long long cross(const pt& p) const { return x * p.y - y * p.x; }\n    long long cross(const pt& a, const pt& b) const { return (a - *this).cross(b - *this); }\n};\n\nint sgn(const long long& x) { return x >= 0 ? x ? 1 : 0 : -1; }\n\nbool inter1(long long a, long long b, long long c, long long d) {\n    if (a > b)\n        swap(a, b);\n    if (c > d)\n        swap(c, d);\n    return max(a, c) <= min(b, d);\n}\n\nbool check_inter(const pt& a, const pt& b, const pt& c, const pt& d) {\n    if (c.cross(a, d) == 0 && c.cross(b, d) == 0)\n        return inter1(a.x, b.x, c.x, d.x) && inter1(a.y, b.y, c.y, d.y);\n    return sgn(a.cross(b, c)) != sgn(a.cross(b, d)) &&\n           sgn(c.cross(d, a)) != sgn(c.cross(d, b));\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: segments_intersection_checking\n---\n\n# Check if two segments intersect\n\nYou are given two segments $(a, b)$ and $(c, d)$.\nYou have to check if they intersect.\nOf course, you may find their intersection and check if it isn't empty, but this can't be done in integers for segments with integer coordinates.\nThe approach described here can work in integers.\n\n## Algorithm\n\nFirstly, consider the case when the segments are part of the same line.\nIn this case it is sufficient to check if their projections on $Ox$ and $Oy$ intersect.\nIn the other case $a$ and $b$ must not lie on the same side of line $(c, d)$, and $c$ and $d$ must not lie on the same side of line $(a, b)$.\nIt can be checked with a couple of cross products.\n\n## Implementation\n\nThe given algorithm is implemented for integer points. Of course, it can be easily modified to work with doubles.\n\n```{.cpp file=check-segments-inter}\nstruct pt {\n    long long x, y;\n    pt() {}\n    pt(long long _x, long long _y) : x(_x), y(_y) {}\n    pt operator-(const pt& p) const { return pt(x - p.x, y - p.y); }\n    long long cross(const pt& p) const { return x * p.y - y * p.x; }\n    long long cross(const pt& a, const pt& b) const { return (a - *this).cross(b - *this); }\n};\n\nint sgn(const long long& x) { return x >= 0 ? x ? 1 : 0 : -1; }\n\nbool inter1(long long a, long long b, long long c, long long d) {\n    if (a > b)\n        swap(a, b);\n    if (c > d)\n        swap(c, d);\n    return max(a, c) <= min(b, d);\n}\n\nbool check_inter(const pt& a, const pt& b, const pt& c, const pt& d) {\n    if (c.cross(a, d) == 0 && c.cross(b, d) == 0)\n        return inter1(a.x, b.x, c.x, d.x) && inter1(a.y, b.y, c.y, d.y);\n    return sgn(a.cross(b, c)) != sgn(a.cross(b, d)) &&\n           sgn(c.cross(d, a)) != sgn(c.cross(d, b));\n}\n```\n", "problem_ids": [], "title": "Check if two segments intersect"}, {"article": "---\ntags:\n  - Original\n---\n\n# Convex hull trick and Li Chao tree\n\nConsider the following problem. There are $n$ cities. You want to travel from city $1$ to city $n$ by car. To do this you have to buy some gasoline. It is known that a liter of gasoline costs $cost_k$ in the $k^{th}$ city. Initially your fuel tank is empty and you spend one liter of gasoline per kilometer. Cities are located on the same line in ascending order with $k^{th}$ city having coordinate $x_k$. Also you have to pay $toll_k$ to enter $k^{th}$ city. Your task is to make the trip with minimum possible cost. It's obvious that the solution can be calculated via dynamic programming:\n\n$$dp_i = toll_i+\\min\\limits_{j<i}(cost_j \\cdot (x_i - x_j)+dp_j)$$\n\nNaive approach will give you $O(n^2)$ complexity which can be improved to $O(n \\log n)$ or $O(n \\log [C \\varepsilon^{-1}])$ where $C$ is largest possible $|x_i|$ and $\\varepsilon$ is precision with which $x_i$ is considered ($\\varepsilon = 1$ for integers which is usually the case). To do this one should note that the problem can be reduced to adding linear functions $k \\cdot x + b$ to the set and finding minimum value of the functions in some particular point $x$. There are two main approaches one can use here.\n\n## Convex hull trick\n\nThe idea of this approach is to maintain a lower convex hull of linear functions.\nActually it would be a bit more convenient to consider them not as linear functions, but as points $(k;b)$ on the plane such that we will have to find the point which has the least dot product with a given point $(x;1)$, that is, for this point $kx+b$ is minimized which is the same as initial problem.\nSuch minimum will necessarily be on lower convex envelope of these points as can be seen below:\n\n<center> ![lower convex hull](convex_hull_trick.png) </center>\n\nOne has to keep points on the convex hull and normal vectors of the hull's edges.\nWhen you have a $(x;1)$ query you'll have to find the normal vector closest to it in terms of angles between them, then the optimum linear function will correspond to one of its endpoints.\nTo see that, one should note that points having a constant dot product with $(x;1)$ lie on a line which is orthogonal to $(x;1)$, so the optimum linear function will be the one in which tangent to convex hull which is collinear with normal to $(x;1)$ touches the hull.\nThis point is the one such that normals of edges lying to the left and to the right of it are headed in different sides of $(x;1)$.\n\nThis approach is useful when queries of adding linear functions are monotone in terms of $k$ or if we work offline, i.e. we may firstly add all linear functions and answer queries afterwards.\nSo we cannot solve the cities/gasoline problems using this way.\nThat would require handling online queries.\nWhen it comes to deal with online queries however, things will go tough and one will have to use some kind of set data structure to implement a proper convex hull.\nOnline approach will however not be considered in this article due to its hardness and because second approach (which is Li Chao tree) allows to solve the problem way more simply.\nWorth mentioning that one can still use this approach online without complications by square-root-decomposition.\nThat is, rebuild convex hull from scratch each $\\sqrt n$ new lines. \n\nTo implement this approach one should begin with some geometric utility functions, here we suggest to use the C++ complex number type.\n\n```cpp\ntypedef int ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n \nftype dot(point a, point b) {\n\treturn (conj(a) * b).x();\n}\n \nftype cross(point a, point b) {\n\treturn (conj(a) * b).y();\n}\n```\n\nHere we will assume that when linear functions are added, their $k$ only increases and we want to find minimum values.\nWe will keep points in vector $hull$ and normal vectors in vector $vecs$.\nWhen we add a new point, we have to look at the angle formed between last edge in convex hull and vector from last point in convex hull to new point.\nThis angle has to be directed counter-clockwise, that is the dot product of the last normal vector in the hull (directed inside hull) and the vector from the last point to the new one has to be non-negative.\nAs long as this isn't true, we should erase the last point in the convex hull alongside with the corresponding edge.\n\n```cpp\nvector<point> hull, vecs;\n \nvoid add_line(ftype k, ftype b) {\n    point nw = {k, b};\n    while(!vecs.empty() && dot(vecs.back(), nw - hull.back()) < 0) {\n        hull.pop_back();\n        vecs.pop_back();\n    }\n    if(!hull.empty()) {\n        vecs.push_back(1i * (nw - hull.back()));\n    }\n    hull.push_back(nw);\n}\n \n```\nNow to get the minimum value in some point we will find the first normal vector in the convex hull that is directed counter-clockwise from $(x;1)$. The left endpoint of such edge will be the answer. To check if vector $a$ is not directed counter-clockwise of vector $b$, we should check if their cross product $[a,b]$ is positive.\n```cpp\nint get(ftype x) {\n    point query = {x, 1};\n    auto it = lower_bound(vecs.begin(), vecs.end(), query, [](point a, point b) {\n        return cross(a, b) > 0;\n    });\n    return dot(query, hull[it - vecs.begin()]);\n}\n```\n\n## Li Chao tree\n\nAssume you're given a set of functions such that each two can intersect at most once. Let's keep in each vertex of a segment tree some function in such way, that if we go from root to the leaf it will be guaranteed that one of the functions we met on the path will be the one giving the minimum value in that leaf. Let's see how to construct it.\n\nAssume we're in some vertex corresponding to half-segment $[l,r)$ and the function $f_{old}$ is kept there and we add the function $f_{new}$. Then the intersection point will be either in $[l;m)$ or in $[m;r)$ where $m=\\left\\lfloor\\tfrac{l+r}{2}\\right\\rfloor$. We can efficiently find that out by comparing the values of the functions in points $l$ and $m$. If the dominating function changes, then it is in $[l;m)$ otherwise it is in $[m;r)$. Now for the half of the segment with no intersection we will pick the lower function and write it in the current vertex. You can see that it will always be the one which is lower in point $m$. After that we recursively go to the other half of the segment with the function which was the upper one. As you can see this will keep correctness on the first half of segment and in the other one correctness will be maintained during the recursive call. Thus we can add functions and check the minimum value in the point in $O(\\log [C\\varepsilon^{-1}])$.\n\nHere is the illustration of what is going on in the vertex when we add new function:\n\n<center>![Li Chao Tree vertex](li_chao_vertex.png)</center>\n\nLet's go to implementation now. Once again we will use complex numbers to keep linear functions.\n\n```{.cpp file=lichaotree_line_definition}\ntypedef long long ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n \nftype dot(point a, point b) {\n    return (conj(a) * b).x();\n}\n \nftype f(point a,  ftype x) {\n    return dot(a, {x, 1});\n}\n```\nWe will keep functions in the array $line$ and use binary indexing of the segment tree. If you want to use it on large numbers or doubles, you should use a dynamic segment tree. \nThe segment tree should be initialized with default values, e.g. with lines $0x + \\infty$.\n\n```{.cpp file=lichaotree_addline}\nconst int maxn = 2e5;\n \npoint line[4 * maxn];\n \nvoid add_line(point nw, int v = 1, int l = 0, int r = maxn) {\n    int m = (l + r) / 2;\n    bool lef = f(nw, l) < f(line[v], l);\n    bool mid = f(nw, m) < f(line[v], m);\n    if(mid) {\n        swap(line[v], nw);\n    }\n    if(r - l == 1) {\n        return;\n    } else if(lef != mid) {\n        add_line(nw, 2 * v, l, m);\n    } else {\n        add_line(nw, 2 * v + 1, m, r);\n    }\n}\n```\nNow to get the minimum in some point $x$ we simply choose the minimum value along the path to the point.\n```{.cpp file=lichaotree_getminimum}\nftype get(int x, int v = 1, int l = 0, int r = maxn) {\n    int m = (l + r) / 2;\n    if(r - l == 1) {\n        return f(line[v], x);\n    } else if(x < m) {\n        return min(f(line[v], x), get(x, 2 * v, l, m));\n    } else {\n        return min(f(line[v], x), get(x, 2 * v + 1, m, r));\n    }\n}\n```\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Convex hull trick and Li Chao tree\n\nConsider the following problem. There are $n$ cities. You want to travel from city $1$ to city $n$ by car. To do this you have to buy some gasoline. It is known that a liter of gasoline costs $cost_k$ in the $k^{th}$ city. Initially your fuel tank is empty and you spend one liter of gasoline per kilometer. Cities are located on the same line in ascending order with $k^{th}$ city having coordinate $x_k$. Also you have to pay $toll_k$ to enter $k^{th}$ city. Your task is to make the trip with minimum possible cost. It's obvious that the solution can be calculated via dynamic programming:\n\n$$dp_i = toll_i+\\min\\limits_{j<i}(cost_j \\cdot (x_i - x_j)+dp_j)$$\n\nNaive approach will give you $O(n^2)$ complexity which can be improved to $O(n \\log n)$ or $O(n \\log [C \\varepsilon^{-1}])$ where $C$ is largest possible $|x_i|$ and $\\varepsilon$ is precision with which $x_i$ is considered ($\\varepsilon = 1$ for integers which is usually the case). To do this one should note that the problem can be reduced to adding linear functions $k \\cdot x + b$ to the set and finding minimum value of the functions in some particular point $x$. There are two main approaches one can use here.\n\n## Convex hull trick\n\nThe idea of this approach is to maintain a lower convex hull of linear functions.\nActually it would be a bit more convenient to consider them not as linear functions, but as points $(k;b)$ on the plane such that we will have to find the point which has the least dot product with a given point $(x;1)$, that is, for this point $kx+b$ is minimized which is the same as initial problem.\nSuch minimum will necessarily be on lower convex envelope of these points as can be seen below:\n\n<center> ![lower convex hull](convex_hull_trick.png) </center>\n\nOne has to keep points on the convex hull and normal vectors of the hull's edges.\nWhen you have a $(x;1)$ query you'll have to find the normal vector closest to it in terms of angles between them, then the optimum linear function will correspond to one of its endpoints.\nTo see that, one should note that points having a constant dot product with $(x;1)$ lie on a line which is orthogonal to $(x;1)$, so the optimum linear function will be the one in which tangent to convex hull which is collinear with normal to $(x;1)$ touches the hull.\nThis point is the one such that normals of edges lying to the left and to the right of it are headed in different sides of $(x;1)$.\n\nThis approach is useful when queries of adding linear functions are monotone in terms of $k$ or if we work offline, i.e. we may firstly add all linear functions and answer queries afterwards.\nSo we cannot solve the cities/gasoline problems using this way.\nThat would require handling online queries.\nWhen it comes to deal with online queries however, things will go tough and one will have to use some kind of set data structure to implement a proper convex hull.\nOnline approach will however not be considered in this article due to its hardness and because second approach (which is Li Chao tree) allows to solve the problem way more simply.\nWorth mentioning that one can still use this approach online without complications by square-root-decomposition.\nThat is, rebuild convex hull from scratch each $\\sqrt n$ new lines. \n\nTo implement this approach one should begin with some geometric utility functions, here we suggest to use the C++ complex number type.\n\n```cpp\ntypedef int ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n \nftype dot(point a, point b) {\n\treturn (conj(a) * b).x();\n}\n \nftype cross(point a, point b) {\n\treturn (conj(a) * b).y();\n}\n```\n\nHere we will assume that when linear functions are added, their $k$ only increases and we want to find minimum values.\nWe will keep points in vector $hull$ and normal vectors in vector $vecs$.\nWhen we add a new point, we have to look at the angle formed between last edge in convex hull and vector from last point in convex hull to new point.\nThis angle has to be directed counter-clockwise, that is the dot product of the last normal vector in the hull (directed inside hull) and the vector from the last point to the new one has to be non-negative.\nAs long as this isn't true, we should erase the last point in the convex hull alongside with the corresponding edge.\n\n```cpp\nvector<point> hull, vecs;\n \nvoid add_line(ftype k, ftype b) {\n    point nw = {k, b};\n    while(!vecs.empty() && dot(vecs.back(), nw - hull.back()) < 0) {\n        hull.pop_back();\n        vecs.pop_back();\n    }\n    if(!hull.empty()) {\n        vecs.push_back(1i * (nw - hull.back()));\n    }\n    hull.push_back(nw);\n}\n \n```\nNow to get the minimum value in some point we will find the first normal vector in the convex hull that is directed counter-clockwise from $(x;1)$. The left endpoint of such edge will be the answer. To check if vector $a$ is not directed counter-clockwise of vector $b$, we should check if their cross product $[a,b]$ is positive.\n```cpp\nint get(ftype x) {\n    point query = {x, 1};\n    auto it = lower_bound(vecs.begin(), vecs.end(), query, [](point a, point b) {\n        return cross(a, b) > 0;\n    });\n    return dot(query, hull[it - vecs.begin()]);\n}\n```\n\n## Li Chao tree\n\nAssume you're given a set of functions such that each two can intersect at most once. Let's keep in each vertex of a segment tree some function in such way, that if we go from root to the leaf it will be guaranteed that one of the functions we met on the path will be the one giving the minimum value in that leaf. Let's see how to construct it.\n\nAssume we're in some vertex corresponding to half-segment $[l,r)$ and the function $f_{old}$ is kept there and we add the function $f_{new}$. Then the intersection point will be either in $[l;m)$ or in $[m;r)$ where $m=\\left\\lfloor\\tfrac{l+r}{2}\\right\\rfloor$. We can efficiently find that out by comparing the values of the functions in points $l$ and $m$. If the dominating function changes, then it is in $[l;m)$ otherwise it is in $[m;r)$. Now for the half of the segment with no intersection we will pick the lower function and write it in the current vertex. You can see that it will always be the one which is lower in point $m$. After that we recursively go to the other half of the segment with the function which was the upper one. As you can see this will keep correctness on the first half of segment and in the other one correctness will be maintained during the recursive call. Thus we can add functions and check the minimum value in the point in $O(\\log [C\\varepsilon^{-1}])$.\n\nHere is the illustration of what is going on in the vertex when we add new function:\n\n<center>![Li Chao Tree vertex](li_chao_vertex.png)</center>\n\nLet's go to implementation now. Once again we will use complex numbers to keep linear functions.\n\n```{.cpp file=lichaotree_line_definition}\ntypedef long long ftype;\ntypedef complex<ftype> point;\n#define x real\n#define y imag\n \nftype dot(point a, point b) {\n    return (conj(a) * b).x();\n}\n \nftype f(point a,  ftype x) {\n    return dot(a, {x, 1});\n}\n```\nWe will keep functions in the array $line$ and use binary indexing of the segment tree. If you want to use it on large numbers or doubles, you should use a dynamic segment tree. \nThe segment tree should be initialized with default values, e.g. with lines $0x + \\infty$.\n\n```{.cpp file=lichaotree_addline}\nconst int maxn = 2e5;\n \npoint line[4 * maxn];\n \nvoid add_line(point nw, int v = 1, int l = 0, int r = maxn) {\n    int m = (l + r) / 2;\n    bool lef = f(nw, l) < f(line[v], l);\n    bool mid = f(nw, m) < f(line[v], m);\n    if(mid) {\n        swap(line[v], nw);\n    }\n    if(r - l == 1) {\n        return;\n    } else if(lef != mid) {\n        add_line(nw, 2 * v, l, m);\n    } else {\n        add_line(nw, 2 * v + 1, m, r);\n    }\n}\n```\nNow to get the minimum in some point $x$ we simply choose the minimum value along the path to the point.\n```{.cpp file=lichaotree_getminimum}\nftype get(int x, int v = 1, int l = 0, int r = maxn) {\n    int m = (l + r) / 2;\n    if(r - l == 1) {\n        return f(line[v], x);\n    } else if(x < m) {\n        return min(f(line[v], x), get(x, 2 * v, l, m));\n    } else {\n        return min(f(line[v], x), get(x, 2 * v + 1, m, r));\n    }\n}\n```\n\n## Problems\n\n* [Codebreaker - TROUBLES](https://codeforces.com/gym/103536/problem/B) (simple application of Convex Hull Trick after a couple of observations)\n* [CS Academy - Squared Ends](https://csacademy.com/contest/archive/task/squared-ends)\n* [Codeforces - Escape Through Leaf](http://codeforces.com/contest/932/problem/F)\n* [CodeChef - Polynomials](https://www.codechef.com/NOV17/problems/POLY)\n* [Codeforces - Kalila and Dimna in the Logging Industry](https://codeforces.com/problemset/problem/319/C)\n* [Codeforces - Product Sum](https://codeforces.com/problemset/problem/631/E)\n* [Codeforces - Bear and Bowling 4](https://codeforces.com/problemset/problem/660/F)\n* [APIO 2010 - Commando](https://dmoj.ca/problem/apio10p1)\n", "problem_ids": ["932_F", "319_C", "631_E", "660_F"], "title": "Convex hull trick and Li Chao tree"}, {"article": "---\ntags:\n  - Original\n---\n\n# Basic Geometry\n\nIn this article we will consider basic operations on points in Euclidean space which maintains the foundation of the whole analytical geometry.\nWe will consider for each point $\\mathbf r$ the vector $\\vec{\\mathbf r}$ directed from $\\mathbf 0$ to $\\mathbf r$.\nLater we will not distinguish between $\\mathbf r$ and $\\vec{\\mathbf r}$ and use the term **point** as a synonym for **vector**.\n\n## Linear operations\n\nBoth 2D and 3D points maintain linear space, which means that for them sum of points and multiplication of point by some number are defined. Here are those basic implementations for 2D:\n\n```{.cpp file=point2d}\nstruct point2d {\n    ftype x, y;\n    point2d() {}\n    point2d(ftype x, ftype y): x(x), y(y) {}\n    point2d& operator+=(const point2d &t) {\n        x += t.x;\n        y += t.y;\n        return *this;\n    }\n    point2d& operator-=(const point2d &t) {\n        x -= t.x;\n        y -= t.y;\n        return *this;\n    }\n    point2d& operator*=(ftype t) {\n        x *= t;\n        y *= t;\n        return *this;\n    }\n    point2d& operator/=(ftype t) {\n        x /= t;\n        y /= t;\n        return *this;\n    }\n    point2d operator+(const point2d &t) const {\n        return point2d(*this) += t;\n    }\n    point2d operator-(const point2d &t) const {\n        return point2d(*this) -= t;\n    }\n    point2d operator*(ftype t) const {\n        return point2d(*this) *= t;\n    }\n    point2d operator/(ftype t) const {\n        return point2d(*this) /= t;\n    }\n};\npoint2d operator*(ftype a, point2d b) {\n    return b * a;\n}\n```\nAnd 3D points:\n```{.cpp file=point3d}\nstruct point3d {\n    ftype x, y, z;\n    point3d() {}\n    point3d(ftype x, ftype y, ftype z): x(x), y(y), z(z) {}\n    point3d& operator+=(const point3d &t) {\n        x += t.x;\n        y += t.y;\n        z += t.z;\n        return *this;\n    }\n    point3d& operator-=(const point3d &t) {\n        x -= t.x;\n        y -= t.y;\n        z -= t.z;\n        return *this;\n    }\n    point3d& operator*=(ftype t) {\n        x *= t;\n        y *= t;\n        z *= t;\n        return *this;\n    }\n    point3d& operator/=(ftype t) {\n        x /= t;\n        y /= t;\n        z /= t;\n        return *this;\n    }\n    point3d operator+(const point3d &t) const {\n        return point3d(*this) += t;\n    }\n    point3d operator-(const point3d &t) const {\n        return point3d(*this) -= t;\n    }\n    point3d operator*(ftype t) const {\n        return point3d(*this) *= t;\n    }\n    point3d operator/(ftype t) const {\n        return point3d(*this) /= t;\n    }\n};\npoint3d operator*(ftype a, point3d b) {\n    return b * a;\n}\n```\n\nHere `ftype` is some type used for coordinates, usually `int`, `double` or `long long`.\n\n## Dot product\n\n### Definition\nThe dot (or scalar) product $\\mathbf a \\cdot \\mathbf b$ for vectors $\\mathbf a$ and $\\mathbf b$ can be defined in two identical ways.\nGeometrically it is product of the length of the first vector by the length of the projection of the second vector onto the first one.\nAs you may see from the image below this projection is nothing but $|\\mathbf a| \\cos \\theta$ where $\\theta$ is the angle between $\\mathbf a$ and $\\mathbf b$. Thus $\\mathbf a\\cdot  \\mathbf b = |\\mathbf a| \\cos \\theta \\cdot |\\mathbf b|$.\n\n<center>![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Dot_Product.svg/300px-Dot_Product.svg.png)</center>\n\nThe dot product holds some notable properties:\n\n1. $\\mathbf a \\cdot \\mathbf b = \\mathbf b \\cdot \\mathbf a$\n2. $(\\alpha \\cdot \\mathbf a)\\cdot \\mathbf b = \\alpha \\cdot (\\mathbf a \\cdot \\mathbf b)$\n3. $(\\mathbf a + \\mathbf b)\\cdot \\mathbf c = \\mathbf a \\cdot \\mathbf c + \\mathbf b \\cdot \\mathbf c$\n\nI.e. it is a commutative function which is linear with respect to both arguments.\nLet's denote the unit vectors as\n\n$$\\mathbf e_x = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\mathbf e_y = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\mathbf e_z = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}.$$\n\nWith this notation we can write the vector $\\mathbf r = (x;y;z)$ as $r = x \\cdot \\mathbf e_x + y \\cdot \\mathbf e_y + z \\cdot \\mathbf e_z$.\nAnd since for unit vectors \n\n$$\\mathbf e_x\\cdot \\mathbf e_x = \\mathbf e_y\\cdot \\mathbf e_y = \\mathbf e_z\\cdot \\mathbf e_z = 1,\\\\\n\\mathbf e_x\\cdot \\mathbf e_y = \\mathbf e_y\\cdot \\mathbf e_z = \\mathbf e_z\\cdot \\mathbf e_x = 0$$\n\nwe can see that in terms of coordinates for $\\mathbf a = (x_1;y_1;z_1)$ and $\\mathbf b = (x_2;y_2;z_2)$ holds\n\n$$\\mathbf a\\cdot \\mathbf b = (x_1 \\cdot \\mathbf e_x + y_1 \\cdot\\mathbf e_y + z_1 \\cdot\\mathbf e_z)\\cdot( x_2 \\cdot\\mathbf e_x + y_2 \\cdot\\mathbf e_y + z_2 \\cdot\\mathbf e_z) = x_1 x_2 + y_1 y_2 + z_1 z_2$$\n\nThat is also the algebraic definition of the dot product.\nFrom this we can write functions which calculate it.\n\n```{.cpp file=dotproduct}\nftype dot(point2d a, point2d b) {\n    return a.x * b.x + a.y * b.y;\n}\nftype dot(point3d a, point3d b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n```\n\nWhen solving problems one should use algebraic definition to calculate dot products, but keep in mind geometric definition and properties to use it.\n\n### Properties\n\nWe can define many geometrical properties via the dot product.\nFor example \n\n1. Norm of $\\mathbf a$ (squared length): $|\\mathbf a|^2 = \\mathbf a\\cdot \\mathbf a$\n2. Length of $\\mathbf a$: $|\\mathbf a| = \\sqrt{\\mathbf a\\cdot \\mathbf a}$\n3. Projection of $\\mathbf a$ onto $\\mathbf b$: $\\dfrac{\\mathbf a\\cdot\\mathbf b}{|\\mathbf b|}$\n4. Angle between vectors: $\\arccos \\left(\\dfrac{\\mathbf a\\cdot \\mathbf b}{|\\mathbf a| \\cdot |\\mathbf b|}\\right)$\n5. From the previous point we may see that the dot product is positive if the angle between them is acute, negative if it is obtuse and it equals zero if they are orthogonal, i.e. they form a right angle.\n\nNote that all these functions do not depend on the number of dimensions, hence they will be the same for the 2D and 3D case:\n\n```{.cpp file=dotproperties}\nftype norm(point2d a) {\n    return dot(a, a);\n}\ndouble abs(point2d a) {\n    return sqrt(norm(a));\n}\ndouble proj(point2d a, point2d b) {\n    return dot(a, b) / abs(b);\n}\ndouble angle(point2d a, point2d b) {\n    return acos(dot(a, b) / abs(a) / abs(b));\n}\n```\n\nTo see the next important property we should take a look at the set of points $\\mathbf r$ for which $\\mathbf r\\cdot \\mathbf a = C$ for some fixed constant $C$.\nYou can see that this set of points is exactly the set of points for which the projection onto $\\mathbf a$ is the point $C \\cdot \\dfrac{\\mathbf a}{|\\mathbf a|}$ and they form a hyperplane orthogonal to $\\mathbf a$.\nYou can see the vector $\\mathbf a$ alongside with several such vectors having same dot product with it in 2D on the picture below:\n\n<center>![Vectors having same dot product with a](https://i.imgur.com/eyO7St4.png)</center>\n\nIn 2D these vectors will form a line, in 3D they will form a plane.\nNote that this result allows us to define a line in 2D as $\\mathbf r\\cdot \\mathbf n=C$ or $(\\mathbf r - \\mathbf r_0)\\cdot \\mathbf n=0$ where $\\mathbf n$ is vector orthogonal to the line and $\\mathbf r_0$ is any vector already present on the line and $C = \\mathbf r_0\\cdot \\mathbf n$.\nIn the same manner a plane can be defined in 3D.\n\n## Cross product\n\n### Definition\n\nAssume you have three vectors $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$ in 3D space joined in a parallelepiped as in the picture below:\n<center>![Three vectors](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Parallelepiped_volume.svg/240px-Parallelepiped_volume.svg.png)</center>\n\nHow would you calculate its volume?\nFrom school we know that we should multiply the area of the base with the height, which is projection of $\\mathbf a$ onto direction orthogonal to base.\nThat means that if we define $\\mathbf b \\times \\mathbf c$ as the vector which is orthogonal to both $\\mathbf b$ and $\\mathbf c$ and which length is equal to the area of the parallelogram formed by $\\mathbf b$ and $\\mathbf c$ then $|\\mathbf a\\cdot (\\mathbf b\\times\\mathbf c)|$ will be equal to the volume of the parallelepiped.\nFor integrity we will say that $\\mathbf b\\times \\mathbf c$ will be always directed in such way that the rotation from the vector $\\mathbf b$ to the vector $\\mathbf c$ from the point of $\\mathbf b\\times \\mathbf c$ is always counter-clockwise (see the picture below).\n\n<center>![cross product](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/Cross_product_vector.svg/250px-Cross_product_vector.svg.png)</center>\n\nThis defines the cross (or vector) product $\\mathbf b\\times \\mathbf c$ of the vectors $\\mathbf b$ and $\\mathbf c$ and the triple product $\\mathbf a\\cdot(\\mathbf b\\times \\mathbf c)$ of the vectors $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$.\n\nSome notable properties of cross and triple products:\n\n1.  $\\mathbf a\\times \\mathbf b = -\\mathbf b\\times \\mathbf a$\n2.  $(\\alpha \\cdot \\mathbf a)\\times \\mathbf b = \\alpha \\cdot (\\mathbf a\\times \\mathbf b)$\n3.  For any $\\mathbf b$ and $\\mathbf c$ there is exactly one vector $\\mathbf r$ such that $\\mathbf a\\cdot (\\mathbf b\\times \\mathbf c) = \\mathbf a\\cdot\\mathbf r$ for any vector $\\mathbf a$. <br>Indeed if there are two such vectors $\\mathbf r_1$ and $\\mathbf r_2$ then $\\mathbf a\\cdot (\\mathbf r_1 - \\mathbf r_2)=0$ for all vectors $\\mathbf a$ which is possible only when $\\mathbf r_1 = \\mathbf r_2$.\n4.  $\\mathbf a\\cdot (\\mathbf b\\times \\mathbf c) = \\mathbf b\\cdot (\\mathbf c\\times \\mathbf a) = -\\mathbf a\\cdot( \\mathbf c\\times \\mathbf b)$\n5.  $(\\mathbf a + \\mathbf b)\\times \\mathbf c = \\mathbf a\\times \\mathbf c + \\mathbf b\\times \\mathbf c$.\n    Indeed for all vectors $\\mathbf r$ the chain of equations holds:\n\n    \\[\\mathbf r\\cdot( (\\mathbf a + \\mathbf b)\\times \\mathbf c) = (\\mathbf a + \\mathbf b) \\cdot (\\mathbf c\\times \\mathbf r) =  \\mathbf a \\cdot(\\mathbf c\\times \\mathbf r) + \\mathbf b\\cdot(\\mathbf c\\times \\mathbf r) = \\mathbf r\\cdot (\\mathbf a\\times \\mathbf c) + \\mathbf r\\cdot(\\mathbf b\\times \\mathbf c) = \\mathbf r\\cdot(\\mathbf a\\times \\mathbf c + \\mathbf b\\times \\mathbf c)\\]\n\n    Which proves $(\\mathbf a + \\mathbf b)\\times \\mathbf c = \\mathbf a\\times \\mathbf c + \\mathbf b\\times \\mathbf c$ due to point 3.\n\n6.  $|\\mathbf a\\times \\mathbf b|=|\\mathbf a| \\cdot |\\mathbf b| \\sin \\theta$ where $\\theta$ is angle between $\\mathbf a$ and $\\mathbf b$, since $|\\mathbf a\\times \\mathbf b|$ equals to the area of the parallelogram formed by $\\mathbf a$ and $\\mathbf b$. \n\nGiven all this and that the following equation holds for the unit vectors\n\n$$\\mathbf e_x\\times \\mathbf e_x = \\mathbf e_y\\times \\mathbf e_y = \\mathbf e_z\\times \\mathbf e_z = \\mathbf 0,\\\\\n\\mathbf e_x\\times \\mathbf e_y = \\mathbf e_z,~\\mathbf e_y\\times \\mathbf e_z = \\mathbf e_x,~\\mathbf e_z\\times \\mathbf e_x = \\mathbf e_y$$\n\nwe can calculate the cross product of $\\mathbf a = (x_1;y_1;z_1)$ and $\\mathbf b = (x_2;y_2;z_2)$ in coordinate form:\n\n$$\\mathbf a\\times \\mathbf b = (x_1 \\cdot \\mathbf e_x + y_1 \\cdot \\mathbf e_y + z_1 \\cdot \\mathbf e_z)\\times (x_2 \\cdot \\mathbf e_x + y_2 \\cdot \\mathbf e_y + z_2 \\cdot \\mathbf e_z) =$$\n\n$$(y_1 z_2 - z_1 y_2)\\mathbf e_x  + (z_1 x_2 - x_1 z_2)\\mathbf e_y + (x_1 y_2 - y_1 x_2)$$\n\nWhich also can be written in the more elegant form:\n\n$$\\mathbf a\\times \\mathbf b = \\begin{vmatrix}\\mathbf e_x & \\mathbf e_y & \\mathbf e_z \\\\ x_1 & y_1 & z_1 \\\\ x_2 & y_2 & z_2 \\end{vmatrix},~a\\cdot(b\\times c) = \\begin{vmatrix} x_1 & y_1 & z_1 \\\\ x_2 & y_2 & z_2 \\\\ x_3 & y_3 & z_3 \\end{vmatrix}$$\n\nHere $| \\cdot |$ stands for the determinant of a matrix. \n\nSome kind of cross product (namely the pseudo-scalar product) can also be implemented in the 2D case.\nIf we would like to calculate the area of parallelogram formed by vectors $\\mathbf a$ and $\\mathbf b$ we would compute $|\\mathbf e_z\\cdot(\\mathbf a\\times \\mathbf b)| = |x_1 y_2 - y_1 x_2|$.\nAnother way to obtain the same result is to multiply $|\\mathbf a|$ (base of parallelogram) with the height, which is the projection of vector $\\mathbf b$ onto vector $\\mathbf a$ rotated by $90^\\circ$ which in turn is $\\widehat{\\mathbf a}=(-y_1;x_1)$.\nThat is, to calculate $|\\widehat{\\mathbf a}\\cdot\\mathbf b|=|x_1y_2 - y_1 x_2|$. \n\nIf we will take the sign into consideration then the area will be positive if the rotation from $\\mathbf a$ to $\\mathbf b$ (i.e. from the view of the point of $\\mathbf e_z$) is performed counter-clockwise and negative otherwise.\nThat defines the pseudo-scalar product.\nNote that it also equals $|\\mathbf a| \\cdot |\\mathbf b| \\sin \\theta$ where $\\theta$ is angle from $\\mathbf a$ to $\\mathbf b$ count counter-clockwise (and negative if rotation is clockwise).\n\nLet's implement all this stuff!\n\n```{.cpp file=crossproduct}\npoint3d cross(point3d a, point3d b) {\n    return point3d(a.y * b.z - a.z * b.y,\n                   a.z * b.x - a.x * b.z,\n                   a.x * b.y - a.y * b.x);\n}\nftype triple(point3d a, point3d b, point3d c) {\n    return dot(a, cross(b, c));\n}\nftype cross(point2d a, point2d b) {\n    return a.x * b.y - a.y * b.x;\n}\n```\n\n### Properties\n\nAs for the cross product, it equals to the zero vector iff the vectors $\\mathbf a$ and $\\mathbf b$ are collinear (they form a common line, i.e. they are parallel).\nThe same thing holds for the triple product, it is equal to zero iff the vectors $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$ are coplanar (they form a common plane).\n\nFrom this we can obtain universal equations defining lines and planes.\nA line can be defined via its direction vector $\\mathbf d$ and an initial point $\\mathbf r_0$ or by two points $\\mathbf a$ and $\\mathbf b$.\nIt is defined as $(\\mathbf r - \\mathbf r_0)\\times\\mathbf d=0$ or as $(\\mathbf r - \\mathbf a)\\times (\\mathbf b - \\mathbf a) = 0$.\nAs for planes, it can be defined by three points $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$ as $(\\mathbf r - \\mathbf a)\\cdot((\\mathbf b - \\mathbf a)\\times (\\mathbf c - \\mathbf a))=0$ or by initial point $\\mathbf r_0$ and two direction vectors lying in this plane $\\mathbf d_1$ and $\\mathbf d_2$: $(\\mathbf r - \\mathbf r_0)\\cdot(\\mathbf d_1\\times \\mathbf d_2)=0$.\n\nIn 2D the pseudo-scalar product also may be used to check the orientation between two vectors because it is positive if the rotation from the first to the second vector is clockwise and negative otherwise.\nAnd, of course, it can be used to calculate areas of polygons, which is described in a different article.\nA triple product can be used for the same purpose in 3D space.\n\n## Exercises\n\n### Line intersection\n\nThere are many possible ways to define a line in 2D and you shouldn't hesitate to combine them.\nFor example we have two lines and we want to find their intersection points.\nWe can say that all points from first line can be parameterized as $\\mathbf r = \\mathbf a_1 + t \\cdot \\mathbf d_1$ where $\\mathbf a_1$ is initial point, $\\mathbf d_1$ is direction and $t$ is some real parameter.\nAs for second line all its points must satisfy $(\\mathbf r - \\mathbf a_2)\\times \\mathbf d_2=0$. From this we can easily find parameter $t$:\n\n$$(\\mathbf a_1 + t \\cdot \\mathbf d_1 - \\mathbf a_2)\\times \\mathbf d_2=0 \\quad\\Rightarrow\\quad t = \\dfrac{(\\mathbf a_2 - \\mathbf a_1)\\times\\mathbf d_2}{\\mathbf d_1\\times \\mathbf d_2}$$\n\nLet's implement function to intersect two lines.\n\n```{.cpp file=basic_line_intersection}\npoint2d intersect(point2d a1, point2d d1, point2d a2, point2d d2) {\n    return a1 + cross(a2 - a1, d2) / cross(d1, d2) * d1;\n}\n```\n\n### Planes intersection\n\nHowever sometimes it might be hard to use some geometric insights.\nFor example, you're given three planes defined by initial points $\\mathbf a_i$ and directions $\\mathbf d_i$ and you want to find their intersection point.\nYou may note that you just have to solve the system of equations:\n\n$$\\begin{cases}\\mathbf r\\cdot \\mathbf n_1 = \\mathbf a_1\\cdot \\mathbf n_1, \\\\ \\mathbf r\\cdot \\mathbf n_2 = \\mathbf a_2\\cdot \\mathbf n_2, \\\\ \\mathbf r\\cdot \\mathbf n_3 = \\mathbf a_3\\cdot \\mathbf n_3\\end{cases}$$\n\nInstead of thinking on geometric approach, you can work out an algebraic one which can be obtained immediately.\nFor example, given that you already implemented a point class, it will be easy for you to solve this system using Cramer's rule because the triple product is simply the determinant of the matrix obtained from the vectors being its columns:\n\n```{.cpp file=plane_intersection}\npoint3d intersect(point3d a1, point3d n1, point3d a2, point3d n2, point3d a3, point3d n3) {\n    point3d x(n1.x, n2.x, n3.x);\n    point3d y(n1.y, n2.y, n3.y);\n    point3d z(n1.z, n2.z, n3.z); \n    point3d d(dot(a1, n1), dot(a2, n2), dot(a3, n3));\n    return point3d(triple(d, y, z),\n                   triple(x, d, z),\n                   triple(x, y, d)) / triple(n1, n2, n3);\n}\n```\n\nNow you may try to find out approaches for common geometric operations yourself to get used to all this stuff.\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Basic Geometry\n\nIn this article we will consider basic operations on points in Euclidean space which maintains the foundation of the whole analytical geometry.\nWe will consider for each point $\\mathbf r$ the vector $\\vec{\\mathbf r}$ directed from $\\mathbf 0$ to $\\mathbf r$.\nLater we will not distinguish between $\\mathbf r$ and $\\vec{\\mathbf r}$ and use the term **point** as a synonym for **vector**.\n\n## Linear operations\n\nBoth 2D and 3D points maintain linear space, which means that for them sum of points and multiplication of point by some number are defined. Here are those basic implementations for 2D:\n\n```{.cpp file=point2d}\nstruct point2d {\n    ftype x, y;\n    point2d() {}\n    point2d(ftype x, ftype y): x(x), y(y) {}\n    point2d& operator+=(const point2d &t) {\n        x += t.x;\n        y += t.y;\n        return *this;\n    }\n    point2d& operator-=(const point2d &t) {\n        x -= t.x;\n        y -= t.y;\n        return *this;\n    }\n    point2d& operator*=(ftype t) {\n        x *= t;\n        y *= t;\n        return *this;\n    }\n    point2d& operator/=(ftype t) {\n        x /= t;\n        y /= t;\n        return *this;\n    }\n    point2d operator+(const point2d &t) const {\n        return point2d(*this) += t;\n    }\n    point2d operator-(const point2d &t) const {\n        return point2d(*this) -= t;\n    }\n    point2d operator*(ftype t) const {\n        return point2d(*this) *= t;\n    }\n    point2d operator/(ftype t) const {\n        return point2d(*this) /= t;\n    }\n};\npoint2d operator*(ftype a, point2d b) {\n    return b * a;\n}\n```\nAnd 3D points:\n```{.cpp file=point3d}\nstruct point3d {\n    ftype x, y, z;\n    point3d() {}\n    point3d(ftype x, ftype y, ftype z): x(x), y(y), z(z) {}\n    point3d& operator+=(const point3d &t) {\n        x += t.x;\n        y += t.y;\n        z += t.z;\n        return *this;\n    }\n    point3d& operator-=(const point3d &t) {\n        x -= t.x;\n        y -= t.y;\n        z -= t.z;\n        return *this;\n    }\n    point3d& operator*=(ftype t) {\n        x *= t;\n        y *= t;\n        z *= t;\n        return *this;\n    }\n    point3d& operator/=(ftype t) {\n        x /= t;\n        y /= t;\n        z /= t;\n        return *this;\n    }\n    point3d operator+(const point3d &t) const {\n        return point3d(*this) += t;\n    }\n    point3d operator-(const point3d &t) const {\n        return point3d(*this) -= t;\n    }\n    point3d operator*(ftype t) const {\n        return point3d(*this) *= t;\n    }\n    point3d operator/(ftype t) const {\n        return point3d(*this) /= t;\n    }\n};\npoint3d operator*(ftype a, point3d b) {\n    return b * a;\n}\n```\n\nHere `ftype` is some type used for coordinates, usually `int`, `double` or `long long`.\n\n## Dot product\n\n### Definition\nThe dot (or scalar) product $\\mathbf a \\cdot \\mathbf b$ for vectors $\\mathbf a$ and $\\mathbf b$ can be defined in two identical ways.\nGeometrically it is product of the length of the first vector by the length of the projection of the second vector onto the first one.\nAs you may see from the image below this projection is nothing but $|\\mathbf a| \\cos \\theta$ where $\\theta$ is the angle between $\\mathbf a$ and $\\mathbf b$. Thus $\\mathbf a\\cdot  \\mathbf b = |\\mathbf a| \\cos \\theta \\cdot |\\mathbf b|$.\n\n<center>![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Dot_Product.svg/300px-Dot_Product.svg.png)</center>\n\nThe dot product holds some notable properties:\n\n1. $\\mathbf a \\cdot \\mathbf b = \\mathbf b \\cdot \\mathbf a$\n2. $(\\alpha \\cdot \\mathbf a)\\cdot \\mathbf b = \\alpha \\cdot (\\mathbf a \\cdot \\mathbf b)$\n3. $(\\mathbf a + \\mathbf b)\\cdot \\mathbf c = \\mathbf a \\cdot \\mathbf c + \\mathbf b \\cdot \\mathbf c$\n\nI.e. it is a commutative function which is linear with respect to both arguments.\nLet's denote the unit vectors as\n\n$$\\mathbf e_x = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\mathbf e_y = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\mathbf e_z = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}.$$\n\nWith this notation we can write the vector $\\mathbf r = (x;y;z)$ as $r = x \\cdot \\mathbf e_x + y \\cdot \\mathbf e_y + z \\cdot \\mathbf e_z$.\nAnd since for unit vectors \n\n$$\\mathbf e_x\\cdot \\mathbf e_x = \\mathbf e_y\\cdot \\mathbf e_y = \\mathbf e_z\\cdot \\mathbf e_z = 1,\\\\\n\\mathbf e_x\\cdot \\mathbf e_y = \\mathbf e_y\\cdot \\mathbf e_z = \\mathbf e_z\\cdot \\mathbf e_x = 0$$\n\nwe can see that in terms of coordinates for $\\mathbf a = (x_1;y_1;z_1)$ and $\\mathbf b = (x_2;y_2;z_2)$ holds\n\n$$\\mathbf a\\cdot \\mathbf b = (x_1 \\cdot \\mathbf e_x + y_1 \\cdot\\mathbf e_y + z_1 \\cdot\\mathbf e_z)\\cdot( x_2 \\cdot\\mathbf e_x + y_2 \\cdot\\mathbf e_y + z_2 \\cdot\\mathbf e_z) = x_1 x_2 + y_1 y_2 + z_1 z_2$$\n\nThat is also the algebraic definition of the dot product.\nFrom this we can write functions which calculate it.\n\n```{.cpp file=dotproduct}\nftype dot(point2d a, point2d b) {\n    return a.x * b.x + a.y * b.y;\n}\nftype dot(point3d a, point3d b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n```\n\nWhen solving problems one should use algebraic definition to calculate dot products, but keep in mind geometric definition and properties to use it.\n\n### Properties\n\nWe can define many geometrical properties via the dot product.\nFor example \n\n1. Norm of $\\mathbf a$ (squared length): $|\\mathbf a|^2 = \\mathbf a\\cdot \\mathbf a$\n2. Length of $\\mathbf a$: $|\\mathbf a| = \\sqrt{\\mathbf a\\cdot \\mathbf a}$\n3. Projection of $\\mathbf a$ onto $\\mathbf b$: $\\dfrac{\\mathbf a\\cdot\\mathbf b}{|\\mathbf b|}$\n4. Angle between vectors: $\\arccos \\left(\\dfrac{\\mathbf a\\cdot \\mathbf b}{|\\mathbf a| \\cdot |\\mathbf b|}\\right)$\n5. From the previous point we may see that the dot product is positive if the angle between them is acute, negative if it is obtuse and it equals zero if they are orthogonal, i.e. they form a right angle.\n\nNote that all these functions do not depend on the number of dimensions, hence they will be the same for the 2D and 3D case:\n\n```{.cpp file=dotproperties}\nftype norm(point2d a) {\n    return dot(a, a);\n}\ndouble abs(point2d a) {\n    return sqrt(norm(a));\n}\ndouble proj(point2d a, point2d b) {\n    return dot(a, b) / abs(b);\n}\ndouble angle(point2d a, point2d b) {\n    return acos(dot(a, b) / abs(a) / abs(b));\n}\n```\n\nTo see the next important property we should take a look at the set of points $\\mathbf r$ for which $\\mathbf r\\cdot \\mathbf a = C$ for some fixed constant $C$.\nYou can see that this set of points is exactly the set of points for which the projection onto $\\mathbf a$ is the point $C \\cdot \\dfrac{\\mathbf a}{|\\mathbf a|}$ and they form a hyperplane orthogonal to $\\mathbf a$.\nYou can see the vector $\\mathbf a$ alongside with several such vectors having same dot product with it in 2D on the picture below:\n\n<center>![Vectors having same dot product with a](https://i.imgur.com/eyO7St4.png)</center>\n\nIn 2D these vectors will form a line, in 3D they will form a plane.\nNote that this result allows us to define a line in 2D as $\\mathbf r\\cdot \\mathbf n=C$ or $(\\mathbf r - \\mathbf r_0)\\cdot \\mathbf n=0$ where $\\mathbf n$ is vector orthogonal to the line and $\\mathbf r_0$ is any vector already present on the line and $C = \\mathbf r_0\\cdot \\mathbf n$.\nIn the same manner a plane can be defined in 3D.\n\n## Cross product\n\n### Definition\n\nAssume you have three vectors $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$ in 3D space joined in a parallelepiped as in the picture below:\n<center>![Three vectors](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Parallelepiped_volume.svg/240px-Parallelepiped_volume.svg.png)</center>\n\nHow would you calculate its volume?\nFrom school we know that we should multiply the area of the base with the height, which is projection of $\\mathbf a$ onto direction orthogonal to base.\nThat means that if we define $\\mathbf b \\times \\mathbf c$ as the vector which is orthogonal to both $\\mathbf b$ and $\\mathbf c$ and which length is equal to the area of the parallelogram formed by $\\mathbf b$ and $\\mathbf c$ then $|\\mathbf a\\cdot (\\mathbf b\\times\\mathbf c)|$ will be equal to the volume of the parallelepiped.\nFor integrity we will say that $\\mathbf b\\times \\mathbf c$ will be always directed in such way that the rotation from the vector $\\mathbf b$ to the vector $\\mathbf c$ from the point of $\\mathbf b\\times \\mathbf c$ is always counter-clockwise (see the picture below).\n\n<center>![cross product](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/Cross_product_vector.svg/250px-Cross_product_vector.svg.png)</center>\n\nThis defines the cross (or vector) product $\\mathbf b\\times \\mathbf c$ of the vectors $\\mathbf b$ and $\\mathbf c$ and the triple product $\\mathbf a\\cdot(\\mathbf b\\times \\mathbf c)$ of the vectors $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$.\n\nSome notable properties of cross and triple products:\n\n1.  $\\mathbf a\\times \\mathbf b = -\\mathbf b\\times \\mathbf a$\n2.  $(\\alpha \\cdot \\mathbf a)\\times \\mathbf b = \\alpha \\cdot (\\mathbf a\\times \\mathbf b)$\n3.  For any $\\mathbf b$ and $\\mathbf c$ there is exactly one vector $\\mathbf r$ such that $\\mathbf a\\cdot (\\mathbf b\\times \\mathbf c) = \\mathbf a\\cdot\\mathbf r$ for any vector $\\mathbf a$. <br>Indeed if there are two such vectors $\\mathbf r_1$ and $\\mathbf r_2$ then $\\mathbf a\\cdot (\\mathbf r_1 - \\mathbf r_2)=0$ for all vectors $\\mathbf a$ which is possible only when $\\mathbf r_1 = \\mathbf r_2$.\n4.  $\\mathbf a\\cdot (\\mathbf b\\times \\mathbf c) = \\mathbf b\\cdot (\\mathbf c\\times \\mathbf a) = -\\mathbf a\\cdot( \\mathbf c\\times \\mathbf b)$\n5.  $(\\mathbf a + \\mathbf b)\\times \\mathbf c = \\mathbf a\\times \\mathbf c + \\mathbf b\\times \\mathbf c$.\n    Indeed for all vectors $\\mathbf r$ the chain of equations holds:\n\n    \\[\\mathbf r\\cdot( (\\mathbf a + \\mathbf b)\\times \\mathbf c) = (\\mathbf a + \\mathbf b) \\cdot (\\mathbf c\\times \\mathbf r) =  \\mathbf a \\cdot(\\mathbf c\\times \\mathbf r) + \\mathbf b\\cdot(\\mathbf c\\times \\mathbf r) = \\mathbf r\\cdot (\\mathbf a\\times \\mathbf c) + \\mathbf r\\cdot(\\mathbf b\\times \\mathbf c) = \\mathbf r\\cdot(\\mathbf a\\times \\mathbf c + \\mathbf b\\times \\mathbf c)\\]\n\n    Which proves $(\\mathbf a + \\mathbf b)\\times \\mathbf c = \\mathbf a\\times \\mathbf c + \\mathbf b\\times \\mathbf c$ due to point 3.\n\n6.  $|\\mathbf a\\times \\mathbf b|=|\\mathbf a| \\cdot |\\mathbf b| \\sin \\theta$ where $\\theta$ is angle between $\\mathbf a$ and $\\mathbf b$, since $|\\mathbf a\\times \\mathbf b|$ equals to the area of the parallelogram formed by $\\mathbf a$ and $\\mathbf b$. \n\nGiven all this and that the following equation holds for the unit vectors\n\n$$\\mathbf e_x\\times \\mathbf e_x = \\mathbf e_y\\times \\mathbf e_y = \\mathbf e_z\\times \\mathbf e_z = \\mathbf 0,\\\\\n\\mathbf e_x\\times \\mathbf e_y = \\mathbf e_z,~\\mathbf e_y\\times \\mathbf e_z = \\mathbf e_x,~\\mathbf e_z\\times \\mathbf e_x = \\mathbf e_y$$\n\nwe can calculate the cross product of $\\mathbf a = (x_1;y_1;z_1)$ and $\\mathbf b = (x_2;y_2;z_2)$ in coordinate form:\n\n$$\\mathbf a\\times \\mathbf b = (x_1 \\cdot \\mathbf e_x + y_1 \\cdot \\mathbf e_y + z_1 \\cdot \\mathbf e_z)\\times (x_2 \\cdot \\mathbf e_x + y_2 \\cdot \\mathbf e_y + z_2 \\cdot \\mathbf e_z) =$$\n\n$$(y_1 z_2 - z_1 y_2)\\mathbf e_x  + (z_1 x_2 - x_1 z_2)\\mathbf e_y + (x_1 y_2 - y_1 x_2)$$\n\nWhich also can be written in the more elegant form:\n\n$$\\mathbf a\\times \\mathbf b = \\begin{vmatrix}\\mathbf e_x & \\mathbf e_y & \\mathbf e_z \\\\ x_1 & y_1 & z_1 \\\\ x_2 & y_2 & z_2 \\end{vmatrix},~a\\cdot(b\\times c) = \\begin{vmatrix} x_1 & y_1 & z_1 \\\\ x_2 & y_2 & z_2 \\\\ x_3 & y_3 & z_3 \\end{vmatrix}$$\n\nHere $| \\cdot |$ stands for the determinant of a matrix. \n\nSome kind of cross product (namely the pseudo-scalar product) can also be implemented in the 2D case.\nIf we would like to calculate the area of parallelogram formed by vectors $\\mathbf a$ and $\\mathbf b$ we would compute $|\\mathbf e_z\\cdot(\\mathbf a\\times \\mathbf b)| = |x_1 y_2 - y_1 x_2|$.\nAnother way to obtain the same result is to multiply $|\\mathbf a|$ (base of parallelogram) with the height, which is the projection of vector $\\mathbf b$ onto vector $\\mathbf a$ rotated by $90^\\circ$ which in turn is $\\widehat{\\mathbf a}=(-y_1;x_1)$.\nThat is, to calculate $|\\widehat{\\mathbf a}\\cdot\\mathbf b|=|x_1y_2 - y_1 x_2|$. \n\nIf we will take the sign into consideration then the area will be positive if the rotation from $\\mathbf a$ to $\\mathbf b$ (i.e. from the view of the point of $\\mathbf e_z$) is performed counter-clockwise and negative otherwise.\nThat defines the pseudo-scalar product.\nNote that it also equals $|\\mathbf a| \\cdot |\\mathbf b| \\sin \\theta$ where $\\theta$ is angle from $\\mathbf a$ to $\\mathbf b$ count counter-clockwise (and negative if rotation is clockwise).\n\nLet's implement all this stuff!\n\n```{.cpp file=crossproduct}\npoint3d cross(point3d a, point3d b) {\n    return point3d(a.y * b.z - a.z * b.y,\n                   a.z * b.x - a.x * b.z,\n                   a.x * b.y - a.y * b.x);\n}\nftype triple(point3d a, point3d b, point3d c) {\n    return dot(a, cross(b, c));\n}\nftype cross(point2d a, point2d b) {\n    return a.x * b.y - a.y * b.x;\n}\n```\n\n### Properties\n\nAs for the cross product, it equals to the zero vector iff the vectors $\\mathbf a$ and $\\mathbf b$ are collinear (they form a common line, i.e. they are parallel).\nThe same thing holds for the triple product, it is equal to zero iff the vectors $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$ are coplanar (they form a common plane).\n\nFrom this we can obtain universal equations defining lines and planes.\nA line can be defined via its direction vector $\\mathbf d$ and an initial point $\\mathbf r_0$ or by two points $\\mathbf a$ and $\\mathbf b$.\nIt is defined as $(\\mathbf r - \\mathbf r_0)\\times\\mathbf d=0$ or as $(\\mathbf r - \\mathbf a)\\times (\\mathbf b - \\mathbf a) = 0$.\nAs for planes, it can be defined by three points $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$ as $(\\mathbf r - \\mathbf a)\\cdot((\\mathbf b - \\mathbf a)\\times (\\mathbf c - \\mathbf a))=0$ or by initial point $\\mathbf r_0$ and two direction vectors lying in this plane $\\mathbf d_1$ and $\\mathbf d_2$: $(\\mathbf r - \\mathbf r_0)\\cdot(\\mathbf d_1\\times \\mathbf d_2)=0$.\n\nIn 2D the pseudo-scalar product also may be used to check the orientation between two vectors because it is positive if the rotation from the first to the second vector is clockwise and negative otherwise.\nAnd, of course, it can be used to calculate areas of polygons, which is described in a different article.\nA triple product can be used for the same purpose in 3D space.\n\n## Exercises\n\n### Line intersection\n\nThere are many possible ways to define a line in 2D and you shouldn't hesitate to combine them.\nFor example we have two lines and we want to find their intersection points.\nWe can say that all points from first line can be parameterized as $\\mathbf r = \\mathbf a_1 + t \\cdot \\mathbf d_1$ where $\\mathbf a_1$ is initial point, $\\mathbf d_1$ is direction and $t$ is some real parameter.\nAs for second line all its points must satisfy $(\\mathbf r - \\mathbf a_2)\\times \\mathbf d_2=0$. From this we can easily find parameter $t$:\n\n$$(\\mathbf a_1 + t \\cdot \\mathbf d_1 - \\mathbf a_2)\\times \\mathbf d_2=0 \\quad\\Rightarrow\\quad t = \\dfrac{(\\mathbf a_2 - \\mathbf a_1)\\times\\mathbf d_2}{\\mathbf d_1\\times \\mathbf d_2}$$\n\nLet's implement function to intersect two lines.\n\n```{.cpp file=basic_line_intersection}\npoint2d intersect(point2d a1, point2d d1, point2d a2, point2d d2) {\n    return a1 + cross(a2 - a1, d2) / cross(d1, d2) * d1;\n}\n```\n\n### Planes intersection\n\nHowever sometimes it might be hard to use some geometric insights.\nFor example, you're given three planes defined by initial points $\\mathbf a_i$ and directions $\\mathbf d_i$ and you want to find their intersection point.\nYou may note that you just have to solve the system of equations:\n\n$$\\begin{cases}\\mathbf r\\cdot \\mathbf n_1 = \\mathbf a_1\\cdot \\mathbf n_1, \\\\ \\mathbf r\\cdot \\mathbf n_2 = \\mathbf a_2\\cdot \\mathbf n_2, \\\\ \\mathbf r\\cdot \\mathbf n_3 = \\mathbf a_3\\cdot \\mathbf n_3\\end{cases}$$\n\nInstead of thinking on geometric approach, you can work out an algebraic one which can be obtained immediately.\nFor example, given that you already implemented a point class, it will be easy for you to solve this system using Cramer's rule because the triple product is simply the determinant of the matrix obtained from the vectors being its columns:\n\n```{.cpp file=plane_intersection}\npoint3d intersect(point3d a1, point3d n1, point3d a2, point3d n2, point3d a3, point3d n3) {\n    point3d x(n1.x, n2.x, n3.x);\n    point3d y(n1.y, n2.y, n3.y);\n    point3d z(n1.z, n2.z, n3.z); \n    point3d d(dot(a1, n1), dot(a2, n2), dot(a3, n3));\n    return point3d(triple(d, y, z),\n                   triple(x, d, z),\n                   triple(x, y, d)) / triple(n1, n2, n3);\n}\n```\n\nNow you may try to find out approaches for common geometric operations yourself to get used to all this stuff.\n", "problem_ids": [], "title": "Basic Geometry"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: circles_intersection\n---\n\n# Circle-Circle Intersection\n\nYou are given two circles on a 2D plane, each one described as coordinates of its center and its radius. Find the points of their intersection (possible cases: one or two points, no intersection or circles coincide).\n\n## Solution\n\nLet's reduce this problem to the [circle-line intersection problem](circle-line-intersection.md).\n\nAssume without loss of generality that the first circle is centered at the origin (if this is not true, we can move the origin to the center of the first circle and adjust the coordinates of intersection points accordingly at output time). We have a system of two equations:\n\n$$x^2+y^2=r_1^2$$\n\n$$(x - x_2)^2 + (y - y_2)^2 = r_2^2$$\n\nSubtract the first equation from the second one to get rid of the second powers of variables:\n\n$$x^2+y^2=r_1^2$$\n\n$$x \\cdot (-2x_2) + y \\cdot (-2y_2) + (x_2^2+y_2^2+r_1^2-r_2^2) = 0$$\n\nThus, we've reduced the original problem to the problem of finding intersections of the first circle and a line:\n\n$$Ax + By + C = 0$$\n\n$$\\begin{align}\nA &= -2x_2 \\\\\nB &= -2y_2 \\\\\nC &= x_2^2+y_2^2+r_1^2-r_2^2\n\\end{align}$$\n\nAnd this problem can be solved as described in the [corresponding article](circle-line-intersection.md).\n\nThe only degenerate case we need to consider separately is when the centers of the circles coincide. In this case $x_2=y_2=0$, and the line equation will be $C = r_1^2-r_2^2 = 0$. If the radii of the circles are the same, there are infinitely many intersection points, if they differ, there are no intersections.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: circles_intersection\n---\n\n# Circle-Circle Intersection\n\nYou are given two circles on a 2D plane, each one described as coordinates of its center and its radius. Find the points of their intersection (possible cases: one or two points, no intersection or circles coincide).\n\n## Solution\n\nLet's reduce this problem to the [circle-line intersection problem](circle-line-intersection.md).\n\nAssume without loss of generality that the first circle is centered at the origin (if this is not true, we can move the origin to the center of the first circle and adjust the coordinates of intersection points accordingly at output time). We have a system of two equations:\n\n$$x^2+y^2=r_1^2$$\n\n$$(x - x_2)^2 + (y - y_2)^2 = r_2^2$$\n\nSubtract the first equation from the second one to get rid of the second powers of variables:\n\n$$x^2+y^2=r_1^2$$\n\n$$x \\cdot (-2x_2) + y \\cdot (-2y_2) + (x_2^2+y_2^2+r_1^2-r_2^2) = 0$$\n\nThus, we've reduced the original problem to the problem of finding intersections of the first circle and a line:\n\n$$Ax + By + C = 0$$\n\n$$\\begin{align}\nA &= -2x_2 \\\\\nB &= -2y_2 \\\\\nC &= x_2^2+y_2^2+r_1^2-r_2^2\n\\end{align}$$\n\nAnd this problem can be solved as described in the [corresponding article](circle-line-intersection.md).\n\nThe only degenerate case we need to consider separately is when the centers of the circles coincide. In this case $x_2=y_2=0$, and the line equation will be $C = r_1^2-r_2^2 = 0$. If the radii of the circles are the same, there are infinitely many intersection points, if they differ, there are no intersections.\n\n## Practice Problems\n\n- [RadarFinder](https://community.topcoder.com/stat?c=problem_statement&pm=7766)\n- [Runaway to a shadow - Codeforces Round #357](http://codeforces.com/problemset/problem/681/E)\n- [ASC 1 Problem F \"Get out!\"](http://codeforces.com/gym/100199/problem/F)\n- [SPOJ: CIRCINT](http://www.spoj.com/problems/CIRCINT/)\n- [UVA - 10301 - Rings and Glue](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1242)\n- [Codeforces 933C A Colorful Prospect](https://codeforces.com/problemset/problem/933/C)\n- [TIMUS 1429 Biscuits](https://acm.timus.ru/problem.aspx?space=1&num=1429)\n", "problem_ids": [], "title": "Circle-Circle Intersection"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: segments_intersection\n---\n\n# Finding intersection of two segments\n\nYou are given two segments AB and CD, described as pairs of their endpoints. Each segment can be a single point if its endpoints are the same. \nYou have to find the intersection of these segments, which can be empty (if the segments don't intersect), a single point or a segment (if the given segments overlap).\n\n## Solution\n\nWe can find the intersection point of segments in the same way as [the intersection of lines](lines-intersection.md): \nreconstruct line equations from the segments' endpoints and check whether they are parallel. \n\nIf the lines are not parallel, we need to find their point of intersection and check whether it belongs to both segments\n(to do this it's sufficient to verify that the intersection point belongs to each segment projected on X and Y axes). \nIn this case the answer will be either \"no intersection\" or the single point of lines' intersection.\n\nThe case of parallel lines is slightly more complicated (the case of one or more segments being a single point also belongs here).\nIn this case we need to check that both segments belong to the same line.\nIf they don't, the answer is \"no intersection\".\nIf they do, the answer is the intersection of the segments belonging to the same line, which is obtained by \nordering the endpoints of both segments in the increasing order of certain coordinate and taking the rightmost of left endpoints and the leftmost of right endpoints.\n\nIf both segments are single points, these points have to be identical, and it makes sense to perform this check separately.\n\nIn the beginning of the algorithm let's add a bounding box check - it is necessary for the case when the segments belong to the same line, \nand (being a lightweight check) it allows the algorithm to work faster on average on random tests.\n\n\n## Implementation\n\nHere is the implementation, including all helper functions for lines and segments processing.\n\nThe main function `intersect` returns true if the segments have a non-empty intersection, \nand stores endpoints of the intersection segment in arguments `left` and `right`. \nIf the answer is a single point, the values written to `left` and `right` will be the same.\n\n```{.cpp file=segment_intersection}\nconst double EPS = 1E-9;\n\nstruct pt {\n    double x, y;\n\n    bool operator<(const pt& p) const\n    {\n        return x < p.x - EPS || (abs(x - p.x) < EPS && y < p.y - EPS);\n    }\n};\n\nstruct line {\n    double a, b, c;\n\n    line() {}\n    line(pt p, pt q)\n    {\n        a = p.y - q.y;\n        b = q.x - p.x;\n        c = -a * p.x - b * p.y;\n        norm();\n    }\n\n    void norm()\n    {\n        double z = sqrt(a * a + b * b);\n        if (abs(z) > EPS)\n            a /= z, b /= z, c /= z;\n    }\n\n    double dist(pt p) const { return a * p.x + b * p.y + c; }\n};\n\ndouble det(double a, double b, double c, double d)\n{\n    return a * d - b * c;\n}\n\ninline bool betw(double l, double r, double x)\n{\n    return min(l, r) <= x + EPS && x <= max(l, r) + EPS;\n}\n\ninline bool intersect_1d(double a, double b, double c, double d)\n{\n    if (a > b)\n        swap(a, b);\n    if (c > d)\n        swap(c, d);\n    return max(a, c) <= min(b, d) + EPS;\n}\n\nbool intersect(pt a, pt b, pt c, pt d, pt& left, pt& right)\n{\n    if (!intersect_1d(a.x, b.x, c.x, d.x) || !intersect_1d(a.y, b.y, c.y, d.y))\n        return false;\n    line m(a, b);\n    line n(c, d);\n    double zn = det(m.a, m.b, n.a, n.b);\n    if (abs(zn) < EPS) {\n        if (abs(m.dist(c)) > EPS || abs(n.dist(a)) > EPS)\n            return false;\n        if (b < a)\n            swap(a, b);\n        if (d < c)\n            swap(c, d);\n        left = max(a, c);\n        right = min(b, d);\n        return true;\n    } else {\n        left.x = right.x = -det(m.c, m.b, n.c, n.b) / zn;\n        left.y = right.y = -det(m.a, m.c, n.a, n.c) / zn;\n        return betw(a.x, b.x, left.x) && betw(a.y, b.y, left.y) &&\n               betw(c.x, d.x, left.x) && betw(c.y, d.y, left.y);\n    }\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: segments_intersection\n---\n\n# Finding intersection of two segments\n\nYou are given two segments AB and CD, described as pairs of their endpoints. Each segment can be a single point if its endpoints are the same. \nYou have to find the intersection of these segments, which can be empty (if the segments don't intersect), a single point or a segment (if the given segments overlap).\n\n## Solution\n\nWe can find the intersection point of segments in the same way as [the intersection of lines](lines-intersection.md): \nreconstruct line equations from the segments' endpoints and check whether they are parallel. \n\nIf the lines are not parallel, we need to find their point of intersection and check whether it belongs to both segments\n(to do this it's sufficient to verify that the intersection point belongs to each segment projected on X and Y axes). \nIn this case the answer will be either \"no intersection\" or the single point of lines' intersection.\n\nThe case of parallel lines is slightly more complicated (the case of one or more segments being a single point also belongs here).\nIn this case we need to check that both segments belong to the same line.\nIf they don't, the answer is \"no intersection\".\nIf they do, the answer is the intersection of the segments belonging to the same line, which is obtained by \nordering the endpoints of both segments in the increasing order of certain coordinate and taking the rightmost of left endpoints and the leftmost of right endpoints.\n\nIf both segments are single points, these points have to be identical, and it makes sense to perform this check separately.\n\nIn the beginning of the algorithm let's add a bounding box check - it is necessary for the case when the segments belong to the same line, \nand (being a lightweight check) it allows the algorithm to work faster on average on random tests.\n\n\n## Implementation\n\nHere is the implementation, including all helper functions for lines and segments processing.\n\nThe main function `intersect` returns true if the segments have a non-empty intersection, \nand stores endpoints of the intersection segment in arguments `left` and `right`. \nIf the answer is a single point, the values written to `left` and `right` will be the same.\n\n```{.cpp file=segment_intersection}\nconst double EPS = 1E-9;\n\nstruct pt {\n    double x, y;\n\n    bool operator<(const pt& p) const\n    {\n        return x < p.x - EPS || (abs(x - p.x) < EPS && y < p.y - EPS);\n    }\n};\n\nstruct line {\n    double a, b, c;\n\n    line() {}\n    line(pt p, pt q)\n    {\n        a = p.y - q.y;\n        b = q.x - p.x;\n        c = -a * p.x - b * p.y;\n        norm();\n    }\n\n    void norm()\n    {\n        double z = sqrt(a * a + b * b);\n        if (abs(z) > EPS)\n            a /= z, b /= z, c /= z;\n    }\n\n    double dist(pt p) const { return a * p.x + b * p.y + c; }\n};\n\ndouble det(double a, double b, double c, double d)\n{\n    return a * d - b * c;\n}\n\ninline bool betw(double l, double r, double x)\n{\n    return min(l, r) <= x + EPS && x <= max(l, r) + EPS;\n}\n\ninline bool intersect_1d(double a, double b, double c, double d)\n{\n    if (a > b)\n        swap(a, b);\n    if (c > d)\n        swap(c, d);\n    return max(a, c) <= min(b, d) + EPS;\n}\n\nbool intersect(pt a, pt b, pt c, pt d, pt& left, pt& right)\n{\n    if (!intersect_1d(a.x, b.x, c.x, d.x) || !intersect_1d(a.y, b.y, c.y, d.y))\n        return false;\n    line m(a, b);\n    line n(c, d);\n    double zn = det(m.a, m.b, n.a, n.b);\n    if (abs(zn) < EPS) {\n        if (abs(m.dist(c)) > EPS || abs(n.dist(a)) > EPS)\n            return false;\n        if (b < a)\n            swap(a, b);\n        if (d < c)\n            swap(c, d);\n        left = max(a, c);\n        right = min(b, d);\n        return true;\n    } else {\n        left.x = right.x = -det(m.c, m.b, n.c, n.b) / zn;\n        left.y = right.y = -det(m.a, m.c, n.a, n.c) / zn;\n        return betw(a.x, b.x, left.x) && betw(a.y, b.y, left.y) &&\n               betw(c.x, d.x, left.x) && betw(c.y, d.y, left.y);\n    }\n}\n```\n", "problem_ids": [], "title": "Finding intersection of two segments"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: convex_hull_graham\n---\n\n# Convex Hull construction\n\nIn this article we will discuss the problem of constructing a convex hull from a set of points.\n\nConsider $N$ points given on a plane, and the objective is to generate a convex hull, i.e. the smallest\nconvex polygon that contains all the given points.\n\nWe will see the **Graham's scan** algorithm published in 1972 by Graham, and\nalso the **Monotone chain** algorithm published in 1979 by Andrew. Both\nare $\\mathcal{O}(N \\log N)$, and are asymptotically optimal (as it is proven that there\nis no algorithm asymptotically better), with the exception of a few problems where\nparallel or online processing is involved.\n\n## Graham's scan Algorithm\nThe algorithm first finds the bottom-most point $P_0$. If there are multiple points\nwith the same Y coordinate, the one with the smaller X coordinate is considered. This\nstep takes $\\mathcal{O}(N)$ time.\n\nNext, all the other points are sorted by polar angle in clockwise order.\nIf the polar angle between two or more points is the same, the tie should be broken by distance from $P_0$, in increasing order.\n\nThen we iterate through each point one by one, and make sure that the current\npoint and the two before it make a clockwise turn, otherwise the previous\npoint is discarded, since it would make a non-convex shape. Checking for clockwise or anticlockwise\nnature can be done by checking the [orientation](oriented-triangle-area.md).\n\nWe use a stack to store the points, and once we reach the original point $P_0$,\nthe algorithm is done and we return the stack containing all the points of the\nconvex hull in clockwise order.\n\nIf you need to include the collinear points while doing a Graham scan, you need\nanother step after sorting. You need to get the points that have the biggest\npolar distance from $P_0$ (these should be at the end of the sorted vector) and are collinear.\nThe points in this line should be reversed so that we can output all the\ncollinear points, otherwise the algorithm would get the nearest point in this\nline and bail. This step shouldn't be included in the non-collinear version\nof the algorithm, otherwise you wouldn't get the smallest convex hull.\n\n### Implementation\n\n```{.cpp file=graham_scan}\nstruct pt {\n    double x, y;\n};\n\nint orientation(pt a, pt b, pt c) {\n    double v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\n    if (v < 0) return -1; // clockwise\n    if (v > 0) return +1; // counter-clockwise\n    return 0;\n}\n\nbool cw(pt a, pt b, pt c, bool include_collinear) {\n    int o = orientation(a, b, c);\n    return o < 0 || (include_collinear && o == 0);\n}\nbool collinear(pt a, pt b, pt c) { return orientation(a, b, c) == 0; }\n\nvoid convex_hull(vector<pt>& a, bool include_collinear = false) {\n    pt p0 = *min_element(a.begin(), a.end(), [](pt a, pt b) {\n        return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n    });\n    sort(a.begin(), a.end(), [&p0](const pt& a, const pt& b) {\n        int o = orientation(p0, a, b);\n        if (o == 0)\n            return (p0.x-a.x)*(p0.x-a.x) + (p0.y-a.y)*(p0.y-a.y)\n                < (p0.x-b.x)*(p0.x-b.x) + (p0.y-b.y)*(p0.y-b.y);\n        return o < 0;\n    });\n    if (include_collinear) {\n        int i = (int)a.size()-1;\n        while (i >= 0 && collinear(p0, a[i], a.back())) i--;\n        reverse(a.begin()+i+1, a.end());\n    }\n\n    vector<pt> st;\n    for (int i = 0; i < (int)a.size(); i++) {\n        while (st.size() > 1 && !cw(st[st.size()-2], st.back(), a[i], include_collinear))\n            st.pop_back();\n        st.push_back(a[i]);\n    }\n\n    a = st;\n}\n```\n\n## Monotone chain Algorithm\nThe algorithm first finds the leftmost and rightmost points A and B. In the event multiple such points exist,\nthe lowest among the left (lowest Y-coordinate) is taken as A, and the highest among the right (highest Y-coordinate)\nis taken as B. Clearly, A and B must both belong to the convex hull as they are the farthest away and they cannot be contained\nby any line formed by a pair among the given points.\n\nNow, draw a line through AB. This divides all the other points into two sets, S1 and S2, where S1 contains all the points\nabove the line connecting A and B, and S2 contains all the points below the line joining A and B. The points that lie on\nthe line joining A and B may belong to either set. The points A and B belong to both sets. Now the algorithm\nconstructs the upper set S1 and the lower set S2 and then combines them to obtain the answer. \n\nTo get the upper set, we sort all points by the x-coordinate. For each point we check if either - the current point is the last point,\n(which we defined as B), or if the orientation between the line between A and the current point and the line between the current point and B is clockwise. In those cases the \ncurrent point belongs to the upper set S1. Checking for clockwise or anticlockwise nature can be done by checking the [orientation](oriented-triangle-area.md).\n\nIf the given point belongs to the upper set, we check the angle made by the line connecting the second last point and the last point in the upper convex hull,\nwith the line connecting the last point in the upper convex hull and the current point. If the angle is not clockwise, we remove the most recent point added\nto the upper convex hull as the current point will be able to contain the previous point once it is added to the convex\nhull.\n\nThe same logic applies for the lower set S2. If either - the current point is B, or the orientation of the lines, formed by A and the \ncurrent point and the current point and B, is counterclockwise - then it belongs to S2.\n\nIf the given point belongs to the lower set, we act similarly as for a point on the upper set except we check for a counterclockwise\norientation instead of a clockwise orientation. Thus, if the angle made by the line connecting the second last point and the last point in the lower convex hull,\nwith the line connecting the last point in the lower convex hull and the current point is not counterclockwise, we remove the most recent point added to the lower convex hull as the current point will be able to contain\nthe previous point once added to the hull.\n\nThe final convex hull is obtained from the union of the upper and lower convex hull, forming a clockwise hull, and the implementation is as follows.\n\nIf you need collinear points, you just need to check for them in the clockwise/counterclockwise routines.\nHowever, this allows for a degenerate case where all the input points are collinear in a single line, and the algorithm would output repeated points.\nTo solve this, we check whether the upper hull contains all the points, and if it does, we just return the points in reverse, as that\nis what Graham's implementation would return in this case.\n\n### Implementation\n\n```{.cpp file=monotone_chain}\nstruct pt {\n    double x, y;\n};\n\nint orientation(pt a, pt b, pt c) {\n    double v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\n    if (v < 0) return -1; // clockwise\n    if (v > 0) return +1; // counter-clockwise\n    return 0;\n}\n\nbool cw(pt a, pt b, pt c, bool include_collinear) {\n    int o = orientation(a, b, c);\n    return o < 0 || (include_collinear && o == 0);\n}\nbool ccw(pt a, pt b, pt c, bool include_collinear) {\n    int o = orientation(a, b, c);\n    return o > 0 || (include_collinear && o == 0);\n}\n\nvoid convex_hull(vector<pt>& a, bool include_collinear = false) {\n    if (a.size() == 1)\n        return;\n\n    sort(a.begin(), a.end(), [](pt a, pt b) {\n        return make_pair(a.x, a.y) < make_pair(b.x, b.y);\n    });\n    pt p1 = a[0], p2 = a.back();\n    vector<pt> up, down;\n    up.push_back(p1);\n    down.push_back(p1);\n    for (int i = 1; i < (int)a.size(); i++) {\n        if (i == a.size() - 1 || cw(p1, a[i], p2, include_collinear)) {\n            while (up.size() >= 2 && !cw(up[up.size()-2], up[up.size()-1], a[i], include_collinear))\n                up.pop_back();\n            up.push_back(a[i]);\n        }\n        if (i == a.size() - 1 || ccw(p1, a[i], p2, include_collinear)) {\n            while (down.size() >= 2 && !ccw(down[down.size()-2], down[down.size()-1], a[i], include_collinear))\n                down.pop_back();\n            down.push_back(a[i]);\n        }\n    }\n\n    if (include_collinear && up.size() == a.size()) {\n        reverse(a.begin(), a.end());\n        return;\n    }\n    a.clear();\n    for (int i = 0; i < (int)up.size(); i++)\n        a.push_back(up[i]);\n    for (int i = down.size() - 2; i > 0; i--)\n        a.push_back(down[i]);\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: convex_hull_graham\n---\n\n# Convex Hull construction\n\nIn this article we will discuss the problem of constructing a convex hull from a set of points.\n\nConsider $N$ points given on a plane, and the objective is to generate a convex hull, i.e. the smallest\nconvex polygon that contains all the given points.\n\nWe will see the **Graham's scan** algorithm published in 1972 by Graham, and\nalso the **Monotone chain** algorithm published in 1979 by Andrew. Both\nare $\\mathcal{O}(N \\log N)$, and are asymptotically optimal (as it is proven that there\nis no algorithm asymptotically better), with the exception of a few problems where\nparallel or online processing is involved.\n\n## Graham's scan Algorithm\nThe algorithm first finds the bottom-most point $P_0$. If there are multiple points\nwith the same Y coordinate, the one with the smaller X coordinate is considered. This\nstep takes $\\mathcal{O}(N)$ time.\n\nNext, all the other points are sorted by polar angle in clockwise order.\nIf the polar angle between two or more points is the same, the tie should be broken by distance from $P_0$, in increasing order.\n\nThen we iterate through each point one by one, and make sure that the current\npoint and the two before it make a clockwise turn, otherwise the previous\npoint is discarded, since it would make a non-convex shape. Checking for clockwise or anticlockwise\nnature can be done by checking the [orientation](oriented-triangle-area.md).\n\nWe use a stack to store the points, and once we reach the original point $P_0$,\nthe algorithm is done and we return the stack containing all the points of the\nconvex hull in clockwise order.\n\nIf you need to include the collinear points while doing a Graham scan, you need\nanother step after sorting. You need to get the points that have the biggest\npolar distance from $P_0$ (these should be at the end of the sorted vector) and are collinear.\nThe points in this line should be reversed so that we can output all the\ncollinear points, otherwise the algorithm would get the nearest point in this\nline and bail. This step shouldn't be included in the non-collinear version\nof the algorithm, otherwise you wouldn't get the smallest convex hull.\n\n### Implementation\n\n```{.cpp file=graham_scan}\nstruct pt {\n    double x, y;\n};\n\nint orientation(pt a, pt b, pt c) {\n    double v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\n    if (v < 0) return -1; // clockwise\n    if (v > 0) return +1; // counter-clockwise\n    return 0;\n}\n\nbool cw(pt a, pt b, pt c, bool include_collinear) {\n    int o = orientation(a, b, c);\n    return o < 0 || (include_collinear && o == 0);\n}\nbool collinear(pt a, pt b, pt c) { return orientation(a, b, c) == 0; }\n\nvoid convex_hull(vector<pt>& a, bool include_collinear = false) {\n    pt p0 = *min_element(a.begin(), a.end(), [](pt a, pt b) {\n        return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n    });\n    sort(a.begin(), a.end(), [&p0](const pt& a, const pt& b) {\n        int o = orientation(p0, a, b);\n        if (o == 0)\n            return (p0.x-a.x)*(p0.x-a.x) + (p0.y-a.y)*(p0.y-a.y)\n                < (p0.x-b.x)*(p0.x-b.x) + (p0.y-b.y)*(p0.y-b.y);\n        return o < 0;\n    });\n    if (include_collinear) {\n        int i = (int)a.size()-1;\n        while (i >= 0 && collinear(p0, a[i], a.back())) i--;\n        reverse(a.begin()+i+1, a.end());\n    }\n\n    vector<pt> st;\n    for (int i = 0; i < (int)a.size(); i++) {\n        while (st.size() > 1 && !cw(st[st.size()-2], st.back(), a[i], include_collinear))\n            st.pop_back();\n        st.push_back(a[i]);\n    }\n\n    a = st;\n}\n```\n\n## Monotone chain Algorithm\nThe algorithm first finds the leftmost and rightmost points A and B. In the event multiple such points exist,\nthe lowest among the left (lowest Y-coordinate) is taken as A, and the highest among the right (highest Y-coordinate)\nis taken as B. Clearly, A and B must both belong to the convex hull as they are the farthest away and they cannot be contained\nby any line formed by a pair among the given points.\n\nNow, draw a line through AB. This divides all the other points into two sets, S1 and S2, where S1 contains all the points\nabove the line connecting A and B, and S2 contains all the points below the line joining A and B. The points that lie on\nthe line joining A and B may belong to either set. The points A and B belong to both sets. Now the algorithm\nconstructs the upper set S1 and the lower set S2 and then combines them to obtain the answer. \n\nTo get the upper set, we sort all points by the x-coordinate. For each point we check if either - the current point is the last point,\n(which we defined as B), or if the orientation between the line between A and the current point and the line between the current point and B is clockwise. In those cases the \ncurrent point belongs to the upper set S1. Checking for clockwise or anticlockwise nature can be done by checking the [orientation](oriented-triangle-area.md).\n\nIf the given point belongs to the upper set, we check the angle made by the line connecting the second last point and the last point in the upper convex hull,\nwith the line connecting the last point in the upper convex hull and the current point. If the angle is not clockwise, we remove the most recent point added\nto the upper convex hull as the current point will be able to contain the previous point once it is added to the convex\nhull.\n\nThe same logic applies for the lower set S2. If either - the current point is B, or the orientation of the lines, formed by A and the \ncurrent point and the current point and B, is counterclockwise - then it belongs to S2.\n\nIf the given point belongs to the lower set, we act similarly as for a point on the upper set except we check for a counterclockwise\norientation instead of a clockwise orientation. Thus, if the angle made by the line connecting the second last point and the last point in the lower convex hull,\nwith the line connecting the last point in the lower convex hull and the current point is not counterclockwise, we remove the most recent point added to the lower convex hull as the current point will be able to contain\nthe previous point once added to the hull.\n\nThe final convex hull is obtained from the union of the upper and lower convex hull, forming a clockwise hull, and the implementation is as follows.\n\nIf you need collinear points, you just need to check for them in the clockwise/counterclockwise routines.\nHowever, this allows for a degenerate case where all the input points are collinear in a single line, and the algorithm would output repeated points.\nTo solve this, we check whether the upper hull contains all the points, and if it does, we just return the points in reverse, as that\nis what Graham's implementation would return in this case.\n\n### Implementation\n\n```{.cpp file=monotone_chain}\nstruct pt {\n    double x, y;\n};\n\nint orientation(pt a, pt b, pt c) {\n    double v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\n    if (v < 0) return -1; // clockwise\n    if (v > 0) return +1; // counter-clockwise\n    return 0;\n}\n\nbool cw(pt a, pt b, pt c, bool include_collinear) {\n    int o = orientation(a, b, c);\n    return o < 0 || (include_collinear && o == 0);\n}\nbool ccw(pt a, pt b, pt c, bool include_collinear) {\n    int o = orientation(a, b, c);\n    return o > 0 || (include_collinear && o == 0);\n}\n\nvoid convex_hull(vector<pt>& a, bool include_collinear = false) {\n    if (a.size() == 1)\n        return;\n\n    sort(a.begin(), a.end(), [](pt a, pt b) {\n        return make_pair(a.x, a.y) < make_pair(b.x, b.y);\n    });\n    pt p1 = a[0], p2 = a.back();\n    vector<pt> up, down;\n    up.push_back(p1);\n    down.push_back(p1);\n    for (int i = 1; i < (int)a.size(); i++) {\n        if (i == a.size() - 1 || cw(p1, a[i], p2, include_collinear)) {\n            while (up.size() >= 2 && !cw(up[up.size()-2], up[up.size()-1], a[i], include_collinear))\n                up.pop_back();\n            up.push_back(a[i]);\n        }\n        if (i == a.size() - 1 || ccw(p1, a[i], p2, include_collinear)) {\n            while (down.size() >= 2 && !ccw(down[down.size()-2], down[down.size()-1], a[i], include_collinear))\n                down.pop_back();\n            down.push_back(a[i]);\n        }\n    }\n\n    if (include_collinear && up.size() == a.size()) {\n        reverse(a.begin(), a.end());\n        return;\n    }\n    a.clear();\n    for (int i = 0; i < (int)up.size(); i++)\n        a.push_back(up[i]);\n    for (int i = down.size() - 2; i > 0; i--)\n        a.push_back(down[i]);\n}\n```\n\n## Practice Problems\n\n* [Kattis - Convex Hull](https://open.kattis.com/problems/convexhull)\n* [Kattis - Keep the Parade Safe](https://open.kattis.com/problems/parade)\n* [URI 1464 - Onion Layers](https://www.urionlinejudge.com.br/judge/en/problems/view/1464)\n* [Timus 1185: Wall](http://acm.timus.ru/problem.aspx?space=1&num=1185)\n* [Usaco 2014 January Contest, Gold - Cow Curling](http://usaco.org/index.php?page=viewproblem2&cpid=382)\n", "problem_ids": [], "title": "Convex Hull construction"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: voronoi_diagram_2d_n4\n---\n\n# Delaunay triangulation and Voronoi diagram\n\nConsider a set $\\{p_i\\}$ of points on the plane.\nA **Voronoi diagram** $V(\\{p_i\\})$ of $\\{p_i\\}$ is a partition of the plane into $n$ regions $V_i$, where $V_i = \\{p\\in\\mathbb{R}^2;\\ \\rho(p, p_i) = \\min\\ \\rho(p, p_k)\\}$.\nThe cells of the Voronoi diagram are polygons (possibly infinite).\nA **Delaunay triangulation** $D(\\{p_i\\})$ of $\\{p_i\\}$ is a triangulation where every point $p_i$ is outside or on the boundary of the circumcircle of each triangle $T \\in D(\\{p_i\\})$.\n\nThere is a nasty degenerated case when the Voronoi diagram isn't connected and Delaunay triangulation doesn't exist. This case is when all points are collinear.\n\n## Properties\n\nThe Delaunay triangulation maximizes the minimum angle among all possible triangulations.\n\nThe Minimum Euclidean spanning tree of a point set is a subset of edges of its' Delaunay triangulation.\n\n## Duality\n\nSuppose that $\\{p_i\\}$ is not collinear and among $\\{p_i\\}$ no four points lie on one circle. Then $V(\\{p_i\\})$ and $D(\\{p_i\\})$ are dual, so if we obtain one of them, we may obtain the other in $O(n)$. What to do if it's not the case? The collinear case may be processed easily. Otherwise, $V$ and $D'$ are dual, where $D'$ is obtained from $D$ by removing all the edges such that two triangles on this edge share the circumcircle.\n\n## Building Delaunay and Voronoi\n\nBecause of the duality, we only need a fast algorithm to compute only one of $V$ and $D$. We will describe how to build $D(\\{p_i\\})$ in $O(n\\log n)$. The triangulation will be built via divide-and-conquer algorithm due to Guibas and Stolfi.\n\n## Quad-edge data structure\n\nDuring the algorithm $D$ will be stored inside the quad-edge data structure. This structure is described in the picture:\n<center>![Quad-Edge](quad-edge.png)</center>\n\nIn the algorithm we will use the following functions on edges:\n\n  1. `make_edge(a, b)`<br>\n    This function creates an isolated edge from point `a` to point `b` together with its' reverse edge and both dual edges.\n  2. `splice(a, b)`<br>\n    This is a key function of the algorithm. It swaps `a->Onext` with `b->Onext` and `a->Onext->Rot->Onext` with `b->Onext->Rot->Onext`.\n  3. `delete_edge(e)`<br>\n    This function deletes e from the triangulation. To delete `e`, we may simply call `splice(e, e->Oprev)` and `splice(e->Rev, e->Rev->Oprev)`.\n  4. `connect(a, b)`<br>\n    This function creates a new edge `e` from `a->Dest` to `b->Org` in such a way that `a`, `b`, `e` all have the same left face. To do this, we call `e = make_edge(a->Dest, b->Org)`, `splice(e, a->Lnext)` and `splice(e->Rev, b)`.\n\n## Algorithm\n\nThe algorithm will compute the triangulation and return two quad-edges: the counterclockwise convex hull edge out of the leftmost vertex and the clockwise convex hull edge out of the rightmost vertex.\n\nLet's sort all points by x, and if $x_1 = x_2$ then by y. Let's solve the problem for some segment $(l, r)$ (initially $(l, r) = (0, n - 1)$). If $r - l + 1 = 2$, we will add an edge $(p[l], p[r])$ and return. If $r - l + 1 = 3$, we will firstly add the edges $(p[l], p[l + 1])$ and $(p[l + 1], p[r])$. We must also connect them using `splice(a->Rev, b)`. Now we must close the triangle. Our next action will depend on the orientation of $p[l], p[l + 1], p[r]$. If they are collinear, we can't make a triangle, so we simply return `(a, b->Rev)`. Otherwise, we create a new edge `c` by calling `connect(b, a)`. If the points are oriented counter-clockwise, we return `(a, b->Rev)`. Otherwise we return `(c->Rev, c)`.\n\nNow suppose that $r - l + 1 \\ge 4$. Firstly, let's solve $L = (l, \\frac{l + r}{2})$ and $R = (\\frac{l + r}{2} + 1, r)$ recursively. Now we have to merge these triangulations into one triangulation. Note that our points are sorted, so while merging we will add edges from L to R (so-called _cross_ edges) and remove some edges from L to L and from R to R.\nWhat is the structure of the cross edges? All these edges must cross a line parallel to the y-axis and placed at the splitting x value. This establishes a linear ordering of the cross edges, so we can talk about successive cross edges, the bottom-most cross edge, etc. The algorithm will add the cross edges in ascending order. Note that any two adjacent cross edges will have a common endpoint, and the third side of the triangle they define goes from L to L or from R to R. Let's call the current cross edge the base. The successor of the base will either go from the left endpoint of the base to one of the R-neighbors of the right endpoint or vice versa.\nConsider the circumcircle of base and the previous cross edge.\nSuppose this circle is transformed into other circles having base as a chord but lying further into the Oy direction.\nOur circle will go up for a while, but unless base is an upper tangent of L and R we will encounter a point belonging either to L or to R giving rise to a new triangle without any points in the circumcircle.\nThe new L-R edge of this triangle is the next cross edge added.\nTo do this efficiently, we compute two edges `lcand` and `rcand` so that `lcand` points to the first L point encountered in this process, and `rcand` points to the first R point.\nThen we choose the one that would be encountered first. Initially base points to the lower tangent of L and R.\n\n## Implementation\n\nNote that the implementation of the in_circle function is GCC-specific.\n\n```{.cpp file=delaunay}\ntypedef long long ll;\n\nbool ge(const ll& a, const ll& b) { return a >= b; }\nbool le(const ll& a, const ll& b) { return a <= b; }\nbool eq(const ll& a, const ll& b) { return a == b; }\nbool gt(const ll& a, const ll& b) { return a > b; }\nbool lt(const ll& a, const ll& b) { return a < b; }\nint sgn(const ll& a) { return a >= 0 ? a ? 1 : 0 : -1; }\n\nstruct pt {\n    ll x, y;\n    pt() { }\n    pt(ll _x, ll _y) : x(_x), y(_y) { }\n    pt operator-(const pt& p) const {\n        return pt(x - p.x, y - p.y);\n    }\n    ll cross(const pt& p) const {\n        return x * p.y - y * p.x;\n    }\n    ll cross(const pt& a, const pt& b) const {\n        return (a - *this).cross(b - *this);\n    }\n    ll dot(const pt& p) const {\n        return x * p.x + y * p.y;\n    }\n    ll dot(const pt& a, const pt& b) const {\n        return (a - *this).dot(b - *this);\n    }\n    ll sqrLength() const {\n        return this->dot(*this);\n    }\n    bool operator==(const pt& p) const {\n        return eq(x, p.x) && eq(y, p.y);\n    }\n};\n\nconst pt inf_pt = pt(1e18, 1e18);\n\nstruct QuadEdge {\n    pt origin;\n    QuadEdge* rot = nullptr;\n    QuadEdge* onext = nullptr;\n    bool used = false;\n    QuadEdge* rev() const {\n        return rot->rot;\n    }\n    QuadEdge* lnext() const {\n        return rot->rev()->onext->rot;\n    }\n    QuadEdge* oprev() const {\n        return rot->onext->rot;\n    }\n    pt dest() const {\n        return rev()->origin;\n    }\n};\n\nQuadEdge* make_edge(pt from, pt to) {\n    QuadEdge* e1 = new QuadEdge;\n    QuadEdge* e2 = new QuadEdge;\n    QuadEdge* e3 = new QuadEdge;\n    QuadEdge* e4 = new QuadEdge;\n    e1->origin = from;\n    e2->origin = to;\n    e3->origin = e4->origin = inf_pt;\n    e1->rot = e3;\n    e2->rot = e4;\n    e3->rot = e2;\n    e4->rot = e1;\n    e1->onext = e1;\n    e2->onext = e2;\n    e3->onext = e4;\n    e4->onext = e3;\n    return e1;\n}\n\nvoid splice(QuadEdge* a, QuadEdge* b) {\n    swap(a->onext->rot->onext, b->onext->rot->onext);\n    swap(a->onext, b->onext);\n}\n\nvoid delete_edge(QuadEdge* e) {\n    splice(e, e->oprev());\n    splice(e->rev(), e->rev()->oprev());\n    delete e->rev()->rot;\n    delete e->rev();\n    delete e->rot;\n    delete e;\n}\n\nQuadEdge* connect(QuadEdge* a, QuadEdge* b) {\n    QuadEdge* e = make_edge(a->dest(), b->origin);\n    splice(e, a->lnext());\n    splice(e->rev(), b);\n    return e;\n}\n\nbool left_of(pt p, QuadEdge* e) {\n    return gt(p.cross(e->origin, e->dest()), 0);\n}\n\nbool right_of(pt p, QuadEdge* e) {\n    return lt(p.cross(e->origin, e->dest()), 0);\n}\n\ntemplate <class T>\nT det3(T a1, T a2, T a3, T b1, T b2, T b3, T c1, T c2, T c3) {\n    return a1 * (b2 * c3 - c2 * b3) - a2 * (b1 * c3 - c1 * b3) +\n           a3 * (b1 * c2 - c1 * b2);\n}\n\nbool in_circle(pt a, pt b, pt c, pt d) {\n// If there is __int128, calculate directly.\n// Otherwise, calculate angles.\n#if defined(__LP64__) || defined(_WIN64)\n    __int128 det = -det3<__int128>(b.x, b.y, b.sqrLength(), c.x, c.y,\n                                   c.sqrLength(), d.x, d.y, d.sqrLength());\n    det += det3<__int128>(a.x, a.y, a.sqrLength(), c.x, c.y, c.sqrLength(), d.x,\n                          d.y, d.sqrLength());\n    det -= det3<__int128>(a.x, a.y, a.sqrLength(), b.x, b.y, b.sqrLength(), d.x,\n                          d.y, d.sqrLength());\n    det += det3<__int128>(a.x, a.y, a.sqrLength(), b.x, b.y, b.sqrLength(), c.x,\n                          c.y, c.sqrLength());\n    return det > 0;\n#else\n    auto ang = [](pt l, pt mid, pt r) {\n        ll x = mid.dot(l, r);\n        ll y = mid.cross(l, r);\n        long double res = atan2((long double)x, (long double)y);\n        return res;\n    };\n    long double kek = ang(a, b, c) + ang(c, d, a) - ang(b, c, d) - ang(d, a, b);\n    if (kek > 1e-8)\n        return true;\n    else\n        return false;\n#endif\n}\n\npair<QuadEdge*, QuadEdge*> build_tr(int l, int r, vector<pt>& p) {\n    if (r - l + 1 == 2) {\n        QuadEdge* res = make_edge(p[l], p[r]);\n        return make_pair(res, res->rev());\n    }\n    if (r - l + 1 == 3) {\n        QuadEdge *a = make_edge(p[l], p[l + 1]), *b = make_edge(p[l + 1], p[r]);\n        splice(a->rev(), b);\n        int sg = sgn(p[l].cross(p[l + 1], p[r]));\n        if (sg == 0)\n            return make_pair(a, b->rev());\n        QuadEdge* c = connect(b, a);\n        if (sg == 1)\n            return make_pair(a, b->rev());\n        else\n            return make_pair(c->rev(), c);\n    }\n    int mid = (l + r) / 2;\n    QuadEdge *ldo, *ldi, *rdo, *rdi;\n    tie(ldo, ldi) = build_tr(l, mid, p);\n    tie(rdi, rdo) = build_tr(mid + 1, r, p);\n    while (true) {\n        if (left_of(rdi->origin, ldi)) {\n            ldi = ldi->lnext();\n            continue;\n        }\n        if (right_of(ldi->origin, rdi)) {\n            rdi = rdi->rev()->onext;\n            continue;\n        }\n        break;\n    }\n    QuadEdge* basel = connect(rdi->rev(), ldi);\n    auto valid = [&basel](QuadEdge* e) { return right_of(e->dest(), basel); };\n    if (ldi->origin == ldo->origin)\n        ldo = basel->rev();\n    if (rdi->origin == rdo->origin)\n        rdo = basel;\n    while (true) {\n        QuadEdge* lcand = basel->rev()->onext;\n        if (valid(lcand)) {\n            while (in_circle(basel->dest(), basel->origin, lcand->dest(),\n                             lcand->onext->dest())) {\n                QuadEdge* t = lcand->onext;\n                delete_edge(lcand);\n                lcand = t;\n            }\n        }\n        QuadEdge* rcand = basel->oprev();\n        if (valid(rcand)) {\n            while (in_circle(basel->dest(), basel->origin, rcand->dest(),\n                             rcand->oprev()->dest())) {\n                QuadEdge* t = rcand->oprev();\n                delete_edge(rcand);\n                rcand = t;\n            }\n        }\n        if (!valid(lcand) && !valid(rcand))\n            break;\n        if (!valid(lcand) ||\n            (valid(rcand) && in_circle(lcand->dest(), lcand->origin,\n                                       rcand->origin, rcand->dest())))\n            basel = connect(rcand, basel->rev());\n        else\n            basel = connect(basel->rev(), lcand->rev());\n    }\n    return make_pair(ldo, rdo);\n}\n\nvector<tuple<pt, pt, pt>> delaunay(vector<pt> p) {\n    sort(p.begin(), p.end(), [](const pt& a, const pt& b) {\n        return lt(a.x, b.x) || (eq(a.x, b.x) && lt(a.y, b.y));\n    });\n    auto res = build_tr(0, (int)p.size() - 1, p);\n    QuadEdge* e = res.first;\n    vector<QuadEdge*> edges = {e};\n    while (lt(e->onext->dest().cross(e->dest(), e->origin), 0))\n        e = e->onext;\n    auto add = [&p, &e, &edges]() {\n        QuadEdge* curr = e;\n        do {\n            curr->used = true;\n            p.push_back(curr->origin);\n            edges.push_back(curr->rev());\n            curr = curr->lnext();\n        } while (curr != e);\n    };\n    add();\n    p.clear();\n    int kek = 0;\n    while (kek < (int)edges.size()) {\n        if (!(e = edges[kek++])->used)\n            add();\n    }\n    vector<tuple<pt, pt, pt>> ans;\n    for (int i = 0; i < (int)p.size(); i += 3) {\n        ans.push_back(make_tuple(p[i], p[i + 1], p[i + 2]));\n    }\n    return ans;\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: voronoi_diagram_2d_n4\n---\n\n# Delaunay triangulation and Voronoi diagram\n\nConsider a set $\\{p_i\\}$ of points on the plane.\nA **Voronoi diagram** $V(\\{p_i\\})$ of $\\{p_i\\}$ is a partition of the plane into $n$ regions $V_i$, where $V_i = \\{p\\in\\mathbb{R}^2;\\ \\rho(p, p_i) = \\min\\ \\rho(p, p_k)\\}$.\nThe cells of the Voronoi diagram are polygons (possibly infinite).\nA **Delaunay triangulation** $D(\\{p_i\\})$ of $\\{p_i\\}$ is a triangulation where every point $p_i$ is outside or on the boundary of the circumcircle of each triangle $T \\in D(\\{p_i\\})$.\n\nThere is a nasty degenerated case when the Voronoi diagram isn't connected and Delaunay triangulation doesn't exist. This case is when all points are collinear.\n\n## Properties\n\nThe Delaunay triangulation maximizes the minimum angle among all possible triangulations.\n\nThe Minimum Euclidean spanning tree of a point set is a subset of edges of its' Delaunay triangulation.\n\n## Duality\n\nSuppose that $\\{p_i\\}$ is not collinear and among $\\{p_i\\}$ no four points lie on one circle. Then $V(\\{p_i\\})$ and $D(\\{p_i\\})$ are dual, so if we obtain one of them, we may obtain the other in $O(n)$. What to do if it's not the case? The collinear case may be processed easily. Otherwise, $V$ and $D'$ are dual, where $D'$ is obtained from $D$ by removing all the edges such that two triangles on this edge share the circumcircle.\n\n## Building Delaunay and Voronoi\n\nBecause of the duality, we only need a fast algorithm to compute only one of $V$ and $D$. We will describe how to build $D(\\{p_i\\})$ in $O(n\\log n)$. The triangulation will be built via divide-and-conquer algorithm due to Guibas and Stolfi.\n\n## Quad-edge data structure\n\nDuring the algorithm $D$ will be stored inside the quad-edge data structure. This structure is described in the picture:\n<center>![Quad-Edge](quad-edge.png)</center>\n\nIn the algorithm we will use the following functions on edges:\n\n  1. `make_edge(a, b)`<br>\n    This function creates an isolated edge from point `a` to point `b` together with its' reverse edge and both dual edges.\n  2. `splice(a, b)`<br>\n    This is a key function of the algorithm. It swaps `a->Onext` with `b->Onext` and `a->Onext->Rot->Onext` with `b->Onext->Rot->Onext`.\n  3. `delete_edge(e)`<br>\n    This function deletes e from the triangulation. To delete `e`, we may simply call `splice(e, e->Oprev)` and `splice(e->Rev, e->Rev->Oprev)`.\n  4. `connect(a, b)`<br>\n    This function creates a new edge `e` from `a->Dest` to `b->Org` in such a way that `a`, `b`, `e` all have the same left face. To do this, we call `e = make_edge(a->Dest, b->Org)`, `splice(e, a->Lnext)` and `splice(e->Rev, b)`.\n\n## Algorithm\n\nThe algorithm will compute the triangulation and return two quad-edges: the counterclockwise convex hull edge out of the leftmost vertex and the clockwise convex hull edge out of the rightmost vertex.\n\nLet's sort all points by x, and if $x_1 = x_2$ then by y. Let's solve the problem for some segment $(l, r)$ (initially $(l, r) = (0, n - 1)$). If $r - l + 1 = 2$, we will add an edge $(p[l], p[r])$ and return. If $r - l + 1 = 3$, we will firstly add the edges $(p[l], p[l + 1])$ and $(p[l + 1], p[r])$. We must also connect them using `splice(a->Rev, b)`. Now we must close the triangle. Our next action will depend on the orientation of $p[l], p[l + 1], p[r]$. If they are collinear, we can't make a triangle, so we simply return `(a, b->Rev)`. Otherwise, we create a new edge `c` by calling `connect(b, a)`. If the points are oriented counter-clockwise, we return `(a, b->Rev)`. Otherwise we return `(c->Rev, c)`.\n\nNow suppose that $r - l + 1 \\ge 4$. Firstly, let's solve $L = (l, \\frac{l + r}{2})$ and $R = (\\frac{l + r}{2} + 1, r)$ recursively. Now we have to merge these triangulations into one triangulation. Note that our points are sorted, so while merging we will add edges from L to R (so-called _cross_ edges) and remove some edges from L to L and from R to R.\nWhat is the structure of the cross edges? All these edges must cross a line parallel to the y-axis and placed at the splitting x value. This establishes a linear ordering of the cross edges, so we can talk about successive cross edges, the bottom-most cross edge, etc. The algorithm will add the cross edges in ascending order. Note that any two adjacent cross edges will have a common endpoint, and the third side of the triangle they define goes from L to L or from R to R. Let's call the current cross edge the base. The successor of the base will either go from the left endpoint of the base to one of the R-neighbors of the right endpoint or vice versa.\nConsider the circumcircle of base and the previous cross edge.\nSuppose this circle is transformed into other circles having base as a chord but lying further into the Oy direction.\nOur circle will go up for a while, but unless base is an upper tangent of L and R we will encounter a point belonging either to L or to R giving rise to a new triangle without any points in the circumcircle.\nThe new L-R edge of this triangle is the next cross edge added.\nTo do this efficiently, we compute two edges `lcand` and `rcand` so that `lcand` points to the first L point encountered in this process, and `rcand` points to the first R point.\nThen we choose the one that would be encountered first. Initially base points to the lower tangent of L and R.\n\n## Implementation\n\nNote that the implementation of the in_circle function is GCC-specific.\n\n```{.cpp file=delaunay}\ntypedef long long ll;\n\nbool ge(const ll& a, const ll& b) { return a >= b; }\nbool le(const ll& a, const ll& b) { return a <= b; }\nbool eq(const ll& a, const ll& b) { return a == b; }\nbool gt(const ll& a, const ll& b) { return a > b; }\nbool lt(const ll& a, const ll& b) { return a < b; }\nint sgn(const ll& a) { return a >= 0 ? a ? 1 : 0 : -1; }\n\nstruct pt {\n    ll x, y;\n    pt() { }\n    pt(ll _x, ll _y) : x(_x), y(_y) { }\n    pt operator-(const pt& p) const {\n        return pt(x - p.x, y - p.y);\n    }\n    ll cross(const pt& p) const {\n        return x * p.y - y * p.x;\n    }\n    ll cross(const pt& a, const pt& b) const {\n        return (a - *this).cross(b - *this);\n    }\n    ll dot(const pt& p) const {\n        return x * p.x + y * p.y;\n    }\n    ll dot(const pt& a, const pt& b) const {\n        return (a - *this).dot(b - *this);\n    }\n    ll sqrLength() const {\n        return this->dot(*this);\n    }\n    bool operator==(const pt& p) const {\n        return eq(x, p.x) && eq(y, p.y);\n    }\n};\n\nconst pt inf_pt = pt(1e18, 1e18);\n\nstruct QuadEdge {\n    pt origin;\n    QuadEdge* rot = nullptr;\n    QuadEdge* onext = nullptr;\n    bool used = false;\n    QuadEdge* rev() const {\n        return rot->rot;\n    }\n    QuadEdge* lnext() const {\n        return rot->rev()->onext->rot;\n    }\n    QuadEdge* oprev() const {\n        return rot->onext->rot;\n    }\n    pt dest() const {\n        return rev()->origin;\n    }\n};\n\nQuadEdge* make_edge(pt from, pt to) {\n    QuadEdge* e1 = new QuadEdge;\n    QuadEdge* e2 = new QuadEdge;\n    QuadEdge* e3 = new QuadEdge;\n    QuadEdge* e4 = new QuadEdge;\n    e1->origin = from;\n    e2->origin = to;\n    e3->origin = e4->origin = inf_pt;\n    e1->rot = e3;\n    e2->rot = e4;\n    e3->rot = e2;\n    e4->rot = e1;\n    e1->onext = e1;\n    e2->onext = e2;\n    e3->onext = e4;\n    e4->onext = e3;\n    return e1;\n}\n\nvoid splice(QuadEdge* a, QuadEdge* b) {\n    swap(a->onext->rot->onext, b->onext->rot->onext);\n    swap(a->onext, b->onext);\n}\n\nvoid delete_edge(QuadEdge* e) {\n    splice(e, e->oprev());\n    splice(e->rev(), e->rev()->oprev());\n    delete e->rev()->rot;\n    delete e->rev();\n    delete e->rot;\n    delete e;\n}\n\nQuadEdge* connect(QuadEdge* a, QuadEdge* b) {\n    QuadEdge* e = make_edge(a->dest(), b->origin);\n    splice(e, a->lnext());\n    splice(e->rev(), b);\n    return e;\n}\n\nbool left_of(pt p, QuadEdge* e) {\n    return gt(p.cross(e->origin, e->dest()), 0);\n}\n\nbool right_of(pt p, QuadEdge* e) {\n    return lt(p.cross(e->origin, e->dest()), 0);\n}\n\ntemplate <class T>\nT det3(T a1, T a2, T a3, T b1, T b2, T b3, T c1, T c2, T c3) {\n    return a1 * (b2 * c3 - c2 * b3) - a2 * (b1 * c3 - c1 * b3) +\n           a3 * (b1 * c2 - c1 * b2);\n}\n\nbool in_circle(pt a, pt b, pt c, pt d) {\n// If there is __int128, calculate directly.\n// Otherwise, calculate angles.\n#if defined(__LP64__) || defined(_WIN64)\n    __int128 det = -det3<__int128>(b.x, b.y, b.sqrLength(), c.x, c.y,\n                                   c.sqrLength(), d.x, d.y, d.sqrLength());\n    det += det3<__int128>(a.x, a.y, a.sqrLength(), c.x, c.y, c.sqrLength(), d.x,\n                          d.y, d.sqrLength());\n    det -= det3<__int128>(a.x, a.y, a.sqrLength(), b.x, b.y, b.sqrLength(), d.x,\n                          d.y, d.sqrLength());\n    det += det3<__int128>(a.x, a.y, a.sqrLength(), b.x, b.y, b.sqrLength(), c.x,\n                          c.y, c.sqrLength());\n    return det > 0;\n#else\n    auto ang = [](pt l, pt mid, pt r) {\n        ll x = mid.dot(l, r);\n        ll y = mid.cross(l, r);\n        long double res = atan2((long double)x, (long double)y);\n        return res;\n    };\n    long double kek = ang(a, b, c) + ang(c, d, a) - ang(b, c, d) - ang(d, a, b);\n    if (kek > 1e-8)\n        return true;\n    else\n        return false;\n#endif\n}\n\npair<QuadEdge*, QuadEdge*> build_tr(int l, int r, vector<pt>& p) {\n    if (r - l + 1 == 2) {\n        QuadEdge* res = make_edge(p[l], p[r]);\n        return make_pair(res, res->rev());\n    }\n    if (r - l + 1 == 3) {\n        QuadEdge *a = make_edge(p[l], p[l + 1]), *b = make_edge(p[l + 1], p[r]);\n        splice(a->rev(), b);\n        int sg = sgn(p[l].cross(p[l + 1], p[r]));\n        if (sg == 0)\n            return make_pair(a, b->rev());\n        QuadEdge* c = connect(b, a);\n        if (sg == 1)\n            return make_pair(a, b->rev());\n        else\n            return make_pair(c->rev(), c);\n    }\n    int mid = (l + r) / 2;\n    QuadEdge *ldo, *ldi, *rdo, *rdi;\n    tie(ldo, ldi) = build_tr(l, mid, p);\n    tie(rdi, rdo) = build_tr(mid + 1, r, p);\n    while (true) {\n        if (left_of(rdi->origin, ldi)) {\n            ldi = ldi->lnext();\n            continue;\n        }\n        if (right_of(ldi->origin, rdi)) {\n            rdi = rdi->rev()->onext;\n            continue;\n        }\n        break;\n    }\n    QuadEdge* basel = connect(rdi->rev(), ldi);\n    auto valid = [&basel](QuadEdge* e) { return right_of(e->dest(), basel); };\n    if (ldi->origin == ldo->origin)\n        ldo = basel->rev();\n    if (rdi->origin == rdo->origin)\n        rdo = basel;\n    while (true) {\n        QuadEdge* lcand = basel->rev()->onext;\n        if (valid(lcand)) {\n            while (in_circle(basel->dest(), basel->origin, lcand->dest(),\n                             lcand->onext->dest())) {\n                QuadEdge* t = lcand->onext;\n                delete_edge(lcand);\n                lcand = t;\n            }\n        }\n        QuadEdge* rcand = basel->oprev();\n        if (valid(rcand)) {\n            while (in_circle(basel->dest(), basel->origin, rcand->dest(),\n                             rcand->oprev()->dest())) {\n                QuadEdge* t = rcand->oprev();\n                delete_edge(rcand);\n                rcand = t;\n            }\n        }\n        if (!valid(lcand) && !valid(rcand))\n            break;\n        if (!valid(lcand) ||\n            (valid(rcand) && in_circle(lcand->dest(), lcand->origin,\n                                       rcand->origin, rcand->dest())))\n            basel = connect(rcand, basel->rev());\n        else\n            basel = connect(basel->rev(), lcand->rev());\n    }\n    return make_pair(ldo, rdo);\n}\n\nvector<tuple<pt, pt, pt>> delaunay(vector<pt> p) {\n    sort(p.begin(), p.end(), [](const pt& a, const pt& b) {\n        return lt(a.x, b.x) || (eq(a.x, b.x) && lt(a.y, b.y));\n    });\n    auto res = build_tr(0, (int)p.size() - 1, p);\n    QuadEdge* e = res.first;\n    vector<QuadEdge*> edges = {e};\n    while (lt(e->onext->dest().cross(e->dest(), e->origin), 0))\n        e = e->onext;\n    auto add = [&p, &e, &edges]() {\n        QuadEdge* curr = e;\n        do {\n            curr->used = true;\n            p.push_back(curr->origin);\n            edges.push_back(curr->rev());\n            curr = curr->lnext();\n        } while (curr != e);\n    };\n    add();\n    p.clear();\n    int kek = 0;\n    while (kek < (int)edges.size()) {\n        if (!(e = edges[kek++])->used)\n            add();\n    }\n    vector<tuple<pt, pt, pt>> ans;\n    for (int i = 0; i < (int)p.size(); i += 3) {\n        ans.push_back(make_tuple(p[i], p[i + 1], p[i + 2]));\n    }\n    return ans;\n}\n```\n\n## Problems\n * [TIMUS 1504 Good Manners](http://acm.timus.ru/problem.aspx?space=1&num=1504)\n * [TIMUS 1520 Empire Strikes Back](http://acm.timus.ru/problem.aspx?space=1&num=1520)\n * [SGU 383 Caravans](https://codeforces.com/problemsets/acmsguru/problem/99999/383)\n", "problem_ids": [], "title": "Delaunay triangulation and Voronoi diagram"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: nearest_points\n---\n\n# Finding the nearest pair of points\n\n## Problem statement\n\nGiven $n$ points on the plane. Each point $p_i$ is defined by its coordinates $(x_i,y_i)$. It is required to find among them two such points, such that the distance between them is minimal:\n\n$$ \\min_{\\scriptstyle i, j=0 \\ldots n-1,\\atop \\scriptstyle i \\neq j } \\rho (p_i, p_j). $$\n\nWe take the usual Euclidean distances:\n\n$$ \\rho (p_i,p_j) = \\sqrt{(x_i-x_j)^2 + (y_i-y_j)^2} .$$\n\nThe trivial algorithm - iterating over all pairs and calculating the distance for each \u2014 works in $O(n^2)$. \n\nThe algorithm running in time $O(n \\log n)$ is described below. This algorithm was proposed by Shamos and Hoey in 1975. (Source: Ch. 5 Notes of _Algorithm Design_ by Kleinberg & Tardos, also see [here](https://ieeexplore.ieee.org/abstract/document/4567872)) Preparata and Shamos also showed that this algorithm is optimal in the decision tree model.\n\n## Algorithm\nWe construct an algorithm according to the general scheme of **divide-and-conquer** algorithms: the algorithm is designed as a recursive function, to which we pass a set of points; this recursive function splits this set in half, calls itself recursively on each half, and then performs some operations to combine the answers. The operation of combining consist of  detecting the cases when one point of the optimal solution fell into one half, and the other point into the other (in this case, recursive calls from each of the halves cannot detect this pair separately). The main difficulty, as always in case of divide and conquer algorithms, lies in the effective implementation of the merging stage. If a set of $n$ points is passed to the recursive function, then the merge stage should work no more than $O(n)$, then the asymptotics of the whole algorithm $T(n)$ will be found from the equation:\n\n$$T(n) = 2T(n/2) + O(n).$$ \n\nThe solution to this equation, as is known, is $T(n) = O(n \\log n).$\n\nSo, we proceed on to the construction of the algorithm. In order to come to an effective implementation of the merge stage in the future, we will divide the set of points into two subsets, according to their $x$-coordinates: In fact, we draw some vertical line dividing the set of points into two subsets of approximately the same size. It is convenient to make such a partition as follows: We sort the points in the standard way as pairs of numbers, ie.:\n\n$$p_i < p_j \\Longleftrightarrow (x_i < x_j) \\lor \\Big(\\left(x_i = x_j\\right) \\wedge \\left(y_i < y_j \\right) \\Big) $$\n\nThen take the middle point after sorting $p_m (m = \\lfloor n/2 \\rfloor)$, and all the points before it and the $p_m$ itself are assigned to the first half, and all the points after it - to the second half:\n\n$$A_1 = \\{p_i \\ | \\ i = 0 \\ldots m \\}$$\n\n$$A_2 = \\{p_i \\ | \\ i = m + 1 \\ldots n-1 \\}.$$ \n\nNow, calling recursively on each of the sets $A_1$ and $A_2$, we will find the answers $h_1$ and $h_2$ for each of the halves. And take the best of them: $h = \\min(h_1, h_2)$.\n\nNow we need to make a **merge stage**, i.e. we try to find such pairs of points, for which the distance between which is less than $h$ and one point is lying in $A_1$ and the other in $A_2$.\nIt is obvious that it is sufficient to consider only those points that are separated from the vertical line by a distance less than $h$, i.e. the set $B$ of the points considered at this stage is equal to:\n\n$$B = \\{ p_i\\ | \\ | x_i - x_m\\ | < h \\}.$$ \n\nFor each point in the set $B$, we try to find the points that are closer to it than $h$. For example, it is sufficient to consider only those points whose $y$-coordinate differs by no more than $h$. Moreover, it makes no sense to consider those points whose $y$-coordinate is greater than the $y$-coordinate of the current point. Thus, for each point $p_i$ we define the set of considered points $C(p_i)$ as follows:\n\n$$C(p_i) = \\{ p_j\\ |\\ p_j \\in B,\\ \\ y_i - h < y_j \\le y_i \\}.$$\n\nIf we sort the points of the set $B$ by $y$-coordinate, it will be very easy to find $C(p_i)$: these are several points in a row ahead to the point $p_i$.\n\nSo, in the new notation, the **merging stage** looks like this: build a set $B$, sort the points in it by $y$-coordinate, then for each point $p_i \\in B$ consider all points $p_j \\in C(p_i)$, and for each pair $(p_i,p_j)$ calculate the distance and compare with the current best distance.\n\nAt first glance, this is still a non-optimal algorithm: it seems that the sizes of sets $C(p_i)$ will be of order $n$, and the required asymptotics will not work. However, surprisingly, it can be proved that the size of each of the sets $C(p_i)$ is a quantity $O(1)$, i.e. it does not exceed some small constant regardless of the points themselves. Proof of this fact is given in the next section.\n\nFinally, we pay attention to the sorting, which the above algorithm contains: first,sorting by pairs $(x, y)$, and then second, sorting the elements of the set $B$ by $y$. In fact, both of these sorts inside the recursive function can be eliminated (otherwise we would not reach the $O(n)$ estimate for the **merging stage**, and the general asymptotics of the algorithm would be $O(n \\log^2 n)$). It is easy to get rid of the first sort \u2014 it is enough to perform this sort before starting the recursion: after all, the elements themselves do not change inside the recursion, so there is no need to sort again. With the second sorting a little more difficult to perform, performing it previously will not work. But, remembering the merge sort, which also works on the principle of divide-and-conquer, we can simply embed this sort in our recursion. Let recursion, taking some set of points (as we remember,ordered by pairs $(x, y)$), return the same set, but sorted by the $y$-coordinate. To do this, simply merge (in $O(n)$) the two results returned by recursive calls. This will result in a set sorted by $y$-coordinate.\n\n## Evaluation of the asymptotics\n\nTo show that the above algorithm is actually executed in $O(n \\log n)$, we need to prove the following fact: $|C(p_i)| = O(1)$.\n\nSo, let us consider some point $p_i$; recall that the set $C(p_i)$ is a set of points whose $y$-coordinate lies in the segment $[y_i-h; y_i]$, and, moreover, along the $x$ coordinate, the point $p_i$ itself, and all the points of the set $C(p_i)$ lie in the band width $2h$. In other words, the points we are considering $p_i$ and $C(p_i)$ lie in a rectangle of size $2h \\times h$.\n\nOur task is to estimate the maximum number of points that can lie in this rectangle $2h \\times h$; thus, we estimate the maximum size of the set $C(p_i)$. At the same time, when evaluating, we must not forget that there may be repeated points.\n\nRemember that $h$ was obtained from the results of two recursive calls \u2014 on sets $A_1$ and $A_2$, and $A_1$ contains points to the left of the partition line and partially on it, $A_2$ contains the remaining points of the partition line and points to the right of it. For any pair of points from $A_1$, as well as from $A_2$, the distance can not be less than $h$ \u2014 otherwise it would mean incorrect operation of the recursive function.\n\nTo estimate the maximum number of points in the rectangle $2h \\times h$ we divide it into two squares $h \\times h$, the first square include all points $C(p_i) \\cap A_1$, and the second contains all the others, i.e. $C(p_i) \\cap A_2$. It follows from the above considerations that in each of these squares the distance between any two points is at least $h$.\n\nWe show that there are at most four points in each square. For example, this can be done as follows: divide the square into $4$ sub-squares with sides $h/2$. Then there can be no more than one point in each of these sub-squares (since even the diagonal is equal to $h / \\sqrt{2}$, which is less than $h$). Therefore, there can be no more than $4$ points in the whole square.\n\nSo, we have proved that in a rectangle $2h \\times h$ can not be more than $4 \\cdot 2 = 8$ points, and, therefore, the size of the set $C(p_i)$ cannot exceed $7$, as required.\n\n## Implementation\n\nWe introduce a data structure to store a point (its coordinates and a number) and comparison operators required for two types of sorting:\n\n```{.cpp file=nearest_pair_def}\nstruct pt {\n    int x, y, id;\n};\n\nstruct cmp_x {\n    bool operator()(const pt & a, const pt & b) const {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    }\n};\n \nstruct cmp_y {\n    bool operator()(const pt & a, const pt & b) const {\n        return a.y < b.y;\n    }\n};\n \nint n;\nvector<pt> a;\n```\n\nFor a convenient implementation of recursion, we introduce an auxiliary function upd_ans(), which will calculate the distance between two points and check whether it is better than the current answer:\n\n```{.cpp file=nearest_pair_update}\ndouble mindist;\npair<int, int> best_pair;\n \nvoid upd_ans(const pt & a, const pt & b) {\n    double dist = sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));\n    if (dist < mindist) {\n        mindist = dist;\n        best_pair = {a.id, b.id};\n    }\n}\n```\n\nFinally, the implementation of the recursion itself. It is assumed that before calling it, the array $a[]$ is already sorted by $x$-coordinate. In recursion we pass just two pointers $l, r$, which indicate that it should look for the answer for $a[l \\ldots r)$. If the distance between $r$ and $l$ is too small, the recursion must be stopped, and perform a trivial algorithm to find the nearest pair and then sort the subarray by $y$-coordinate.\n\nTo merge two sets of points received from recursive calls into one (ordered by $y$-coordinate), we use the standard STL $merge()$ function, and create an auxiliary buffer $t[]$(one for all recursive calls). (Using inplace_merge () is impractical because it generally does not work in linear time.)\n\nFinally, the set $B$ is stored in the same array $t$.\n\n```{.cpp file=nearest_pair_rec}\nvector<pt> t;\n\nvoid rec(int l, int r) {\n    if (r - l <= 3) {\n        for (int i = l; i < r; ++i) {\n            for (int j = i + 1; j < r; ++j) {\n                upd_ans(a[i], a[j]);\n            }\n        }\n        sort(a.begin() + l, a.begin() + r, cmp_y());\n        return;\n    }\n\n    int m = (l + r) >> 1;\n    int midx = a[m].x;\n    rec(l, m);\n    rec(m, r);\n\n    merge(a.begin() + l, a.begin() + m, a.begin() + m, a.begin() + r, t.begin(), cmp_y());\n    copy(t.begin(), t.begin() + r - l, a.begin() + l);\n\n    int tsz = 0;\n    for (int i = l; i < r; ++i) {\n        if (abs(a[i].x - midx) < mindist) {\n            for (int j = tsz - 1; j >= 0 && a[i].y - t[j].y < mindist; --j)\n                upd_ans(a[i], t[j]);\n            t[tsz++] = a[i];\n        }\n    }\n}\n```\n\nBy the way, if all the coordinates are integer, then at the time of the recursion you can not move to fractional values, and store in $mindist$ the square of the minimum distance.\n\nIn the main program, recursion should be called as follows:\n\n```{.cpp file=nearest_pair_main}\nt.resize(n);\nsort(a.begin(), a.end(), cmp_x());\nmindist = 1E20;\nrec(0, n);\n```\n\n## Generalization: finding a triangle with minimal perimeter\n\nThe algorithm described above is interestingly generalized to this problem: among a given set of points, choose three different points so that the sum of pairwise distances between them is the smallest.\n\nIn fact, to solve this problem, the algorithm remains the same: we divide the field into two halves of the vertical line, call the solution recursively on both halves, choose the minimum $minper$ from the found perimeters, build a strip with the thickness of $minper / 2$, and iterate through all triangles that can improve the answer. (Note that the triangle with perimeter $\\le minper$ has the longest side $\\le minper / 2$.)\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: nearest_points\n---\n\n# Finding the nearest pair of points\n\n## Problem statement\n\nGiven $n$ points on the plane. Each point $p_i$ is defined by its coordinates $(x_i,y_i)$. It is required to find among them two such points, such that the distance between them is minimal:\n\n$$ \\min_{\\scriptstyle i, j=0 \\ldots n-1,\\atop \\scriptstyle i \\neq j } \\rho (p_i, p_j). $$\n\nWe take the usual Euclidean distances:\n\n$$ \\rho (p_i,p_j) = \\sqrt{(x_i-x_j)^2 + (y_i-y_j)^2} .$$\n\nThe trivial algorithm - iterating over all pairs and calculating the distance for each \u2014 works in $O(n^2)$. \n\nThe algorithm running in time $O(n \\log n)$ is described below. This algorithm was proposed by Shamos and Hoey in 1975. (Source: Ch. 5 Notes of _Algorithm Design_ by Kleinberg & Tardos, also see [here](https://ieeexplore.ieee.org/abstract/document/4567872)) Preparata and Shamos also showed that this algorithm is optimal in the decision tree model.\n\n## Algorithm\nWe construct an algorithm according to the general scheme of **divide-and-conquer** algorithms: the algorithm is designed as a recursive function, to which we pass a set of points; this recursive function splits this set in half, calls itself recursively on each half, and then performs some operations to combine the answers. The operation of combining consist of  detecting the cases when one point of the optimal solution fell into one half, and the other point into the other (in this case, recursive calls from each of the halves cannot detect this pair separately). The main difficulty, as always in case of divide and conquer algorithms, lies in the effective implementation of the merging stage. If a set of $n$ points is passed to the recursive function, then the merge stage should work no more than $O(n)$, then the asymptotics of the whole algorithm $T(n)$ will be found from the equation:\n\n$$T(n) = 2T(n/2) + O(n).$$ \n\nThe solution to this equation, as is known, is $T(n) = O(n \\log n).$\n\nSo, we proceed on to the construction of the algorithm. In order to come to an effective implementation of the merge stage in the future, we will divide the set of points into two subsets, according to their $x$-coordinates: In fact, we draw some vertical line dividing the set of points into two subsets of approximately the same size. It is convenient to make such a partition as follows: We sort the points in the standard way as pairs of numbers, ie.:\n\n$$p_i < p_j \\Longleftrightarrow (x_i < x_j) \\lor \\Big(\\left(x_i = x_j\\right) \\wedge \\left(y_i < y_j \\right) \\Big) $$\n\nThen take the middle point after sorting $p_m (m = \\lfloor n/2 \\rfloor)$, and all the points before it and the $p_m$ itself are assigned to the first half, and all the points after it - to the second half:\n\n$$A_1 = \\{p_i \\ | \\ i = 0 \\ldots m \\}$$\n\n$$A_2 = \\{p_i \\ | \\ i = m + 1 \\ldots n-1 \\}.$$ \n\nNow, calling recursively on each of the sets $A_1$ and $A_2$, we will find the answers $h_1$ and $h_2$ for each of the halves. And take the best of them: $h = \\min(h_1, h_2)$.\n\nNow we need to make a **merge stage**, i.e. we try to find such pairs of points, for which the distance between which is less than $h$ and one point is lying in $A_1$ and the other in $A_2$.\nIt is obvious that it is sufficient to consider only those points that are separated from the vertical line by a distance less than $h$, i.e. the set $B$ of the points considered at this stage is equal to:\n\n$$B = \\{ p_i\\ | \\ | x_i - x_m\\ | < h \\}.$$ \n\nFor each point in the set $B$, we try to find the points that are closer to it than $h$. For example, it is sufficient to consider only those points whose $y$-coordinate differs by no more than $h$. Moreover, it makes no sense to consider those points whose $y$-coordinate is greater than the $y$-coordinate of the current point. Thus, for each point $p_i$ we define the set of considered points $C(p_i)$ as follows:\n\n$$C(p_i) = \\{ p_j\\ |\\ p_j \\in B,\\ \\ y_i - h < y_j \\le y_i \\}.$$\n\nIf we sort the points of the set $B$ by $y$-coordinate, it will be very easy to find $C(p_i)$: these are several points in a row ahead to the point $p_i$.\n\nSo, in the new notation, the **merging stage** looks like this: build a set $B$, sort the points in it by $y$-coordinate, then for each point $p_i \\in B$ consider all points $p_j \\in C(p_i)$, and for each pair $(p_i,p_j)$ calculate the distance and compare with the current best distance.\n\nAt first glance, this is still a non-optimal algorithm: it seems that the sizes of sets $C(p_i)$ will be of order $n$, and the required asymptotics will not work. However, surprisingly, it can be proved that the size of each of the sets $C(p_i)$ is a quantity $O(1)$, i.e. it does not exceed some small constant regardless of the points themselves. Proof of this fact is given in the next section.\n\nFinally, we pay attention to the sorting, which the above algorithm contains: first,sorting by pairs $(x, y)$, and then second, sorting the elements of the set $B$ by $y$. In fact, both of these sorts inside the recursive function can be eliminated (otherwise we would not reach the $O(n)$ estimate for the **merging stage**, and the general asymptotics of the algorithm would be $O(n \\log^2 n)$). It is easy to get rid of the first sort \u2014 it is enough to perform this sort before starting the recursion: after all, the elements themselves do not change inside the recursion, so there is no need to sort again. With the second sorting a little more difficult to perform, performing it previously will not work. But, remembering the merge sort, which also works on the principle of divide-and-conquer, we can simply embed this sort in our recursion. Let recursion, taking some set of points (as we remember,ordered by pairs $(x, y)$), return the same set, but sorted by the $y$-coordinate. To do this, simply merge (in $O(n)$) the two results returned by recursive calls. This will result in a set sorted by $y$-coordinate.\n\n## Evaluation of the asymptotics\n\nTo show that the above algorithm is actually executed in $O(n \\log n)$, we need to prove the following fact: $|C(p_i)| = O(1)$.\n\nSo, let us consider some point $p_i$; recall that the set $C(p_i)$ is a set of points whose $y$-coordinate lies in the segment $[y_i-h; y_i]$, and, moreover, along the $x$ coordinate, the point $p_i$ itself, and all the points of the set $C(p_i)$ lie in the band width $2h$. In other words, the points we are considering $p_i$ and $C(p_i)$ lie in a rectangle of size $2h \\times h$.\n\nOur task is to estimate the maximum number of points that can lie in this rectangle $2h \\times h$; thus, we estimate the maximum size of the set $C(p_i)$. At the same time, when evaluating, we must not forget that there may be repeated points.\n\nRemember that $h$ was obtained from the results of two recursive calls \u2014 on sets $A_1$ and $A_2$, and $A_1$ contains points to the left of the partition line and partially on it, $A_2$ contains the remaining points of the partition line and points to the right of it. For any pair of points from $A_1$, as well as from $A_2$, the distance can not be less than $h$ \u2014 otherwise it would mean incorrect operation of the recursive function.\n\nTo estimate the maximum number of points in the rectangle $2h \\times h$ we divide it into two squares $h \\times h$, the first square include all points $C(p_i) \\cap A_1$, and the second contains all the others, i.e. $C(p_i) \\cap A_2$. It follows from the above considerations that in each of these squares the distance between any two points is at least $h$.\n\nWe show that there are at most four points in each square. For example, this can be done as follows: divide the square into $4$ sub-squares with sides $h/2$. Then there can be no more than one point in each of these sub-squares (since even the diagonal is equal to $h / \\sqrt{2}$, which is less than $h$). Therefore, there can be no more than $4$ points in the whole square.\n\nSo, we have proved that in a rectangle $2h \\times h$ can not be more than $4 \\cdot 2 = 8$ points, and, therefore, the size of the set $C(p_i)$ cannot exceed $7$, as required.\n\n## Implementation\n\nWe introduce a data structure to store a point (its coordinates and a number) and comparison operators required for two types of sorting:\n\n```{.cpp file=nearest_pair_def}\nstruct pt {\n    int x, y, id;\n};\n\nstruct cmp_x {\n    bool operator()(const pt & a, const pt & b) const {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    }\n};\n \nstruct cmp_y {\n    bool operator()(const pt & a, const pt & b) const {\n        return a.y < b.y;\n    }\n};\n \nint n;\nvector<pt> a;\n```\n\nFor a convenient implementation of recursion, we introduce an auxiliary function upd_ans(), which will calculate the distance between two points and check whether it is better than the current answer:\n\n```{.cpp file=nearest_pair_update}\ndouble mindist;\npair<int, int> best_pair;\n \nvoid upd_ans(const pt & a, const pt & b) {\n    double dist = sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));\n    if (dist < mindist) {\n        mindist = dist;\n        best_pair = {a.id, b.id};\n    }\n}\n```\n\nFinally, the implementation of the recursion itself. It is assumed that before calling it, the array $a[]$ is already sorted by $x$-coordinate. In recursion we pass just two pointers $l, r$, which indicate that it should look for the answer for $a[l \\ldots r)$. If the distance between $r$ and $l$ is too small, the recursion must be stopped, and perform a trivial algorithm to find the nearest pair and then sort the subarray by $y$-coordinate.\n\nTo merge two sets of points received from recursive calls into one (ordered by $y$-coordinate), we use the standard STL $merge()$ function, and create an auxiliary buffer $t[]$(one for all recursive calls). (Using inplace_merge () is impractical because it generally does not work in linear time.)\n\nFinally, the set $B$ is stored in the same array $t$.\n\n```{.cpp file=nearest_pair_rec}\nvector<pt> t;\n\nvoid rec(int l, int r) {\n    if (r - l <= 3) {\n        for (int i = l; i < r; ++i) {\n            for (int j = i + 1; j < r; ++j) {\n                upd_ans(a[i], a[j]);\n            }\n        }\n        sort(a.begin() + l, a.begin() + r, cmp_y());\n        return;\n    }\n\n    int m = (l + r) >> 1;\n    int midx = a[m].x;\n    rec(l, m);\n    rec(m, r);\n\n    merge(a.begin() + l, a.begin() + m, a.begin() + m, a.begin() + r, t.begin(), cmp_y());\n    copy(t.begin(), t.begin() + r - l, a.begin() + l);\n\n    int tsz = 0;\n    for (int i = l; i < r; ++i) {\n        if (abs(a[i].x - midx) < mindist) {\n            for (int j = tsz - 1; j >= 0 && a[i].y - t[j].y < mindist; --j)\n                upd_ans(a[i], t[j]);\n            t[tsz++] = a[i];\n        }\n    }\n}\n```\n\nBy the way, if all the coordinates are integer, then at the time of the recursion you can not move to fractional values, and store in $mindist$ the square of the minimum distance.\n\nIn the main program, recursion should be called as follows:\n\n```{.cpp file=nearest_pair_main}\nt.resize(n);\nsort(a.begin(), a.end(), cmp_x());\nmindist = 1E20;\nrec(0, n);\n```\n\n## Generalization: finding a triangle with minimal perimeter\n\nThe algorithm described above is interestingly generalized to this problem: among a given set of points, choose three different points so that the sum of pairwise distances between them is the smallest.\n\nIn fact, to solve this problem, the algorithm remains the same: we divide the field into two halves of the vertical line, call the solution recursively on both halves, choose the minimum $minper$ from the found perimeters, build a strip with the thickness of $minper / 2$, and iterate through all triangles that can improve the answer. (Note that the triangle with perimeter $\\le minper$ has the longest side $\\le minper / 2$.)\n\n## Practice problems\n\n* [UVA 10245 \"The Closest Pair Problem\" [difficulty: low]](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1186)\n* [SPOJ #8725 CLOPPAIR \"Closest Point Pair\" [difficulty: low]](https://www.spoj.com/problems/CLOPPAIR/)\n* [CODEFORCES Team Olympiad Saratov - 2011 \"Minimum amount\" [difficulty: medium]](http://codeforces.com/contest/120/problem/J)\n* [Google CodeJam 2009 Final \" Min Perimeter \"[difficulty: medium]](https://code.google.com/codejam/contest/311101/dashboard#s=a&a=1)\n* [SPOJ #7029 CLOSEST \"Closest Triple\" [difficulty: medium]](https://www.spoj.com/problems/CLOSEST/)\n* [TIMUS 1514 National Park [difficulty: medium]](https://acm.timus.ru/problem.aspx?space=1&num=1514)\n", "problem_ids": [], "title": "Finding the nearest pair of points"}, {"article": "---\ntitle: Point location in O(log n)\ntags:\n  - Original\n---\n# Point location in $O(log n)$\n\nConsider the following problem: you are given a [planar subdivision](https://en.wikipedia.org/wiki/Planar_straight-line_graph) without no vertices of degree one and zero, and a lot of queries.\nEach query is a point, for which we should determine the face of the subdivision it belongs to.\nWe will answer each query in $O(\\log n)$ offline.<br>\nThis problem may arise when you need to locate some points in a Voronoi diagram or in some simple polygon.\n\n## Algorithm\n\nFirstly, for each query point $p\\ (x_0, y_0)$ we want to find such an edge that if the point belongs to any edge, the point lies on the edge we found, otherwise this edge must intersect the line $x = x_0$ at some unique point $(x_0, y)$ where $y < y_0$ and this $y$ is maximum among all such edges.\nThe following image shows both cases.\n\n<center>![Image of Goal](point_location_goal.png)</center>\n\nWe will solve this problem offline using the sweep line algorithm. Let's iterate over x-coordinates of query points and edges' endpoints in increasing order and keep a set of edges $s$. For each x-coordinate we will add some events beforehand.\n\nThe events will be of four types: _add_, _remove_, _vertical_, _get_.\nFor each vertical edge (both endpoints have the same x-coordinate) we will add one _vertical_ event for the corresponding x-coordinate.\nFor every other edge we will add one _add_ event for the minimum of x-coordinates of the endpoints and one _remove_ event for the maximum of x-coordinates of the endpoints.\nFinally, for each query point we will add one _get_ event for its x-coordinate.\n\nFor each x-coordinate we will sort the events by their types in order (_vertical_, _get_, _remove_, _add_).\nThe following image shows all events in sorted order for each x-coordinate.\n\n<center>![Image of Events](point_location_events.png)</center>\n\nWe will keep two sets during the sweep-line process.\nA set $t$ for all non-vertical edges, and one set $vert$ especially for the vertical ones.\nWe will clear the set $vert$ at the beginning of processing each x-coordinate.\n\nNow let's process the events for a fixed x-coordinate.\n\n - If we got a _vertical_ event, we will simply insert the minimum y-coordinate of the corresponding edge's endpoints to $vert$.\n - If we got a _remove_ or _add_ event, we will remove the corresponding edge from $t$ or add it to $t$.\n - Finally, for each _get_ event we must check if the point lies on some vertical edge by performing a binary search in $vert$.\nIf the point doesn't lie on any vertical edge, we must find the answer for this query in $t$.\nTo do this, we again make a binary search.\nIn order to handle some degenerate cases (e.g. in case of the triangle $(0,~0)$, $(0,~2)$, $(1, 1)$ when we query the point $(0,~0)$), we must answer all _get_ events again after we processed all the events for this x-coordinate and choose the best of two answers.\n\nNow let's choose a comparator for the set $t$.\nThis comparator should check if one edge doesn't lie above other for every x-coordinate they both cover. Suppose that we have two edges $(a, b)$ and $(c, d)$. Then the comparator is (in pseudocode):<br>\n\n$val = sgn((b - a)\\times(c - a)) + sgn((b - a)\\times(d - a))$<br>\n<b>if</b> $val \\neq 0$<br>\n<b>then return</b> $val > 0$<br>\n$val = sgn((d - c)\\times(a - c)) + sgn((d - c)\\times(b - c))$<br>\n<b>return</b> $val < 0$<br>\n\nNow for every query we have the corresponding edge.\nHow to find the face?\nIf we couldn't find the edge it means that the point is in the outer face.\nIf the point belongs to the edge we found, the face is not unique.\nOtherwise, there are two candidates - the faces that are bounded by this edge.\nHow to check which one is the answer? Note that the edge is not vertical.\nThen the answer is the face that is above this edge.\nLet's find such a face for each non-vertical edge.\nConsider a counter-clockwise traversal of each face.\nIf during this traversal we increased x-coordinate while passing through the edge, then this face is the face we need to find for this edge.\n\n## Notes\n\nActually, with persistent trees this approach can be used to answer the queries online.\n\n## Implementation\n\nThe following code is implemented for integers, but it can be easily modified to work with doubles (by changing the compare methods and the point type).\nThis implementation assumes that the subdivision is correctly stored inside a [DCEL](https://en.wikipedia.org/wiki/Doubly_connected_edge_list) and the outer face is numbered $-1$.<br>\nFor each query a pair $(1, i)$ is returned if the point lies strictly inside the face number $i$, and a pair $(0, i)$ is returned if the point lies on the edge number $i$.\n\n```{.cpp file=point-location}\ntypedef long long ll;\n\nbool ge(const ll& a, const ll& b) { return a >= b; }\nbool le(const ll& a, const ll& b) { return a <= b; }\nbool eq(const ll& a, const ll& b) { return a == b; }\nbool gt(const ll& a, const ll& b) { return a > b; }\nbool lt(const ll& a, const ll& b) { return a < b; }\nint sgn(const ll& x) { return le(x, 0) ? eq(x, 0) ? 0 : -1 : 1; }\n\nstruct pt {\n    ll x, y;\n    pt() {}\n    pt(ll _x, ll _y) : x(_x), y(_y) {}\n    pt operator-(const pt& a) const { return pt(x - a.x, y - a.y); }\n    ll dot(const pt& a) const { return x * a.x + y * a.y; }\n    ll dot(const pt& a, const pt& b) const { return (a - *this).dot(b - *this); }\n    ll cross(const pt& a) const { return x * a.y - y * a.x; }\n    ll cross(const pt& a, const pt& b) const { return (a - *this).cross(b - *this); }\n    bool operator==(const pt& a) const { return a.x == x && a.y == y; }\n};\n\nstruct Edge {\n    pt l, r;\n};\n\nbool edge_cmp(Edge* edge1, Edge* edge2)\n{\n    const pt a = edge1->l, b = edge1->r;\n    const pt c = edge2->l, d = edge2->r;\n    int val = sgn(a.cross(b, c)) + sgn(a.cross(b, d));\n    if (val != 0)\n        return val > 0;\n    val = sgn(c.cross(d, a)) + sgn(c.cross(d, b));\n    return val < 0;\n}\n\nenum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };\n\nstruct Event {\n    EventType type;\n    int pos;\n    bool operator<(const Event& event) const { return type < event.type; }\n};\n\nvector<Edge*> sweepline(vector<Edge*> planar, vector<pt> queries)\n{\n    using pt_type = decltype(pt::x);\n\n    // collect all x-coordinates\n    auto s =\n        set<pt_type, std::function<bool(const pt_type&, const pt_type&)>>(lt);\n    for (pt p : queries)\n        s.insert(p.x);\n    for (Edge* e : planar) {\n        s.insert(e->l.x);\n        s.insert(e->r.x);\n    }\n\n    // map all x-coordinates to ids\n    int cid = 0;\n    auto id =\n        map<pt_type, int, std::function<bool(const pt_type&, const pt_type&)>>(\n            lt);\n    for (auto x : s)\n        id[x] = cid++;\n\n    // create events\n    auto t = set<Edge*, decltype(*edge_cmp)>(edge_cmp);\n    auto vert_cmp = [](const pair<pt_type, int>& l,\n                       const pair<pt_type, int>& r) {\n        if (!eq(l.first, r.first))\n            return lt(l.first, r.first);\n        return l.second < r.second;\n    };\n    auto vert = set<pair<pt_type, int>, decltype(vert_cmp)>(vert_cmp);\n    vector<vector<Event>> events(cid);\n    for (int i = 0; i < (int)queries.size(); i++) {\n        int x = id[queries[i].x];\n        events[x].push_back(Event{GET, i});\n    }\n    for (int i = 0; i < (int)planar.size(); i++) {\n        int lx = id[planar[i]->l.x], rx = id[planar[i]->r.x];\n        if (lx > rx) {\n            swap(lx, rx);\n            swap(planar[i]->l, planar[i]->r);\n        }\n        if (lx == rx) {\n            events[lx].push_back(Event{VERT, i});\n        } else {\n            events[lx].push_back(Event{ADD, i});\n            events[rx].push_back(Event{DEL, i});\n        }\n    }\n\n    // perform sweep line algorithm\n    vector<Edge*> ans(queries.size(), nullptr);\n    for (int x = 0; x < cid; x++) {\n        sort(events[x].begin(), events[x].end());\n        vert.clear();\n        for (Event event : events[x]) {\n            if (event.type == DEL) {\n                t.erase(planar[event.pos]);\n            }\n            if (event.type == VERT) {\n                vert.insert(make_pair(\n                    min(planar[event.pos]->l.y, planar[event.pos]->r.y),\n                    event.pos));\n            }\n            if (event.type == ADD) {\n                t.insert(planar[event.pos]);\n            }\n            if (event.type == GET) {\n                auto jt = vert.upper_bound(\n                    make_pair(queries[event.pos].y, planar.size()));\n                if (jt != vert.begin()) {\n                    --jt;\n                    int i = jt->second;\n                    if (ge(max(planar[i]->l.y, planar[i]->r.y),\n                           queries[event.pos].y)) {\n                        ans[event.pos] = planar[i];\n                        continue;\n                    }\n                }\n                Edge* e = new Edge;\n                e->l = e->r = queries[event.pos];\n                auto it = t.upper_bound(e);\n                if (it != t.begin())\n                    ans[event.pos] = *(--it);\n                delete e;\n            }\n        }\n\n        for (Event event : events[x]) {\n            if (event.type != GET)\n                continue;\n            if (ans[event.pos] != nullptr &&\n                eq(ans[event.pos]->l.x, ans[event.pos]->r.x))\n                continue;\n\n            Edge* e = new Edge;\n            e->l = e->r = queries[event.pos];\n            auto it = t.upper_bound(e);\n            delete e;\n            if (it == t.begin())\n                e = nullptr;\n            else\n                e = *(--it);\n            if (ans[event.pos] == nullptr) {\n                ans[event.pos] = e;\n                continue;\n            }\n            if (e == nullptr)\n                continue;\n            if (e == ans[event.pos])\n                continue;\n            if (id[ans[event.pos]->r.x] == x) {\n                if (id[e->l.x] == x) {\n                    if (gt(e->l.y, ans[event.pos]->r.y))\n                        ans[event.pos] = e;\n                }\n            } else {\n                ans[event.pos] = e;\n            }\n        }\n    }\n    return ans;\n}\n\nstruct DCEL {\n    struct Edge {\n        pt origin;\n        Edge* nxt = nullptr;\n        Edge* twin = nullptr;\n        int face;\n    };\n    vector<Edge*> body;\n};\n\nvector<pair<int, int>> point_location(DCEL planar, vector<pt> queries)\n{\n    vector<pair<int, int>> ans(queries.size());\n    vector<Edge*> planar2;\n    map<intptr_t, int> pos;\n    map<intptr_t, int> added_on;\n    int n = planar.body.size();\n    for (int i = 0; i < n; i++) {\n        if (planar.body[i]->face > planar.body[i]->twin->face)\n            continue;\n        Edge* e = new Edge;\n        e->l = planar.body[i]->origin;\n        e->r = planar.body[i]->twin->origin;\n        added_on[(intptr_t)e] = i;\n        pos[(intptr_t)e] =\n            lt(planar.body[i]->origin.x, planar.body[i]->twin->origin.x)\n                ? planar.body[i]->face\n                : planar.body[i]->twin->face;\n        planar2.push_back(e);\n    }\n    auto res = sweepline(planar2, queries);\n    for (int i = 0; i < (int)queries.size(); i++) {\n        if (res[i] == nullptr) {\n            ans[i] = make_pair(1, -1);\n            continue;\n        }\n        pt p = queries[i];\n        pt l = res[i]->l, r = res[i]->r;\n        if (eq(p.cross(l, r), 0) && le(p.dot(l, r), 0)) {\n            ans[i] = make_pair(0, added_on[(intptr_t)res[i]]);\n            continue;\n        }\n        ans[i] = make_pair(1, pos[(intptr_t)res[i]]);\n    }\n    for (auto e : planar2)\n        delete e;\n    return ans;\n}\n```\n\n", "full_article": "---\ntitle: Point location in O(log n)\ntags:\n  - Original\n---\n# Point location in $O(log n)$\n\nConsider the following problem: you are given a [planar subdivision](https://en.wikipedia.org/wiki/Planar_straight-line_graph) without no vertices of degree one and zero, and a lot of queries.\nEach query is a point, for which we should determine the face of the subdivision it belongs to.\nWe will answer each query in $O(\\log n)$ offline.<br>\nThis problem may arise when you need to locate some points in a Voronoi diagram or in some simple polygon.\n\n## Algorithm\n\nFirstly, for each query point $p\\ (x_0, y_0)$ we want to find such an edge that if the point belongs to any edge, the point lies on the edge we found, otherwise this edge must intersect the line $x = x_0$ at some unique point $(x_0, y)$ where $y < y_0$ and this $y$ is maximum among all such edges.\nThe following image shows both cases.\n\n<center>![Image of Goal](point_location_goal.png)</center>\n\nWe will solve this problem offline using the sweep line algorithm. Let's iterate over x-coordinates of query points and edges' endpoints in increasing order and keep a set of edges $s$. For each x-coordinate we will add some events beforehand.\n\nThe events will be of four types: _add_, _remove_, _vertical_, _get_.\nFor each vertical edge (both endpoints have the same x-coordinate) we will add one _vertical_ event for the corresponding x-coordinate.\nFor every other edge we will add one _add_ event for the minimum of x-coordinates of the endpoints and one _remove_ event for the maximum of x-coordinates of the endpoints.\nFinally, for each query point we will add one _get_ event for its x-coordinate.\n\nFor each x-coordinate we will sort the events by their types in order (_vertical_, _get_, _remove_, _add_).\nThe following image shows all events in sorted order for each x-coordinate.\n\n<center>![Image of Events](point_location_events.png)</center>\n\nWe will keep two sets during the sweep-line process.\nA set $t$ for all non-vertical edges, and one set $vert$ especially for the vertical ones.\nWe will clear the set $vert$ at the beginning of processing each x-coordinate.\n\nNow let's process the events for a fixed x-coordinate.\n\n - If we got a _vertical_ event, we will simply insert the minimum y-coordinate of the corresponding edge's endpoints to $vert$.\n - If we got a _remove_ or _add_ event, we will remove the corresponding edge from $t$ or add it to $t$.\n - Finally, for each _get_ event we must check if the point lies on some vertical edge by performing a binary search in $vert$.\nIf the point doesn't lie on any vertical edge, we must find the answer for this query in $t$.\nTo do this, we again make a binary search.\nIn order to handle some degenerate cases (e.g. in case of the triangle $(0,~0)$, $(0,~2)$, $(1, 1)$ when we query the point $(0,~0)$), we must answer all _get_ events again after we processed all the events for this x-coordinate and choose the best of two answers.\n\nNow let's choose a comparator for the set $t$.\nThis comparator should check if one edge doesn't lie above other for every x-coordinate they both cover. Suppose that we have two edges $(a, b)$ and $(c, d)$. Then the comparator is (in pseudocode):<br>\n\n$val = sgn((b - a)\\times(c - a)) + sgn((b - a)\\times(d - a))$<br>\n<b>if</b> $val \\neq 0$<br>\n<b>then return</b> $val > 0$<br>\n$val = sgn((d - c)\\times(a - c)) + sgn((d - c)\\times(b - c))$<br>\n<b>return</b> $val < 0$<br>\n\nNow for every query we have the corresponding edge.\nHow to find the face?\nIf we couldn't find the edge it means that the point is in the outer face.\nIf the point belongs to the edge we found, the face is not unique.\nOtherwise, there are two candidates - the faces that are bounded by this edge.\nHow to check which one is the answer? Note that the edge is not vertical.\nThen the answer is the face that is above this edge.\nLet's find such a face for each non-vertical edge.\nConsider a counter-clockwise traversal of each face.\nIf during this traversal we increased x-coordinate while passing through the edge, then this face is the face we need to find for this edge.\n\n## Notes\n\nActually, with persistent trees this approach can be used to answer the queries online.\n\n## Implementation\n\nThe following code is implemented for integers, but it can be easily modified to work with doubles (by changing the compare methods and the point type).\nThis implementation assumes that the subdivision is correctly stored inside a [DCEL](https://en.wikipedia.org/wiki/Doubly_connected_edge_list) and the outer face is numbered $-1$.<br>\nFor each query a pair $(1, i)$ is returned if the point lies strictly inside the face number $i$, and a pair $(0, i)$ is returned if the point lies on the edge number $i$.\n\n```{.cpp file=point-location}\ntypedef long long ll;\n\nbool ge(const ll& a, const ll& b) { return a >= b; }\nbool le(const ll& a, const ll& b) { return a <= b; }\nbool eq(const ll& a, const ll& b) { return a == b; }\nbool gt(const ll& a, const ll& b) { return a > b; }\nbool lt(const ll& a, const ll& b) { return a < b; }\nint sgn(const ll& x) { return le(x, 0) ? eq(x, 0) ? 0 : -1 : 1; }\n\nstruct pt {\n    ll x, y;\n    pt() {}\n    pt(ll _x, ll _y) : x(_x), y(_y) {}\n    pt operator-(const pt& a) const { return pt(x - a.x, y - a.y); }\n    ll dot(const pt& a) const { return x * a.x + y * a.y; }\n    ll dot(const pt& a, const pt& b) const { return (a - *this).dot(b - *this); }\n    ll cross(const pt& a) const { return x * a.y - y * a.x; }\n    ll cross(const pt& a, const pt& b) const { return (a - *this).cross(b - *this); }\n    bool operator==(const pt& a) const { return a.x == x && a.y == y; }\n};\n\nstruct Edge {\n    pt l, r;\n};\n\nbool edge_cmp(Edge* edge1, Edge* edge2)\n{\n    const pt a = edge1->l, b = edge1->r;\n    const pt c = edge2->l, d = edge2->r;\n    int val = sgn(a.cross(b, c)) + sgn(a.cross(b, d));\n    if (val != 0)\n        return val > 0;\n    val = sgn(c.cross(d, a)) + sgn(c.cross(d, b));\n    return val < 0;\n}\n\nenum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };\n\nstruct Event {\n    EventType type;\n    int pos;\n    bool operator<(const Event& event) const { return type < event.type; }\n};\n\nvector<Edge*> sweepline(vector<Edge*> planar, vector<pt> queries)\n{\n    using pt_type = decltype(pt::x);\n\n    // collect all x-coordinates\n    auto s =\n        set<pt_type, std::function<bool(const pt_type&, const pt_type&)>>(lt);\n    for (pt p : queries)\n        s.insert(p.x);\n    for (Edge* e : planar) {\n        s.insert(e->l.x);\n        s.insert(e->r.x);\n    }\n\n    // map all x-coordinates to ids\n    int cid = 0;\n    auto id =\n        map<pt_type, int, std::function<bool(const pt_type&, const pt_type&)>>(\n            lt);\n    for (auto x : s)\n        id[x] = cid++;\n\n    // create events\n    auto t = set<Edge*, decltype(*edge_cmp)>(edge_cmp);\n    auto vert_cmp = [](const pair<pt_type, int>& l,\n                       const pair<pt_type, int>& r) {\n        if (!eq(l.first, r.first))\n            return lt(l.first, r.first);\n        return l.second < r.second;\n    };\n    auto vert = set<pair<pt_type, int>, decltype(vert_cmp)>(vert_cmp);\n    vector<vector<Event>> events(cid);\n    for (int i = 0; i < (int)queries.size(); i++) {\n        int x = id[queries[i].x];\n        events[x].push_back(Event{GET, i});\n    }\n    for (int i = 0; i < (int)planar.size(); i++) {\n        int lx = id[planar[i]->l.x], rx = id[planar[i]->r.x];\n        if (lx > rx) {\n            swap(lx, rx);\n            swap(planar[i]->l, planar[i]->r);\n        }\n        if (lx == rx) {\n            events[lx].push_back(Event{VERT, i});\n        } else {\n            events[lx].push_back(Event{ADD, i});\n            events[rx].push_back(Event{DEL, i});\n        }\n    }\n\n    // perform sweep line algorithm\n    vector<Edge*> ans(queries.size(), nullptr);\n    for (int x = 0; x < cid; x++) {\n        sort(events[x].begin(), events[x].end());\n        vert.clear();\n        for (Event event : events[x]) {\n            if (event.type == DEL) {\n                t.erase(planar[event.pos]);\n            }\n            if (event.type == VERT) {\n                vert.insert(make_pair(\n                    min(planar[event.pos]->l.y, planar[event.pos]->r.y),\n                    event.pos));\n            }\n            if (event.type == ADD) {\n                t.insert(planar[event.pos]);\n            }\n            if (event.type == GET) {\n                auto jt = vert.upper_bound(\n                    make_pair(queries[event.pos].y, planar.size()));\n                if (jt != vert.begin()) {\n                    --jt;\n                    int i = jt->second;\n                    if (ge(max(planar[i]->l.y, planar[i]->r.y),\n                           queries[event.pos].y)) {\n                        ans[event.pos] = planar[i];\n                        continue;\n                    }\n                }\n                Edge* e = new Edge;\n                e->l = e->r = queries[event.pos];\n                auto it = t.upper_bound(e);\n                if (it != t.begin())\n                    ans[event.pos] = *(--it);\n                delete e;\n            }\n        }\n\n        for (Event event : events[x]) {\n            if (event.type != GET)\n                continue;\n            if (ans[event.pos] != nullptr &&\n                eq(ans[event.pos]->l.x, ans[event.pos]->r.x))\n                continue;\n\n            Edge* e = new Edge;\n            e->l = e->r = queries[event.pos];\n            auto it = t.upper_bound(e);\n            delete e;\n            if (it == t.begin())\n                e = nullptr;\n            else\n                e = *(--it);\n            if (ans[event.pos] == nullptr) {\n                ans[event.pos] = e;\n                continue;\n            }\n            if (e == nullptr)\n                continue;\n            if (e == ans[event.pos])\n                continue;\n            if (id[ans[event.pos]->r.x] == x) {\n                if (id[e->l.x] == x) {\n                    if (gt(e->l.y, ans[event.pos]->r.y))\n                        ans[event.pos] = e;\n                }\n            } else {\n                ans[event.pos] = e;\n            }\n        }\n    }\n    return ans;\n}\n\nstruct DCEL {\n    struct Edge {\n        pt origin;\n        Edge* nxt = nullptr;\n        Edge* twin = nullptr;\n        int face;\n    };\n    vector<Edge*> body;\n};\n\nvector<pair<int, int>> point_location(DCEL planar, vector<pt> queries)\n{\n    vector<pair<int, int>> ans(queries.size());\n    vector<Edge*> planar2;\n    map<intptr_t, int> pos;\n    map<intptr_t, int> added_on;\n    int n = planar.body.size();\n    for (int i = 0; i < n; i++) {\n        if (planar.body[i]->face > planar.body[i]->twin->face)\n            continue;\n        Edge* e = new Edge;\n        e->l = planar.body[i]->origin;\n        e->r = planar.body[i]->twin->origin;\n        added_on[(intptr_t)e] = i;\n        pos[(intptr_t)e] =\n            lt(planar.body[i]->origin.x, planar.body[i]->twin->origin.x)\n                ? planar.body[i]->face\n                : planar.body[i]->twin->face;\n        planar2.push_back(e);\n    }\n    auto res = sweepline(planar2, queries);\n    for (int i = 0; i < (int)queries.size(); i++) {\n        if (res[i] == nullptr) {\n            ans[i] = make_pair(1, -1);\n            continue;\n        }\n        pt p = queries[i];\n        pt l = res[i]->l, r = res[i]->r;\n        if (eq(p.cross(l, r), 0) && le(p.dot(l, r), 0)) {\n            ans[i] = make_pair(0, added_on[(intptr_t)res[i]]);\n            continue;\n        }\n        ans[i] = make_pair(1, pos[(intptr_t)res[i]]);\n    }\n    for (auto e : planar2)\n        delete e;\n    return ans;\n}\n```\n\n## Problems\n * [TIMUS 1848 Fly Hunt](http://acm.timus.ru/problem.aspx?space=1&num=1848&locale=en)\n * [UVA 12310 Point Location](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=297&page=show_problem&problem=3732)\n", "problem_ids": [], "title": "Point location in $O(log n)$"}, {"article": "---\ntitle: Finding faces of a planar graph\ntags:\n  - Translated\ne_maxx_link: facets\n---\n# Finding faces of a planar graph\n\nConsider a graph $G$ with $n$ vertices and $m$ edges, which can be drawn on a plane in such a way that two edges intersect only at a common vertex (if it exists).\nSuch graphs are called **planar**. Now suppose that we are given a planar graph together with its straight-line embedding, which means that for each vertex $v$ we have a corresponding point $(x, y)$ and all edges are drawn as line segments between these points without intersection (such embedding always exists). These line segments split the plane into several regions, which are called faces. Exactly one of the faces is unbounded. This face is called **outer**, while the other faces are called **inner**.\n\nIn this article we will deal with finding both inner and outer faces of a planar graph. We will assume that the graph is connected.\n\n## Some facts about planar graphs\n\nIn this section we present several facts about planar graphs without proof. Readers who are interested in proofs should refer to [Graph Theory by R. Diestel](https://sites.math.washington.edu/~billey/classes/562.winter.2018/articles/GraphTheory.pdf) or some other book.\n\n### Euler's theorem\nEuler's theorem states that any correct embedding of a connected planar graph with $n$ vertices, $m$ edges and $f$ faces satisfies:\n\n$$n - m + f = 2$$\n\nAnd more generally, every planar graph with $k$ connected components satisfies:\n\n$$n - m + f = 1 + k$$\n\n### Number of edges of a planar graph.\nIf $n \\ge 3$ then the maximum number of edges of a planar graph with $n$ vertices is $3n - 6$. This number is achieved by any connected planar graph where each face is bounded by a triangle. In terms of complexity this fact means that $m = O(n)$ for any planar graph.\n\n### Number of faces of a planar graph.\nAs a direct consequence of the above fact, if $n \\ge 3$ then the maximum number of faces of a planar graph with $n$ vertices is $2n - 4$.\n\n### Minimum vertex degree in a planar graph.\nEvery planar graph has a vertex of degree 5 or less.\n\n## The algorithm\n\nFirstly, sort the adjacent edges for each vertex by polar angle.\nNow let's traverse the graph in the following way. Suppose that we entered vertex $u$ through the edge $(v, u)$ and $(u, w)$ is the next edge after $(v, u)$ in the sorted adjacency list of $u$. Then the next vertex will be $w$. It turns out that if we start this traversal at some edge $(v, u)$, we will traverse exactly one of the faces adjacent to $(v, u)$, the exact face depending on whether our first step is from $u$ to $v$ or from $v$ to $u$.\n\nNow the algorithm is quite obvious. We must iterate over all edges of the graph and start the traversal for each edge that wasn't visited by one of the previous traversals. This way we will find each face exactly once, and each edge will be traversed twice (once in each direction).\n\n### Finding the next edge\nDuring the traversal we have to find the next edge in counter-clockwise order. The most obvious way to find the next edge is binary search by angle. However, given the counter-clockwise order of adjacent edges for each vertex, we can precompute the next edges and store them in a hash table. If the edges are already sorted by angle, the complexity of finding all faces in this case becomes linear.\n\n### Finding the outer face\nIt's not hard to see that the algorithm traverses each inner face in a clockwise order and the outer face in the counter-clockwise order, so the outer face can be found by checking the order of each face.\n\n### Complexity\nIt's quite clear that the complexity of the algorithm is $O(m \\log m)$ because of sorting, and since $m = O(n)$, it's actually $O(n \\log n)$. As mentioned before, without sorting the complexity becomes $O(n)$.\n\n## What if the graph isn't connected?\n\nAt the first glance it may seem that finding faces of a disconnected graph is not much harder because we can run the same algorithm for each connected component. However, the components may be drawn in a nested way, forming **holes** (see the image below). In this case the inner face of some component becomes the outer face of some other components and has a complex disconnected border. Dealing with such cases is quite hard, one possible approach is to identify nested components with [point location](point-location.md) algorithms. \n\n<center>![Planar graph with holes](planar_hole.png)</center>\n\n## Implementation\nThe following implementation returns a vector of vertices for each face, outer face goes first.\nInner faces are returned in counter-clockwise orders and the outer face is returned in clockwise order.\n\nFor simplicity we find the next edge by doing binary search by angle.\n```{.cpp file=planar}\nstruct Point {\n    int64_t x, y;\n\n    Point(int64_t x_, int64_t y_): x(x_), y(y_) {}\n\n    Point operator - (const Point & p) const {\n        return Point(x - p.x, y - p.y);\n    }\n\n    int64_t cross (const Point & p) const {\n        return x * p.y - y * p.x;\n    }\n\n    int64_t cross (const Point & p, const Point & q) const {\n        return (p - *this).cross(q - *this);\n    }\n\n    int half () const {\n        return int(y < 0 || (y == 0 && x < 0));\n    }\n};\n\nstd::vector<std::vector<size_t>> find_faces(std::vector<Point> vertices, std::vector<std::vector<size_t>> adj) {\n    size_t n = vertices.size();\n    std::vector<std::vector<char>> used(n);\n    for (size_t i = 0; i < n; i++) {\n        used[i].resize(adj[i].size());\n        used[i].assign(adj[i].size(), 0);\n        auto compare = [&](size_t l, size_t r) {\n            Point pl = vertices[l] - vertices[i];\n            Point pr = vertices[r] - vertices[i];\n            if (pl.half() != pr.half())\n                return pl.half() < pr.half();\n            return pl.cross(pr) > 0;\n        };\n        std::sort(adj[i].begin(), adj[i].end(), compare);\n    }\n    std::vector<std::vector<size_t>> faces;\n    for (size_t i = 0; i < n; i++) {\n        for (size_t edge_id = 0; edge_id < adj[i].size(); edge_id++) {\n            if (used[i][edge_id]) {\n                continue;\n            }\n            std::vector<size_t> face;\n            size_t v = i;\n            size_t e = edge_id;\n            while (!used[v][e]) {\n                used[v][e] = true;\n                face.push_back(v);\n                size_t u = adj[v][e];\n                size_t e1 = std::lower_bound(adj[u].begin(), adj[u].end(), v, [&](size_t l, size_t r) {\n                    Point pl = vertices[l] - vertices[u];\n                    Point pr = vertices[r] - vertices[u];\n                    if (pl.half() != pr.half())\n                        return pl.half() < pr.half();\n                    return pl.cross(pr) > 0;\n                }) - adj[u].begin() + 1;\n                if (e1 == adj[u].size()) {\n                    e1 = 0;\n                }\n                v = u;\n                e = e1;\n            }\n            std::reverse(face.begin(), face.end());\n            int sign = 0;\n            for (size_t j = 0; j < face.size(); j++) {\n                size_t j1 = (j + 1) % face.size();\n                size_t j2 = (j + 2) % face.size();\n                int64_t val = vertices[face[j]].cross(vertices[face[j1]], vertices[face[j2]]);\n                if (val > 0) {\n                    sign = 1;\n                    break;\n                } else if (val < 0) {\n                    sign = -1;\n                    break;\n                }\n            }\n            if (sign <= 0) {\n                faces.insert(faces.begin(), face);\n            } else {\n                faces.emplace_back(face);\n            }\n        }\n    }\n    return faces;\n}\n```\n\n## Building planar graph from line segments\n\nSometimes you are not given a graph explicitly, but rather as a set of line segments on a plane, and the actual graph is formed by intersecting those segments, as shown in the picture below. In this case you have to build the graph manually. The easiest way to do so is as follows. Fix a segment and intersect it with all other segments. Then sort all intersection points together with the two endpoints of the segment lexicographically and add them to the graph as vertices. Also link each two adjacent vertices in lexicographical order by an edge. After doing this procedure for all edges we will obtain the graph. Of course, we should ensure that two equal intersection points will always correspond to the same vertex. The easiest way to do this is to store the points in a map by their coordinates, regarding points whose coordinates differ by a small number (say, less than $10^{-9}$) as equal. This algorithm works in $O(n^2 \\log n)$.\n\n<center>![Implicitly defined graph](planar_implicit.png)</center>\n\n## Implementation\n```{.cpp file=planar_implicit}\nusing dbl = long double;\n\nconst dbl eps = 1e-9;\n\nstruct Point {\n    dbl x, y;\n\n    Point(){}\n    Point(dbl x_, dbl y_): x(x_), y(y_) {}\n\n    Point operator * (dbl d) const {\n        return Point(x * d, y * d);\n    }\n\n    Point operator + (const Point & p) const {\n        return Point(x + p.x, y + p.y);\n    }\n\n    Point operator - (const Point & p) const {\n        return Point(x - p.x, y - p.y);\n    }\n\n    dbl cross (const Point & p) const {\n        return x * p.y - y * p.x;\n    }\n\n    dbl cross (const Point & p, const Point & q) const {\n        return (p - *this).cross(q - *this);\n    }\n\n    dbl dot (const Point & p) const {\n        return x * p.x + y * p.y;\n    }\n\n    dbl dot (const Point & p, const Point & q) const {\n        return (p - *this).dot(q - *this);\n    }\n\n    bool operator < (const Point & p) const {\n        if (fabs(x - p.x) < eps) {\n            if (fabs(y - p.y) < eps) {\n                return false;\n            } else {\n                return y < p.y;\n            }\n        } else {\n            return x < p.x;\n        }\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;\n    }\n\n    bool operator >= (const Point & p) const {\n        return !(*this < p);\n    }\n};\n\nstruct Line{\n\tPoint p[2];\n\n\tLine(Point l, Point r){p[0] = l; p[1] = r;}\n\tPoint& operator [](const int & i){return p[i];}\n\tconst Point& operator[](const int & i)const{return p[i];}\n\tLine(const Line & l){\n\t\tp[0] = l.p[0]; p[1] = l.p[1];\n\t}\n\tPoint getOrth()const{\n\t\treturn Point(p[1].y - p[0].y, p[0].x - p[1].x);\n\t}\n\tbool hasPointLine(const Point & t)const{\n\t\treturn std::fabs(p[0].cross(p[1], t)) < eps;\n\t}\n\tbool hasPointSeg(const Point & t)const{\n\t\treturn hasPointLine(t) && t.dot(p[0], p[1]) < eps;\n\t}\n};\n\nstd::vector<Point> interLineLine(Line l1, Line l2){\n\tif(std::fabs(l1.getOrth().cross(l2.getOrth())) < eps){\n\t\tif(l1.hasPointLine(l2[0]))return {l1[0], l1[1]};\n\t\telse return {};\n\t}\n\tPoint u = l2[1] - l2[0];\n\tPoint v = l1[1] - l1[0];\n\tdbl s = u.cross(l2[0] - l1[0])/u.cross(v);\n\treturn {Point(l1[0] + v * s)};\n}\n\nstd::vector<Point> interSegSeg(Line l1, Line l2){\n\tif (l1[0] == l1[1]) {\n\t\tif (l2[0] == l2[1]) {\n\t\t\tif (l1[0] == l2[0])\n                return {l1[0]};\n\t\t\telse \n                return {};\n\t\t} else {\n\t\t\tif (l2.hasPointSeg(l1[0]))\n                return {l1[0]};\n\t\t\telse\n                return {};\n\t\t}\n\t}\n\tif (l2[0] == l2[1]) {\n\t\tif (l1.hasPointSeg(l2[0]))\n            return {l2[0]};\n\t\telse \n            return {};\n\t}\n\tauto li = interLineLine(l1, l2);\n\tif (li.empty())\n        return li;\n\tif (li.size() == 2) {\n\t\tif (l1[0] >= l1[1])\n            std::swap(l1[0], l1[1]);\n\t\tif (l2[0] >= l2[1])\n            std::swap(l2[0], l2[1]);\n        std::vector<Point> res(2);\n\t\tif (l1[0] < l2[0])\n            res[0] = l2[0];\n        else\n            res[0] = l1[0];\n\t\tif (l1[1] < l2[1])\n            res[1] = l1[1];\n        else\n            res[1] = l2[1];\n\t\tif (res[0] == res[1])\n            res.pop_back();\n\t\tif (res.size() == 2u && res[1] < res[0])\n            return {};\n\t\telse \n            return res;\n\t}\n\tPoint cand = li[0];\n\tif (l1.hasPointSeg(cand) && l2.hasPointSeg(cand))\n        return {cand};\n\telse \n        return {};\n}\n\nstd::pair<std::vector<Point>, std::vector<std::vector<size_t>>> build_graph(std::vector<Line> segments) {\n    std::vector<Point> p;\n    std::vector<std::vector<size_t>> adj;\n    std::map<std::pair<int64_t, int64_t>, size_t> point_id;\n    auto get_point_id = [&](Point pt) {\n        auto repr = std::make_pair(\n            int64_t(std::round(pt.x * 1000000000) + 1e-6),\n            int64_t(std::round(pt.y * 1000000000) + 1e-6)\n        );\n        if (!point_id.count(repr)) {\n            adj.emplace_back();\n            size_t id = point_id.size();\n            point_id[repr] = id;\n            p.push_back(pt);\n            return id;\n        } else {\n            return point_id[repr];\n        }\n    };\n    for (size_t i = 0; i < segments.size(); i++) {\n        std::vector<size_t> curr = {\n            get_point_id(segments[i][0]),\n            get_point_id(segments[i][1])\n        };\n        for (size_t j = 0; j < segments.size(); j++) {\n            if (i == j)\n                continue;\n            auto inter = interSegSeg(segments[i], segments[j]);\n            for (auto pt: inter) {\n                curr.push_back(get_point_id(pt));\n            }\n        }\n        std::sort(curr.begin(), curr.end(), [&](size_t l, size_t r) { return p[l] < p[r]; });\n        curr.erase(std::unique(curr.begin(), curr.end()), curr.end());\n        for (size_t j = 0; j + 1 < curr.size(); j++) {\n            adj[curr[j]].push_back(curr[j + 1]);\n            adj[curr[j + 1]].push_back(curr[j]);\n        }\n    }\n    for (size_t i = 0; i < adj.size(); i++) {\n        std::sort(adj[i].begin(), adj[i].end());\n        // removing edges that were added multiple times\n        adj[i].erase(std::unique(adj[i].begin(), adj[i].end()), adj[i].end());\n    }\n    return {p, adj};\n}\n```\n\n", "full_article": "---\ntitle: Finding faces of a planar graph\ntags:\n  - Translated\ne_maxx_link: facets\n---\n# Finding faces of a planar graph\n\nConsider a graph $G$ with $n$ vertices and $m$ edges, which can be drawn on a plane in such a way that two edges intersect only at a common vertex (if it exists).\nSuch graphs are called **planar**. Now suppose that we are given a planar graph together with its straight-line embedding, which means that for each vertex $v$ we have a corresponding point $(x, y)$ and all edges are drawn as line segments between these points without intersection (such embedding always exists). These line segments split the plane into several regions, which are called faces. Exactly one of the faces is unbounded. This face is called **outer**, while the other faces are called **inner**.\n\nIn this article we will deal with finding both inner and outer faces of a planar graph. We will assume that the graph is connected.\n\n## Some facts about planar graphs\n\nIn this section we present several facts about planar graphs without proof. Readers who are interested in proofs should refer to [Graph Theory by R. Diestel](https://sites.math.washington.edu/~billey/classes/562.winter.2018/articles/GraphTheory.pdf) or some other book.\n\n### Euler's theorem\nEuler's theorem states that any correct embedding of a connected planar graph with $n$ vertices, $m$ edges and $f$ faces satisfies:\n\n$$n - m + f = 2$$\n\nAnd more generally, every planar graph with $k$ connected components satisfies:\n\n$$n - m + f = 1 + k$$\n\n### Number of edges of a planar graph.\nIf $n \\ge 3$ then the maximum number of edges of a planar graph with $n$ vertices is $3n - 6$. This number is achieved by any connected planar graph where each face is bounded by a triangle. In terms of complexity this fact means that $m = O(n)$ for any planar graph.\n\n### Number of faces of a planar graph.\nAs a direct consequence of the above fact, if $n \\ge 3$ then the maximum number of faces of a planar graph with $n$ vertices is $2n - 4$.\n\n### Minimum vertex degree in a planar graph.\nEvery planar graph has a vertex of degree 5 or less.\n\n## The algorithm\n\nFirstly, sort the adjacent edges for each vertex by polar angle.\nNow let's traverse the graph in the following way. Suppose that we entered vertex $u$ through the edge $(v, u)$ and $(u, w)$ is the next edge after $(v, u)$ in the sorted adjacency list of $u$. Then the next vertex will be $w$. It turns out that if we start this traversal at some edge $(v, u)$, we will traverse exactly one of the faces adjacent to $(v, u)$, the exact face depending on whether our first step is from $u$ to $v$ or from $v$ to $u$.\n\nNow the algorithm is quite obvious. We must iterate over all edges of the graph and start the traversal for each edge that wasn't visited by one of the previous traversals. This way we will find each face exactly once, and each edge will be traversed twice (once in each direction).\n\n### Finding the next edge\nDuring the traversal we have to find the next edge in counter-clockwise order. The most obvious way to find the next edge is binary search by angle. However, given the counter-clockwise order of adjacent edges for each vertex, we can precompute the next edges and store them in a hash table. If the edges are already sorted by angle, the complexity of finding all faces in this case becomes linear.\n\n### Finding the outer face\nIt's not hard to see that the algorithm traverses each inner face in a clockwise order and the outer face in the counter-clockwise order, so the outer face can be found by checking the order of each face.\n\n### Complexity\nIt's quite clear that the complexity of the algorithm is $O(m \\log m)$ because of sorting, and since $m = O(n)$, it's actually $O(n \\log n)$. As mentioned before, without sorting the complexity becomes $O(n)$.\n\n## What if the graph isn't connected?\n\nAt the first glance it may seem that finding faces of a disconnected graph is not much harder because we can run the same algorithm for each connected component. However, the components may be drawn in a nested way, forming **holes** (see the image below). In this case the inner face of some component becomes the outer face of some other components and has a complex disconnected border. Dealing with such cases is quite hard, one possible approach is to identify nested components with [point location](point-location.md) algorithms. \n\n<center>![Planar graph with holes](planar_hole.png)</center>\n\n## Implementation\nThe following implementation returns a vector of vertices for each face, outer face goes first.\nInner faces are returned in counter-clockwise orders and the outer face is returned in clockwise order.\n\nFor simplicity we find the next edge by doing binary search by angle.\n```{.cpp file=planar}\nstruct Point {\n    int64_t x, y;\n\n    Point(int64_t x_, int64_t y_): x(x_), y(y_) {}\n\n    Point operator - (const Point & p) const {\n        return Point(x - p.x, y - p.y);\n    }\n\n    int64_t cross (const Point & p) const {\n        return x * p.y - y * p.x;\n    }\n\n    int64_t cross (const Point & p, const Point & q) const {\n        return (p - *this).cross(q - *this);\n    }\n\n    int half () const {\n        return int(y < 0 || (y == 0 && x < 0));\n    }\n};\n\nstd::vector<std::vector<size_t>> find_faces(std::vector<Point> vertices, std::vector<std::vector<size_t>> adj) {\n    size_t n = vertices.size();\n    std::vector<std::vector<char>> used(n);\n    for (size_t i = 0; i < n; i++) {\n        used[i].resize(adj[i].size());\n        used[i].assign(adj[i].size(), 0);\n        auto compare = [&](size_t l, size_t r) {\n            Point pl = vertices[l] - vertices[i];\n            Point pr = vertices[r] - vertices[i];\n            if (pl.half() != pr.half())\n                return pl.half() < pr.half();\n            return pl.cross(pr) > 0;\n        };\n        std::sort(adj[i].begin(), adj[i].end(), compare);\n    }\n    std::vector<std::vector<size_t>> faces;\n    for (size_t i = 0; i < n; i++) {\n        for (size_t edge_id = 0; edge_id < adj[i].size(); edge_id++) {\n            if (used[i][edge_id]) {\n                continue;\n            }\n            std::vector<size_t> face;\n            size_t v = i;\n            size_t e = edge_id;\n            while (!used[v][e]) {\n                used[v][e] = true;\n                face.push_back(v);\n                size_t u = adj[v][e];\n                size_t e1 = std::lower_bound(adj[u].begin(), adj[u].end(), v, [&](size_t l, size_t r) {\n                    Point pl = vertices[l] - vertices[u];\n                    Point pr = vertices[r] - vertices[u];\n                    if (pl.half() != pr.half())\n                        return pl.half() < pr.half();\n                    return pl.cross(pr) > 0;\n                }) - adj[u].begin() + 1;\n                if (e1 == adj[u].size()) {\n                    e1 = 0;\n                }\n                v = u;\n                e = e1;\n            }\n            std::reverse(face.begin(), face.end());\n            int sign = 0;\n            for (size_t j = 0; j < face.size(); j++) {\n                size_t j1 = (j + 1) % face.size();\n                size_t j2 = (j + 2) % face.size();\n                int64_t val = vertices[face[j]].cross(vertices[face[j1]], vertices[face[j2]]);\n                if (val > 0) {\n                    sign = 1;\n                    break;\n                } else if (val < 0) {\n                    sign = -1;\n                    break;\n                }\n            }\n            if (sign <= 0) {\n                faces.insert(faces.begin(), face);\n            } else {\n                faces.emplace_back(face);\n            }\n        }\n    }\n    return faces;\n}\n```\n\n## Building planar graph from line segments\n\nSometimes you are not given a graph explicitly, but rather as a set of line segments on a plane, and the actual graph is formed by intersecting those segments, as shown in the picture below. In this case you have to build the graph manually. The easiest way to do so is as follows. Fix a segment and intersect it with all other segments. Then sort all intersection points together with the two endpoints of the segment lexicographically and add them to the graph as vertices. Also link each two adjacent vertices in lexicographical order by an edge. After doing this procedure for all edges we will obtain the graph. Of course, we should ensure that two equal intersection points will always correspond to the same vertex. The easiest way to do this is to store the points in a map by their coordinates, regarding points whose coordinates differ by a small number (say, less than $10^{-9}$) as equal. This algorithm works in $O(n^2 \\log n)$.\n\n<center>![Implicitly defined graph](planar_implicit.png)</center>\n\n## Implementation\n```{.cpp file=planar_implicit}\nusing dbl = long double;\n\nconst dbl eps = 1e-9;\n\nstruct Point {\n    dbl x, y;\n\n    Point(){}\n    Point(dbl x_, dbl y_): x(x_), y(y_) {}\n\n    Point operator * (dbl d) const {\n        return Point(x * d, y * d);\n    }\n\n    Point operator + (const Point & p) const {\n        return Point(x + p.x, y + p.y);\n    }\n\n    Point operator - (const Point & p) const {\n        return Point(x - p.x, y - p.y);\n    }\n\n    dbl cross (const Point & p) const {\n        return x * p.y - y * p.x;\n    }\n\n    dbl cross (const Point & p, const Point & q) const {\n        return (p - *this).cross(q - *this);\n    }\n\n    dbl dot (const Point & p) const {\n        return x * p.x + y * p.y;\n    }\n\n    dbl dot (const Point & p, const Point & q) const {\n        return (p - *this).dot(q - *this);\n    }\n\n    bool operator < (const Point & p) const {\n        if (fabs(x - p.x) < eps) {\n            if (fabs(y - p.y) < eps) {\n                return false;\n            } else {\n                return y < p.y;\n            }\n        } else {\n            return x < p.x;\n        }\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;\n    }\n\n    bool operator >= (const Point & p) const {\n        return !(*this < p);\n    }\n};\n\nstruct Line{\n\tPoint p[2];\n\n\tLine(Point l, Point r){p[0] = l; p[1] = r;}\n\tPoint& operator [](const int & i){return p[i];}\n\tconst Point& operator[](const int & i)const{return p[i];}\n\tLine(const Line & l){\n\t\tp[0] = l.p[0]; p[1] = l.p[1];\n\t}\n\tPoint getOrth()const{\n\t\treturn Point(p[1].y - p[0].y, p[0].x - p[1].x);\n\t}\n\tbool hasPointLine(const Point & t)const{\n\t\treturn std::fabs(p[0].cross(p[1], t)) < eps;\n\t}\n\tbool hasPointSeg(const Point & t)const{\n\t\treturn hasPointLine(t) && t.dot(p[0], p[1]) < eps;\n\t}\n};\n\nstd::vector<Point> interLineLine(Line l1, Line l2){\n\tif(std::fabs(l1.getOrth().cross(l2.getOrth())) < eps){\n\t\tif(l1.hasPointLine(l2[0]))return {l1[0], l1[1]};\n\t\telse return {};\n\t}\n\tPoint u = l2[1] - l2[0];\n\tPoint v = l1[1] - l1[0];\n\tdbl s = u.cross(l2[0] - l1[0])/u.cross(v);\n\treturn {Point(l1[0] + v * s)};\n}\n\nstd::vector<Point> interSegSeg(Line l1, Line l2){\n\tif (l1[0] == l1[1]) {\n\t\tif (l2[0] == l2[1]) {\n\t\t\tif (l1[0] == l2[0])\n                return {l1[0]};\n\t\t\telse \n                return {};\n\t\t} else {\n\t\t\tif (l2.hasPointSeg(l1[0]))\n                return {l1[0]};\n\t\t\telse\n                return {};\n\t\t}\n\t}\n\tif (l2[0] == l2[1]) {\n\t\tif (l1.hasPointSeg(l2[0]))\n            return {l2[0]};\n\t\telse \n            return {};\n\t}\n\tauto li = interLineLine(l1, l2);\n\tif (li.empty())\n        return li;\n\tif (li.size() == 2) {\n\t\tif (l1[0] >= l1[1])\n            std::swap(l1[0], l1[1]);\n\t\tif (l2[0] >= l2[1])\n            std::swap(l2[0], l2[1]);\n        std::vector<Point> res(2);\n\t\tif (l1[0] < l2[0])\n            res[0] = l2[0];\n        else\n            res[0] = l1[0];\n\t\tif (l1[1] < l2[1])\n            res[1] = l1[1];\n        else\n            res[1] = l2[1];\n\t\tif (res[0] == res[1])\n            res.pop_back();\n\t\tif (res.size() == 2u && res[1] < res[0])\n            return {};\n\t\telse \n            return res;\n\t}\n\tPoint cand = li[0];\n\tif (l1.hasPointSeg(cand) && l2.hasPointSeg(cand))\n        return {cand};\n\telse \n        return {};\n}\n\nstd::pair<std::vector<Point>, std::vector<std::vector<size_t>>> build_graph(std::vector<Line> segments) {\n    std::vector<Point> p;\n    std::vector<std::vector<size_t>> adj;\n    std::map<std::pair<int64_t, int64_t>, size_t> point_id;\n    auto get_point_id = [&](Point pt) {\n        auto repr = std::make_pair(\n            int64_t(std::round(pt.x * 1000000000) + 1e-6),\n            int64_t(std::round(pt.y * 1000000000) + 1e-6)\n        );\n        if (!point_id.count(repr)) {\n            adj.emplace_back();\n            size_t id = point_id.size();\n            point_id[repr] = id;\n            p.push_back(pt);\n            return id;\n        } else {\n            return point_id[repr];\n        }\n    };\n    for (size_t i = 0; i < segments.size(); i++) {\n        std::vector<size_t> curr = {\n            get_point_id(segments[i][0]),\n            get_point_id(segments[i][1])\n        };\n        for (size_t j = 0; j < segments.size(); j++) {\n            if (i == j)\n                continue;\n            auto inter = interSegSeg(segments[i], segments[j]);\n            for (auto pt: inter) {\n                curr.push_back(get_point_id(pt));\n            }\n        }\n        std::sort(curr.begin(), curr.end(), [&](size_t l, size_t r) { return p[l] < p[r]; });\n        curr.erase(std::unique(curr.begin(), curr.end()), curr.end());\n        for (size_t j = 0; j + 1 < curr.size(); j++) {\n            adj[curr[j]].push_back(curr[j + 1]);\n            adj[curr[j + 1]].push_back(curr[j]);\n        }\n    }\n    for (size_t i = 0; i < adj.size(); i++) {\n        std::sort(adj[i].begin(), adj[i].end());\n        // removing edges that were added multiple times\n        adj[i].erase(std::unique(adj[i].begin(), adj[i].end()), adj[i].end());\n    }\n    return {p, adj};\n}\n```\n\n## Problems\n * [TIMUS 1664 Pipeline Transportation](https://acm.timus.ru/problem.aspx?space=1&num=1664)\n * [TIMUS 1681 Brother Bear's Garden](https://acm.timus.ru/problem.aspx?space=1&num=1681)\n", "problem_ids": [], "title": "Finding faces of a planar graph"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: pick_grid_theorem\n---\n\n# Pick's Theorem\n\nA polygon without self-intersections is called lattice if all its vertices have integer coordinates in some 2D grid. Pick's theorem provides a way to compute the area of this polygon through the number of vertices that are lying on the boundary and the number of vertices that lie strictly inside the polygon.\n\n## Formula\n\nGiven a certain lattice polygon with non-zero area.\n\nWe denote its area by $S$, the number of points with integer coordinates lying strictly inside the polygon by $I$ and the number of points lying on polygon sides by $B$.\n\nThen, the **Pick's formula** states:\n\n$$S=I+\\frac{B}{2}-1$$\n\nIn particular, if the values of $I$ and $B$ for a polygon are given, the area can be calculated in $O(1)$ without even knowing the vertices.\n\nThis formula was discovered and proven by Austrian mathematician Georg Alexander Pick in 1899.\n\n## Proof\n\nThe proof is carried out in many stages: from simple polygons to arbitrary ones:\n\n- A single square: $S=1, I=0, B=4$, which satisfies the formula.\n\n- An arbitrary non-degenerate rectangle with sides parallel to coordinate axes: Assume $a$ and $b$ be the length of the sides of rectangle. Then, $S=ab, I=(a-1)(b-1), B=2(a+b)$. On substituting, we see that formula is true.\n\n- A right angle with legs parallel to the axes: To prove this, note that any such triangle can be obtained by cutting off a rectangle by a diagonal. Denoting the number of integral points lying on diagonal by $c$, it can be shown that Pick's formula holds for this triangle regardless of $c$.\n\n- An arbitrary triangle: Note that any such triangle can be turned into a rectangle by attaching it to sides of right-angled triangles with legs parallel to the axes (you will not need more than 3 such triangles). From here, we can get correct formula for any triangle.\n\n- An arbitrary polygon: To prove this, triangulate it, ie, divide into triangles with integral coordinates. Further, it is possible to prove that Pick's theorem retains its validity when a polygon is added to a triangle. Thus, we have proven Pick's formula for arbitrary polygon.\n\n## Generalization to higher dimensions\n\nUnfortunately, this simple and beautiful formula cannot be generalized to higher dimensions.\n\nJohn Reeve demonstrated this by proposing a tetrahedron (**Reeve tetrahedron**) with following vertices in 1957:\n\n$$A=(0,0,0),\nB=(1,0,0),\nC=(0,1,0),\nD=(1,1,k),$$\n\nwhere $k$ can be any natural number. Then for any $k$, the tetrahedron $ABCD$ does not contain integer point inside it and has only $4$ points on its borders, $A, B, C, D$. Thus, the volume and surface area may vary in spite of unchanged number of points within and on boundary. Therefore, Pick's theorem doesn't allow generalizations.\n\nHowever, higher dimensions still has a generalization using **Ehrhart polynomials** but they are quite complex and depends not only on points inside but also on the boundary of polytype.\n\n## Extra Resources\nA few simple examples and a simple proof of Pick's theorem can be found [here](http://www.geometer.org/mathcircles/pick.pdf).\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: pick_grid_theorem\n---\n\n# Pick's Theorem\n\nA polygon without self-intersections is called lattice if all its vertices have integer coordinates in some 2D grid. Pick's theorem provides a way to compute the area of this polygon through the number of vertices that are lying on the boundary and the number of vertices that lie strictly inside the polygon.\n\n## Formula\n\nGiven a certain lattice polygon with non-zero area.\n\nWe denote its area by $S$, the number of points with integer coordinates lying strictly inside the polygon by $I$ and the number of points lying on polygon sides by $B$.\n\nThen, the **Pick's formula** states:\n\n$$S=I+\\frac{B}{2}-1$$\n\nIn particular, if the values of $I$ and $B$ for a polygon are given, the area can be calculated in $O(1)$ without even knowing the vertices.\n\nThis formula was discovered and proven by Austrian mathematician Georg Alexander Pick in 1899.\n\n## Proof\n\nThe proof is carried out in many stages: from simple polygons to arbitrary ones:\n\n- A single square: $S=1, I=0, B=4$, which satisfies the formula.\n\n- An arbitrary non-degenerate rectangle with sides parallel to coordinate axes: Assume $a$ and $b$ be the length of the sides of rectangle. Then, $S=ab, I=(a-1)(b-1), B=2(a+b)$. On substituting, we see that formula is true.\n\n- A right angle with legs parallel to the axes: To prove this, note that any such triangle can be obtained by cutting off a rectangle by a diagonal. Denoting the number of integral points lying on diagonal by $c$, it can be shown that Pick's formula holds for this triangle regardless of $c$.\n\n- An arbitrary triangle: Note that any such triangle can be turned into a rectangle by attaching it to sides of right-angled triangles with legs parallel to the axes (you will not need more than 3 such triangles). From here, we can get correct formula for any triangle.\n\n- An arbitrary polygon: To prove this, triangulate it, ie, divide into triangles with integral coordinates. Further, it is possible to prove that Pick's theorem retains its validity when a polygon is added to a triangle. Thus, we have proven Pick's formula for arbitrary polygon.\n\n## Generalization to higher dimensions\n\nUnfortunately, this simple and beautiful formula cannot be generalized to higher dimensions.\n\nJohn Reeve demonstrated this by proposing a tetrahedron (**Reeve tetrahedron**) with following vertices in 1957:\n\n$$A=(0,0,0),\nB=(1,0,0),\nC=(0,1,0),\nD=(1,1,k),$$\n\nwhere $k$ can be any natural number. Then for any $k$, the tetrahedron $ABCD$ does not contain integer point inside it and has only $4$ points on its borders, $A, B, C, D$. Thus, the volume and surface area may vary in spite of unchanged number of points within and on boundary. Therefore, Pick's theorem doesn't allow generalizations.\n\nHowever, higher dimensions still has a generalization using **Ehrhart polynomials** but they are quite complex and depends not only on points inside but also on the boundary of polytype.\n\n## Extra Resources\nA few simple examples and a simple proof of Pick's theorem can be found [here](http://www.geometer.org/mathcircles/pick.pdf).\n", "problem_ids": [], "title": "Pick's Theorem"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: oriented_area\n---\n\n# Oriented area of a triangle\n\nGiven three points $p_1$, $p_2$ and $p_3$, calculate an oriented (signed) area of a triangle formed by them. The sign of the area is determined in the following way: imagine you are standing in the plane at point $p_1$ and are facing $p_2$. You go to $p_2$ and if $p_3$ is to your right (then we say the three vectors turn \"clockwise\"), the sign of the area is negative, otherwise it is positive. If the three points are collinear, the area is zero.\n\nUsing this signed area, we can both get the regular unsigned area (as the absolute value of the signed area) and determine if the points lie clockwise or counterclockwise in their specified order (which is useful, for example, in convex hull algorithms).\n\n\n## Calculation\nWe can use the fact that a determinant of a $2\\times 2$ matrix is equal to the signed area of a parallelogram spanned by column (or row) vectors of the matrix.\nThis is analog to the definition of the cross product in 2D (see [Basic Geometry](basic-geometry.md)).\nBy dividing this area by two we get the area of a triangle that we are interested in.\nWe will use $\\vec{p_1p_2}$ and $\\vec{p_2p_3}$ as the column vectors and calculate a $2\\times 2$ determinant:\n\n$$2S=\\left|\\begin{matrix}x_2-x_1 & x_3-x_2\\\\y_2-y_1 & y_3-y_2\\end{matrix}\\right|=(x_2-x_1)(y_3-y_2)-(x_3-x_2)(y_2-y_1)$$\n\n## Implementation\n\n```cpp\nint signed_area_parallelogram(point2d p1, point2d p2, point2d p3) {\n    return cross(p2 - p1, p3 - p2);\n}\n\ndouble triangle_area(point2d p1, point2d p2, point2d p3) {\n    return abs(signed_area_parallelogram(p1, p2, p3)) / 2.0;\n}\n\nbool clockwise(point2d p1, point2d p2, point2d p3) {\n    return signed_area_parallelogram(p1, p2, p3) < 0;\n}\n\nbool counter_clockwise(point2d p1, point2d p2, point2d p3) {\n    return signed_area_parallelogram(p1, p2, p3) > 0;\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: oriented_area\n---\n\n# Oriented area of a triangle\n\nGiven three points $p_1$, $p_2$ and $p_3$, calculate an oriented (signed) area of a triangle formed by them. The sign of the area is determined in the following way: imagine you are standing in the plane at point $p_1$ and are facing $p_2$. You go to $p_2$ and if $p_3$ is to your right (then we say the three vectors turn \"clockwise\"), the sign of the area is negative, otherwise it is positive. If the three points are collinear, the area is zero.\n\nUsing this signed area, we can both get the regular unsigned area (as the absolute value of the signed area) and determine if the points lie clockwise or counterclockwise in their specified order (which is useful, for example, in convex hull algorithms).\n\n\n## Calculation\nWe can use the fact that a determinant of a $2\\times 2$ matrix is equal to the signed area of a parallelogram spanned by column (or row) vectors of the matrix.\nThis is analog to the definition of the cross product in 2D (see [Basic Geometry](basic-geometry.md)).\nBy dividing this area by two we get the area of a triangle that we are interested in.\nWe will use $\\vec{p_1p_2}$ and $\\vec{p_2p_3}$ as the column vectors and calculate a $2\\times 2$ determinant:\n\n$$2S=\\left|\\begin{matrix}x_2-x_1 & x_3-x_2\\\\y_2-y_1 & y_3-y_2\\end{matrix}\\right|=(x_2-x_1)(y_3-y_2)-(x_3-x_2)(y_2-y_1)$$\n\n## Implementation\n\n```cpp\nint signed_area_parallelogram(point2d p1, point2d p2, point2d p3) {\n    return cross(p2 - p1, p3 - p2);\n}\n\ndouble triangle_area(point2d p1, point2d p2, point2d p3) {\n    return abs(signed_area_parallelogram(p1, p2, p3)) / 2.0;\n}\n\nbool clockwise(point2d p1, point2d p2, point2d p3) {\n    return signed_area_parallelogram(p1, p2, p3) < 0;\n}\n\nbool counter_clockwise(point2d p1, point2d p2, point2d p3) {\n    return signed_area_parallelogram(p1, p2, p3) > 0;\n}\n```\n\n## Practice Problems\n* [Codechef - Chef and Polygons](https://www.codechef.com/problems/CHEFPOLY)\n", "problem_ids": [], "title": "Oriented area of a triangle"}, {"article": "---\ntitle: Check if point belongs to the convex polygon in O(log N)\ntags:\n  - Translated\ne_maxx_link: pt_in_polygon\n---\n# Check if point belongs to the convex polygon in $O(\\log N)$\n\nConsider the following problem: you are given a convex polygon with integer vertices and a lot of queries.\nEach query is a point, for which we should determine whether it lies inside or on the boundary of the polygon or not.\nSuppose the polygon is ordered counter-clockwise. We will answer each query in $O(\\log n)$ online.\n\n## Algorithm\nLet's pick the point with the smallest x-coordinate. If there are several of them, we pick the one with the smallest y-coordinate. Let's denote it as $p_0$.\nNow all other points $p_1,\\dots,p_n$ of the polygon are ordered by their polar angle from the chosen point (because the polygon is ordered counter-clockwise).\n\nIf the point belongs to the polygon, it belongs to some triangle $p_0, p_i, p_{i + 1}$ (maybe more than one if it lies on the boundary of triangles).\nConsider the triangle $p_0, p_i, p_{i + 1}$ such that $p$ belongs to this triangle and $i$ is maximum among all such triangles.\n\nThere is one special case. $p$ lies on the segment $(p_0, p_n)$. This case we will check separately.\nOtherwise all points $p_j$ with $j \\le i$ are counter-clockwise from $p$ with respect to $p_0$, and all other points are not counter-clockwise from $p$.\nThis means that we can apply binary search for the point $p_i$, such that $p_i$ is not counter-clockwise from $p$ with respect to $p_0$, and $i$ is maximum among all such points.\nAnd afterwards we check if the points is actually in the determined triangle.\n\nThe sign of $(a - c) \\times (b - c)$ will tell us, if the point $a$ is clockwise or counter-clockwise from the point $b$ with respect to the point $c$.\nIf $(a - c) \\times (b - c) > 0$, then the point $a$ is to the right of the vector going from $c$ to $b$, which means clockwise from $b$ with respect to $c$.\nAnd if $(a - c) \\times (b - c) < 0$, then the point is to the left, or counter clockwise.\nAnd it is exactly on the line between the points $b$ and $c$.\n\nBack to the algorithm:\nConsider a query point $p$.\nFirstly, we must check if the point lies between $p_1$ and $p_n$.\nOtherwise we already know that it cannot be part of the polygon.\nThis can be done by checking if the cross product $(p_1 - p_0)\\times(p - p_0)$ is zero or has the same sign with $(p_1 - p_0)\\times(p_n - p_0)$, and $(p_n - p_0)\\times(p - p_0)$ is zero or has the same sign with $(p_n - p_0)\\times(p_1 - p_0)$.\nThen we handle the special case in which $p$ is part of the line $(p_0, p_1)$.\nAnd then we can binary search the last point from $p_1,\\dots p_n$ which is not counter-clockwise from $p$ with respect to $p_0$.\nFor a single point $p_i$ this condition can be checked by checking that $(p_i - p_0)\\times(p - p_0) \\le 0$. After we found such a point $p_i$, we must test if $p$ lies inside the triangle $p_0, p_i, p_{i + 1}$.\nTo test if it belongs to the triangle, we may simply check that $|(p_i - p_0)\\times(p_{i + 1} - p_0)| = |(p_0 - p)\\times(p_i - p)| + |(p_i - p)\\times(p_{i + 1} - p)| + |(p_{i + 1} - p)\\times(p_0 - p)|$.\nThis checks if the area of the triangle $p_0, p_i, p_{i+1}$ has to exact same size as the sum of the sizes of the triangle $p_0, p_i, p$, the triangle $p_0, p, p_{i+1}$ and the triangle $p_i, p_{i+1}, p$.\nIf $p$ is outside, then the sum of those three triangle will be bigger than the size of the triangle.\nIf it is inside, then it will be equal.\n\n## Implementation\n\nThe function `prepare` will make sure that the lexicographical smallest point (smallest x value, and in ties smallest y value) will be $p_0$, and computes the vectors $p_i - p_0$.\nAfterwards the function `pointInConvexPolygon` computes the result of a query.\nWe additionally remember the point $p_0$ and translate all queried points with it in order compute the correct distance, as vectors don't have an initial point.\nBy translating the query points we can assume that all vectors start at the origin $(0, 0)$, and simplify the computations for distances and lengths.\n\n```{.cpp file=points_in_convex_polygon}\nstruct pt {\n    long long x, y;\n    pt() {}\n    pt(long long _x, long long _y) : x(_x), y(_y) {}\n    pt operator+(const pt &p) const { return pt(x + p.x, y + p.y); }\n    pt operator-(const pt &p) const { return pt(x - p.x, y - p.y); }\n    long long cross(const pt &p) const { return x * p.y - y * p.x; }\n    long long dot(const pt &p) const { return x * p.x + y * p.y; }\n    long long cross(const pt &a, const pt &b) const { return (a - *this).cross(b - *this); }\n    long long dot(const pt &a, const pt &b) const { return (a - *this).dot(b - *this); }\n    long long sqrLen() const { return this->dot(*this); }\n};\n\nbool lexComp(const pt &l, const pt &r) {\n    return l.x < r.x || (l.x == r.x && l.y < r.y);\n}\n\nint sgn(long long val) { return val > 0 ? 1 : (val == 0 ? 0 : -1); }\n\nvector<pt> seq;\npt translation;\nint n;\n\nbool pointInTriangle(pt a, pt b, pt c, pt point) {\n    long long s1 = abs(a.cross(b, c));\n    long long s2 = abs(point.cross(a, b)) + abs(point.cross(b, c)) + abs(point.cross(c, a));\n    return s1 == s2;\n}\n\nvoid prepare(vector<pt> &points) {\n    n = points.size();\n    int pos = 0;\n    for (int i = 1; i < n; i++) {\n        if (lexComp(points[i], points[pos]))\n            pos = i;\n    }\n    rotate(points.begin(), points.begin() + pos, points.end());\n\n    n--;\n    seq.resize(n);\n    for (int i = 0; i < n; i++)\n        seq[i] = points[i + 1] - points[0];\n    translation = points[0];\n}\n\nbool pointInConvexPolygon(pt point) {\n    point = point - translation;\n    if (seq[0].cross(point) != 0 &&\n            sgn(seq[0].cross(point)) != sgn(seq[0].cross(seq[n - 1])))\n        return false;\n    if (seq[n - 1].cross(point) != 0 &&\n            sgn(seq[n - 1].cross(point)) != sgn(seq[n - 1].cross(seq[0])))\n        return false;\n\n    if (seq[0].cross(point) == 0)\n        return seq[0].sqrLen() >= point.sqrLen();\n\n    int l = 0, r = n - 1;\n    while (r - l > 1) {\n        int mid = (l + r) / 2;\n        int pos = mid;\n        if (seq[pos].cross(point) >= 0)\n            l = mid;\n        else\n            r = mid;\n    }\n    int pos = l;\n    return pointInTriangle(seq[pos], seq[pos + 1], pt(0, 0), point);\n}\n```\n\n", "full_article": "---\ntitle: Check if point belongs to the convex polygon in O(log N)\ntags:\n  - Translated\ne_maxx_link: pt_in_polygon\n---\n# Check if point belongs to the convex polygon in $O(\\log N)$\n\nConsider the following problem: you are given a convex polygon with integer vertices and a lot of queries.\nEach query is a point, for which we should determine whether it lies inside or on the boundary of the polygon or not.\nSuppose the polygon is ordered counter-clockwise. We will answer each query in $O(\\log n)$ online.\n\n## Algorithm\nLet's pick the point with the smallest x-coordinate. If there are several of them, we pick the one with the smallest y-coordinate. Let's denote it as $p_0$.\nNow all other points $p_1,\\dots,p_n$ of the polygon are ordered by their polar angle from the chosen point (because the polygon is ordered counter-clockwise).\n\nIf the point belongs to the polygon, it belongs to some triangle $p_0, p_i, p_{i + 1}$ (maybe more than one if it lies on the boundary of triangles).\nConsider the triangle $p_0, p_i, p_{i + 1}$ such that $p$ belongs to this triangle and $i$ is maximum among all such triangles.\n\nThere is one special case. $p$ lies on the segment $(p_0, p_n)$. This case we will check separately.\nOtherwise all points $p_j$ with $j \\le i$ are counter-clockwise from $p$ with respect to $p_0$, and all other points are not counter-clockwise from $p$.\nThis means that we can apply binary search for the point $p_i$, such that $p_i$ is not counter-clockwise from $p$ with respect to $p_0$, and $i$ is maximum among all such points.\nAnd afterwards we check if the points is actually in the determined triangle.\n\nThe sign of $(a - c) \\times (b - c)$ will tell us, if the point $a$ is clockwise or counter-clockwise from the point $b$ with respect to the point $c$.\nIf $(a - c) \\times (b - c) > 0$, then the point $a$ is to the right of the vector going from $c$ to $b$, which means clockwise from $b$ with respect to $c$.\nAnd if $(a - c) \\times (b - c) < 0$, then the point is to the left, or counter clockwise.\nAnd it is exactly on the line between the points $b$ and $c$.\n\nBack to the algorithm:\nConsider a query point $p$.\nFirstly, we must check if the point lies between $p_1$ and $p_n$.\nOtherwise we already know that it cannot be part of the polygon.\nThis can be done by checking if the cross product $(p_1 - p_0)\\times(p - p_0)$ is zero or has the same sign with $(p_1 - p_0)\\times(p_n - p_0)$, and $(p_n - p_0)\\times(p - p_0)$ is zero or has the same sign with $(p_n - p_0)\\times(p_1 - p_0)$.\nThen we handle the special case in which $p$ is part of the line $(p_0, p_1)$.\nAnd then we can binary search the last point from $p_1,\\dots p_n$ which is not counter-clockwise from $p$ with respect to $p_0$.\nFor a single point $p_i$ this condition can be checked by checking that $(p_i - p_0)\\times(p - p_0) \\le 0$. After we found such a point $p_i$, we must test if $p$ lies inside the triangle $p_0, p_i, p_{i + 1}$.\nTo test if it belongs to the triangle, we may simply check that $|(p_i - p_0)\\times(p_{i + 1} - p_0)| = |(p_0 - p)\\times(p_i - p)| + |(p_i - p)\\times(p_{i + 1} - p)| + |(p_{i + 1} - p)\\times(p_0 - p)|$.\nThis checks if the area of the triangle $p_0, p_i, p_{i+1}$ has to exact same size as the sum of the sizes of the triangle $p_0, p_i, p$, the triangle $p_0, p, p_{i+1}$ and the triangle $p_i, p_{i+1}, p$.\nIf $p$ is outside, then the sum of those three triangle will be bigger than the size of the triangle.\nIf it is inside, then it will be equal.\n\n## Implementation\n\nThe function `prepare` will make sure that the lexicographical smallest point (smallest x value, and in ties smallest y value) will be $p_0$, and computes the vectors $p_i - p_0$.\nAfterwards the function `pointInConvexPolygon` computes the result of a query.\nWe additionally remember the point $p_0$ and translate all queried points with it in order compute the correct distance, as vectors don't have an initial point.\nBy translating the query points we can assume that all vectors start at the origin $(0, 0)$, and simplify the computations for distances and lengths.\n\n```{.cpp file=points_in_convex_polygon}\nstruct pt {\n    long long x, y;\n    pt() {}\n    pt(long long _x, long long _y) : x(_x), y(_y) {}\n    pt operator+(const pt &p) const { return pt(x + p.x, y + p.y); }\n    pt operator-(const pt &p) const { return pt(x - p.x, y - p.y); }\n    long long cross(const pt &p) const { return x * p.y - y * p.x; }\n    long long dot(const pt &p) const { return x * p.x + y * p.y; }\n    long long cross(const pt &a, const pt &b) const { return (a - *this).cross(b - *this); }\n    long long dot(const pt &a, const pt &b) const { return (a - *this).dot(b - *this); }\n    long long sqrLen() const { return this->dot(*this); }\n};\n\nbool lexComp(const pt &l, const pt &r) {\n    return l.x < r.x || (l.x == r.x && l.y < r.y);\n}\n\nint sgn(long long val) { return val > 0 ? 1 : (val == 0 ? 0 : -1); }\n\nvector<pt> seq;\npt translation;\nint n;\n\nbool pointInTriangle(pt a, pt b, pt c, pt point) {\n    long long s1 = abs(a.cross(b, c));\n    long long s2 = abs(point.cross(a, b)) + abs(point.cross(b, c)) + abs(point.cross(c, a));\n    return s1 == s2;\n}\n\nvoid prepare(vector<pt> &points) {\n    n = points.size();\n    int pos = 0;\n    for (int i = 1; i < n; i++) {\n        if (lexComp(points[i], points[pos]))\n            pos = i;\n    }\n    rotate(points.begin(), points.begin() + pos, points.end());\n\n    n--;\n    seq.resize(n);\n    for (int i = 0; i < n; i++)\n        seq[i] = points[i + 1] - points[0];\n    translation = points[0];\n}\n\nbool pointInConvexPolygon(pt point) {\n    point = point - translation;\n    if (seq[0].cross(point) != 0 &&\n            sgn(seq[0].cross(point)) != sgn(seq[0].cross(seq[n - 1])))\n        return false;\n    if (seq[n - 1].cross(point) != 0 &&\n            sgn(seq[n - 1].cross(point)) != sgn(seq[n - 1].cross(seq[0])))\n        return false;\n\n    if (seq[0].cross(point) == 0)\n        return seq[0].sqrLen() >= point.sqrLen();\n\n    int l = 0, r = n - 1;\n    while (r - l > 1) {\n        int mid = (l + r) / 2;\n        int pos = mid;\n        if (seq[pos].cross(point) >= 0)\n            l = mid;\n        else\n            r = mid;\n    }\n    int pos = l;\n    return pointInTriangle(seq[pos], seq[pos + 1], pt(0, 0), point);\n}\n```\n\n## Problems\n[SGU253 Theodore Roosevelt](https://codeforces.com/problemsets/acmsguru/problem/99999/253)\n[Codeforces 55E Very simple problem](https://codeforces.com/contest/55/problem/E)\n", "problem_ids": [], "title": "Check if point belongs to the convex polygon in $O(\\log N)$"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: lines_intersection\n---\n\n# Intersection Point of Lines\n\nYou are given two lines, described via the equations $a_1 x + b_1 y + c_1 = 0$ and  $a_2 x + b_2 y + c_2 = 0$.\nWe have to find the intersection point of the lines, or determine that the lines are parallel.\n\n## Solution\n\nIf two lines are not parallel, they intersect.\nTo find their intersection point, we need to solve the following system of linear equations:\n\n$$\\begin{cases} a_1 x + b_1 y + c_1 = 0 \\\\\na_2 x + b_2 y + c_2 = 0\n\\end{cases}$$\n\nUsing Cramer's rule, we can immediately write down the solution for the system, which will give us the required intersection point of the lines:\n\n$$x = - \\frac{\\begin{vmatrix}c_1 & b_1 \\cr c_2 & b_2\\end{vmatrix}}{\\begin{vmatrix}a_1 & b_1 \\cr a_2 & b_2\\end{vmatrix} } = - \\frac{c_1 b_2 - c_2 b_1}{a_1 b_2 - a_2 b_1},$$\n\n$$y = - \\frac{\\begin{vmatrix}a_1 & c_1 \\cr a_2 & c_2\\end{vmatrix}}{\\begin{vmatrix}a_1 & b_1 \\cr a_2 & b_2\\end{vmatrix}} = - \\frac{a_1 c_2 - a_2 c_1}{a_1 b_2 - a_2 b_1}.$$\n\nIf the denominator equals $0$, i.e.\n\n$$\\begin{vmatrix}a_1 & b_1 \\cr a_2 & b_2\\end{vmatrix} = a_1 b_2 - a_2 b_1 = 0 $$\n\nthen either the system has no solutions (the lines are parallel and distinct) or there are infinitely many solutions (the lines overlap).\nIf we need to distinguish these two cases, we have to check if coefficients $c$ are proportional with the same ratio as the coefficients $a$ and $b$.\nTo do that we only have calculate the following determinants, and if they both equal $0$, the lines overlap:\n\n$$\\begin{vmatrix}a_1 & c_1 \\cr a_2 & c_2\\end{vmatrix}, \\begin{vmatrix}b_1 & c_1 \\cr b_2 & c_2\\end{vmatrix} $$\n\nNotice, a different approach for computing the intersection point is explained in the article [Basic Geometry](basic-geometry.md).\n\n## Implementation\n\n```{.cpp file=line_intersection}\nstruct pt {\n    double x, y;\n};\n\nstruct line {\n    double a, b, c;\n};\n\nconst double EPS = 1e-9;\n\ndouble det(double a, double b, double c, double d) {\n    return a*d - b*c;\n}\n\nbool intersect(line m, line n, pt & res) {\n    double zn = det(m.a, m.b, n.a, n.b);\n    if (abs(zn) < EPS)\n        return false;\n    res.x = -det(m.c, m.b, n.c, n.b) / zn;\n    res.y = -det(m.a, m.c, n.a, n.c) / zn;\n    return true;\n}\n\nbool parallel(line m, line n) {\n    return abs(det(m.a, m.b, n.a, n.b)) < EPS;\n}\n\nbool equivalent(line m, line n) {\n    return abs(det(m.a, m.b, n.a, n.b)) < EPS\n        && abs(det(m.a, m.c, n.a, n.c)) < EPS\n        && abs(det(m.b, m.c, n.b, n.c)) < EPS;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: lines_intersection\n---\n\n# Intersection Point of Lines\n\nYou are given two lines, described via the equations $a_1 x + b_1 y + c_1 = 0$ and  $a_2 x + b_2 y + c_2 = 0$.\nWe have to find the intersection point of the lines, or determine that the lines are parallel.\n\n## Solution\n\nIf two lines are not parallel, they intersect.\nTo find their intersection point, we need to solve the following system of linear equations:\n\n$$\\begin{cases} a_1 x + b_1 y + c_1 = 0 \\\\\na_2 x + b_2 y + c_2 = 0\n\\end{cases}$$\n\nUsing Cramer's rule, we can immediately write down the solution for the system, which will give us the required intersection point of the lines:\n\n$$x = - \\frac{\\begin{vmatrix}c_1 & b_1 \\cr c_2 & b_2\\end{vmatrix}}{\\begin{vmatrix}a_1 & b_1 \\cr a_2 & b_2\\end{vmatrix} } = - \\frac{c_1 b_2 - c_2 b_1}{a_1 b_2 - a_2 b_1},$$\n\n$$y = - \\frac{\\begin{vmatrix}a_1 & c_1 \\cr a_2 & c_2\\end{vmatrix}}{\\begin{vmatrix}a_1 & b_1 \\cr a_2 & b_2\\end{vmatrix}} = - \\frac{a_1 c_2 - a_2 c_1}{a_1 b_2 - a_2 b_1}.$$\n\nIf the denominator equals $0$, i.e.\n\n$$\\begin{vmatrix}a_1 & b_1 \\cr a_2 & b_2\\end{vmatrix} = a_1 b_2 - a_2 b_1 = 0 $$\n\nthen either the system has no solutions (the lines are parallel and distinct) or there are infinitely many solutions (the lines overlap).\nIf we need to distinguish these two cases, we have to check if coefficients $c$ are proportional with the same ratio as the coefficients $a$ and $b$.\nTo do that we only have calculate the following determinants, and if they both equal $0$, the lines overlap:\n\n$$\\begin{vmatrix}a_1 & c_1 \\cr a_2 & c_2\\end{vmatrix}, \\begin{vmatrix}b_1 & c_1 \\cr b_2 & c_2\\end{vmatrix} $$\n\nNotice, a different approach for computing the intersection point is explained in the article [Basic Geometry](basic-geometry.md).\n\n## Implementation\n\n```{.cpp file=line_intersection}\nstruct pt {\n    double x, y;\n};\n\nstruct line {\n    double a, b, c;\n};\n\nconst double EPS = 1e-9;\n\ndouble det(double a, double b, double c, double d) {\n    return a*d - b*c;\n}\n\nbool intersect(line m, line n, pt & res) {\n    double zn = det(m.a, m.b, n.a, n.b);\n    if (abs(zn) < EPS)\n        return false;\n    res.x = -det(m.c, m.b, n.c, n.b) / zn;\n    res.y = -det(m.a, m.c, n.a, n.c) / zn;\n    return true;\n}\n\nbool parallel(line m, line n) {\n    return abs(det(m.a, m.b, n.a, n.b)) < EPS;\n}\n\nbool equivalent(line m, line n) {\n    return abs(det(m.a, m.b, n.a, n.b)) < EPS\n        && abs(det(m.a, m.c, n.a, n.c)) < EPS\n        && abs(det(m.b, m.c, n.b, n.c)) < EPS;\n}\n```\n", "problem_ids": [], "title": "Intersection Point of Lines"}, {"article": "---\ntags:\n  - Original\n---\n\n# Half-plane intersection\n\nIn this article we will discuss the problem of computing the intersection of a set of half-planes. Such an intersection can be conveniently represented as a convex region/polygon, where every point inside of it is also inside all of the half-planes, and it is this polygon that we're trying to find or construct. We give some initial intuition for the problem, describe a $O(N \\log N)$ approach known as the Sort-and-Incremental algorithm and give some sample applications of this technique.\n\nIt is strongly recommended for the reader to be familiar with basic geometrical primitives and operations (points, vectors, intersection of lines). Additionally, knowledge about [Convex Hulls](../geometry/convex-hull.md) or the [Convex Hull Trick](../geometry/convex_hull_trick.md) may help to better understand the concepts in this article, but they are not a prerequisite by any means.\n\n## Initial clarifications and definitions\n\nFor the entire article, we will make some assumptions (unless specified otherwise):\n\n1. We define $N$ to be the quantity of half-planes in the given set.\n2. We will represent lines and half-planes by one point and one vector (any point that lies on the given line, and the direction vector of the line). In the case of half-planes, we assume that every half-plane allows the region to the left side of its direction vector. Additionally, we define the angle of a half-plane to be the polar angle of its direction vector. See image below for example.\n3. We will assume that the resulting intersection is always either bounded or empty. If we need to handle the unbounded case, we can simply add 4 half-planes that define a large-enough bounding box. \n4. We will assume, for simplicity, that there are no parallel half-planes in the given set. Towards the end of the article we will discuss how to deal with such cases.\n\n![](halfplanes_rep.png) \n\nThe half-plane $y \\geq 2x - 2$ can be represented as the point $P = (1, 0)$ with direction vector $PQ = Q - P = (1, 2)$\n\n## Brute force approach - $O(N^3)$ {data-toc-label=\"Brute force approach - O(N^3)\"}\n\nOne of the most straightforward and obvious solutions would be to compute the intersection point of the lines of all pairs of half-planes and, for each point, check if it is inside all of the other half-planes. Since there are $O(N^2)$ intersection points, and for each of them we have to check $O(N)$ half-planes, the total time complexity is $O(N^3)$. The actual region of the intersection can then be reconstructed using, for example, a Convex Hull algorithm on the set of intersection points that were included in all the half-planes. \n\nIt is fairly easy to see why this works: the vertices of the resulting convex polygon are all intersection points of the half-plane lines, and each of those vertices is obviously part of all the half-planes. The main advantage of this method is that its easy to understand, remember and code on-the-fly if you just need to check if the intersection is empty or not. However, it is awfully slow and unfit for most problems, so we need something faster.\n\n## Incremental approach - $O(N^2)$ {data-toc-label=\"Incremental approach - O(N^2)\"}\n\nAnother fairly straightforward approach is to incrementally construct the intersection of the half-planes, one at a time. This method is basically equivalent to cutting a convex polygon by a line $N$ times, and removing the redundant half-planes at every step. To do this, we can represent the convex polygon as a list of line segments, and to cut it with a half-plane we simply find the intersection points of the segments with the half-plane line (there will only be two intersection points if the line properly intersects the polygon), and replace all the line segments in-between with the new segment corresponding to the half-plane. Since such procedure can be implemented in linear time, we can simply start with a big bounding box and cut it down with each one of the half-planes, obtaining a total time complexity of $O(N^2)$.\n\nThis method is a big step in the right direction, but it does feel wasteful to have to iterate over $O(N)$ half-planes at every step. We will see next that, by making some clever observations, the ideas behind this incremental approach can be recycled to create a $O(N \\log N)$ algorithm.\n\n## Sort-and-Incremental algorithm - $O(N \\log N)$ {data-toc-label=\"Sort-and-Incremental algorithm - O(N log N)\"}\n\nThe first properly-documented source of this algorithm we could find was Zeyuan Zhu's thesis for Chinese Team Selecting Contest titled [New Algorithm for Half-plane Intersection and its Practical Value](http://people.csail.mit.edu/zeyuan/publications.htm), from the year 2006. The approach we'll describe next is based on this same algorithm, but instead of computing two separate intersections for the lower and upper halves of the intersections, we'll construct it all at once in one pass with a deque (double-ended queue).\n\nThe algorithm itself, as the name may spoil, takes advantage of the fact that the resulting region from the intersection of half-planes is convex, and thus it will consist of some segments of half-planes in order sorted by their angles. This leads to a crucial observation: if we incrementally intersect the half-planes in their order sorted by angle (as they would appear in the final, resulting shape of the intersection) and store them in a double-ended queue, then we will only ever need to remove half-planes from the front and the back of the deque.\n\nTo better visualize this fact, suppose we're performing the incremental approach described previously on a set of half-planes that is sorted by angle (in this case, we'll assume they're sorted from $-\\pi$ to $\\pi$), and suppose that we're about to start some arbitrary $k$'th step. This means we have already constructed the intersection of the first $k-1$ half-planes. Now, because the half-planes are sorted by angle, whatever the $k$'th half-plane is, we can be sure that it will form a convex turn with the $(K-1)$'th half-plane. For that reason, a few things may happen:\n\n1. Some (possibly none) of the half-planes in the back of the intersection may become *redundant*. In this case, we need to pop these now-useless half-planes from the back of the deque. \n2. Some (possibly none) of the half-planes at the front may become *redundant*. Analogous to case 1, we just pop them from the front of the deque.\n3. The intersection may become empty (after handling cases 1 and/or 2). In this case, we just report the intersection is empty and terminate the algorithm.\n\n*We say a half-plane is \"redundant\" if it does not contribute anything to the intersection. Such a half-plane could be removed and the resulting intersection would not change at all.*\n\nHere's a small example with an illustration:\n\nLet $H = \\{ A, B, C, D, E \\}$ be the set of half-planes currently present in the intersection. Additionally, let $P = \\{ p, q, r, s \\}$ be the set of intersection points of adjacent half-planes in H. Now, suppose we wish to intersect it with the half-plane $F$, as seen in the illustration below:\n\n![](halfplanes_hp1.png)\n\nNotice the half-plane $F$ makes $A$ and $E$ redundant in the intersection. So we remove both $A$ and $E$ from the front and back of the intersection, respectively, and add $F$ at the end. And we finally obtain the new intersection $H = \\{ B, C, D, F\\}$ with $P = \\{ q, r, t, u \\}$.\n\n![](halfplanes_hp2.png)\n\nWith all of this in mind, we have almost everything we need to actually implement the algorithm, but we still need to talk about some special cases. At the beginning of the article we said we would add a bounding box to take care of the cases where the intersection could be unbounded, so the only tricky case we actually need to handle is parallel half-planes. We can have two sub-cases: two half-planes can be parallel with the same direction or with opposite direction. The reason this case needs to be handled separately is because we will need to compute intersection points of half-plane lines to be able to check if a half-plane is redundant or not, and two parallel lines have no intersection point, so we need a special way to deal with them.\n\nFor the case of parallel half-planes of opposite orientation: Notice that, because we're adding the bounding box to deal with the unbounded case, this also deals with the case where we have two adjacent parallel half-planes with opposite directions after sorting, since there will have to be at least one of the bounding-box half-planes in between these two (remember they are sorted by angle). \n\n * However, it is possible that, after removing some half-planes from the back of the deque, two parallel half-planes of opposite direction end up together. This case only happens, specifically, when these two half-planes form an empty intersection, as this last half-plane will cause everything to be removed from the deque. To avoid this problem, we have to manually check for parallel half-planes, and if they have opposite direction, we just instantly stop the algorithm and return an empty intersection.\n\n\nThus the only case we actually need to handle is having multiple half-planes with the same angle, and it turns out this case is fairly easy to handle: we only have keep the leftmost half-plane and erase the rest, since they will be completely redundant anyways.\nTo sum up, the full algorithm will roughly look as follows:\n\n1. We begin by sorting the set of half-planes by angle, which takes $O(N \\log N)$ time.\n2. We will iterate over the set of half-planes, and for each one, we will perform the incremental procedure, popping from the front and the back of the double-ended queue as necessary. This will take linear time in total, as every half-plane can only be added or removed once.\n3. At the end, the convex polygon resulting from the intersection can be simply obtained by computing the intersection points of adjacent half-planes in the deque at the end of the procedure. This will take linear time as well. It is also possible to store such points during step 2 and skip this step entirely, but we believe it is slightly easier (in terms of implementation) to compute them on-the-fly.\n\nIn total, we have achieved a time complexity of $O(N \\log N)$. Since sorting is clearly the bottleneck, the algorithm can be made to run in linear time in the special case where we are given half-planes sorted in advance by their angles (an example of such a case would be obtaining the half-planes that define a convex polygon). \n\n### Direct implementation\n\nHere is a sample, direct implementation of the algorithm, with comments explaining most parts: \n\nSimple point/vector and half-plane structs:\n\n```cpp\n// Redefine epsilon and infinity as necessary. Be mindful of precision errors.\nconst long double eps = 1e-9, inf = 1e9; \n\n// Basic point/vector struct.\nstruct Point { \n\n    long double x, y;\n    explicit Point(long double x = 0, long double y = 0) : x(x), y(y) {}\n\n    // Addition, substraction, multiply by constant, dot product, cross product.\n\n    friend Point operator + (const Point& p, const Point& q) {\n        return Point(p.x + q.x, p.y + q.y); \n    }\n\n    friend Point operator - (const Point& p, const Point& q) { \n        return Point(p.x - q.x, p.y - q.y); \n    }\n\n    friend Point operator * (const Point& p, const long double& k) { \n        return Point(p.x * k, p.y * k); \n    } \n    \n    friend long double dot(const Point& p, const Point& q) {\n    \treturn p.x * q.x + p.y * q.y;\n    }\n\n    friend long double cross(const Point& p, const Point& q) { \n        return p.x * q.y - p.y * q.x; \n    }\n};\n\n// Basic half-plane struct.\nstruct Halfplane { \n\n    // 'p' is a passing point of the line and 'pq' is the direction vector of the line.\n    Point p, pq; \n    long double angle;\n\n    Halfplane() {}\n    Halfplane(const Point& a, const Point& b) : p(a), pq(b - a) {\n        angle = atan2l(pq.y, pq.x);    \n    }\n\n    // Check if point 'r' is outside this half-plane. \n    // Every half-plane allows the region to the LEFT of its line.\n    bool out(const Point& r) { \n        return cross(pq, r - p) < -eps; \n    }\n\n    // Comparator for sorting. \n    bool operator < (const Halfplane& e) const { \n        return angle < e.angle;\n    } \n\n    // Intersection point of the lines of two half-planes. It is assumed they're never parallel.\n    friend Point inter(const Halfplane& s, const Halfplane& t) {\n        long double alpha = cross((t.p - s.p), t.pq) / cross(s.pq, t.pq);\n        return s.p + (s.pq * alpha);\n    }\n};\n```\n\nAlgorithm: \n\n```cpp\n// Actual algorithm\nvector<Point> hp_intersect(vector<Halfplane>& H) { \n\n    Point box[4] = {  // Bounding box in CCW order\n        Point(inf, inf), \n        Point(-inf, inf), \n        Point(-inf, -inf), \n        Point(inf, -inf) \n    };\n\n    for(int i = 0; i<4; i++) { // Add bounding box half-planes.\n        Halfplane aux(box[i], box[(i+1) % 4]);\n        H.push_back(aux);\n    }\n\n    // Sort by angle and start algorithm\n    sort(H.begin(), H.end());\n    deque<Halfplane> dq;\n    int len = 0;\n    for(int i = 0; i < int(H.size()); i++) {\n\n        // Remove from the back of the deque while last half-plane is redundant\n        while (len > 1 && H[i].out(inter(dq[len-1], dq[len-2]))) {\n            dq.pop_back();\n            --len;\n        }\n\n        // Remove from the front of the deque while first half-plane is redundant\n        while (len > 1 && H[i].out(inter(dq[0], dq[1]))) {\n            dq.pop_front();\n            --len;\n        }\n        \n        // Special case check: Parallel half-planes\n        if (len > 0 && fabsl(cross(H[i].pq, dq[len-1].pq)) < eps) {\n        \t// Opposite parallel half-planes that ended up checked against each other.\n        \tif (dot(H[i].pq, dq[len-1].pq) < 0.0)\n        \t\treturn vector<Point>();\n        \t\n        \t// Same direction half-plane: keep only the leftmost half-plane.\n        \tif (H[i].out(dq[len-1].p)) {\n        \t\tdq.pop_back();\n        \t\t--len;\n        \t}\n        \telse continue;\n        }\n        \n        // Add new half-plane\n        dq.push_back(H[i]);\n        ++len;\n    }\n\n    // Final cleanup: Check half-planes at the front against the back and vice-versa\n    while (len > 2 && dq[0].out(inter(dq[len-1], dq[len-2]))) {\n        dq.pop_back();\n        --len;\n    }\n\n    while (len > 2 && dq[len-1].out(inter(dq[0], dq[1]))) {\n        dq.pop_front();\n        --len;\n    }\n\n    // Report empty intersection if necessary\n    if (len < 3) return vector<Point>();\n\n    // Reconstruct the convex polygon from the remaining half-planes.\n    vector<Point> ret(len);\n    for(int i = 0; i+1 < len; i++) {\n        ret[i] = inter(dq[i], dq[i+1]);\n    }\n    ret.back() = inter(dq[len-1], dq[0]);\n    return ret;\n}\n```\n\n\n### Implementation discussion\n\nA special thing to note is that, in case there multiple half-planes that intersect at the same point, then this algorithm could return repeated adjacent points in the final polygon. However, this should not have any impact on judging correctly whether the intersection is empty or not, and it does not affect the polygon area at all either. You may want to remove these duplicates depending on what tasks you need to do after. You can do this very easily with std::unique. We want to keep the repeat points during the execution of the algorithm so that the intersections with area equal to zero can be computed correctly (for example, intersections that consist of a single point, line or line-segment). I encourage the reader to test some small hand-made cases where the intersection results in a single point or line.\n\nOne more thing that should be talked about is what to do if we are given half-planes in the form of a linear constraint (for example, $ax + by + c \\leq 0$). In such case, there are two options. You can either implement the algorithm with the corresponding modifications to work with such representation (essentially create your own half-plane struct, should be fairly straightforward if you're familiar with the convex hull trick), or you can transform the lines into the representation we used in this article by taking any 2 points of each line. In general, it is recommended to work with the representation that you're given in the problem to avoid additional precision issues.\n\n## Problems, tasks and applications\n\nMany problems that can be solved with half-plane intersection can also be solved without it, but with (usually) more complicated or uncommon approaches. Generally, half-plane intersection can appear when dealing with problems related to polygons (mostly convex), visibility in the plane and two-dimensional linear programming. Here are some sample tasks that can be solved with this technique: \n\n### Convex polygon intersection \n\nOne of the classical applications of half-plane intersection: Given $N$ polygons, compute the region that is included inside all of the polygons. \n\nSince the intersection of a set of half-planes is a convex polygon, we can also represent a convex polygon as a set of half-planes (every edge of the polygon is a segment of a half-plane). Generate these half-planes for every polygon and compute the intersection of the whole set. The total time complexity is $O(S \\log S)$, where S is the total number of sides of all the polygons. The problem can also theoretically be solved in $O(S \\log N)$ by merging the $N$ sets of half-planes using a heap and then running the algorithm without the sorting step, but such solution has much worse constant factor than straightforward sorting and only provides minor speed gains for very small $N$.\n\n### Visibility in the plane\n\nProblems that require something among the lines of \"determine if some line segments are visible from some point(s) in the plane\" can usually be formulated as half-plane intersection problems. Take, for example, the following task: Given some simple polygon (not necessarily convex), determine if there's any point inside the polygon such that the whole boundary of the polygon can be observed from that point. This is also known as finding the [kernel of a polygon](https://en.wikipedia.org/wiki/Star-shaped_polygon) and can be solved by simple half-plane intersection, taking each edge of the polygon as a half-plane and then computing its intersection.\n\nHere's a related, more interesting problem that was presented by Artem Vasilyev in one of his [Brazilian ICPC Summer School lectures](https://youtu.be/WKyZSitpm6M?t=6463): \nGiven a set $p$ of points $p_1, p_2\\ \\dots \\ p_n$ in the plane, determine if there's any point $q$ you can stand at such that you can see all the points of $p$ from left to right in increasing order of their index.\n\nSuch problem can be solved by noticing that being able to see some point $p_i$ to the left of $p_j$ is the same as being able to see the right side of the line segment from $p_i$ to $p_j$ (or equivalently, being able to see the left side of the segment from $p_j$ to $p_i$). With that in mind, we can simply create a half-plane for every line segment $p_i p_{i+1}$ (or $p_{i+1} p_i$ depending on the orientation you choose) and check if the intersection of the whole set is empty or not.\n\n### Half-plane intersection with binary search\n\nAnother common application is utilizing half-plane intersection as a tool to validate the predicate of a binary search procedure. Here's an example of such a problem, also presented by Artem Vasilyev in the same lecture that was previously mentioned: Given a **convex** polygon $P$, find the biggest circumference that can be inscribed inside of it.\n\nInstead of looking for some sort of closed-form solution, annoying formulas or obscure algorithmic solutions, lets instead try to binary search on the answer. Notice that, for some fixed $r$, a circle with radius $r$ can be inscribed inside $P$ only if there exists some point inside $P$ that has distance greater or equal than $r$ to all the points of the boundary of $P$. This condition can be validated by \"shrinking\" the polygon inwards by a distance of $r$ and checking that the polygon remains non-degenerate (or is a point/segment itself). Such procedure can be simulated by taking the half-planes of the polygon sides in counter-clockwise order, translating each of them by a distance of $r$ in the direction of the region they allow (that is, orthogonal to the direction vector of the half-plane), and checking if the intersection is not empty.\n\nClearly, if we can inscribe a circle of radius $r$, we can also inscribe any other circle of radius smaller than $r$. So we can perform a binary search on the radius $r$ and validate every step using half-plane intersection. Also, note that the half-planes of a convex polygon are already sorted by angle, so the sorting step can be skipped in the algorithm. Thus we obtain a total time complexity of $O(NK)$, where $N$ is the number of polygon vertices and $K$ is the number of iterations of the binary search (the actual value will depend on the range of possible answers and the desired precision).\n\n### Two-dimensional linear programming\n\nOne more application of half-plane intersection is linear programming in two variables. All linear constraints for two variables can be expressed in the form of $Ax + By + C \\leq 0$ (inequality comparator may vary). Clearly, these are just half-planes, so checking if a feasible solution exists for a set of linear constraints can be done with half-plane intersection. Additionally, for a given set of linear constraints, it is possible to compute the region of feasible solutions (i.e. the intersection of the half-planes) and then answer multiple queries of maximizing/minimizing some linear function $f(x, y)$ subject to the constraints in $O(\\log N)$ per query using binary search (very similar to the convex hull trick).\n\nIt is worth mentioning that there also exists a fairly simple randomized algorithm that can check whether a set of linear constraints has a feasible solution or not, and maximize/minimize some linear function subject to the given constraints. This randomized algorithm was also explained nicely by Artem Vasilyev in the lecture mentioned earlier. Here are some additional resources on it, should the reader be interested: [CG - Lecture 4, parts 4 and 5](https://youtu.be/5dfc355t2y4) and [Petr Mitrichev's blog (which includes the solution to the hardest problem in the practice problems list below)](https://petr-mitrichev.blogspot.com/2016/07/a-half-plane-week.html).\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Half-plane intersection\n\nIn this article we will discuss the problem of computing the intersection of a set of half-planes. Such an intersection can be conveniently represented as a convex region/polygon, where every point inside of it is also inside all of the half-planes, and it is this polygon that we're trying to find or construct. We give some initial intuition for the problem, describe a $O(N \\log N)$ approach known as the Sort-and-Incremental algorithm and give some sample applications of this technique.\n\nIt is strongly recommended for the reader to be familiar with basic geometrical primitives and operations (points, vectors, intersection of lines). Additionally, knowledge about [Convex Hulls](../geometry/convex-hull.md) or the [Convex Hull Trick](../geometry/convex_hull_trick.md) may help to better understand the concepts in this article, but they are not a prerequisite by any means.\n\n## Initial clarifications and definitions\n\nFor the entire article, we will make some assumptions (unless specified otherwise):\n\n1. We define $N$ to be the quantity of half-planes in the given set.\n2. We will represent lines and half-planes by one point and one vector (any point that lies on the given line, and the direction vector of the line). In the case of half-planes, we assume that every half-plane allows the region to the left side of its direction vector. Additionally, we define the angle of a half-plane to be the polar angle of its direction vector. See image below for example.\n3. We will assume that the resulting intersection is always either bounded or empty. If we need to handle the unbounded case, we can simply add 4 half-planes that define a large-enough bounding box. \n4. We will assume, for simplicity, that there are no parallel half-planes in the given set. Towards the end of the article we will discuss how to deal with such cases.\n\n![](halfplanes_rep.png) \n\nThe half-plane $y \\geq 2x - 2$ can be represented as the point $P = (1, 0)$ with direction vector $PQ = Q - P = (1, 2)$\n\n## Brute force approach - $O(N^3)$ {data-toc-label=\"Brute force approach - O(N^3)\"}\n\nOne of the most straightforward and obvious solutions would be to compute the intersection point of the lines of all pairs of half-planes and, for each point, check if it is inside all of the other half-planes. Since there are $O(N^2)$ intersection points, and for each of them we have to check $O(N)$ half-planes, the total time complexity is $O(N^3)$. The actual region of the intersection can then be reconstructed using, for example, a Convex Hull algorithm on the set of intersection points that were included in all the half-planes. \n\nIt is fairly easy to see why this works: the vertices of the resulting convex polygon are all intersection points of the half-plane lines, and each of those vertices is obviously part of all the half-planes. The main advantage of this method is that its easy to understand, remember and code on-the-fly if you just need to check if the intersection is empty or not. However, it is awfully slow and unfit for most problems, so we need something faster.\n\n## Incremental approach - $O(N^2)$ {data-toc-label=\"Incremental approach - O(N^2)\"}\n\nAnother fairly straightforward approach is to incrementally construct the intersection of the half-planes, one at a time. This method is basically equivalent to cutting a convex polygon by a line $N$ times, and removing the redundant half-planes at every step. To do this, we can represent the convex polygon as a list of line segments, and to cut it with a half-plane we simply find the intersection points of the segments with the half-plane line (there will only be two intersection points if the line properly intersects the polygon), and replace all the line segments in-between with the new segment corresponding to the half-plane. Since such procedure can be implemented in linear time, we can simply start with a big bounding box and cut it down with each one of the half-planes, obtaining a total time complexity of $O(N^2)$.\n\nThis method is a big step in the right direction, but it does feel wasteful to have to iterate over $O(N)$ half-planes at every step. We will see next that, by making some clever observations, the ideas behind this incremental approach can be recycled to create a $O(N \\log N)$ algorithm.\n\n## Sort-and-Incremental algorithm - $O(N \\log N)$ {data-toc-label=\"Sort-and-Incremental algorithm - O(N log N)\"}\n\nThe first properly-documented source of this algorithm we could find was Zeyuan Zhu's thesis for Chinese Team Selecting Contest titled [New Algorithm for Half-plane Intersection and its Practical Value](http://people.csail.mit.edu/zeyuan/publications.htm), from the year 2006. The approach we'll describe next is based on this same algorithm, but instead of computing two separate intersections for the lower and upper halves of the intersections, we'll construct it all at once in one pass with a deque (double-ended queue).\n\nThe algorithm itself, as the name may spoil, takes advantage of the fact that the resulting region from the intersection of half-planes is convex, and thus it will consist of some segments of half-planes in order sorted by their angles. This leads to a crucial observation: if we incrementally intersect the half-planes in their order sorted by angle (as they would appear in the final, resulting shape of the intersection) and store them in a double-ended queue, then we will only ever need to remove half-planes from the front and the back of the deque.\n\nTo better visualize this fact, suppose we're performing the incremental approach described previously on a set of half-planes that is sorted by angle (in this case, we'll assume they're sorted from $-\\pi$ to $\\pi$), and suppose that we're about to start some arbitrary $k$'th step. This means we have already constructed the intersection of the first $k-1$ half-planes. Now, because the half-planes are sorted by angle, whatever the $k$'th half-plane is, we can be sure that it will form a convex turn with the $(K-1)$'th half-plane. For that reason, a few things may happen:\n\n1. Some (possibly none) of the half-planes in the back of the intersection may become *redundant*. In this case, we need to pop these now-useless half-planes from the back of the deque. \n2. Some (possibly none) of the half-planes at the front may become *redundant*. Analogous to case 1, we just pop them from the front of the deque.\n3. The intersection may become empty (after handling cases 1 and/or 2). In this case, we just report the intersection is empty and terminate the algorithm.\n\n*We say a half-plane is \"redundant\" if it does not contribute anything to the intersection. Such a half-plane could be removed and the resulting intersection would not change at all.*\n\nHere's a small example with an illustration:\n\nLet $H = \\{ A, B, C, D, E \\}$ be the set of half-planes currently present in the intersection. Additionally, let $P = \\{ p, q, r, s \\}$ be the set of intersection points of adjacent half-planes in H. Now, suppose we wish to intersect it with the half-plane $F$, as seen in the illustration below:\n\n![](halfplanes_hp1.png)\n\nNotice the half-plane $F$ makes $A$ and $E$ redundant in the intersection. So we remove both $A$ and $E$ from the front and back of the intersection, respectively, and add $F$ at the end. And we finally obtain the new intersection $H = \\{ B, C, D, F\\}$ with $P = \\{ q, r, t, u \\}$.\n\n![](halfplanes_hp2.png)\n\nWith all of this in mind, we have almost everything we need to actually implement the algorithm, but we still need to talk about some special cases. At the beginning of the article we said we would add a bounding box to take care of the cases where the intersection could be unbounded, so the only tricky case we actually need to handle is parallel half-planes. We can have two sub-cases: two half-planes can be parallel with the same direction or with opposite direction. The reason this case needs to be handled separately is because we will need to compute intersection points of half-plane lines to be able to check if a half-plane is redundant or not, and two parallel lines have no intersection point, so we need a special way to deal with them.\n\nFor the case of parallel half-planes of opposite orientation: Notice that, because we're adding the bounding box to deal with the unbounded case, this also deals with the case where we have two adjacent parallel half-planes with opposite directions after sorting, since there will have to be at least one of the bounding-box half-planes in between these two (remember they are sorted by angle). \n\n * However, it is possible that, after removing some half-planes from the back of the deque, two parallel half-planes of opposite direction end up together. This case only happens, specifically, when these two half-planes form an empty intersection, as this last half-plane will cause everything to be removed from the deque. To avoid this problem, we have to manually check for parallel half-planes, and if they have opposite direction, we just instantly stop the algorithm and return an empty intersection.\n\n\nThus the only case we actually need to handle is having multiple half-planes with the same angle, and it turns out this case is fairly easy to handle: we only have keep the leftmost half-plane and erase the rest, since they will be completely redundant anyways.\nTo sum up, the full algorithm will roughly look as follows:\n\n1. We begin by sorting the set of half-planes by angle, which takes $O(N \\log N)$ time.\n2. We will iterate over the set of half-planes, and for each one, we will perform the incremental procedure, popping from the front and the back of the double-ended queue as necessary. This will take linear time in total, as every half-plane can only be added or removed once.\n3. At the end, the convex polygon resulting from the intersection can be simply obtained by computing the intersection points of adjacent half-planes in the deque at the end of the procedure. This will take linear time as well. It is also possible to store such points during step 2 and skip this step entirely, but we believe it is slightly easier (in terms of implementation) to compute them on-the-fly.\n\nIn total, we have achieved a time complexity of $O(N \\log N)$. Since sorting is clearly the bottleneck, the algorithm can be made to run in linear time in the special case where we are given half-planes sorted in advance by their angles (an example of such a case would be obtaining the half-planes that define a convex polygon). \n\n### Direct implementation\n\nHere is a sample, direct implementation of the algorithm, with comments explaining most parts: \n\nSimple point/vector and half-plane structs:\n\n```cpp\n// Redefine epsilon and infinity as necessary. Be mindful of precision errors.\nconst long double eps = 1e-9, inf = 1e9; \n\n// Basic point/vector struct.\nstruct Point { \n\n    long double x, y;\n    explicit Point(long double x = 0, long double y = 0) : x(x), y(y) {}\n\n    // Addition, substraction, multiply by constant, dot product, cross product.\n\n    friend Point operator + (const Point& p, const Point& q) {\n        return Point(p.x + q.x, p.y + q.y); \n    }\n\n    friend Point operator - (const Point& p, const Point& q) { \n        return Point(p.x - q.x, p.y - q.y); \n    }\n\n    friend Point operator * (const Point& p, const long double& k) { \n        return Point(p.x * k, p.y * k); \n    } \n    \n    friend long double dot(const Point& p, const Point& q) {\n    \treturn p.x * q.x + p.y * q.y;\n    }\n\n    friend long double cross(const Point& p, const Point& q) { \n        return p.x * q.y - p.y * q.x; \n    }\n};\n\n// Basic half-plane struct.\nstruct Halfplane { \n\n    // 'p' is a passing point of the line and 'pq' is the direction vector of the line.\n    Point p, pq; \n    long double angle;\n\n    Halfplane() {}\n    Halfplane(const Point& a, const Point& b) : p(a), pq(b - a) {\n        angle = atan2l(pq.y, pq.x);    \n    }\n\n    // Check if point 'r' is outside this half-plane. \n    // Every half-plane allows the region to the LEFT of its line.\n    bool out(const Point& r) { \n        return cross(pq, r - p) < -eps; \n    }\n\n    // Comparator for sorting. \n    bool operator < (const Halfplane& e) const { \n        return angle < e.angle;\n    } \n\n    // Intersection point of the lines of two half-planes. It is assumed they're never parallel.\n    friend Point inter(const Halfplane& s, const Halfplane& t) {\n        long double alpha = cross((t.p - s.p), t.pq) / cross(s.pq, t.pq);\n        return s.p + (s.pq * alpha);\n    }\n};\n```\n\nAlgorithm: \n\n```cpp\n// Actual algorithm\nvector<Point> hp_intersect(vector<Halfplane>& H) { \n\n    Point box[4] = {  // Bounding box in CCW order\n        Point(inf, inf), \n        Point(-inf, inf), \n        Point(-inf, -inf), \n        Point(inf, -inf) \n    };\n\n    for(int i = 0; i<4; i++) { // Add bounding box half-planes.\n        Halfplane aux(box[i], box[(i+1) % 4]);\n        H.push_back(aux);\n    }\n\n    // Sort by angle and start algorithm\n    sort(H.begin(), H.end());\n    deque<Halfplane> dq;\n    int len = 0;\n    for(int i = 0; i < int(H.size()); i++) {\n\n        // Remove from the back of the deque while last half-plane is redundant\n        while (len > 1 && H[i].out(inter(dq[len-1], dq[len-2]))) {\n            dq.pop_back();\n            --len;\n        }\n\n        // Remove from the front of the deque while first half-plane is redundant\n        while (len > 1 && H[i].out(inter(dq[0], dq[1]))) {\n            dq.pop_front();\n            --len;\n        }\n        \n        // Special case check: Parallel half-planes\n        if (len > 0 && fabsl(cross(H[i].pq, dq[len-1].pq)) < eps) {\n        \t// Opposite parallel half-planes that ended up checked against each other.\n        \tif (dot(H[i].pq, dq[len-1].pq) < 0.0)\n        \t\treturn vector<Point>();\n        \t\n        \t// Same direction half-plane: keep only the leftmost half-plane.\n        \tif (H[i].out(dq[len-1].p)) {\n        \t\tdq.pop_back();\n        \t\t--len;\n        \t}\n        \telse continue;\n        }\n        \n        // Add new half-plane\n        dq.push_back(H[i]);\n        ++len;\n    }\n\n    // Final cleanup: Check half-planes at the front against the back and vice-versa\n    while (len > 2 && dq[0].out(inter(dq[len-1], dq[len-2]))) {\n        dq.pop_back();\n        --len;\n    }\n\n    while (len > 2 && dq[len-1].out(inter(dq[0], dq[1]))) {\n        dq.pop_front();\n        --len;\n    }\n\n    // Report empty intersection if necessary\n    if (len < 3) return vector<Point>();\n\n    // Reconstruct the convex polygon from the remaining half-planes.\n    vector<Point> ret(len);\n    for(int i = 0; i+1 < len; i++) {\n        ret[i] = inter(dq[i], dq[i+1]);\n    }\n    ret.back() = inter(dq[len-1], dq[0]);\n    return ret;\n}\n```\n\n\n### Implementation discussion\n\nA special thing to note is that, in case there multiple half-planes that intersect at the same point, then this algorithm could return repeated adjacent points in the final polygon. However, this should not have any impact on judging correctly whether the intersection is empty or not, and it does not affect the polygon area at all either. You may want to remove these duplicates depending on what tasks you need to do after. You can do this very easily with std::unique. We want to keep the repeat points during the execution of the algorithm so that the intersections with area equal to zero can be computed correctly (for example, intersections that consist of a single point, line or line-segment). I encourage the reader to test some small hand-made cases where the intersection results in a single point or line.\n\nOne more thing that should be talked about is what to do if we are given half-planes in the form of a linear constraint (for example, $ax + by + c \\leq 0$). In such case, there are two options. You can either implement the algorithm with the corresponding modifications to work with such representation (essentially create your own half-plane struct, should be fairly straightforward if you're familiar with the convex hull trick), or you can transform the lines into the representation we used in this article by taking any 2 points of each line. In general, it is recommended to work with the representation that you're given in the problem to avoid additional precision issues.\n\n## Problems, tasks and applications\n\nMany problems that can be solved with half-plane intersection can also be solved without it, but with (usually) more complicated or uncommon approaches. Generally, half-plane intersection can appear when dealing with problems related to polygons (mostly convex), visibility in the plane and two-dimensional linear programming. Here are some sample tasks that can be solved with this technique: \n\n### Convex polygon intersection \n\nOne of the classical applications of half-plane intersection: Given $N$ polygons, compute the region that is included inside all of the polygons. \n\nSince the intersection of a set of half-planes is a convex polygon, we can also represent a convex polygon as a set of half-planes (every edge of the polygon is a segment of a half-plane). Generate these half-planes for every polygon and compute the intersection of the whole set. The total time complexity is $O(S \\log S)$, where S is the total number of sides of all the polygons. The problem can also theoretically be solved in $O(S \\log N)$ by merging the $N$ sets of half-planes using a heap and then running the algorithm without the sorting step, but such solution has much worse constant factor than straightforward sorting and only provides minor speed gains for very small $N$.\n\n### Visibility in the plane\n\nProblems that require something among the lines of \"determine if some line segments are visible from some point(s) in the plane\" can usually be formulated as half-plane intersection problems. Take, for example, the following task: Given some simple polygon (not necessarily convex), determine if there's any point inside the polygon such that the whole boundary of the polygon can be observed from that point. This is also known as finding the [kernel of a polygon](https://en.wikipedia.org/wiki/Star-shaped_polygon) and can be solved by simple half-plane intersection, taking each edge of the polygon as a half-plane and then computing its intersection.\n\nHere's a related, more interesting problem that was presented by Artem Vasilyev in one of his [Brazilian ICPC Summer School lectures](https://youtu.be/WKyZSitpm6M?t=6463): \nGiven a set $p$ of points $p_1, p_2\\ \\dots \\ p_n$ in the plane, determine if there's any point $q$ you can stand at such that you can see all the points of $p$ from left to right in increasing order of their index.\n\nSuch problem can be solved by noticing that being able to see some point $p_i$ to the left of $p_j$ is the same as being able to see the right side of the line segment from $p_i$ to $p_j$ (or equivalently, being able to see the left side of the segment from $p_j$ to $p_i$). With that in mind, we can simply create a half-plane for every line segment $p_i p_{i+1}$ (or $p_{i+1} p_i$ depending on the orientation you choose) and check if the intersection of the whole set is empty or not.\n\n### Half-plane intersection with binary search\n\nAnother common application is utilizing half-plane intersection as a tool to validate the predicate of a binary search procedure. Here's an example of such a problem, also presented by Artem Vasilyev in the same lecture that was previously mentioned: Given a **convex** polygon $P$, find the biggest circumference that can be inscribed inside of it.\n\nInstead of looking for some sort of closed-form solution, annoying formulas or obscure algorithmic solutions, lets instead try to binary search on the answer. Notice that, for some fixed $r$, a circle with radius $r$ can be inscribed inside $P$ only if there exists some point inside $P$ that has distance greater or equal than $r$ to all the points of the boundary of $P$. This condition can be validated by \"shrinking\" the polygon inwards by a distance of $r$ and checking that the polygon remains non-degenerate (or is a point/segment itself). Such procedure can be simulated by taking the half-planes of the polygon sides in counter-clockwise order, translating each of them by a distance of $r$ in the direction of the region they allow (that is, orthogonal to the direction vector of the half-plane), and checking if the intersection is not empty.\n\nClearly, if we can inscribe a circle of radius $r$, we can also inscribe any other circle of radius smaller than $r$. So we can perform a binary search on the radius $r$ and validate every step using half-plane intersection. Also, note that the half-planes of a convex polygon are already sorted by angle, so the sorting step can be skipped in the algorithm. Thus we obtain a total time complexity of $O(NK)$, where $N$ is the number of polygon vertices and $K$ is the number of iterations of the binary search (the actual value will depend on the range of possible answers and the desired precision).\n\n### Two-dimensional linear programming\n\nOne more application of half-plane intersection is linear programming in two variables. All linear constraints for two variables can be expressed in the form of $Ax + By + C \\leq 0$ (inequality comparator may vary). Clearly, these are just half-planes, so checking if a feasible solution exists for a set of linear constraints can be done with half-plane intersection. Additionally, for a given set of linear constraints, it is possible to compute the region of feasible solutions (i.e. the intersection of the half-planes) and then answer multiple queries of maximizing/minimizing some linear function $f(x, y)$ subject to the constraints in $O(\\log N)$ per query using binary search (very similar to the convex hull trick).\n\nIt is worth mentioning that there also exists a fairly simple randomized algorithm that can check whether a set of linear constraints has a feasible solution or not, and maximize/minimize some linear function subject to the given constraints. This randomized algorithm was also explained nicely by Artem Vasilyev in the lecture mentioned earlier. Here are some additional resources on it, should the reader be interested: [CG - Lecture 4, parts 4 and 5](https://youtu.be/5dfc355t2y4) and [Petr Mitrichev's blog (which includes the solution to the hardest problem in the practice problems list below)](https://petr-mitrichev.blogspot.com/2016/07/a-half-plane-week.html).\n\n## Practice problems\n\n### Classic problems, direct application\n\n* [Codechef - Animesh decides to settle down](https://www.codechef.com/problems/CHN02)\n* [POJ - How I mathematician Wonder What You Are!](http://poj.org/problem?id=3130)\n* [POJ - Rotating Scoreboard](http://poj.org/problem?id=3335)\n* [POJ - Video Surveillance](http://poj.org/problem?id=1474)\n* [POJ - Art Gallery](http://poj.org/problem?id=1279)\n* [POJ - Uyuw's Concert](http://poj.org/problem?id=2451)\n\n### Harder problems\n\n* [POJ - Most Distant Point from the Sea - Medium](http://poj.org/problem?id=3525)\n* [Baekjoon - Jeju's Island - Same as above but seemingly stronger test cases](https://www.acmicpc.net/problem/3903)\n* [POJ - Feng Shui - Medium](http://poj.org/problem?id=3384)\n* [POJ - Triathlon - Medium/hard](http://poj.org/problem?id=1755)\n* [DMOJ - Arrow - Medium/hard](https://dmoj.ca/problem/ccoprep3p3)\n* [POJ - Jungle Outpost - Hard](http://poj.org/problem?id=3968)\n* [Codeforces - Jungle Outpost (alternative link, problem J) - Hard](https://codeforces.com/gym/101309/attachments?mobile=false) \n* [Yandex - Asymmetry Value (need virtual contest to see, problem F) - Very Hard](https://contest.yandex.com/contest/2540/enter/)\n\n### Additional problems\n\n* 40th Petrozavodsk Programming Camp, Winter 2021 - Day 1: Jagiellonian U Contest, Grand Prix of Krakow - Problem B: (Almost) Fair Cake-Cutting. At the time of writing the article, this problem was private and only accessible by participants of the Programming Camp.\n\n## References, bibliography and other sources\n\n### Main sources\n\n* [New Algorithm for Half-plane Intersection and its Practical Value.](http://people.csail.mit.edu/zeyuan/publications.htm) Original paper of the algorithm.\n* [Artem Vasilyev's Brazilian ICPC Summer School 2020 lecture.](https://youtu.be/WKyZSitpm6M?t=6463) Amazing lecture on half-plane intersection. Also covers other geometry topics.\n\n### Good blogs (Chinese)\n\n* [Fundamentals of Computational Geometry - Intersection of Half-planes.](https://zhuanlan.zhihu.com/p/83499723)\n* [Detailed introduction to the half-plane intersection algorithm.](https://blog.csdn.net/qq_40861916/article/details/83541403)\n* [Summary of Half-plane intersection problems.](https://blog.csdn.net/qq_40482358/article/details/87921815)\n* [Sorting incremental method of half-plane intersection.](https://blog.csdn.net/u012061345/article/details/23872929)\n\n### Randomized algorithm\n\n* [Linear Programming and Half-Plane intersection - Parts 4 and 5.](https://youtu.be/5dfc355t2y4)\n* [Petr Mitrichev's Blog: A half-plane week.](https://petr-mitrichev.blogspot.com/2016/07/a-half-plane-week.html)\n", "problem_ids": [], "title": "Half-plane intersection"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: circle_tangents\n---\n\n# Finding common tangents to two circles\n\nGiven two circles. It is required to find all their common tangents, i.e. all such lines that touch both circles simultaneously.\n\nThe described algorithm will also work in the case when one (or both) circles degenerate into points. Thus, this algorithm can also be used to find tangents to a circle passing through a given point.\n\n\n## The number of common tangents\nThe number of common tangents to two circles can be **0,1,2,3,4** and **infinite**.\nLook at the images for different cases.\n<center>![\"Different cases of tangents common to two circles\"](tangents-to-two-circles.png)</center>\n\nHere, we won't be considering **degenerate** cases, i.e *when the circles coincide (in this case they have infinitely many common tangents), or one circle lies inside the other (in this case they have no common tangents, or if the circles are tangent, there is one common tangent).*\n\nIn most cases, two circles have **four** common tangents.\n\nIf the circles **are tangent** , then they will have three common tangents, but this can be understood as a degenerate case: as if the two tangents coincided.\n\nMoreover, the algorithm described below will work in the case when one or both circles have zero radius: in this case there will be, respectively, two or one common tangent.\n\nSumming up, we will always look for **four tangents** for all cases except infinite tangents case (The infinite tangents case needs to be handled separately and it is not discussed here). In degenerate cases, some of tangents will coincide, but nevertheless, these cases will also fit into the big picture.\n\n\n\n## Algorithm\nFor the sake of simplicity of the algorithm, we will assume, without losing generality, that the center of the first circle has coordinates $(0, 0)$. (If this is not the case, then this can be achieved by simply shifting the whole picture, and after finding a solution, by shifting the obtained straight lines back.)\n\nDenote $r_1$ and $r_2$ the radii of the first and second circles, and by $(v_x,v_y)$ the coordinates of the center of the second circle and point $v$ different from origin. (Note: we are not considering the case in which both the circles are same).\n\nTo solve the problem, we approach it purely **algebraically** . We need to find all the lines of the form $ax + by + c = 0$ that lie at a distance $r_1$ from the origin of coordinates, and at a distance $r_2$ from a point $v$. In addition, we impose the condition of normalization of the straight line: the sum of the squares of the coefficients and must be equal to one (this is necessary, otherwise the same straight line will correspond to infinitely many representations of the form $ax + by + c = 0$). Total we get such a system of equations for the desired $a, b, c$:\n\n$$\\begin{align}\na^2 + b^2 &= 1 \\\\\n\\mid a \\cdot 0 + b \\cdot 0 + c \\mid &= r_1 \\\\\n\\mid a \\cdot v_x + b \\cdot v_y + c \\mid &= r_2\n\\end{align}$$\n\nTo get rid of the modulus, note that there are only four ways to open the modulus in this system. All these methods can be considered by the general case, if we understand the opening of the modulus as the fact that the coefficient on the right-hand side may be multiplied by -1. In other words, we turn to this system:\n\n$$\\begin{align}\na^2 + b^2 &= 1 \\\\\nc &= \\pm r_1 \\\\\na \\cdot v_x + b \\cdot v_y + c &= \\pm r_2\n\\end{align}$$\n\n\nEntering the notation $d_1 = \\pm r_1$ and $d_2 = \\pm r_2$ , we come to the conclusion that the system must have four solutions:\n\n$$\\begin{align}\na^2 + b^2 &= 1 \\\\\nc &= d_1 \\\\\na \\cdot v_x + b \\cdot v_y + c &= d_2\n\\end{align}$$\n\nThe solution of this system is reduced to solving a quadratic equation. We will omit all the cumbersome calculations, and immediately give a ready answer:\n\n$$\\begin{align}\na &= {( d_2 - d_1 ) v_x \\pm v_y \\sqrt{v_x^2 + v_y^2-(d_2-d_1)^2} \\over {v_x^2 + v_y^2} } \\\\\nb &= {( d_2 - d_1 ) v_y \\pm v_x \\sqrt{v_x^2 + v_y^2-(d_2-d_1)^2} \\over {v_x^2 + v_y^2} } \\\\\nc &= d_1\n\\end{align}$$\n\nTotal we got eight solutions instead four. However, it is easy to understand where superfluous decisions arise: in fact, in the latter system, it is enough to take only one solution (for example, the first). In fact, the geometric meaning of what we take $\\pm r_1$ and $\\pm r_2$ is clear: we are actually sorting out which side of each circle there is a straight line. Therefore, the two methods that arise when solving the latter system are redundant: it is enough to choose one of the two solutions (only, of course, in all four cases, you must choose the same family of solutions).\n\nThe last thing that we have not yet considered is **how to shift the straight lines** in the case when the first circle was not originally located at the origin. However, everything is simple here: it follows from the linearity of the equation of a straight line that the value $a \\cdot x_0 + b \\cdot y_0$ (where $x_0$ and $y_0$ are the coordinates of the original center of the first circle) must be subtracted from the coefficient $c$.\n\n##Implementation\nWe first describe all the necessary data structures and other auxiliary definitions:\n\n```point-line-circle-struct\nstruct pt {\n    double x, y;\n\n    pt operator- (pt p) {\n        pt res = { x-p.x, y-p.y };\n        return res;\n    }\n};\n\nstruct circle : pt {\n    double r;\n};\n\nstruct line {\n    double a, b, c;\n};\n\nconst double EPS = 1E-9;\n\ndouble sqr (double a) {\n    return a * a;\n}\n```\nThen the solution itself can be written this way (where the main function for the call is the second; and the first function is an auxiliary):\n\n```find-tangents-to-two-circles\nvoid tangents (pt c, double r1, double r2, vector<line> & ans) {\n    double r = r2 - r1;\n    double z = sqr(c.x) + sqr(c.y);\n    double d = z - sqr(r);\n    if (d < -EPS)  return;\n    d = sqrt (abs (d));\n    line l;\n    l.a = (c.x * r + c.y * d) / z;\n    l.b = (c.y * r - c.x * d) / z;\n    l.c = r1;\n    ans.push_back (l);\n}\n\nvector<line> tangents (circle a, circle b) {\n    vector<line> ans;\n    for (int i=-1; i<=1; i+=2)\n        for (int j=-1; j<=1; j+=2)\n            tangents (b-a, a.r*i, b.r*j, ans);\n    for (size_t i=0; i<ans.size(); ++i)\n        ans[i].c -= ans[i].a * a.x + ans[i].b * a.y;\n    return ans;\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: circle_tangents\n---\n\n# Finding common tangents to two circles\n\nGiven two circles. It is required to find all their common tangents, i.e. all such lines that touch both circles simultaneously.\n\nThe described algorithm will also work in the case when one (or both) circles degenerate into points. Thus, this algorithm can also be used to find tangents to a circle passing through a given point.\n\n\n## The number of common tangents\nThe number of common tangents to two circles can be **0,1,2,3,4** and **infinite**.\nLook at the images for different cases.\n<center>![\"Different cases of tangents common to two circles\"](tangents-to-two-circles.png)</center>\n\nHere, we won't be considering **degenerate** cases, i.e *when the circles coincide (in this case they have infinitely many common tangents), or one circle lies inside the other (in this case they have no common tangents, or if the circles are tangent, there is one common tangent).*\n\nIn most cases, two circles have **four** common tangents.\n\nIf the circles **are tangent** , then they will have three common tangents, but this can be understood as a degenerate case: as if the two tangents coincided.\n\nMoreover, the algorithm described below will work in the case when one or both circles have zero radius: in this case there will be, respectively, two or one common tangent.\n\nSumming up, we will always look for **four tangents** for all cases except infinite tangents case (The infinite tangents case needs to be handled separately and it is not discussed here). In degenerate cases, some of tangents will coincide, but nevertheless, these cases will also fit into the big picture.\n\n\n\n## Algorithm\nFor the sake of simplicity of the algorithm, we will assume, without losing generality, that the center of the first circle has coordinates $(0, 0)$. (If this is not the case, then this can be achieved by simply shifting the whole picture, and after finding a solution, by shifting the obtained straight lines back.)\n\nDenote $r_1$ and $r_2$ the radii of the first and second circles, and by $(v_x,v_y)$ the coordinates of the center of the second circle and point $v$ different from origin. (Note: we are not considering the case in which both the circles are same).\n\nTo solve the problem, we approach it purely **algebraically** . We need to find all the lines of the form $ax + by + c = 0$ that lie at a distance $r_1$ from the origin of coordinates, and at a distance $r_2$ from a point $v$. In addition, we impose the condition of normalization of the straight line: the sum of the squares of the coefficients and must be equal to one (this is necessary, otherwise the same straight line will correspond to infinitely many representations of the form $ax + by + c = 0$). Total we get such a system of equations for the desired $a, b, c$:\n\n$$\\begin{align}\na^2 + b^2 &= 1 \\\\\n\\mid a \\cdot 0 + b \\cdot 0 + c \\mid &= r_1 \\\\\n\\mid a \\cdot v_x + b \\cdot v_y + c \\mid &= r_2\n\\end{align}$$\n\nTo get rid of the modulus, note that there are only four ways to open the modulus in this system. All these methods can be considered by the general case, if we understand the opening of the modulus as the fact that the coefficient on the right-hand side may be multiplied by -1. In other words, we turn to this system:\n\n$$\\begin{align}\na^2 + b^2 &= 1 \\\\\nc &= \\pm r_1 \\\\\na \\cdot v_x + b \\cdot v_y + c &= \\pm r_2\n\\end{align}$$\n\n\nEntering the notation $d_1 = \\pm r_1$ and $d_2 = \\pm r_2$ , we come to the conclusion that the system must have four solutions:\n\n$$\\begin{align}\na^2 + b^2 &= 1 \\\\\nc &= d_1 \\\\\na \\cdot v_x + b \\cdot v_y + c &= d_2\n\\end{align}$$\n\nThe solution of this system is reduced to solving a quadratic equation. We will omit all the cumbersome calculations, and immediately give a ready answer:\n\n$$\\begin{align}\na &= {( d_2 - d_1 ) v_x \\pm v_y \\sqrt{v_x^2 + v_y^2-(d_2-d_1)^2} \\over {v_x^2 + v_y^2} } \\\\\nb &= {( d_2 - d_1 ) v_y \\pm v_x \\sqrt{v_x^2 + v_y^2-(d_2-d_1)^2} \\over {v_x^2 + v_y^2} } \\\\\nc &= d_1\n\\end{align}$$\n\nTotal we got eight solutions instead four. However, it is easy to understand where superfluous decisions arise: in fact, in the latter system, it is enough to take only one solution (for example, the first). In fact, the geometric meaning of what we take $\\pm r_1$ and $\\pm r_2$ is clear: we are actually sorting out which side of each circle there is a straight line. Therefore, the two methods that arise when solving the latter system are redundant: it is enough to choose one of the two solutions (only, of course, in all four cases, you must choose the same family of solutions).\n\nThe last thing that we have not yet considered is **how to shift the straight lines** in the case when the first circle was not originally located at the origin. However, everything is simple here: it follows from the linearity of the equation of a straight line that the value $a \\cdot x_0 + b \\cdot y_0$ (where $x_0$ and $y_0$ are the coordinates of the original center of the first circle) must be subtracted from the coefficient $c$.\n\n##Implementation\nWe first describe all the necessary data structures and other auxiliary definitions:\n\n```point-line-circle-struct\nstruct pt {\n    double x, y;\n\n    pt operator- (pt p) {\n        pt res = { x-p.x, y-p.y };\n        return res;\n    }\n};\n\nstruct circle : pt {\n    double r;\n};\n\nstruct line {\n    double a, b, c;\n};\n\nconst double EPS = 1E-9;\n\ndouble sqr (double a) {\n    return a * a;\n}\n```\nThen the solution itself can be written this way (where the main function for the call is the second; and the first function is an auxiliary):\n\n```find-tangents-to-two-circles\nvoid tangents (pt c, double r1, double r2, vector<line> & ans) {\n    double r = r2 - r1;\n    double z = sqr(c.x) + sqr(c.y);\n    double d = z - sqr(r);\n    if (d < -EPS)  return;\n    d = sqrt (abs (d));\n    line l;\n    l.a = (c.x * r + c.y * d) / z;\n    l.b = (c.y * r - c.x * d) / z;\n    l.c = r1;\n    ans.push_back (l);\n}\n\nvector<line> tangents (circle a, circle b) {\n    vector<line> ans;\n    for (int i=-1; i<=1; i+=2)\n        for (int j=-1; j<=1; j+=2)\n            tangents (b-a, a.r*i, b.r*j, ans);\n    for (size_t i=0; i<ans.size(); ++i)\n        ans[i].c -= ans[i].a * a.x + ans[i].b * a.y;\n    return ans;\n}\n```\n\n## Problems\n\n[TIMUS 1163 Chapaev](https://acm.timus.ru/problem.aspx?space=1&num=1163)\n", "problem_ids": [], "title": "Finding common tangents to two circles"}, {"article": "---\ntitle: Finding area of simple polygon in O(N)\ntags:\n  - Translated\ne_maxx_link: polygon_area\n---\n# Finding area of simple polygon in $O(N)$\n\nLet a simple polygon (i.e. without self intersection, not necessarily convex) be given. It is required to calculate its area given its vertices.\n\n## Method 1\n\nThis is easy to do if we go through all edges and add trapezoid areas bounded by each edge and x-axis. The area needs to be taken with sign so that the extra area will be reduced. Hence, the formula is as follows:\n\n$$A = \\sum_{(p,q)\\in \\text{edges}} \\frac{(p_x - q_x) \\cdot (p_y + q_y)}{2}$$\n\nCode:\n\n```cpp\ndouble area(const vector<point>& fig) {\n    double res = 0;\n    for (unsigned i = 0; i < fig.size(); i++) {\n        point p = i ? fig[i - 1] : fig.back();\n        point q = fig[i];\n        res += (p.x - q.x) * (p.y + q.y);\n    }\n    return fabs(res) / 2;\n}\n```\n\n## Method 2\nWe can choose a point $O$ arbitrarily, iterate over all edges adding the oriented area of the triangle formed by the edge and point $O$. Again, due to the sign of area, extra area will be reduced.\n\nThis method is better as it can be generalized to more complex cases (such as when some sides are arcs instead of straight lines)\n", "full_article": "---\ntitle: Finding area of simple polygon in O(N)\ntags:\n  - Translated\ne_maxx_link: polygon_area\n---\n# Finding area of simple polygon in $O(N)$\n\nLet a simple polygon (i.e. without self intersection, not necessarily convex) be given. It is required to calculate its area given its vertices.\n\n## Method 1\n\nThis is easy to do if we go through all edges and add trapezoid areas bounded by each edge and x-axis. The area needs to be taken with sign so that the extra area will be reduced. Hence, the formula is as follows:\n\n$$A = \\sum_{(p,q)\\in \\text{edges}} \\frac{(p_x - q_x) \\cdot (p_y + q_y)}{2}$$\n\nCode:\n\n```cpp\ndouble area(const vector<point>& fig) {\n    double res = 0;\n    for (unsigned i = 0; i < fig.size(); i++) {\n        point p = i ? fig[i - 1] : fig.back();\n        point q = fig[i];\n        res += (p.x - q.x) * (p.y + q.y);\n    }\n    return fabs(res) / 2;\n}\n```\n\n## Method 2\nWe can choose a point $O$ arbitrarily, iterate over all edges adding the oriented area of the triangle formed by the edge and point $O$. Again, due to the sign of area, extra area will be reduced.\n\nThis method is better as it can be generalized to more complex cases (such as when some sides are arcs instead of straight lines)\n", "problem_ids": [], "title": "Finding area of simple polygon in $O(N)$"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: circle_line_intersection\n---\n\n# Circle-Line Intersection\n\nGiven the coordinates of the center of a circle and its radius, and the equation of a line, you're required to find the points of intersection.\n\n## Solution\n\nInstead of solving the system of two equations, we will approach the problem geometrically. This way we get a more accurate solution from the point of view of numerical stability.\n\nWe assume without loss of generality that the circle is centered at the origin. If it's not, we translate it there and correct the $C$ constant in the line equation. So we have a circle centered at $(0,0)$ of radius $r$ and a line with equation $Ax+By+C=0$.\n\nLet's start by find the point on the line which is closest to the origin $(x_0, y_0)$. First, it has to be at a distance\n\n$$ d_0 = \\frac{|C|}{\\sqrt{A^2+B^2}} $$\n\nSecond, since the vector $(A, B)$ is perpendicular to the line, the coordinates of the point must be proportional to the coordinates of this vector. Since we know the distance of the point to the origin, we just need to scale the vector $(A, B)$ to this length, and we'll get:\n\n$$\\begin{align}\nx_0 &= - \\frac{AC}{A^2 + B^2} \\\\\ny_0 &= - \\frac{BC}{A^2 + B^2} \n\\end{align}$$\n\nThe minus signs are not obvious, but they can be easily verified by substituting $x_0$ and $y_0$ in the equation of the line.\n\nAt this stage we can determine the number of intersection points, and even find the solution when there is one or zero points. Indeed, if the distance from $(x_0, y_0)$ to the origin $d_0$ is greater than the radius $r$, the answer is **zero points**. If $d_0=r$, the answer is **one point** $(x_0, y_0)$. If $d_0<r$, there are two points of intersection, and now we have to find their coordinates.\n\nSo, we know that the point $(x_0, y_0)$ is inside the circle. The two points of intersection, $(a_x, a_y)$ and $(b_x, b_y)$, must belong to the line $Ax+By+C=0$ and must be at the same distance $d$ from $(x_0, y_0)$, and this distance is easy to find:\n\n$$ d = \\sqrt{r^2 - \\frac{C^2}{A^2 + B^2}} $$\n\nNote that the vector $(-B, A)$ is collinear to the line, and thus we can find the points in question by adding and subtracting  vector $(-B,A)$, scaled to the length $d$, to the point $(x_0, y_0)$. \n\nFinally, the equations of the two points of intersection are:\n\n$$\\begin{align}\nm &= \\sqrt{\\frac{d^2}{A^2 + B^2}} \\\\\na_x &= x_0 + B \\cdot m, a_y = y_0 - A \\cdot m \\\\\nb_x &= x_0 - B \\cdot m, b_y = y_0 + A \\cdot m\n\\end{align}$$\n\nHad we solved the original system of equations using algebraic methods, we would likely get an answer in a different form with a larger error. The geometric method described here is more graphic and more accurate.\n\n## Implementation\n\nAs indicated at the outset, we assume that the circle is centered at the origin, and therefore the input to the program is the radius $r$ of the circle and the parameters $A$, $B$ and $C$ of the equation of the line.\n\n```cpp\ndouble r, a, b, c; // given as input\ndouble x0 = -a*c/(a*a+b*b), y0 = -b*c/(a*a+b*b);\nif (c*c > r*r*(a*a+b*b)+EPS)\n    puts (\"no points\");\nelse if (abs (c*c - r*r*(a*a+b*b)) < EPS) {\n    puts (\"1 point\");\n    cout << x0 << ' ' << y0 << '\\n';\n}\nelse {\n    double d = r*r - c*c/(a*a+b*b);\n    double mult = sqrt (d / (a*a+b*b));\n    double ax, ay, bx, by;\n    ax = x0 + b * mult;\n    bx = x0 - b * mult;\n    ay = y0 - a * mult;\n    by = y0 + a * mult;\n    puts (\"2 points\");\n    cout << ax << ' ' << ay << '\\n' << bx << ' ' << by << '\\n';\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: circle_line_intersection\n---\n\n# Circle-Line Intersection\n\nGiven the coordinates of the center of a circle and its radius, and the equation of a line, you're required to find the points of intersection.\n\n## Solution\n\nInstead of solving the system of two equations, we will approach the problem geometrically. This way we get a more accurate solution from the point of view of numerical stability.\n\nWe assume without loss of generality that the circle is centered at the origin. If it's not, we translate it there and correct the $C$ constant in the line equation. So we have a circle centered at $(0,0)$ of radius $r$ and a line with equation $Ax+By+C=0$.\n\nLet's start by find the point on the line which is closest to the origin $(x_0, y_0)$. First, it has to be at a distance\n\n$$ d_0 = \\frac{|C|}{\\sqrt{A^2+B^2}} $$\n\nSecond, since the vector $(A, B)$ is perpendicular to the line, the coordinates of the point must be proportional to the coordinates of this vector. Since we know the distance of the point to the origin, we just need to scale the vector $(A, B)$ to this length, and we'll get:\n\n$$\\begin{align}\nx_0 &= - \\frac{AC}{A^2 + B^2} \\\\\ny_0 &= - \\frac{BC}{A^2 + B^2} \n\\end{align}$$\n\nThe minus signs are not obvious, but they can be easily verified by substituting $x_0$ and $y_0$ in the equation of the line.\n\nAt this stage we can determine the number of intersection points, and even find the solution when there is one or zero points. Indeed, if the distance from $(x_0, y_0)$ to the origin $d_0$ is greater than the radius $r$, the answer is **zero points**. If $d_0=r$, the answer is **one point** $(x_0, y_0)$. If $d_0<r$, there are two points of intersection, and now we have to find their coordinates.\n\nSo, we know that the point $(x_0, y_0)$ is inside the circle. The two points of intersection, $(a_x, a_y)$ and $(b_x, b_y)$, must belong to the line $Ax+By+C=0$ and must be at the same distance $d$ from $(x_0, y_0)$, and this distance is easy to find:\n\n$$ d = \\sqrt{r^2 - \\frac{C^2}{A^2 + B^2}} $$\n\nNote that the vector $(-B, A)$ is collinear to the line, and thus we can find the points in question by adding and subtracting  vector $(-B,A)$, scaled to the length $d$, to the point $(x_0, y_0)$. \n\nFinally, the equations of the two points of intersection are:\n\n$$\\begin{align}\nm &= \\sqrt{\\frac{d^2}{A^2 + B^2}} \\\\\na_x &= x_0 + B \\cdot m, a_y = y_0 - A \\cdot m \\\\\nb_x &= x_0 - B \\cdot m, b_y = y_0 + A \\cdot m\n\\end{align}$$\n\nHad we solved the original system of equations using algebraic methods, we would likely get an answer in a different form with a larger error. The geometric method described here is more graphic and more accurate.\n\n## Implementation\n\nAs indicated at the outset, we assume that the circle is centered at the origin, and therefore the input to the program is the radius $r$ of the circle and the parameters $A$, $B$ and $C$ of the equation of the line.\n\n```cpp\ndouble r, a, b, c; // given as input\ndouble x0 = -a*c/(a*a+b*b), y0 = -b*c/(a*a+b*b);\nif (c*c > r*r*(a*a+b*b)+EPS)\n    puts (\"no points\");\nelse if (abs (c*c - r*r*(a*a+b*b)) < EPS) {\n    puts (\"1 point\");\n    cout << x0 << ' ' << y0 << '\\n';\n}\nelse {\n    double d = r*r - c*c/(a*a+b*b);\n    double mult = sqrt (d / (a*a+b*b));\n    double ax, ay, bx, by;\n    ax = x0 + b * mult;\n    bx = x0 - b * mult;\n    ay = y0 - a * mult;\n    by = y0 + a * mult;\n    puts (\"2 points\");\n    cout << ax << ' ' << ay << '\\n' << bx << ' ' << by << '\\n';\n}\n```\n\n## Practice Problems\n\n- [CODECHEF: ANDOOR](https://www.codechef.com/problems/ANDOOR)\n", "problem_ids": [], "title": "Circle-Line Intersection"}, {"article": "---\ntags:\n  - Original\n---\n\n# Lattice points inside non-lattice polygon\n\nFor lattice polygons there is Pick's formula to enumerate the lattice points inside the polygon.\nWhat about polygons with arbitrary vertices?\n\nLet's process each of the polygon's edges individually, and after that we may sum up the amounts of lattice points under each edge considering its orientations to choose a sign (like in calculating the area of a polygon using trapezoids).\n\nFirst of all we should note that if current edge has endpoints in $A=(x_1;y_1)$ and $B=(x_2;y_2)$ then it can be represented as a linear function:\n\n$$y=y_1+(y_2-y_1) \\cdot \\dfrac{x-x_1}{x_2-x_1}=\\left(\\dfrac{y_2-y_1}{x_2-x_1}\\right)\\cdot x + \\left(\\dfrac{y_1x_2-x_1y_2}{x_2-x_1}\\right)$$\n\n$$y = k \\cdot x + b,~k = \\dfrac{y_2-y_1}{x_2-x_1},~b = \\dfrac{y_1x_2-x_1y_2}{x_2-x_1}$$\n\nNow we will perform a substitution $x=x'+\\lceil x_1 \\rceil$ so that $b' = b + k \\cdot \\lceil x_1 \\rceil$.\nThis allows us to work with $x_1'=0$ and $x_2'=x_2 - \\lceil x_1 \\rceil$.\nLet's denote $n = \\lfloor x_2' \\rfloor$.\n\nWe will not sum up points at $x = n$ and on $y = 0$ for the integrity of the algorithm.\nThey may be added manually afterwards.\nThus we have to sum up $\\sum\\limits_{x'=0}^{n - 1} \\lfloor k' \\cdot x' + b'\\rfloor$. We also assume that $k' \\geq 0$ and $b'\\geq 0$.\nOtherwise one should substitute $x'=-t$ and add $\\lceil|b'|\\rceil$ to $b'$.\n\nLet's discuss how we can evaluate a sum $\\sum\\limits_{x=0}^{n - 1} \\lfloor k \\cdot x + b\\rfloor$.\nWe have two cases:\n\n  - $k \\geq 1$ or $b \\geq 1$.\n  \n    Then we should start with summing up points below $y=\\lfloor k \\rfloor \\cdot x + \\lfloor b \\rfloor$. Their amount equals to\n    \n    \\[ \\sum\\limits_{x=0}^{n - 1} \\lfloor k \\rfloor \\cdot x + \\lfloor b \\rfloor=\\dfrac{(\\lfloor k \\rfloor(n-1)+2\\lfloor b \\rfloor) n}{2}. \\]\n    \n    Now we are interested only in points $(x;y)$ such that $\\lfloor k \\rfloor \\cdot x + \\lfloor b \\rfloor < y \\leq k\\cdot x + b$.\n    This amount is the same as the number of points such that $0 < y \\leq (k - \\lfloor k \\rfloor) \\cdot x + (b - \\lfloor b \\rfloor)$.\n    So we reduced our problem to $k'= k - \\lfloor k \\rfloor$, $b' = b - \\lfloor b \\rfloor$ and both $k'$ and $b'$ less than $1$ now.\n    Here is a picture, we just summed up blue points and subtracted the blue linear function from the black one to reduce problem to smaller values for $k$ and $b$:\n    <center>![Subtracting floored linear function](lattice.png)</center>\n\n  - $k < 1$ and $b < 1$.\n\n    If $\\lfloor k \\cdot n + b\\rfloor$ equals $0$, we can safely return $0$.\n    If this is not the case, we can say that there are no lattice points such that $x < 0$ and $0 < y \\leq k \\cdot x + b$.\n    That means that we will have the same answer if we consider new reference system in which $O'=(n;\\lfloor k\\cdot n + b\\rfloor)$, axis $x'$ is directed down and axis $y'$ is directed to the left.\n    For this reference system we are interested in lattice points on the set\n    \n    \\[ \\left\\{(x;y)~\\bigg|~0 \\leq x < \\lfloor k \\cdot n + b\\rfloor,~ 0 < y \\leq \\dfrac{x+(k\\cdot n+b)-\\lfloor k\\cdot n + b \\rfloor}{k}\\right\\} \\]\n    \n    which returns us back to the case $k>1$.\n    You can see new reference point $O'$ and axes $X'$ and $Y'$ in the picture below:\n    <center>![New reference and axes](mirror.png)</center>\n    As you see, in new reference system linear function will have coefficient $\\tfrac 1 k$ and its zero will be in the point $\\lfloor k\\cdot n + b \\rfloor-(k\\cdot n+b)$ which makes formula above correct.\n\n## Complexity analysis\n\nWe have to count at most $\\dfrac{(k(n-1)+2b)n}{2}$ points.\nAmong them we will count $\\dfrac{\\lfloor k \\rfloor (n-1)+2\\lfloor b \\rfloor}{2}$ on the very first step.\nWe may consider that $b$ is negligibly small because we can start with making it less than $1$.\nIn that case we cay say that we count about $\\dfrac{\\lfloor k \\rfloor}{k} \\geq \\dfrac 1 2$  of all points.\nThus we will finish in $O(\\log n)$ steps.\n\n## Implementation\n\nHere is simple function which calculates number of integer points $(x;y)$ such for $0 \\leq x < n$ and $0 < y \\leq \\lfloor k x+b\\rfloor$:\n\n```cpp\nint count_lattices(Fraction k, Fraction b, long long n) {\n    auto fk = k.floor();\n    auto fb = b.floor();\n    auto cnt = 0LL;\n    if (k >= 1 || b >= 1) {\n        cnt += (fk * (n - 1) + 2 * fb) * n / 2;\n        k -= fk;\n        b -= fb;\n    }\n    auto t = k * n + b;\n    auto ft = t.floor();\n    if (ft >= 1) {\n        cnt += count_lattices(1 / k, (t - t.floor()) / k, t.floor());\n    }\n    return cnt;\n}\n```\n\nHere `Fraction` is some class handling rational numbers.\nOn practice it seems that if all denominators and numerators are at most $C$ by absolute value then in the recursive calls they will be at most $C^2$ if you keep dividing numerators and denominators by their greatest common divisor.\nGiven this assumption we can say that one may use doubles and require accuracy of $\\varepsilon^2$ where $\\varepsilon$ is accuracy with which $k$ and $b$ are given.\nThat means that in floor one should consider numbers as integer if they differs at most by $\\varepsilon^2$ from an integer.\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Lattice points inside non-lattice polygon\n\nFor lattice polygons there is Pick's formula to enumerate the lattice points inside the polygon.\nWhat about polygons with arbitrary vertices?\n\nLet's process each of the polygon's edges individually, and after that we may sum up the amounts of lattice points under each edge considering its orientations to choose a sign (like in calculating the area of a polygon using trapezoids).\n\nFirst of all we should note that if current edge has endpoints in $A=(x_1;y_1)$ and $B=(x_2;y_2)$ then it can be represented as a linear function:\n\n$$y=y_1+(y_2-y_1) \\cdot \\dfrac{x-x_1}{x_2-x_1}=\\left(\\dfrac{y_2-y_1}{x_2-x_1}\\right)\\cdot x + \\left(\\dfrac{y_1x_2-x_1y_2}{x_2-x_1}\\right)$$\n\n$$y = k \\cdot x + b,~k = \\dfrac{y_2-y_1}{x_2-x_1},~b = \\dfrac{y_1x_2-x_1y_2}{x_2-x_1}$$\n\nNow we will perform a substitution $x=x'+\\lceil x_1 \\rceil$ so that $b' = b + k \\cdot \\lceil x_1 \\rceil$.\nThis allows us to work with $x_1'=0$ and $x_2'=x_2 - \\lceil x_1 \\rceil$.\nLet's denote $n = \\lfloor x_2' \\rfloor$.\n\nWe will not sum up points at $x = n$ and on $y = 0$ for the integrity of the algorithm.\nThey may be added manually afterwards.\nThus we have to sum up $\\sum\\limits_{x'=0}^{n - 1} \\lfloor k' \\cdot x' + b'\\rfloor$. We also assume that $k' \\geq 0$ and $b'\\geq 0$.\nOtherwise one should substitute $x'=-t$ and add $\\lceil|b'|\\rceil$ to $b'$.\n\nLet's discuss how we can evaluate a sum $\\sum\\limits_{x=0}^{n - 1} \\lfloor k \\cdot x + b\\rfloor$.\nWe have two cases:\n\n  - $k \\geq 1$ or $b \\geq 1$.\n  \n    Then we should start with summing up points below $y=\\lfloor k \\rfloor \\cdot x + \\lfloor b \\rfloor$. Their amount equals to\n    \n    \\[ \\sum\\limits_{x=0}^{n - 1} \\lfloor k \\rfloor \\cdot x + \\lfloor b \\rfloor=\\dfrac{(\\lfloor k \\rfloor(n-1)+2\\lfloor b \\rfloor) n}{2}. \\]\n    \n    Now we are interested only in points $(x;y)$ such that $\\lfloor k \\rfloor \\cdot x + \\lfloor b \\rfloor < y \\leq k\\cdot x + b$.\n    This amount is the same as the number of points such that $0 < y \\leq (k - \\lfloor k \\rfloor) \\cdot x + (b - \\lfloor b \\rfloor)$.\n    So we reduced our problem to $k'= k - \\lfloor k \\rfloor$, $b' = b - \\lfloor b \\rfloor$ and both $k'$ and $b'$ less than $1$ now.\n    Here is a picture, we just summed up blue points and subtracted the blue linear function from the black one to reduce problem to smaller values for $k$ and $b$:\n    <center>![Subtracting floored linear function](lattice.png)</center>\n\n  - $k < 1$ and $b < 1$.\n\n    If $\\lfloor k \\cdot n + b\\rfloor$ equals $0$, we can safely return $0$.\n    If this is not the case, we can say that there are no lattice points such that $x < 0$ and $0 < y \\leq k \\cdot x + b$.\n    That means that we will have the same answer if we consider new reference system in which $O'=(n;\\lfloor k\\cdot n + b\\rfloor)$, axis $x'$ is directed down and axis $y'$ is directed to the left.\n    For this reference system we are interested in lattice points on the set\n    \n    \\[ \\left\\{(x;y)~\\bigg|~0 \\leq x < \\lfloor k \\cdot n + b\\rfloor,~ 0 < y \\leq \\dfrac{x+(k\\cdot n+b)-\\lfloor k\\cdot n + b \\rfloor}{k}\\right\\} \\]\n    \n    which returns us back to the case $k>1$.\n    You can see new reference point $O'$ and axes $X'$ and $Y'$ in the picture below:\n    <center>![New reference and axes](mirror.png)</center>\n    As you see, in new reference system linear function will have coefficient $\\tfrac 1 k$ and its zero will be in the point $\\lfloor k\\cdot n + b \\rfloor-(k\\cdot n+b)$ which makes formula above correct.\n\n## Complexity analysis\n\nWe have to count at most $\\dfrac{(k(n-1)+2b)n}{2}$ points.\nAmong them we will count $\\dfrac{\\lfloor k \\rfloor (n-1)+2\\lfloor b \\rfloor}{2}$ on the very first step.\nWe may consider that $b$ is negligibly small because we can start with making it less than $1$.\nIn that case we cay say that we count about $\\dfrac{\\lfloor k \\rfloor}{k} \\geq \\dfrac 1 2$  of all points.\nThus we will finish in $O(\\log n)$ steps.\n\n## Implementation\n\nHere is simple function which calculates number of integer points $(x;y)$ such for $0 \\leq x < n$ and $0 < y \\leq \\lfloor k x+b\\rfloor$:\n\n```cpp\nint count_lattices(Fraction k, Fraction b, long long n) {\n    auto fk = k.floor();\n    auto fb = b.floor();\n    auto cnt = 0LL;\n    if (k >= 1 || b >= 1) {\n        cnt += (fk * (n - 1) + 2 * fb) * n / 2;\n        k -= fk;\n        b -= fb;\n    }\n    auto t = k * n + b;\n    auto ft = t.floor();\n    if (ft >= 1) {\n        cnt += count_lattices(1 / k, (t - t.floor()) / k, t.floor());\n    }\n    return cnt;\n}\n```\n\nHere `Fraction` is some class handling rational numbers.\nOn practice it seems that if all denominators and numerators are at most $C$ by absolute value then in the recursive calls they will be at most $C^2$ if you keep dividing numerators and denominators by their greatest common divisor.\nGiven this assumption we can say that one may use doubles and require accuracy of $\\varepsilon^2$ where $\\varepsilon$ is accuracy with which $k$ and $b$ are given.\nThat means that in floor one should consider numbers as integer if they differs at most by $\\varepsilon^2$ from an integer.\n", "problem_ids": [], "title": "Lattice points inside non-lattice polygon"}, {"article": "---\ntags:\n  - Original\n---\n\n# Minkowski sum of convex polygons\n\n## Definition\nConsider two sets $A$ and $B$ of points on a plane. Minkowski sum $A + B$ is defined as $\\{a + b| a \\in A, b \\in B\\}$.\nHere we will consider the case when $A$ and $B$ consist of convex polygons $P$ and $Q$ with their interiors.\nThroughout this article we will identify polygons with ordered sequences of their vertices, so that notation like $|P|$ or\n$P_i$ makes sense.\nIt turns out that the sum of convex polygons $P$ and $Q$ is a convex polygon with at most $|P| + |Q|$ vertices.\n\n## Algorithm\n\nHere we consider the polygons to be cyclically enumerated, i. e. $P_{|P|} = P_0,\\ Q_{|Q|} = Q_0$ and so on.\n\nSince the size of the sum is linear in terms of the sizes of initial polygons, we should aim at finding a linear-time algorithm.\nSuppose that both polygons are ordered counter-clockwise. Consider sequences of edges $\\{\\overrightarrow{P_iP_{i+1}}\\}$\nand $\\{\\overrightarrow{Q_jQ_{j+1}}\\}$ ordered by polar angle. We claim that the sequence of edges of $P + Q$ can be obtained by merging\nthese two sequences preserving polar angle order and replacing consequitive co-directed vectors with their sum. Straightforward usage of this idea results\nin a linear-time algorithm, however, restoring the vertices of $P + Q$ from the sequence of sides requires repeated addition of vectors,\nwhich may introduce unwanted precision issues if we're working with floating-point coordinates, so we will describe a slight\nmodification of this idea.\n\n\nFirstly we should reorder the vertices in such a way that the first vertex\nof each polygon has the lowest y-coordinate (in case of several such vertices pick the one with the smallest x-coordinate). After that the sides of both polygons\nwill become sorted by polar angle, so there is no need to sort them manually.\nNow we create two pointers $i$ (pointing to a vertex of $P$) and $j$ (pointing to a vertex of $Q$), both initially set to 0.\nWe repeat the following steps while $i < |P|$ or $j < |Q|$.\n\n1. Append $P_i + Q_j$ to $P + Q$.\n\n2. Compare polar angles of $\\overrightarrow{P_iP_{i + 1}}$ and $\\overrightarrow{Q_jQ_{j+1}}$.\n\n3. Increment the pointer which corresponds to the smallest angle (if the angles are equal, increment both).\n\n## Visualization\n\nHere is a nice visualization, which may help you understand what is going on.\n\n<center>![Visual](minkowski.gif)</center>\n\n## Distance between two polygons\nOne of the most common applications of Minkowski sum is computing the distance between two convex polygons (or simply checking whether they intersect).\nThe distance between two convex polygons $P$ and $Q$ is defined as $\\min\\limits_{a \\in P, b \\in Q} ||a - b||$. One can note that\nthe distance is always attained between two vertices or a vertex and an edge, so we can easily find the distance in $O(|P||Q|)$. However,\nwith clever usage of Minkowski sum we can reduce the complexity to $O(|P| + |Q|)$.\n\nIf we reflect $Q$ through the point $(0, 0)$ obtaining polygon $-Q$, the problem boils down to finding the smallest distance between a point in\n$P + (-Q)$ and $(0, 0)$. We can find that distance in linear time using the following idea.\nIf $(0, 0)$ is inside or on the boundary of polygon, the distance is $0$, otherwise the distance is attained between $(0, 0)$ and some vertex or edge of the polygon.\nSince Minkowski sum can be computed\nin linear time, we obtain a linear-time algorithm for finding the distance between two convex polygons.\n\n## Implementation\nBelow is the implementation of Minkowski sum for polygons with integer points. Note that in this case all computations can be done in integers since\ninstead of computing polar angles and directly comparing them we can look at the sign of cross product of two vectors.\n\n```{.cpp file=minkowski}\nstruct pt{\n    long long x, y;\n    pt operator + (const pt & p) const {\n        return pt{x + p.x, y + p.y};\n    }\n    pt operator - (const pt & p) const {\n        return pt{x - p.x, y - p.y};\n    }\n    long long cross(const pt & p) const {\n        return x * p.y - y * p.x;\n    }\n};\n\nvoid reorder_polygon(vector<pt> & P){\n    size_t pos = 0;\n    for(size_t i = 1; i < P.size(); i++){\n        if(P[i].y < P[pos].y || (P[i].y == P[pos].y && P[i].x < P[pos].x))\n            pos = i;\n    }\n    rotate(P.begin(), P.begin() + pos, P.end());\n}\n\nvector<pt> minkowski(vector<pt> P, vector<pt> Q){\n    // the first vertex must be the lowest\n    reorder_polygon(P);\n    reorder_polygon(Q);\n    // we must ensure cyclic indexing\n    P.push_back(P[0]);\n    P.push_back(P[1]);\n    Q.push_back(Q[0]);\n    Q.push_back(Q[1]);\n    // main part\n    vector<pt> result;\n    size_t i = 0, j = 0;\n    while(i < P.size() - 2 || j < Q.size() - 2){\n        result.push_back(P[i] + Q[j]);\n        auto cross = (P[i + 1] - P[i]).cross(Q[j + 1] - Q[j]);\n        if(cross >= 0 && i < P.size() - 2)\n            ++i;\n        if(cross <= 0 && j < Q.size() - 2)\n            ++j;\n    }\n    return result;\n}\n\n```\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Minkowski sum of convex polygons\n\n## Definition\nConsider two sets $A$ and $B$ of points on a plane. Minkowski sum $A + B$ is defined as $\\{a + b| a \\in A, b \\in B\\}$.\nHere we will consider the case when $A$ and $B$ consist of convex polygons $P$ and $Q$ with their interiors.\nThroughout this article we will identify polygons with ordered sequences of their vertices, so that notation like $|P|$ or\n$P_i$ makes sense.\nIt turns out that the sum of convex polygons $P$ and $Q$ is a convex polygon with at most $|P| + |Q|$ vertices.\n\n## Algorithm\n\nHere we consider the polygons to be cyclically enumerated, i. e. $P_{|P|} = P_0,\\ Q_{|Q|} = Q_0$ and so on.\n\nSince the size of the sum is linear in terms of the sizes of initial polygons, we should aim at finding a linear-time algorithm.\nSuppose that both polygons are ordered counter-clockwise. Consider sequences of edges $\\{\\overrightarrow{P_iP_{i+1}}\\}$\nand $\\{\\overrightarrow{Q_jQ_{j+1}}\\}$ ordered by polar angle. We claim that the sequence of edges of $P + Q$ can be obtained by merging\nthese two sequences preserving polar angle order and replacing consequitive co-directed vectors with their sum. Straightforward usage of this idea results\nin a linear-time algorithm, however, restoring the vertices of $P + Q$ from the sequence of sides requires repeated addition of vectors,\nwhich may introduce unwanted precision issues if we're working with floating-point coordinates, so we will describe a slight\nmodification of this idea.\n\n\nFirstly we should reorder the vertices in such a way that the first vertex\nof each polygon has the lowest y-coordinate (in case of several such vertices pick the one with the smallest x-coordinate). After that the sides of both polygons\nwill become sorted by polar angle, so there is no need to sort them manually.\nNow we create two pointers $i$ (pointing to a vertex of $P$) and $j$ (pointing to a vertex of $Q$), both initially set to 0.\nWe repeat the following steps while $i < |P|$ or $j < |Q|$.\n\n1. Append $P_i + Q_j$ to $P + Q$.\n\n2. Compare polar angles of $\\overrightarrow{P_iP_{i + 1}}$ and $\\overrightarrow{Q_jQ_{j+1}}$.\n\n3. Increment the pointer which corresponds to the smallest angle (if the angles are equal, increment both).\n\n## Visualization\n\nHere is a nice visualization, which may help you understand what is going on.\n\n<center>![Visual](minkowski.gif)</center>\n\n## Distance between two polygons\nOne of the most common applications of Minkowski sum is computing the distance between two convex polygons (or simply checking whether they intersect).\nThe distance between two convex polygons $P$ and $Q$ is defined as $\\min\\limits_{a \\in P, b \\in Q} ||a - b||$. One can note that\nthe distance is always attained between two vertices or a vertex and an edge, so we can easily find the distance in $O(|P||Q|)$. However,\nwith clever usage of Minkowski sum we can reduce the complexity to $O(|P| + |Q|)$.\n\nIf we reflect $Q$ through the point $(0, 0)$ obtaining polygon $-Q$, the problem boils down to finding the smallest distance between a point in\n$P + (-Q)$ and $(0, 0)$. We can find that distance in linear time using the following idea.\nIf $(0, 0)$ is inside or on the boundary of polygon, the distance is $0$, otherwise the distance is attained between $(0, 0)$ and some vertex or edge of the polygon.\nSince Minkowski sum can be computed\nin linear time, we obtain a linear-time algorithm for finding the distance between two convex polygons.\n\n## Implementation\nBelow is the implementation of Minkowski sum for polygons with integer points. Note that in this case all computations can be done in integers since\ninstead of computing polar angles and directly comparing them we can look at the sign of cross product of two vectors.\n\n```{.cpp file=minkowski}\nstruct pt{\n    long long x, y;\n    pt operator + (const pt & p) const {\n        return pt{x + p.x, y + p.y};\n    }\n    pt operator - (const pt & p) const {\n        return pt{x - p.x, y - p.y};\n    }\n    long long cross(const pt & p) const {\n        return x * p.y - y * p.x;\n    }\n};\n\nvoid reorder_polygon(vector<pt> & P){\n    size_t pos = 0;\n    for(size_t i = 1; i < P.size(); i++){\n        if(P[i].y < P[pos].y || (P[i].y == P[pos].y && P[i].x < P[pos].x))\n            pos = i;\n    }\n    rotate(P.begin(), P.begin() + pos, P.end());\n}\n\nvector<pt> minkowski(vector<pt> P, vector<pt> Q){\n    // the first vertex must be the lowest\n    reorder_polygon(P);\n    reorder_polygon(Q);\n    // we must ensure cyclic indexing\n    P.push_back(P[0]);\n    P.push_back(P[1]);\n    Q.push_back(Q[0]);\n    Q.push_back(Q[1]);\n    // main part\n    vector<pt> result;\n    size_t i = 0, j = 0;\n    while(i < P.size() - 2 || j < Q.size() - 2){\n        result.push_back(P[i] + Q[j]);\n        auto cross = (P[i + 1] - P[i]).cross(Q[j + 1] - Q[j]);\n        if(cross >= 0 && i < P.size() - 2)\n            ++i;\n        if(cross <= 0 && j < Q.size() - 2)\n            ++j;\n    }\n    return result;\n}\n\n```\n\n## Problems\n * [Codeforces 87E Mogohu-Rea Idol](https://codeforces.com/problemset/problem/87/E)\n * [Codeforces 1195F Geometers Anonymous Club](https://codeforces.com/contest/1195/problem/F)\n * [TIMUS 1894 Non-Flying Weather](https://acm.timus.ru/problem.aspx?space=1&num=1894)\n", "problem_ids": [], "title": "Minkowski sum of convex polygons"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: length_of_segments_union\n---\n\n# Length of the union of segments\n\nGiven $n$ segments on a line, each described by a pair of coordinates $(a_{i1}, a_{i2})$.\nWe have to find the length of their union.\n\nThe following algorithm was proposed by Klee in 1977.\nIt works in $O(n\\log n)$ and has been proven to be the asymptotically optimal.\n\n## Solution\n\nWe store in an array $x$ the endpoints of all the segments sorted by their values.\nAnd additionally we store whether it is a left end or a right end of a segment.\nNow we iterate over the array, keeping a counter $c$ of currently opened segments.\nWhenever the current element is a left end, we increase this counter, and otherwise we decrease it.\nTo compute the answer, we take the length between the last to $x$ values $x_i - x_{i-1}$, whenever we come to a new coordinate, and there is currently at least one segment is open.\n\n## Implementation\n\n```cpp\nint length_union(const vector<pair<int, int>> &a) {\n    int n = a.size();\n    vector<pair<int, bool>> x(n*2);\n    for (int i = 0; i < n; i++) {\n        x[i*2] = {a[i].first, false};\n        x[i*2+1] = {a[i].second, true};\n    }\n\n    sort(x.begin(), x.end());\n\n    int result = 0;\n    int c = 0;\n    for (int i = 0; i < n * 2; i++) {\n        if (i > 0 && x[i].first > x[i-1].first && c > 0)\n            result += x[i].first - x[i-1].first;\n        if (x[i].second)\n            c--;\n        else\n            c++;\n    }\n    return result;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: length_of_segments_union\n---\n\n# Length of the union of segments\n\nGiven $n$ segments on a line, each described by a pair of coordinates $(a_{i1}, a_{i2})$.\nWe have to find the length of their union.\n\nThe following algorithm was proposed by Klee in 1977.\nIt works in $O(n\\log n)$ and has been proven to be the asymptotically optimal.\n\n## Solution\n\nWe store in an array $x$ the endpoints of all the segments sorted by their values.\nAnd additionally we store whether it is a left end or a right end of a segment.\nNow we iterate over the array, keeping a counter $c$ of currently opened segments.\nWhenever the current element is a left end, we increase this counter, and otherwise we decrease it.\nTo compute the answer, we take the length between the last to $x$ values $x_i - x_{i-1}$, whenever we come to a new coordinate, and there is currently at least one segment is open.\n\n## Implementation\n\n```cpp\nint length_union(const vector<pair<int, int>> &a) {\n    int n = a.size();\n    vector<pair<int, bool>> x(n*2);\n    for (int i = 0; i < n; i++) {\n        x[i*2] = {a[i].first, false};\n        x[i*2+1] = {a[i].second, true};\n    }\n\n    sort(x.begin(), x.end());\n\n    int result = 0;\n    int c = 0;\n    for (int i = 0; i < n * 2; i++) {\n        if (i > 0 && x[i].first > x[i-1].first && c > 0)\n            result += x[i].first - x[i-1].first;\n        if (x[i].second)\n            c--;\n        else\n            c++;\n    }\n    return result;\n}\n```\n", "problem_ids": [], "title": "Length of the union of segments"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: segment_to_line\n---\n\n# Finding the equation of a line for a segment\n\nThe task is: given the coordinates of the ends of a segment, construct a line passing through it.\n\nWe assume that the segment is non-degenerate, i.e. has a length greater than zero (otherwise, of course, infinitely many different lines pass through it).\n\n### Two-dimensional case\n\nLet the given segment be $PQ$ i.e. the known coordinates of its ends $P_x , P_y , Q_x , Q_y$ .\n\nIt is necessary to construct **the equation of a line in the plane** passing through this segment, i.e. find the coefficients $A , B , C$ in the equation of a line:\n\n$$A x + B y + C = 0.$$\n\nNote that for the required triples $(A, B, C)$ there are **infinitely many** solutions which describe the given segment:\nyou can multiply all three coefficients by an arbitrary non-zero number and get the same straight line.\nTherefore, our task is to find one of these triples.\n\nIt is easy to verify (by substitution of these expressions and the coordinates of the points $P$ and $Q$ into the equation of a straight line) that the following set of coefficients fits:\n\n$$\\begin{align}\nA &= P_y - Q_y, \\\\\nB &= Q_x - P_x, \\\\\nC &= - A P_x - B P_y.\n\\end{align}$$\n\n### Integer case\n\nAn important advantage of this method of constructing a straight line is that if the coordinates of the ends were integer, then the coefficients obtained will also be **integer** . In some cases, this allows one to perform geometric operations without resorting to real numbers at all.\n\nHowever, there is a small drawback: for the same straight line different triples of coefficients can be obtained.\nTo avoid this, but do not go away from the integer coefficients, you can apply the following technique, often called **rationing**. Find the [greatest common divisor](../algebra/euclid-algorithm.md) of numbers $| A | , | B | , | C |$ , we divide all three coefficients by it, and then we make the normalization of the sign: if $A <0$ or $A = 0, B <0$ then multiply all three coefficients by $-1$ .\nAs a result, we will come to the conclusion that for identical straight lines, identical triples of coefficients will be obtained, which makes it easy to check straight lines for equality.\n\n### Real case\n\nWhen working with real numbers, you should always be aware of errors.\n\nThe coefficients $A$ and $B$ will have the order of the original coordinates, the coefficient $C$ is of the order of the square of them. This may already be quite large numbers, and, for example, when we [intersect straight lines](lines-intersection.md), they will become even larger, which can lead to large rounding errors already when the coordinates of the end points are of order $10^3$.\n\nTherefore, when working with real numbers, it is desirable to produce the so-called **normalization**, this is straightforward: namely, to make the coefficients such that $A ^ 2 + B ^ 2 = 1$ . To do this, calculate the number $Z$ :\n\n$$Z = \\sqrt{A ^ 2 + B ^ 2},$$\n\nand divide all three coefficients $A , B , C$ by it.\n\nThus, the order of the coefficients $A$ and $B$ will not depend on the order of the input coordinates, and the coefficient $C$ will be of the same order as the input coordinates. In practice, this leads to a significant improvement in the accuracy of calculations.\n\nFinally, we mention the **comparison** of straight lines - in fact, after such a normalization, for the same straight line, only two triples of coefficients can be obtained: up to multiplication by $-1$.\nAccordingly, if we make an additional normalization taking into account the sign (if $A < -\\varepsilon$  or $| A | < \\varepsilon$, $B <- \\varepsilon$ then multiply by $-1$ ), the resulting coefficients will be unique.\n\n### Three-dimensional and multidimensional case\n\nAlready in the three-dimensional case there is **no simple equation** describing a straight line (it can be defined as the intersection of two planes, that is, a system of two equations, but this is an inconvenient method).\n\nConsequently, in the three-dimensional and multidimensional cases we must use the **parametric method of defining a straight line** , i.e. as a point $p$ and a vector $v$ :\n\n$$p + v t, ~~~ t \\in \\mathbb{R}.$$\n\nThose. a straight line is all points that can be obtained from a point $p$ adding a vector $v$ with an arbitrary coefficient.\n\nThe **construction** of a straight line in a parametric form along the coordinates of the ends of a segment is trivial, we just take one end of the segment for the point $p$, and the vector from the first to the second end \u2014 for the vector $v$.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: segment_to_line\n---\n\n# Finding the equation of a line for a segment\n\nThe task is: given the coordinates of the ends of a segment, construct a line passing through it.\n\nWe assume that the segment is non-degenerate, i.e. has a length greater than zero (otherwise, of course, infinitely many different lines pass through it).\n\n### Two-dimensional case\n\nLet the given segment be $PQ$ i.e. the known coordinates of its ends $P_x , P_y , Q_x , Q_y$ .\n\nIt is necessary to construct **the equation of a line in the plane** passing through this segment, i.e. find the coefficients $A , B , C$ in the equation of a line:\n\n$$A x + B y + C = 0.$$\n\nNote that for the required triples $(A, B, C)$ there are **infinitely many** solutions which describe the given segment:\nyou can multiply all three coefficients by an arbitrary non-zero number and get the same straight line.\nTherefore, our task is to find one of these triples.\n\nIt is easy to verify (by substitution of these expressions and the coordinates of the points $P$ and $Q$ into the equation of a straight line) that the following set of coefficients fits:\n\n$$\\begin{align}\nA &= P_y - Q_y, \\\\\nB &= Q_x - P_x, \\\\\nC &= - A P_x - B P_y.\n\\end{align}$$\n\n### Integer case\n\nAn important advantage of this method of constructing a straight line is that if the coordinates of the ends were integer, then the coefficients obtained will also be **integer** . In some cases, this allows one to perform geometric operations without resorting to real numbers at all.\n\nHowever, there is a small drawback: for the same straight line different triples of coefficients can be obtained.\nTo avoid this, but do not go away from the integer coefficients, you can apply the following technique, often called **rationing**. Find the [greatest common divisor](../algebra/euclid-algorithm.md) of numbers $| A | , | B | , | C |$ , we divide all three coefficients by it, and then we make the normalization of the sign: if $A <0$ or $A = 0, B <0$ then multiply all three coefficients by $-1$ .\nAs a result, we will come to the conclusion that for identical straight lines, identical triples of coefficients will be obtained, which makes it easy to check straight lines for equality.\n\n### Real case\n\nWhen working with real numbers, you should always be aware of errors.\n\nThe coefficients $A$ and $B$ will have the order of the original coordinates, the coefficient $C$ is of the order of the square of them. This may already be quite large numbers, and, for example, when we [intersect straight lines](lines-intersection.md), they will become even larger, which can lead to large rounding errors already when the coordinates of the end points are of order $10^3$.\n\nTherefore, when working with real numbers, it is desirable to produce the so-called **normalization**, this is straightforward: namely, to make the coefficients such that $A ^ 2 + B ^ 2 = 1$ . To do this, calculate the number $Z$ :\n\n$$Z = \\sqrt{A ^ 2 + B ^ 2},$$\n\nand divide all three coefficients $A , B , C$ by it.\n\nThus, the order of the coefficients $A$ and $B$ will not depend on the order of the input coordinates, and the coefficient $C$ will be of the same order as the input coordinates. In practice, this leads to a significant improvement in the accuracy of calculations.\n\nFinally, we mention the **comparison** of straight lines - in fact, after such a normalization, for the same straight line, only two triples of coefficients can be obtained: up to multiplication by $-1$.\nAccordingly, if we make an additional normalization taking into account the sign (if $A < -\\varepsilon$  or $| A | < \\varepsilon$, $B <- \\varepsilon$ then multiply by $-1$ ), the resulting coefficients will be unique.\n\n### Three-dimensional and multidimensional case\n\nAlready in the three-dimensional case there is **no simple equation** describing a straight line (it can be defined as the intersection of two planes, that is, a system of two equations, but this is an inconvenient method).\n\nConsequently, in the three-dimensional and multidimensional cases we must use the **parametric method of defining a straight line** , i.e. as a point $p$ and a vector $v$ :\n\n$$p + v t, ~~~ t \\in \\mathbb{R}.$$\n\nThose. a straight line is all points that can be obtained from a point $p$ adding a vector $v$ with an arbitrary coefficient.\n\nThe **construction** of a straight line in a parametric form along the coordinates of the ends of a segment is trivial, we just take one end of the segment for the point $p$, and the vector from the first to the second end \u2014 for the vector $v$.\n", "problem_ids": [], "title": "Finding the equation of a line for a segment"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: triangles_union\n---\n\n# Vertical decomposition\n\n## Overview\nVertical decomposition is a powerful technique used in various geometry problems. The general idea is to cut the plane into several vertical stripes\nwith some \"good\" properties and solve the problem for these stripes independently. We will illustrate the idea on some examples.\n\n## Area of the union of triangles\nSuppose that there are $n$ triangles on a plane and we are to find the area of their union. The problem would be easy if the triangles didn't intersect, so\nlet's get rid of these intersections by dividing the plane into vertical stripes by drawing vertical lines through all vertices and all points of intersection of\nsides of different triangles. There may be $O(n^2)$ such lines so we obtained $O(n^2)$ stripes. Now consider some vertical stripe. Each non-vertical segment either crosses it from left to right or doesn't cross at all.\nAlso, no two segments intersect strictly inside the stripe. It means that the part of the union of triangles that lies inside this stripe is composed of disjoint trapezoids with bases lying on the sides of the stripe.\nThis property allows us to compute the area inside each stripe with a following scanline algorithm. Each segment crossing the stripe is either upper or lower, depending on whether the interior of the corresponding triangle\nis above or below the segment. We can visualize each upper segment as an opening bracket and each lower segment as a closing bracket and decompose the stripe into trapezoids by decomposing the bracket sequence into smaller correct bracket sequences. This algorithm requires $O(n^3\\log n)$ time and $O(n^2)$ memory.\n### Optimization 1\nFirstly we will reduce the runtime to $O(n^2\\log n)$. Instead of generating trapezoids for each stripe let's fix some triangle side (segment $s = (s_0, s_1)$) and find the set of stripes where this segment is a side of some trapezoid. Note that in this case we only have to find the stripes where the balance of brackets below (or above, in case of a lower segment) $s$ is zero. It means that instead of running vertical scanline for each stripe we can run a horizontal scanline for all parts of other segments which affect the balance of brackets with respect to $s$.\nFor simplicity we will show how to do this for an upper segment, the algorithm for lower segments is similar. Consider some other non-vertical segment $t = (t_0, t_1)$ and find the intersection $[x_1, x_2]$ of projections of $s$ and $t$ on $Ox$. If this intersection is empty or consists of one point, $t$ can be discarded since $s$ and $t$ do not intersect the interior of the same stripe. Otherwise consider the intersection $I$ of $s$ and $t$. There are three cases.\n\n1.  $I = \\varnothing$\n\n    In this case $t$ is either above or below $s$ on $[x_1, x_2]$. If $t$ is above, it doesn't affect whether $s$ is a side of some trapezoid or not.\n    If $t$ is below $s$, we should add $1$ or $-1$ to the balance of bracket sequences for all stripes in $[x_1, x_2]$, depending on whether $t$ is upper or lower.\n\n2.  $I$ consists of a single point $p$\n\n    This case can be reduced to the previous one by splitting $[x_1, x_2]$ into $[x_1, p_x]$ and $[p_x, x_2]$.\n\n3.  $I$ is some segment $l$\n\n    This case means that the parts of $s$ and $t$ for $x\\in[x_1, x_2]$ coincide. If $t$ is lower, $s$ is clearly not a side of a trapezoid.\n    Otherwise, it could happen that both $s$ and $t$ can be considered as a side of some trapezoid. In order to resolve this ambiguity, we can\n    decide that only the segment with the lowest index should be considered as a side (here we suppose that triangle sides are enumerated in some way). So, if $index(s) < index(t)$, we should ignore this case,\n    otherwise we should mark that $s$ can never be a side on $[x_1, x_2]$ (for example, by adding a corresponding event with balance $-2$).\n\nHere is a graphic representation of the three cases.\n\n<center>![Visual](triangle_union.png)</center>\n\nFinally we should remark on processing all the additions of $1$ or $-1$ on all stripes in $[x_1, x_2]$. For each addition of $w$ on $[x_1, x_2]$ we can create events $(x_1, w),\\ (x_2, -w)$\nand process all these events with a sweep line.\n\n### Optimization 2\nNote that if we apply the previous optimization, we no longer have to find all stripes explicitly. This reduces the memory consumption to $O(n)$.\n\n## Intersection of convex polygons\nAnother usage of vertical decomposition is to compute the intersection of two convex polygons in linear time. Suppose the plane is split into vertical stripes by vertical lines passing through each\nvertex of each polygon. Then if we consider one of the input polygons and some stripe, their intersection is either a trapezoid, a triangle or a point. Therefore we can simply intersect these shapes for each vertical stripe and merge these intersections into a single polygon.\n\n## Implementation\n\nBelow is the code that calculates area of the union of a set of triangles in $O(n^2\\log n)$ time and $O(n)$ memory.\n\n```{.cpp file=triangle_union}\ntypedef double dbl;\n\nconst dbl eps = 1e-9;\n \ninline bool eq(dbl x, dbl y){\n    return fabs(x - y) < eps;\n}\n \ninline bool lt(dbl x, dbl y){\n    return x < y - eps;\n}\n \ninline bool gt(dbl x, dbl y){\n    return x > y + eps;\n}\n \ninline bool le(dbl x, dbl y){\n    return x < y + eps;\n}\n \ninline bool ge(dbl x, dbl y){\n    return x > y - eps;\n}\n \nstruct pt{\n    dbl x, y;\n    inline pt operator - (const pt & p)const{\n        return pt{x - p.x, y - p.y};\n    }\n    inline pt operator + (const pt & p)const{\n        return pt{x + p.x, y + p.y};\n    }\n    inline pt operator * (dbl a)const{\n        return pt{x * a, y * a};\n    }\n    inline dbl cross(const pt & p)const{\n        return x * p.y - y * p.x;\n    }\n    inline dbl dot(const pt & p)const{\n        return x * p.x + y * p.y;\n    }\n    inline bool operator == (const pt & p)const{\n        return eq(x, p.x) && eq(y, p.y);\n    }\n};\n \nstruct Line{\n    pt p[2];\n    Line(){}\n    Line(pt a, pt b):p{a, b}{}\n    pt vec()const{\n        return p[1] - p[0];\n    }\n    pt& operator [](size_t i){\n        return p[i];\n    }\n};\n \ninline bool lexComp(const pt & l, const pt & r){\n\tif(fabs(l.x - r.x) > eps){\n\t\treturn l.x < r.x;\n\t}\n\telse return l.y < r.y;\n}\n \nvector<pt> interSegSeg(Line l1, Line l2){\n    if(eq(l1.vec().cross(l2.vec()), 0)){\n        if(!eq(l1.vec().cross(l2[0] - l1[0]), 0))\n            return {};\n        if(!lexComp(l1[0], l1[1]))\n            swap(l1[0], l1[1]);\n        if(!lexComp(l2[0], l2[1]))\n            swap(l2[0], l2[1]);\n        pt l = lexComp(l1[0], l2[0]) ? l2[0] : l1[0];\n        pt r = lexComp(l1[1], l2[1]) ? l1[1] : l2[1];\n        if(l == r)\n            return {l};\n        else return lexComp(l, r) ? vector<pt>{l, r} : vector<pt>();\n    }\n    else{\n        dbl s = (l2[0] - l1[0]).cross(l2.vec()) / l1.vec().cross(l2.vec());\n        pt inter = l1[0] + l1.vec() * s;\n        if(ge(s, 0) && le(s, 1) && le((l2[0] - inter).dot(l2[1] - inter), 0))\n            return {inter};\n        else\n            return {};\n    }\n}\ninline char get_segtype(Line segment, pt other_point){\n    if(eq(segment[0].x, segment[1].x))\n        return 0;\n    if(!lexComp(segment[0], segment[1]))\n        swap(segment[0], segment[1]);\n    return (segment[1] - segment[0]).cross(other_point - segment[0]) > 0 ? 1 : -1;\n}\n \ndbl union_area(vector<tuple<pt, pt, pt> > triangles){\n    vector<Line> segments(3 * triangles.size());\n    vector<char> segtype(segments.size());\n    for(size_t i = 0; i < triangles.size(); i++){\n        pt a, b, c;\n        tie(a, b, c) = triangles[i];\n        segments[3 * i] = lexComp(a, b) ? Line(a, b) : Line(b, a);\n        segtype[3 * i] = get_segtype(segments[3 * i], c);\n        segments[3 * i + 1] = lexComp(b, c) ? Line(b, c) : Line(c, b);\n        segtype[3 * i + 1] = get_segtype(segments[3 * i + 1], a);\n        segments[3 * i + 2] = lexComp(c, a) ? Line(c, a) : Line(a, c);\n        segtype[3 * i + 2] = get_segtype(segments[3 * i + 2], b);\n    }\n    vector<dbl> k(segments.size()), b(segments.size());\n    for(size_t i = 0; i < segments.size(); i++){\n        if(segtype[i]){\n            k[i] = (segments[i][1].y - segments[i][0].y) / (segments[i][1].x - segments[i][0].x);\n            b[i] = segments[i][0].y - k[i] * segments[i][0].x;\n        }\n    }\n    dbl ans = 0;\n    for(size_t i = 0; i < segments.size(); i++){\n        if(!segtype[i])\n            continue;\n        dbl l = segments[i][0].x, r = segments[i][1].x;\n        vector<pair<dbl, int> > evts;\n        for(size_t j = 0; j < segments.size(); j++){\n            if(!segtype[j] || i == j)\n                continue;\n            dbl l1 = segments[j][0].x, r1 = segments[j][1].x;\n            if(ge(l1, r) || ge(l, r1))\n                continue;\n            dbl common_l = max(l, l1), common_r = min(r, r1);\n            auto pts = interSegSeg(segments[i], segments[j]);\n            if(pts.empty()){\n                dbl yl1 = k[j] * common_l + b[j];\n                dbl yl = k[i] * common_l + b[i];\n                if(lt(yl1, yl) == (segtype[i] == 1)){\n                    int evt_type = -segtype[i] * segtype[j];\n                    evts.emplace_back(common_l, evt_type);\n                    evts.emplace_back(common_r, -evt_type);\n                }\n            }\n            else if(pts.size() == 1u){\n                dbl yl = k[i] * common_l + b[i], yl1 = k[j] * common_l + b[j];\n                int evt_type = -segtype[i] * segtype[j];\n                if(lt(yl1, yl) == (segtype[i] == 1)){\n                    evts.emplace_back(common_l, evt_type);\n                    evts.emplace_back(pts[0].x, -evt_type);\n                }\n                yl = k[i] * common_r + b[i], yl1 = k[j] * common_r + b[j];\n                if(lt(yl1, yl) == (segtype[i] == 1)){\n                    evts.emplace_back(pts[0].x, evt_type);\n                    evts.emplace_back(common_r, -evt_type);\n                }\n            }\n            else{\n                if(segtype[j] != segtype[i] || j > i){\n                    evts.emplace_back(common_l, -2);\n                    evts.emplace_back(common_r, 2);\n                }\n            }\n        }\n        evts.emplace_back(l, 0);\n        sort(evts.begin(), evts.end());\n        size_t j = 0;\n        int balance = 0;\n        while(j < evts.size()){\n            size_t ptr = j;\n            while(ptr < evts.size() && eq(evts[j].first, evts[ptr].first)){\n                balance += evts[ptr].second;\n                ++ptr;\n            }\n            if(!balance && !eq(evts[j].first, r)){\n                dbl next_x = ptr == evts.size() ? r : evts[ptr].first;\n                ans -= segtype[i] * (k[i] * (next_x + evts[j].first) + 2 * b[i]) * (next_x - evts[j].first);\n            }\n            j = ptr;\n        }\n    }\n    return ans/2;\n}\n\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: triangles_union\n---\n\n# Vertical decomposition\n\n## Overview\nVertical decomposition is a powerful technique used in various geometry problems. The general idea is to cut the plane into several vertical stripes\nwith some \"good\" properties and solve the problem for these stripes independently. We will illustrate the idea on some examples.\n\n## Area of the union of triangles\nSuppose that there are $n$ triangles on a plane and we are to find the area of their union. The problem would be easy if the triangles didn't intersect, so\nlet's get rid of these intersections by dividing the plane into vertical stripes by drawing vertical lines through all vertices and all points of intersection of\nsides of different triangles. There may be $O(n^2)$ such lines so we obtained $O(n^2)$ stripes. Now consider some vertical stripe. Each non-vertical segment either crosses it from left to right or doesn't cross at all.\nAlso, no two segments intersect strictly inside the stripe. It means that the part of the union of triangles that lies inside this stripe is composed of disjoint trapezoids with bases lying on the sides of the stripe.\nThis property allows us to compute the area inside each stripe with a following scanline algorithm. Each segment crossing the stripe is either upper or lower, depending on whether the interior of the corresponding triangle\nis above or below the segment. We can visualize each upper segment as an opening bracket and each lower segment as a closing bracket and decompose the stripe into trapezoids by decomposing the bracket sequence into smaller correct bracket sequences. This algorithm requires $O(n^3\\log n)$ time and $O(n^2)$ memory.\n### Optimization 1\nFirstly we will reduce the runtime to $O(n^2\\log n)$. Instead of generating trapezoids for each stripe let's fix some triangle side (segment $s = (s_0, s_1)$) and find the set of stripes where this segment is a side of some trapezoid. Note that in this case we only have to find the stripes where the balance of brackets below (or above, in case of a lower segment) $s$ is zero. It means that instead of running vertical scanline for each stripe we can run a horizontal scanline for all parts of other segments which affect the balance of brackets with respect to $s$.\nFor simplicity we will show how to do this for an upper segment, the algorithm for lower segments is similar. Consider some other non-vertical segment $t = (t_0, t_1)$ and find the intersection $[x_1, x_2]$ of projections of $s$ and $t$ on $Ox$. If this intersection is empty or consists of one point, $t$ can be discarded since $s$ and $t$ do not intersect the interior of the same stripe. Otherwise consider the intersection $I$ of $s$ and $t$. There are three cases.\n\n1.  $I = \\varnothing$\n\n    In this case $t$ is either above or below $s$ on $[x_1, x_2]$. If $t$ is above, it doesn't affect whether $s$ is a side of some trapezoid or not.\n    If $t$ is below $s$, we should add $1$ or $-1$ to the balance of bracket sequences for all stripes in $[x_1, x_2]$, depending on whether $t$ is upper or lower.\n\n2.  $I$ consists of a single point $p$\n\n    This case can be reduced to the previous one by splitting $[x_1, x_2]$ into $[x_1, p_x]$ and $[p_x, x_2]$.\n\n3.  $I$ is some segment $l$\n\n    This case means that the parts of $s$ and $t$ for $x\\in[x_1, x_2]$ coincide. If $t$ is lower, $s$ is clearly not a side of a trapezoid.\n    Otherwise, it could happen that both $s$ and $t$ can be considered as a side of some trapezoid. In order to resolve this ambiguity, we can\n    decide that only the segment with the lowest index should be considered as a side (here we suppose that triangle sides are enumerated in some way). So, if $index(s) < index(t)$, we should ignore this case,\n    otherwise we should mark that $s$ can never be a side on $[x_1, x_2]$ (for example, by adding a corresponding event with balance $-2$).\n\nHere is a graphic representation of the three cases.\n\n<center>![Visual](triangle_union.png)</center>\n\nFinally we should remark on processing all the additions of $1$ or $-1$ on all stripes in $[x_1, x_2]$. For each addition of $w$ on $[x_1, x_2]$ we can create events $(x_1, w),\\ (x_2, -w)$\nand process all these events with a sweep line.\n\n### Optimization 2\nNote that if we apply the previous optimization, we no longer have to find all stripes explicitly. This reduces the memory consumption to $O(n)$.\n\n## Intersection of convex polygons\nAnother usage of vertical decomposition is to compute the intersection of two convex polygons in linear time. Suppose the plane is split into vertical stripes by vertical lines passing through each\nvertex of each polygon. Then if we consider one of the input polygons and some stripe, their intersection is either a trapezoid, a triangle or a point. Therefore we can simply intersect these shapes for each vertical stripe and merge these intersections into a single polygon.\n\n## Implementation\n\nBelow is the code that calculates area of the union of a set of triangles in $O(n^2\\log n)$ time and $O(n)$ memory.\n\n```{.cpp file=triangle_union}\ntypedef double dbl;\n\nconst dbl eps = 1e-9;\n \ninline bool eq(dbl x, dbl y){\n    return fabs(x - y) < eps;\n}\n \ninline bool lt(dbl x, dbl y){\n    return x < y - eps;\n}\n \ninline bool gt(dbl x, dbl y){\n    return x > y + eps;\n}\n \ninline bool le(dbl x, dbl y){\n    return x < y + eps;\n}\n \ninline bool ge(dbl x, dbl y){\n    return x > y - eps;\n}\n \nstruct pt{\n    dbl x, y;\n    inline pt operator - (const pt & p)const{\n        return pt{x - p.x, y - p.y};\n    }\n    inline pt operator + (const pt & p)const{\n        return pt{x + p.x, y + p.y};\n    }\n    inline pt operator * (dbl a)const{\n        return pt{x * a, y * a};\n    }\n    inline dbl cross(const pt & p)const{\n        return x * p.y - y * p.x;\n    }\n    inline dbl dot(const pt & p)const{\n        return x * p.x + y * p.y;\n    }\n    inline bool operator == (const pt & p)const{\n        return eq(x, p.x) && eq(y, p.y);\n    }\n};\n \nstruct Line{\n    pt p[2];\n    Line(){}\n    Line(pt a, pt b):p{a, b}{}\n    pt vec()const{\n        return p[1] - p[0];\n    }\n    pt& operator [](size_t i){\n        return p[i];\n    }\n};\n \ninline bool lexComp(const pt & l, const pt & r){\n\tif(fabs(l.x - r.x) > eps){\n\t\treturn l.x < r.x;\n\t}\n\telse return l.y < r.y;\n}\n \nvector<pt> interSegSeg(Line l1, Line l2){\n    if(eq(l1.vec().cross(l2.vec()), 0)){\n        if(!eq(l1.vec().cross(l2[0] - l1[0]), 0))\n            return {};\n        if(!lexComp(l1[0], l1[1]))\n            swap(l1[0], l1[1]);\n        if(!lexComp(l2[0], l2[1]))\n            swap(l2[0], l2[1]);\n        pt l = lexComp(l1[0], l2[0]) ? l2[0] : l1[0];\n        pt r = lexComp(l1[1], l2[1]) ? l1[1] : l2[1];\n        if(l == r)\n            return {l};\n        else return lexComp(l, r) ? vector<pt>{l, r} : vector<pt>();\n    }\n    else{\n        dbl s = (l2[0] - l1[0]).cross(l2.vec()) / l1.vec().cross(l2.vec());\n        pt inter = l1[0] + l1.vec() * s;\n        if(ge(s, 0) && le(s, 1) && le((l2[0] - inter).dot(l2[1] - inter), 0))\n            return {inter};\n        else\n            return {};\n    }\n}\ninline char get_segtype(Line segment, pt other_point){\n    if(eq(segment[0].x, segment[1].x))\n        return 0;\n    if(!lexComp(segment[0], segment[1]))\n        swap(segment[0], segment[1]);\n    return (segment[1] - segment[0]).cross(other_point - segment[0]) > 0 ? 1 : -1;\n}\n \ndbl union_area(vector<tuple<pt, pt, pt> > triangles){\n    vector<Line> segments(3 * triangles.size());\n    vector<char> segtype(segments.size());\n    for(size_t i = 0; i < triangles.size(); i++){\n        pt a, b, c;\n        tie(a, b, c) = triangles[i];\n        segments[3 * i] = lexComp(a, b) ? Line(a, b) : Line(b, a);\n        segtype[3 * i] = get_segtype(segments[3 * i], c);\n        segments[3 * i + 1] = lexComp(b, c) ? Line(b, c) : Line(c, b);\n        segtype[3 * i + 1] = get_segtype(segments[3 * i + 1], a);\n        segments[3 * i + 2] = lexComp(c, a) ? Line(c, a) : Line(a, c);\n        segtype[3 * i + 2] = get_segtype(segments[3 * i + 2], b);\n    }\n    vector<dbl> k(segments.size()), b(segments.size());\n    for(size_t i = 0; i < segments.size(); i++){\n        if(segtype[i]){\n            k[i] = (segments[i][1].y - segments[i][0].y) / (segments[i][1].x - segments[i][0].x);\n            b[i] = segments[i][0].y - k[i] * segments[i][0].x;\n        }\n    }\n    dbl ans = 0;\n    for(size_t i = 0; i < segments.size(); i++){\n        if(!segtype[i])\n            continue;\n        dbl l = segments[i][0].x, r = segments[i][1].x;\n        vector<pair<dbl, int> > evts;\n        for(size_t j = 0; j < segments.size(); j++){\n            if(!segtype[j] || i == j)\n                continue;\n            dbl l1 = segments[j][0].x, r1 = segments[j][1].x;\n            if(ge(l1, r) || ge(l, r1))\n                continue;\n            dbl common_l = max(l, l1), common_r = min(r, r1);\n            auto pts = interSegSeg(segments[i], segments[j]);\n            if(pts.empty()){\n                dbl yl1 = k[j] * common_l + b[j];\n                dbl yl = k[i] * common_l + b[i];\n                if(lt(yl1, yl) == (segtype[i] == 1)){\n                    int evt_type = -segtype[i] * segtype[j];\n                    evts.emplace_back(common_l, evt_type);\n                    evts.emplace_back(common_r, -evt_type);\n                }\n            }\n            else if(pts.size() == 1u){\n                dbl yl = k[i] * common_l + b[i], yl1 = k[j] * common_l + b[j];\n                int evt_type = -segtype[i] * segtype[j];\n                if(lt(yl1, yl) == (segtype[i] == 1)){\n                    evts.emplace_back(common_l, evt_type);\n                    evts.emplace_back(pts[0].x, -evt_type);\n                }\n                yl = k[i] * common_r + b[i], yl1 = k[j] * common_r + b[j];\n                if(lt(yl1, yl) == (segtype[i] == 1)){\n                    evts.emplace_back(pts[0].x, evt_type);\n                    evts.emplace_back(common_r, -evt_type);\n                }\n            }\n            else{\n                if(segtype[j] != segtype[i] || j > i){\n                    evts.emplace_back(common_l, -2);\n                    evts.emplace_back(common_r, 2);\n                }\n            }\n        }\n        evts.emplace_back(l, 0);\n        sort(evts.begin(), evts.end());\n        size_t j = 0;\n        int balance = 0;\n        while(j < evts.size()){\n            size_t ptr = j;\n            while(ptr < evts.size() && eq(evts[j].first, evts[ptr].first)){\n                balance += evts[ptr].second;\n                ++ptr;\n            }\n            if(!balance && !eq(evts[j].first, r)){\n                dbl next_x = ptr == evts.size() ? r : evts[ptr].first;\n                ans -= segtype[i] * (k[i] * (next_x + evts[j].first) + 2 * b[i]) * (next_x - evts[j].first);\n            }\n            j = ptr;\n        }\n    }\n    return ans/2;\n}\n\n```\n\n## Problems\n * [Codeforces 62C Inquisition](https://codeforces.com/contest/62/problem/C)\n * [Codeforces 107E Darts](https://codeforces.com/contest/107/problem/E)\n", "problem_ids": [], "title": "Vertical decomposition"}, {"article": "---\ntags:\n  - Original\n---\n\n# Knuth's Optimization\n\nKnuth's optimization, also known as the Knuth-Yao Speedup, is a special case of dynamic programming on ranges, that can optimize the time complexity of solutions by a linear factor, from $O(n^3)$ for standard range DP to $O(n^2)$.\n\n## Conditions\n\nThe Speedup is applied for transitions of the form\n\n$$dp(i, j) = \\min_{i \\leq k < j} [ dp(i, k) + dp(k+1, j) + C(i, j) ].$$\n\nSimilar to [divide and conquer DP](./divide-and-conquer-dp.md), let $opt(i, j)$ be the value of $k$ that minimizes the expression in the transition ($opt$ is referred to as the \"optimal splitting point\" further in this article). The optimization requires that the following holds:\n\n$$opt(i, j-1) \\leq opt(i, j) \\leq opt(i+1, j).$$\n\nWe can show that it is true when the cost function $C$ satisfies the following conditions for $a \\leq b \\leq c \\leq d$:\n\n1. $C(b, c) \\leq C(a, d)$;\n\n2. $C(a, c) + C(b, d) \\leq C(a, d) + C(b, c)$ (the quadrangle inequality [QI]).\n\nThis result is proved further below.\n\n## Algorithm\n\nLet's process the dp states in such a way that we calculate $dp(i, j-1)$ and $dp(i+1, j)$ before $dp(i, j)$, and in doing so we also calculate $opt(i, j-1)$ and $opt(i+1, j)$. Then for calculating $opt(i, j)$, instead of testing values of $k$ from $i$ to $j-1$, we only need to test from $opt(i, j-1)$ to $opt(i+1, j)$. To process $(i,j)$ pairs in this order it is sufficient to use nested for loops in which $i$ goes from the maximum value to the minimum one and $j$ goes from $i+1$ to the maximum value.\n\n### Generic implementation\n\nThough implementation varies, here's a fairly generic\nexample. The structure of the code is almost identical to that of Range DP.\n\n```{.cpp file=knuth_optimization}\n\nint solve() {\n    int N;\n    ... // read N and input\n    int dp[N][N], opt[N][N];\n\n    auto C = [&](int i, int j) {\n        ... // Implement cost function C.\n    };\n\n    for (int i = 0; i < N; i++) {\n        opt[i][i] = i;\n        ... // Initialize dp[i][i] according to the problem\n    }\n\n    for (int i = N-2; i >= 0; i--) {\n        for (int j = i+1; j < N; j++) {\n            int mn = INT_MAX;\n            int cost = C(i, j);\n            for (int k = opt[i][j-1]; k <= min(j-1, opt[i+1][j]); k++) {\n                if (mn >= dp[i][k] + dp[k+1][j] + cost) {\n                    opt[i][j] = k; \n                    mn = dp[i][k] + dp[k+1][j] + cost; \n                }\n            }\n            dp[i][j] = mn; \n        }\n    }\n\n    cout << dp[0][N-1] << endl;\n}\n```\n\n### Complexity\n\nA complexity of the algorithm can be estimated as the following sum:\n\n$$\n\\sum\\limits_{i=1}^N \\sum\\limits_{j=i+1}^N [opt(i+1,j)-opt(i,j-1)] =\n\\sum\\limits_{i=1}^N \\sum\\limits_{j=i}^{N-1} [opt(i+1,j+1)-opt(i,j)].\n$$\n\nAs you see, most of the terms in this expression cancel each other out, except for positive terms with $j=N$ and negative terms with $i=1$. Thus, the whole sum can be estimated as\n\n$$\n\\sum\\limits_{k=1}^N[opt(k,N)-opt(1,k)] = O(n^2),\n$$\n\nrather than $O(n^3)$ as it would be if we were using a regular range DP.\n\n### On practice\n\nThe most common application of Knuth's optimization is in Range DP, with the given transition. The only difficulty is in proving that the cost function satisfies the given conditions. The simplest case is when the cost function $C(i, j)$ is simply the sum of the elements of the subarray $S[i, i+1, ..., j]$ for some array (depending on the question). However, they can be more complicated at times. \n\nNote that more than the conditions on the dp transition and the cost function, the key to this optimization is the inequality on the optimum splitting point. In some problems, such as the optimal binary search tree problem (which is, incidentally, the original problem for which this optimization was developed), the transitions and cost functions will be less obvious, however, one can still prove that $opt(i, j-1) \\leq opt(i, j) \\leq opt(i+1, j)$, and thus, use this optimization.\n\n\n### Proof of correctness\n\nTo prove the correctness of this algorithm in terms of $C(i,j)$ conditions, it suffices to prove that\n\n$$\nopt(i, j-1) \\leq opt(i, j) \\leq opt(i+1, j)\n$$\n\nassuming the given conditions are satisfied. \n\n!!! lemma \"Lemma\"\n    $dp(i, j)$ also satisfies the quadrangle inequality, given the conditions of the problem are satisfied.\n\n??? hint \"Proof\"\n    The proof for this lemma uses strong induction. It has been taken from the paper <a href=\"https://dl.acm.org/doi/pdf/10.1145/800141.804691\">Efficient Dynamic Programming Using Quadrangle Inequalities</a>, authored by F. Frances Yao, which introduced the Knuth-Yao Speedup (this particular statement is Lemma 2.1 in the paper). The idea is to induct on the length $l = d - a$. The case where $l = 1$ is trivial. For $l > 1$ consider 2 cases:  \n\n    1. $b = c$  \n    The inequality reduces to $dp(a, b) + dp(b, d) \\leq dp(a, d)$ (This assumes that $dp(i, i) = 0$ for all $i$, which is the case for all problems using this optimization). Let $opt(a,d) = z$. \n\n        - If $z < j$,  \n        Note that\n        \n            $$\n            dp(a, b) \\leq dp_{z}(a, b) = dp(a, z) + dp(z+1, b) + C(a, b).\n            $$\n            \n            Therefore,  \n            \n            $$\n            dp(a, b) + dp(b, d) \\leq dp(a, z) + dp(z+1, b) + dp(b, d) + C(a, b)\n            $$\n\n            From the induction hypothesis, $dp(z+1, b) + dp(b, d) \\leq dp(z+1, d)$. Also, it is given that $C(a, b) \\leq C(a, d)$. Combining these 2 facts with above inequality yields the desired result.\n\n        - If $z \\geq j$, the proof of this case is symmetric to the previous case.\n\n    2. $b < c$  \n    Let $opt(b, c) = z$ and $opt(a, d) = y$. \n        \n        - If $z \\leq y$,  \n        \n            $$\n            dp(a, c) + dp(b, d) \\leq dp_{z}(a, c) + dp_{y}(b, d)\n            $$\n\n            where\n\n            $$\n            dp_{z}(a, c) + dp_{y}(b, d) = C(a, c) + C(b, d) + dp(a, z) + dp(z+1, c) + dp(b, y) + dp(y+1, d).\n            $$\n\n            Using the QI on $C$ and on the dp state for the indices $z+1 \\leq y+1 \\leq c \\leq d$ (from the induction hypothesis) yields the desired result.\n        \n        - If $z > y$, the proof of this case is symmetric to the previous case.\n\n    This completes the proof of the lemma.\n\nNow, consider the following setup. We have 2 indices $i \\leq p \\leq q < j$. Set $dp_{k} = C(i, j) + dp(i, k) + dp(k+1, j)$.\n\nSuppose we show that\n\n$$\ndp_{p}(i, j-1) \\geq dp_{q}(i, j-1) \\implies dp_{p}(i, j) \\geq dp_{q}(i, j).\n$$\n\nSetting $q = opt(i, j-1)$, by definition, $dp_{p}(i, j-1) \\geq dp_{q}(i, j-1)$. Therefore, applying the inequality to all $i \\leq p \\leq q$, we can infer that $opt(i, j)$ is at least as much as $opt(i, j-1)$, proving the first half of the inequality.\n\nNow, using the QI on some indices $p+1 \\leq q+1 \\leq j-1 \\leq j$, we get\n\n$$\\begin{align}\n&dp(p+1, j-1) + dp(q+1, j) \u2264 dp(q+1, j-1) + dp(p+1, j) \\\\\n\\implies& (dp(i, p) + dp(p+1, j-1) + C(i, j-1)) + (dp(i, q) + dp(q+1, j) + C(i, j)) \\\\  \n\\leq& (dp(i, q) + dp(q+1, j-1) + C(i, j-1)) + (dp(i, p) + dp(p+1, j) + C(i, j)) \\\\  \n\\implies& dp_{p}(i, j-1) + dp_{q}(i, j) \u2264 dp_{p}(i, j) + dp_{q}(i, j-1) \\\\\n\\implies& dp_{p}(i, j-1) - dp_{q}(i, j-1) \u2264 dp_{p}(i, j) - dp_{q}(i, j) \\\\\n\\end{align}$$\n\nFinally,\n\n$$\\begin{align}\n&dp_{p}(i, j-1) \\geq dp_{q}(i, j-1) \\\\\n&\\implies 0 \\leq dp_{p}(i, j-1) - dp_{q}(i, j-1) \\leq dp_{p}(i, j) - dp_{q}(i, j) \\\\\n&\\implies dp_{p}(i, j) \\geq dp_{q}(i, j)\n\\end{align}$$  \n\nThis proves the first part of the inequality, i.e., $opt(i, j-1) \\leq opt(i, j)$. The second part $opt(i, j) \\leq opt(i+1, j)$ can be shown with the same idea, starting with the inequality \n$dp(i, p) + dp(i+1, q) \u2264 dp(i+1, p) + dp(i, q)$.\n\nThis completes the proof.\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Knuth's Optimization\n\nKnuth's optimization, also known as the Knuth-Yao Speedup, is a special case of dynamic programming on ranges, that can optimize the time complexity of solutions by a linear factor, from $O(n^3)$ for standard range DP to $O(n^2)$.\n\n## Conditions\n\nThe Speedup is applied for transitions of the form\n\n$$dp(i, j) = \\min_{i \\leq k < j} [ dp(i, k) + dp(k+1, j) + C(i, j) ].$$\n\nSimilar to [divide and conquer DP](./divide-and-conquer-dp.md), let $opt(i, j)$ be the value of $k$ that minimizes the expression in the transition ($opt$ is referred to as the \"optimal splitting point\" further in this article). The optimization requires that the following holds:\n\n$$opt(i, j-1) \\leq opt(i, j) \\leq opt(i+1, j).$$\n\nWe can show that it is true when the cost function $C$ satisfies the following conditions for $a \\leq b \\leq c \\leq d$:\n\n1. $C(b, c) \\leq C(a, d)$;\n\n2. $C(a, c) + C(b, d) \\leq C(a, d) + C(b, c)$ (the quadrangle inequality [QI]).\n\nThis result is proved further below.\n\n## Algorithm\n\nLet's process the dp states in such a way that we calculate $dp(i, j-1)$ and $dp(i+1, j)$ before $dp(i, j)$, and in doing so we also calculate $opt(i, j-1)$ and $opt(i+1, j)$. Then for calculating $opt(i, j)$, instead of testing values of $k$ from $i$ to $j-1$, we only need to test from $opt(i, j-1)$ to $opt(i+1, j)$. To process $(i,j)$ pairs in this order it is sufficient to use nested for loops in which $i$ goes from the maximum value to the minimum one and $j$ goes from $i+1$ to the maximum value.\n\n### Generic implementation\n\nThough implementation varies, here's a fairly generic\nexample. The structure of the code is almost identical to that of Range DP.\n\n```{.cpp file=knuth_optimization}\n\nint solve() {\n    int N;\n    ... // read N and input\n    int dp[N][N], opt[N][N];\n\n    auto C = [&](int i, int j) {\n        ... // Implement cost function C.\n    };\n\n    for (int i = 0; i < N; i++) {\n        opt[i][i] = i;\n        ... // Initialize dp[i][i] according to the problem\n    }\n\n    for (int i = N-2; i >= 0; i--) {\n        for (int j = i+1; j < N; j++) {\n            int mn = INT_MAX;\n            int cost = C(i, j);\n            for (int k = opt[i][j-1]; k <= min(j-1, opt[i+1][j]); k++) {\n                if (mn >= dp[i][k] + dp[k+1][j] + cost) {\n                    opt[i][j] = k; \n                    mn = dp[i][k] + dp[k+1][j] + cost; \n                }\n            }\n            dp[i][j] = mn; \n        }\n    }\n\n    cout << dp[0][N-1] << endl;\n}\n```\n\n### Complexity\n\nA complexity of the algorithm can be estimated as the following sum:\n\n$$\n\\sum\\limits_{i=1}^N \\sum\\limits_{j=i+1}^N [opt(i+1,j)-opt(i,j-1)] =\n\\sum\\limits_{i=1}^N \\sum\\limits_{j=i}^{N-1} [opt(i+1,j+1)-opt(i,j)].\n$$\n\nAs you see, most of the terms in this expression cancel each other out, except for positive terms with $j=N$ and negative terms with $i=1$. Thus, the whole sum can be estimated as\n\n$$\n\\sum\\limits_{k=1}^N[opt(k,N)-opt(1,k)] = O(n^2),\n$$\n\nrather than $O(n^3)$ as it would be if we were using a regular range DP.\n\n### On practice\n\nThe most common application of Knuth's optimization is in Range DP, with the given transition. The only difficulty is in proving that the cost function satisfies the given conditions. The simplest case is when the cost function $C(i, j)$ is simply the sum of the elements of the subarray $S[i, i+1, ..., j]$ for some array (depending on the question). However, they can be more complicated at times. \n\nNote that more than the conditions on the dp transition and the cost function, the key to this optimization is the inequality on the optimum splitting point. In some problems, such as the optimal binary search tree problem (which is, incidentally, the original problem for which this optimization was developed), the transitions and cost functions will be less obvious, however, one can still prove that $opt(i, j-1) \\leq opt(i, j) \\leq opt(i+1, j)$, and thus, use this optimization.\n\n\n### Proof of correctness\n\nTo prove the correctness of this algorithm in terms of $C(i,j)$ conditions, it suffices to prove that\n\n$$\nopt(i, j-1) \\leq opt(i, j) \\leq opt(i+1, j)\n$$\n\nassuming the given conditions are satisfied. \n\n!!! lemma \"Lemma\"\n    $dp(i, j)$ also satisfies the quadrangle inequality, given the conditions of the problem are satisfied.\n\n??? hint \"Proof\"\n    The proof for this lemma uses strong induction. It has been taken from the paper <a href=\"https://dl.acm.org/doi/pdf/10.1145/800141.804691\">Efficient Dynamic Programming Using Quadrangle Inequalities</a>, authored by F. Frances Yao, which introduced the Knuth-Yao Speedup (this particular statement is Lemma 2.1 in the paper). The idea is to induct on the length $l = d - a$. The case where $l = 1$ is trivial. For $l > 1$ consider 2 cases:  \n\n    1. $b = c$  \n    The inequality reduces to $dp(a, b) + dp(b, d) \\leq dp(a, d)$ (This assumes that $dp(i, i) = 0$ for all $i$, which is the case for all problems using this optimization). Let $opt(a,d) = z$. \n\n        - If $z < j$,  \n        Note that\n        \n            $$\n            dp(a, b) \\leq dp_{z}(a, b) = dp(a, z) + dp(z+1, b) + C(a, b).\n            $$\n            \n            Therefore,  \n            \n            $$\n            dp(a, b) + dp(b, d) \\leq dp(a, z) + dp(z+1, b) + dp(b, d) + C(a, b)\n            $$\n\n            From the induction hypothesis, $dp(z+1, b) + dp(b, d) \\leq dp(z+1, d)$. Also, it is given that $C(a, b) \\leq C(a, d)$. Combining these 2 facts with above inequality yields the desired result.\n\n        - If $z \\geq j$, the proof of this case is symmetric to the previous case.\n\n    2. $b < c$  \n    Let $opt(b, c) = z$ and $opt(a, d) = y$. \n        \n        - If $z \\leq y$,  \n        \n            $$\n            dp(a, c) + dp(b, d) \\leq dp_{z}(a, c) + dp_{y}(b, d)\n            $$\n\n            where\n\n            $$\n            dp_{z}(a, c) + dp_{y}(b, d) = C(a, c) + C(b, d) + dp(a, z) + dp(z+1, c) + dp(b, y) + dp(y+1, d).\n            $$\n\n            Using the QI on $C$ and on the dp state for the indices $z+1 \\leq y+1 \\leq c \\leq d$ (from the induction hypothesis) yields the desired result.\n        \n        - If $z > y$, the proof of this case is symmetric to the previous case.\n\n    This completes the proof of the lemma.\n\nNow, consider the following setup. We have 2 indices $i \\leq p \\leq q < j$. Set $dp_{k} = C(i, j) + dp(i, k) + dp(k+1, j)$.\n\nSuppose we show that\n\n$$\ndp_{p}(i, j-1) \\geq dp_{q}(i, j-1) \\implies dp_{p}(i, j) \\geq dp_{q}(i, j).\n$$\n\nSetting $q = opt(i, j-1)$, by definition, $dp_{p}(i, j-1) \\geq dp_{q}(i, j-1)$. Therefore, applying the inequality to all $i \\leq p \\leq q$, we can infer that $opt(i, j)$ is at least as much as $opt(i, j-1)$, proving the first half of the inequality.\n\nNow, using the QI on some indices $p+1 \\leq q+1 \\leq j-1 \\leq j$, we get\n\n$$\\begin{align}\n&dp(p+1, j-1) + dp(q+1, j) \u2264 dp(q+1, j-1) + dp(p+1, j) \\\\\n\\implies& (dp(i, p) + dp(p+1, j-1) + C(i, j-1)) + (dp(i, q) + dp(q+1, j) + C(i, j)) \\\\  \n\\leq& (dp(i, q) + dp(q+1, j-1) + C(i, j-1)) + (dp(i, p) + dp(p+1, j) + C(i, j)) \\\\  \n\\implies& dp_{p}(i, j-1) + dp_{q}(i, j) \u2264 dp_{p}(i, j) + dp_{q}(i, j-1) \\\\\n\\implies& dp_{p}(i, j-1) - dp_{q}(i, j-1) \u2264 dp_{p}(i, j) - dp_{q}(i, j) \\\\\n\\end{align}$$\n\nFinally,\n\n$$\\begin{align}\n&dp_{p}(i, j-1) \\geq dp_{q}(i, j-1) \\\\\n&\\implies 0 \\leq dp_{p}(i, j-1) - dp_{q}(i, j-1) \\leq dp_{p}(i, j) - dp_{q}(i, j) \\\\\n&\\implies dp_{p}(i, j) \\geq dp_{q}(i, j)\n\\end{align}$$  \n\nThis proves the first part of the inequality, i.e., $opt(i, j-1) \\leq opt(i, j)$. The second part $opt(i, j) \\leq opt(i+1, j)$ can be shown with the same idea, starting with the inequality \n$dp(i, p) + dp(i+1, q) \u2264 dp(i+1, p) + dp(i, q)$.\n\nThis completes the proof.\n\n## Practice Problems\n- [UVA - Cutting Sticks](https://onlinejudge.org/external/100/10003.pdf)\n- [UVA - Prefix Codes](https://onlinejudge.org/external/120/12057.pdf)\n- [SPOJ - Breaking String](https://www.spoj.com/problems/BRKSTRNG/)\n- [UVA - Optimal Binary Search Tree](https://onlinejudge.org/external/103/10304.pdf)\n\n\n## References\n- [Geeksforgeeks Article](https://www.geeksforgeeks.org/knuths-optimization-in-dynamic-programming/)\n- [Doc on DP Speedups](https://home.cse.ust.hk/~golin/COMP572/Notes/DP_speedup.pdf)\n- [Efficient Dynamic Programming Using Quadrangle Inequalities](https://dl.acm.org/doi/pdf/10.1145/800141.804691)\n", "problem_ids": [], "title": "Knuth's Optimization"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: maximum_zero_submatrix\n---\n\n# Finding the largest zero submatrix\n\nYou are given a matrix with `n` rows and `m` columns. Find the largest submatrix consisting of only zeros (a submatrix is a rectangular area of the matrix).\n\n## Algorithm\n\nElements of the matrix will be `a[i][j]`, where `i = 0...n - 1`, `j = 0... m - 1`. For simplicity, we will consider all non-zero elements equal to 1.\n\n### Step 1: Auxiliary dynamic\n\nFirst, we calculate the following auxiliary matrix: `d[i][j]`, nearest row that has a 1 above `a[i][j]`. Formally speaking, `d[i][j]` is the largest row number (from `0` to `i - 1`), in which there is a element equal to `1` in the `j`-th column. \nWhile iterating from top-left to bottom-right, when we stand in row `i`, we know the values from the previous row, so, it is enough to update just the elements with value `1`. We can save the values in a simple array `d[i]`, `i = 1...m - 1`, because in the further algorithm we will process the matrix one row at a time and only need the values of the current row.\n\n```cpp\nvector<int> d(m, -1);\nfor (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n        if (a[i][j] == 1) {\n            d[j] = i;\n        }\n    }\n}\n```\n\n### Step 2: Problem solving\n\nWe can solve the problem in $O(n m^2)$ iterating through rows, considering every possible left and right columns for a submatrix. The bottom of the rectangle will be the current row, and using `d[i][j]` we can find the top row. However, it is possible to go further and significantly improve the complexity of the solution.\n\nIt is clear that the desired zero submatrix is bounded on all four sides by some ones, which prevent it from increasing in size and improving the answer. Therefore,  we will not miss the answer if we act as follows: for every cell `j` in row `i` (the bottom row of a potential zero submatrix) we will have `d[i][j]` as the top row of the current zero submatrix. It now remains to determine the optimal left and right boundaries of the zero submatrix, i.e. maximally push this submatrix to the left and right of the `j`-th column. \n\nWhat does it mean to push the maximum to the left? It means to find an index `k1` for which `d[i][k1] > d[i][j]`, and at the same time `k1` - the closest one to the left of the index `j`. It is clear that then `k1 + 1` gives the number of the left column of the required zero submatrix. If there is no such index at all, then put `k1` = `-1`(this means that we were able to extend the current zero submatrix to the left all the way to the border of matrix `a`).\n\nSymmetrically, you can define an index `k2` for the right border: this is the closest index to the right of `j` such that `d[i][k2] > d[i][j]` (or `m`, if there is no such index).\n\nSo, the indices `k1` and `k2`, if we learn to search for them effectively, will give us all the necessary information about the current zero submatrix. In particular, its area will be equal to `(i - d[i][j]) * (k2 - k1 - 1)`.\n\nHow to look for these indexes `k1` and `k2` effectively with fixed `i` and `j`? We can do that in $O(1)$ on average.\n\nTo achieve such complexity, you can use the stack as follows. Let's first learn how to search for an index `k1`, and save its value for each index `j` within the current row `i` in matrix `d1[i][j]`. To do this, we will look through all the columns `j` from left to right, and we will store in the stack only those columns that have `d[][]` strictly greater than `d[i][j]`. It is clear that when moving from a column `j` to the next column, it is necessary to update the content of the stack. When there is an inappropriate element at the top of the stack (i.e. `d[][] <= d[i][j]`) pop it. It is easy to understand that it is enough to remove from the stack only from its top, and from none of its other places (because the stack will contain an increasing `d` sequence of columns).\n\nThe value `d1[i][j]` for each `j` will be equal to the value lying at that moment on top of the stack.\n\nThe dynamics `d2[i][j]` for finding the indices `k2` is considered similar, only you need to view the columns from right to left.\n\nIt is clear that since there are exactly `m` pieces added to the stack on each line, there could not be more deletions either, the sum of complexities will be linear, so the final complexity of the algorithm is $O(nm)$.\n\nIt should also be noted that this algorithm consumes $O(m)$ memory (not counting the input data - the matrix `a[][]`).\n\n### Implementation\n\n```cpp\nint zero_matrix(vector<vector<int>> a) {\n    int n = a.size();\n    int m = a[0].size();\n\n    int ans = 0;\n    vector<int> d(m, -1), d1(m), d2(m);\n    stack<int> st;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (a[i][j] == 1)\n                d[j] = i;\n        }\n\n        for (int j = 0; j < m; ++j) {\n            while (!st.empty() && d[st.top()] <= d[j])\n                st.pop();\n            d1[j] = st.empty() ? -1 : st.top();\n            st.push(j);\n        }\n        while (!st.empty())\n            st.pop();\n\n        for (int j = m - 1; j >= 0; --j) {\n            while (!st.empty() && d[st.top()] <= d[j])\n                st.pop();\n            d2[j] = st.empty() ? m : st.top();\n            st.push(j);\n        }\n        while (!st.empty())\n            st.pop();\n\n        for (int j = 0; j < m; ++j)\n            ans = max(ans, (i - d[j]) * (d2[j] - d1[j] - 1));\n    }\n    return ans;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: maximum_zero_submatrix\n---\n\n# Finding the largest zero submatrix\n\nYou are given a matrix with `n` rows and `m` columns. Find the largest submatrix consisting of only zeros (a submatrix is a rectangular area of the matrix).\n\n## Algorithm\n\nElements of the matrix will be `a[i][j]`, where `i = 0...n - 1`, `j = 0... m - 1`. For simplicity, we will consider all non-zero elements equal to 1.\n\n### Step 1: Auxiliary dynamic\n\nFirst, we calculate the following auxiliary matrix: `d[i][j]`, nearest row that has a 1 above `a[i][j]`. Formally speaking, `d[i][j]` is the largest row number (from `0` to `i - 1`), in which there is a element equal to `1` in the `j`-th column. \nWhile iterating from top-left to bottom-right, when we stand in row `i`, we know the values from the previous row, so, it is enough to update just the elements with value `1`. We can save the values in a simple array `d[i]`, `i = 1...m - 1`, because in the further algorithm we will process the matrix one row at a time and only need the values of the current row.\n\n```cpp\nvector<int> d(m, -1);\nfor (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n        if (a[i][j] == 1) {\n            d[j] = i;\n        }\n    }\n}\n```\n\n### Step 2: Problem solving\n\nWe can solve the problem in $O(n m^2)$ iterating through rows, considering every possible left and right columns for a submatrix. The bottom of the rectangle will be the current row, and using `d[i][j]` we can find the top row. However, it is possible to go further and significantly improve the complexity of the solution.\n\nIt is clear that the desired zero submatrix is bounded on all four sides by some ones, which prevent it from increasing in size and improving the answer. Therefore,  we will not miss the answer if we act as follows: for every cell `j` in row `i` (the bottom row of a potential zero submatrix) we will have `d[i][j]` as the top row of the current zero submatrix. It now remains to determine the optimal left and right boundaries of the zero submatrix, i.e. maximally push this submatrix to the left and right of the `j`-th column. \n\nWhat does it mean to push the maximum to the left? It means to find an index `k1` for which `d[i][k1] > d[i][j]`, and at the same time `k1` - the closest one to the left of the index `j`. It is clear that then `k1 + 1` gives the number of the left column of the required zero submatrix. If there is no such index at all, then put `k1` = `-1`(this means that we were able to extend the current zero submatrix to the left all the way to the border of matrix `a`).\n\nSymmetrically, you can define an index `k2` for the right border: this is the closest index to the right of `j` such that `d[i][k2] > d[i][j]` (or `m`, if there is no such index).\n\nSo, the indices `k1` and `k2`, if we learn to search for them effectively, will give us all the necessary information about the current zero submatrix. In particular, its area will be equal to `(i - d[i][j]) * (k2 - k1 - 1)`.\n\nHow to look for these indexes `k1` and `k2` effectively with fixed `i` and `j`? We can do that in $O(1)$ on average.\n\nTo achieve such complexity, you can use the stack as follows. Let's first learn how to search for an index `k1`, and save its value for each index `j` within the current row `i` in matrix `d1[i][j]`. To do this, we will look through all the columns `j` from left to right, and we will store in the stack only those columns that have `d[][]` strictly greater than `d[i][j]`. It is clear that when moving from a column `j` to the next column, it is necessary to update the content of the stack. When there is an inappropriate element at the top of the stack (i.e. `d[][] <= d[i][j]`) pop it. It is easy to understand that it is enough to remove from the stack only from its top, and from none of its other places (because the stack will contain an increasing `d` sequence of columns).\n\nThe value `d1[i][j]` for each `j` will be equal to the value lying at that moment on top of the stack.\n\nThe dynamics `d2[i][j]` for finding the indices `k2` is considered similar, only you need to view the columns from right to left.\n\nIt is clear that since there are exactly `m` pieces added to the stack on each line, there could not be more deletions either, the sum of complexities will be linear, so the final complexity of the algorithm is $O(nm)$.\n\nIt should also be noted that this algorithm consumes $O(m)$ memory (not counting the input data - the matrix `a[][]`).\n\n### Implementation\n\n```cpp\nint zero_matrix(vector<vector<int>> a) {\n    int n = a.size();\n    int m = a[0].size();\n\n    int ans = 0;\n    vector<int> d(m, -1), d1(m), d2(m);\n    stack<int> st;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (a[i][j] == 1)\n                d[j] = i;\n        }\n\n        for (int j = 0; j < m; ++j) {\n            while (!st.empty() && d[st.top()] <= d[j])\n                st.pop();\n            d1[j] = st.empty() ? -1 : st.top();\n            st.push(j);\n        }\n        while (!st.empty())\n            st.pop();\n\n        for (int j = m - 1; j >= 0; --j) {\n            while (!st.empty() && d[st.top()] <= d[j])\n                st.pop();\n            d2[j] = st.empty() ? m : st.top();\n            st.push(j);\n        }\n        while (!st.empty())\n            st.pop();\n\n        for (int j = 0; j < m; ++j)\n            ans = max(ans, (i - d[j]) * (d2[j] - d1[j] - 1));\n    }\n    return ans;\n}\n```\n", "problem_ids": [], "title": "Finding the largest zero submatrix"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: profile_dynamics\n---\n\n# Dynamic Programming on Broken Profile. Problem \"Parquet\"\n\nCommon problems solved using DP on broken profile include:\n\n- finding number of ways to fully fill an area (e.g. chessboard/grid) with some figures (e.g. dominoes)\n- finding a way to fill an area with minimum number of figures\n- finding a partial fill with minimum number of unfilled space (or cells, in case of grid)\n- finding a partial fill with the minimum number of figures, such that no more figures can be added\n\n## Problem \"Parquet\"\n\n**Problem description.** Given a grid of size $N \\times M$. Find number of ways to fill the grid with figures of size $2 \\times 1$ (no cell should be left unfilled, and figures should not overlap each other).\n\nLet the DP state be: $dp[i, mask]$, where $i = 1, \\ldots N$ and $mask = 0, \\ldots 2^M - 1$.\n\n$i$ represents number of rows in the current grid, and $mask$ is the state of last row of current grid. If $j$-th bit of $mask$ is $0$ then the corresponding cell is filled, otherwise it is unfilled.\n\nClearly, the answer to the problem will be $dp[N, 0]$.\n\nWe will be building the DP state by iterating over each $i = 1, \\cdots N$ and each $mask = 0, \\ldots 2^M - 1$, and for each $mask$ we will be only transitioning forward, that is, we will be _adding_ figures to the current grid.\n\n### Implementation\n\n```cpp\nint n, m;\nvector < vector<long long> > dp;\n\n\nvoid calc (int x = 0, int y = 0, int mask = 0, int next_mask = 0)\n{\n\tif (x == n)\n\t\treturn;\n\tif (y >= m)\n\t\tdp[x+1][next_mask] += dp[x][mask];\n\telse\n\t{\n\t\tint my_mask = 1 << y;\n\t\tif (mask & my_mask)\n\t\t\tcalc (x, y+1, mask, next_mask);\n\t\telse\n\t\t{\n\t\t\tcalc (x, y+1, mask, next_mask | my_mask);\n\t\t\tif (y+1 < m && ! (mask & my_mask) && ! (mask & (my_mask << 1)))\n\t\t\t\tcalc (x, y+2, mask, next_mask);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tcin >> n >> m;\n\n\tdp.resize (n+1, vector<long long> (1<<m));\n\tdp[0][0] = 1;\n\tfor (int x=0; x<n; ++x)\n\t\tfor (int mask=0; mask<(1<<m); ++mask)\n\t\t\tcalc (x, 0, mask, 0);\n\n\tcout << dp[n][0];\n\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: profile_dynamics\n---\n\n# Dynamic Programming on Broken Profile. Problem \"Parquet\"\n\nCommon problems solved using DP on broken profile include:\n\n- finding number of ways to fully fill an area (e.g. chessboard/grid) with some figures (e.g. dominoes)\n- finding a way to fill an area with minimum number of figures\n- finding a partial fill with minimum number of unfilled space (or cells, in case of grid)\n- finding a partial fill with the minimum number of figures, such that no more figures can be added\n\n## Problem \"Parquet\"\n\n**Problem description.** Given a grid of size $N \\times M$. Find number of ways to fill the grid with figures of size $2 \\times 1$ (no cell should be left unfilled, and figures should not overlap each other).\n\nLet the DP state be: $dp[i, mask]$, where $i = 1, \\ldots N$ and $mask = 0, \\ldots 2^M - 1$.\n\n$i$ represents number of rows in the current grid, and $mask$ is the state of last row of current grid. If $j$-th bit of $mask$ is $0$ then the corresponding cell is filled, otherwise it is unfilled.\n\nClearly, the answer to the problem will be $dp[N, 0]$.\n\nWe will be building the DP state by iterating over each $i = 1, \\cdots N$ and each $mask = 0, \\ldots 2^M - 1$, and for each $mask$ we will be only transitioning forward, that is, we will be _adding_ figures to the current grid.\n\n### Implementation\n\n```cpp\nint n, m;\nvector < vector<long long> > dp;\n\n\nvoid calc (int x = 0, int y = 0, int mask = 0, int next_mask = 0)\n{\n\tif (x == n)\n\t\treturn;\n\tif (y >= m)\n\t\tdp[x+1][next_mask] += dp[x][mask];\n\telse\n\t{\n\t\tint my_mask = 1 << y;\n\t\tif (mask & my_mask)\n\t\t\tcalc (x, y+1, mask, next_mask);\n\t\telse\n\t\t{\n\t\t\tcalc (x, y+1, mask, next_mask | my_mask);\n\t\t\tif (y+1 < m && ! (mask & my_mask) && ! (mask & (my_mask << 1)))\n\t\t\t\tcalc (x, y+2, mask, next_mask);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tcin >> n >> m;\n\n\tdp.resize (n+1, vector<long long> (1<<m));\n\tdp[0][0] = 1;\n\tfor (int x=0; x<n; ++x)\n\t\tfor (int mask=0; mask<(1<<m); ++mask)\n\t\t\tcalc (x, 0, mask, 0);\n\n\tcout << dp[n][0];\n\n}\n```\n\n## Practice Problems\n\n- [UVA 10359 - Tiling](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1300)\n- [UVA 10918 - Tri Tiling](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1859)\n- [SPOJ GNY07H (Four Tiling)](https://www.spoj.com/problems/GNY07H/)\n- [SPOJ M5TILE (Five Tiling)](https://www.spoj.com/problems/M5TILE/)\n- [SPOJ MNTILE (MxN Tiling)](https://www.spoj.com/problems/MNTILE/)\n- [SPOJ DOJ1](https://www.spoj.com/problems/DOJ1/)\n- [SPOJ DOJ2](https://www.spoj.com/problems/DOJ2/)\n- [SPOJ BTCODE_J](https://www.spoj.com/problems/BTCODE_J/)\n- [SPOJ PBOARD](https://www.spoj.com/problems/PBOARD/)\n- [ACM HDU 4285 - Circuits](http://acm.hdu.edu.cn/showproblem.php?pid=4285)\n- [LiveArchive 4608 - Mosaic](https://icpcarchive.ecs.baylor.edu/index.php?option=onlinejudge&page=show_problem&problem=2609)\n- [Timus 1519 - Formula 1](https://acm.timus.ru/problem.aspx?space=1&num=1519)\n- [Codeforces Parquet](https://codeforces.com/problemset/problem/26/C)\n\n## References\n\n- [Blog by EvilBunny](https://web.archive.org/web/20180712171735/https://blog.evilbuggy.com/2018/05/broken-profile-dynamic-programming.html)\n- [TopCoder Recipe by \"syg96\"](https://apps.topcoder.com/forums/?module=Thread&start=0&threadID=697369)\n- [Blogpost by sk765](http://sk765.blogspot.com/2012/02/dynamic-programming-with-profile.html)\n", "problem_ids": [], "title": "Dynamic Programming on Broken Profile. Problem \"Parquet\""}, {"article": "---\ntags:\n  - Original\n---\n\n# Divide and Conquer DP\n\nDivide and Conquer is a dynamic programming optimization.\n\n### Preconditions\nSome dynamic programming problems have a recurrence of this form: \n\n$$\ndp(i, j) = \\min_{0 \\leq k \\leq j} \\\\{ dp(i - 1, k - 1) + C(k, j) \\\\}\n$$\n\nwhere $C(k, j)$ is a cost function and $dp(i, j) = 0$ when $j \\lt 0$. \n\nSay $0 \\leq i \\lt m$ and $0 \\leq j \\lt n$, and evaluating $C$ takes $O(1)$\ntime. Then the straightforward evaluation of the above recurrence is $O(m n^2)$. There\nare $m \\times n$ states, and $n$ transitions for each state.\n\nLet $opt(i, j)$ be the value of $k$ that minimizes the above expression. Assuming that the \ncost function satisfies the quadrangle inequality, we can show that \n$opt(i, j) \\leq opt(i, j + 1)$ for all $i, j$. This is known as the _monotonicity condition_. \nThen, we can apply divide and conquer DP. The optimal\n\"splitting point\" for a fixed $i$ increases as $j$ increases.\n\nThis lets us solve for all states more efficiently. Say we compute $opt(i, j)$\nfor some fixed $i$ and $j$. Then for any $j' < j$ we know that $opt(i, j') \\leq opt(i, j)$.\nThis means when computing $opt(i, j')$, we don't have to consider as many\nsplitting points!\n\nTo minimize the runtime, we apply the idea behind divide and conquer. First,\ncompute $opt(i, n / 2)$. Then, compute $opt(i, n / 4)$, knowing that it is less\nthan or equal to $opt(i, n / 2)$ and $opt(i, 3 n / 4)$ knowing that it is\ngreater than or equal to $opt(i, n / 2)$. By recursively keeping track of the\nlower and upper bounds on $opt$, we reach a $O(m n \\log n)$ runtime. Each\npossible value of $opt(i, j)$ only appears in $\\log n$ different nodes.\n\nNote that it doesn't matter how \"balanced\" $opt(i, j)$ is. Across a fixed\nlevel, each value of $k$ is used at most twice, and there are at most $\\log n$\nlevels.\n\n## Generic implementation\n\nEven though implementation varies based on problem, here's a fairly generic\ntemplate.\nThe function `compute` computes one row $i$ of states `dp_cur`, given the previous row $i-1$ of states `dp_before`.\nIt has to be called with `compute(0, n-1, 0, n-1)`. The function `solve` computes `m` rows and returns the result.\n\n```{.cpp file=divide_and_conquer_dp}\nint m, n;\nvector<long long> dp_before(n), dp_cur(n);\n\nlong long C(int i, int j);\n\n// compute dp_cur[l], ... dp_cur[r] (inclusive)\nvoid compute(int l, int r, int optl, int optr) {\n    if (l > r)\n        return;\n\n    int mid = (l + r) >> 1;\n    pair<long long, int> best = {LLONG_MAX, -1};\n\n    for (int k = optl; k <= min(mid, optr); k++) {\n        best = min(best, {(k ? dp_before[k - 1] : 0) + C(k, mid), k});\n    }\n\n    dp_cur[mid] = best.first;\n    int opt = best.second;\n\n    compute(l, mid - 1, optl, opt);\n    compute(mid + 1, r, opt, optr);\n}\n\nint solve() {\n    for (int i = 0; i < n; i++)\n        dp_before[i] = C(0, i);\n\n    for (int i = 1; i < m; i++) {\n        compute(0, n - 1, 0, n - 1);\n        dp_before = dp_cur;\n    }\n\n    return dp_before[n - 1];\n}\n```\n\n### Things to look out for\n\nThe greatest difficulty with Divide and Conquer DP problems is proving the\nmonotonicity of $opt$. One special case where this is true is when the cost function satisfies the quadrangle inequality, i.e., $C(a, c) + C(b, d) \\leq C(a, d) + C(b, c)$ for all $a \\leq b \\leq c \\leq d$. \nMany Divide and Conquer DP problems can also be solved with the Convex Hull trick or vice-versa. It is useful to know and understand\nboth! \n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Divide and Conquer DP\n\nDivide and Conquer is a dynamic programming optimization.\n\n### Preconditions\nSome dynamic programming problems have a recurrence of this form: \n\n$$\ndp(i, j) = \\min_{0 \\leq k \\leq j} \\\\{ dp(i - 1, k - 1) + C(k, j) \\\\}\n$$\n\nwhere $C(k, j)$ is a cost function and $dp(i, j) = 0$ when $j \\lt 0$. \n\nSay $0 \\leq i \\lt m$ and $0 \\leq j \\lt n$, and evaluating $C$ takes $O(1)$\ntime. Then the straightforward evaluation of the above recurrence is $O(m n^2)$. There\nare $m \\times n$ states, and $n$ transitions for each state.\n\nLet $opt(i, j)$ be the value of $k$ that minimizes the above expression. Assuming that the \ncost function satisfies the quadrangle inequality, we can show that \n$opt(i, j) \\leq opt(i, j + 1)$ for all $i, j$. This is known as the _monotonicity condition_. \nThen, we can apply divide and conquer DP. The optimal\n\"splitting point\" for a fixed $i$ increases as $j$ increases.\n\nThis lets us solve for all states more efficiently. Say we compute $opt(i, j)$\nfor some fixed $i$ and $j$. Then for any $j' < j$ we know that $opt(i, j') \\leq opt(i, j)$.\nThis means when computing $opt(i, j')$, we don't have to consider as many\nsplitting points!\n\nTo minimize the runtime, we apply the idea behind divide and conquer. First,\ncompute $opt(i, n / 2)$. Then, compute $opt(i, n / 4)$, knowing that it is less\nthan or equal to $opt(i, n / 2)$ and $opt(i, 3 n / 4)$ knowing that it is\ngreater than or equal to $opt(i, n / 2)$. By recursively keeping track of the\nlower and upper bounds on $opt$, we reach a $O(m n \\log n)$ runtime. Each\npossible value of $opt(i, j)$ only appears in $\\log n$ different nodes.\n\nNote that it doesn't matter how \"balanced\" $opt(i, j)$ is. Across a fixed\nlevel, each value of $k$ is used at most twice, and there are at most $\\log n$\nlevels.\n\n## Generic implementation\n\nEven though implementation varies based on problem, here's a fairly generic\ntemplate.\nThe function `compute` computes one row $i$ of states `dp_cur`, given the previous row $i-1$ of states `dp_before`.\nIt has to be called with `compute(0, n-1, 0, n-1)`. The function `solve` computes `m` rows and returns the result.\n\n```{.cpp file=divide_and_conquer_dp}\nint m, n;\nvector<long long> dp_before(n), dp_cur(n);\n\nlong long C(int i, int j);\n\n// compute dp_cur[l], ... dp_cur[r] (inclusive)\nvoid compute(int l, int r, int optl, int optr) {\n    if (l > r)\n        return;\n\n    int mid = (l + r) >> 1;\n    pair<long long, int> best = {LLONG_MAX, -1};\n\n    for (int k = optl; k <= min(mid, optr); k++) {\n        best = min(best, {(k ? dp_before[k - 1] : 0) + C(k, mid), k});\n    }\n\n    dp_cur[mid] = best.first;\n    int opt = best.second;\n\n    compute(l, mid - 1, optl, opt);\n    compute(mid + 1, r, opt, optr);\n}\n\nint solve() {\n    for (int i = 0; i < n; i++)\n        dp_before[i] = C(0, i);\n\n    for (int i = 1; i < m; i++) {\n        compute(0, n - 1, 0, n - 1);\n        dp_before = dp_cur;\n    }\n\n    return dp_before[n - 1];\n}\n```\n\n### Things to look out for\n\nThe greatest difficulty with Divide and Conquer DP problems is proving the\nmonotonicity of $opt$. One special case where this is true is when the cost function satisfies the quadrangle inequality, i.e., $C(a, c) + C(b, d) \\leq C(a, d) + C(b, c)$ for all $a \\leq b \\leq c \\leq d$. \nMany Divide and Conquer DP problems can also be solved with the Convex Hull trick or vice-versa. It is useful to know and understand\nboth! \n\n## Practice Problems\n- [AtCoder - Yakiniku Restaurants](https://atcoder.jp/contests/arc067/tasks/arc067_d)\n- [CodeForces - Ciel and Gondolas](https://codeforces.com/contest/321/problem/E) (Be careful with I/O!)\n- [CodeForces - Levels And Regions](https://codeforces.com/problemset/problem/673/E)\n- [CodeForces - Partition Game](https://codeforces.com/contest/1527/problem/E)\n- [CodeForces - The Bakery](https://codeforces.com/problemset/problem/834/D)\n- [CodeForces - Yet Another Minimization Problem](https://codeforces.com/contest/868/problem/F)\n- [Codechef - CHEFAOR](https://www.codechef.com/problems/CHEFAOR)\n- [CodeForces - GUARDS](https://codeforces.com/gym/103536/problem/A) (This is the exact problem in this article.)\n- [Hackerrank - Guardians of the Lunatics](https://www.hackerrank.com/contests/ioi-2014-practice-contest-2/challenges/guardians-lunatics-ioi14)\n- [Hackerrank - Mining](https://www.hackerrank.com/contests/world-codesprint-5/challenges/mining)\n- [Kattis - Money (ACM ICPC World Finals 2017)](https://open.kattis.com/problems/money)\n- [SPOJ - ADAMOLD](https://www.spoj.com/problems/ADAMOLD/)\n- [SPOJ - LARMY](https://www.spoj.com/problems/LARMY/)\n- [SPOJ - NKLEAVES](https://www.spoj.com/problems/NKLEAVES/)\n- [Timus - Bicolored Horses](https://acm.timus.ru/problem.aspx?space=1&num=1167)\n- [USACO - Circular Barn](http://www.usaco.org/index.php?page=viewproblem2&cpid=616)\n- [UVA - Arranging Heaps](https://onlinejudge.org/external/125/12524.pdf)\n- [UVA - Naming Babies](https://onlinejudge.org/external/125/12594.pdf)\n\n\n\n## References\n- [Quora Answer by Michael Levin](https://www.quora.com/What-is-divide-and-conquer-optimization-in-dynamic-programming)\n- [Video Tutorial by \"Sothe\" the Algorithm Wolf](https://www.youtube.com/watch?v=wLXEWuDWnzI)\n", "problem_ids": [], "title": "Divide and Conquer DP"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: maximum_average_segment\n---\n\n# Search the subarray with the maximum/minimum sum\n\nHere, we consider the problem of finding a subarray with maximum sum, as well as some of its variations (including the algorithm for solving this problem online).\n\n## Problem statement\n\nGiven an array of numbers $a[1 \\ldots n]$. It is required to find a subarray $a[l \\ldots r]$ with the maximal sum:\n\n$$ \\max_{ 1 \\le l \\le r \\le n } \\sum_{i=l}^{r} a[i].$$\n\nFor example, if all integers in array $a[]$ were non-negative, then the answer would be the array itself.\nHowever, the solution is non-trivial when the array can contain both positive and negative numbers.\n\nIt is clear that the problem of finding the **minimum** subarray is essentially the same, you just need to change the signs of all numbers.\n\n## Algorithm 1\n\nHere we consider an almost obvious algorithm. (Next, we'll look at another algorithm, which is a little harder to come up with, but its implementation is even shorter.)\n\n### Algorithm description\n\nThe algorithm is very simple.\n\nWe introduce for convenience the **notation**: $s[i] = \\sum_{j=1}^{i} a[j]$. That is, the array $s[i]$ is an array of partial sums of array $a[]$. Also, set $s[0] = 0$.\n\nLet us now iterate over the index $r = 1 \\ldots n$, and learn how to quickly find the optimal $l$ for each current value $r$, at which the maximum sum is reached on the subarray $[l, r]$.\n\nFormally, this means that for the current $r$ we need to find an $l$ (not exceeding $r$), so that the value of $s[r] - s[l-1]$ is maximal. After a trivial transformation, we can see that we need to find in the array $s[]$ a minimum on the segment $[0, r-1]$.\n\nFrom here, we immediately obtain a solution: we simply store where the current minimum is in the array $s[]$. Using this minimum, we find the current optimal index $l$ in $O(1)$, and when moving from the current index $r$ to the next one, we simply update this minimum.\n\nObviously, this algorithm works in $O(n)$ and is asymptotically optimal.\n\n### Implementation\n\nTo implement it, we don't even need to explicitly store an array of partial sums $s[]$ \u2014 we will only need the current element from it.\n\nThe implementation is given in 0-indexed arrays, not in 1-numbering as described above.\n\nWe first give a solution that finds a simple numerical answer without finding the indices of the desired segment:\n\n```cpp\nint ans = a[0], sum = 0, min_sum = 0;\n\nfor (int r = 0; r < n; ++r) {\n    sum += a[r];\n    ans = max(ans, sum - min_sum);\n    min_sum = min(min_sum, sum);\n}\n```\n\nNow we give a full version of the solution, which additionally also finds the boundaries of the desired segment:\n\n```cpp\nint ans = a[0], ans_l = 0, ans_r = 0;\nint sum = 0, min_sum = 0, min_pos = -1;\n\nfor (int r = 0; r < n; ++r) {\n    sum += a[r];\n    int cur = sum - min_sum;\n    if (cur > ans) {\n        ans = cur;\n        ans_l = min_pos + 1;\n        ans_r = r;\n    }\n    if (sum < min_sum) {\n        min_sum = sum;\n        min_pos = r;\n    }\n}\n```\n\n## Algorithm 2\n\nHere we consider a different algorithm. It is a little more difficult to understand, but it is more elegant than the above, and its implementation is a little bit shorter. This algorithm was proposed by Jay Kadane in 1984.\n\n### Algorithm description\n\nThe algorithm itself is as follows. Let's go through the array and accumulate the current partial sum in some variable $s$. If at some point $s$ is negative, we just assign $s=0$. It is argued that the maximum all the values that the variable $s$ is assigned to during the algorithm will be the answer to the problem.\n\n**Proof:**\n\nConsider the first index when the sum of $s$ becomes negative. This means that starting with a zero partial sum, we eventually obtain a negative partial sum \u2014 so this whole prefix of the array, as well as any suffix, has a negative sum. Therefore, this subarray never contributes to the partial sum of any subarray of which it is a prefix, and can simply be dropped.\n\nHowever, this is not enough to prove the algorithm. In the algorithm, we are actually limited in finding the answer only to such segments that begin immediately after the places when $s<0$ happened.\n\nBut, in fact, consider an arbitrary segment $[l, r]$, and $l$ is not in such a \"critical\" position (i.e. $l > p+1$, where $p$ is the last such position, in which $s<0$). Since the last critical position is strictly earlier than in $l-1$, it turns out that the sum of $a[p+1 \\ldots l-1]$ is non-negative. This means that by moving $l$ to position $p+1$, we will increase the answer or, in extreme cases, we will not change it.\n\nOne way or another, it turns out that when searching for an answer, you can limit yourself to only segments that begin immediately after the positions in which $s<0$ appeared. This proves that the algorithm is correct.\n\n### Implementation\n\nAs in algorithm 1, we first gave a simplified implementation that looks for only a numerical answer without finding the boundaries of the desired segment:\n\n```cpp\nint ans = a[0], sum = 0;\n\nfor (int r = 0; r < n; ++r) {\n    sum += a[r];\n    ans = max(ans, sum);\n    sum = max(sum, 0);\n}\n```\n\nA complete solution, maintaining the indexes of the boundaries of the corresponding segment:\n\n```cpp\nint ans = a[0], ans_l = 0, ans_r = 0;\nint sum = 0, minus_pos = -1;\n\nfor (int r = 0; r < n; ++r) {\n    sum += a[r];\n    if (sum > ans) {\n        ans = sum;\n        ans_l = minus_pos + 1;\n        ans_r = r;\n    }\n    if (sum < 0) {\n        sum = 0;\n        minus_pos = r;\n    }\n}\n```\n\n## Related tasks\n\n### Finding the maximum/minimum subarray with constraints\n\nIf the problem condition imposes additional restrictions on the required segment $[l, r]$ (for example, that the length $r-l+1$ of the segment must be within the specified limits), then the described algorithm is likely to be easily generalized to these cases \u2014 anyway, the problem will still be to find the minimum in the array $s[]$ with the specified additional restrictions.\n\n### Two-dimensional case of the problem: search for maximum/minimum submatrix\n\nThe problem described in this article is naturally generalized to large dimensions. For example, in a two-dimensional case, it turns into a search for such a submatrix $[l_1 \\ldots r_1, l_2 \\ldots r_2]$ of a given matrix, which has the maximum sum of numbers in it.\n\nUsing the solution for the one-dimensional case, it is easy to obtain a solution in $O(n^3)$ for the two-dimensions case:\nwe iterate over all possible values of $l_1$ and $r_1$, and calculate the sums from $l_1$ to $r_1$ in each row of the matrix. Now we have the one-dimensional problem of finding the indices $l_2$ and $r_2$ in this array, which can already be solved in linear time.\n\n**Faster** algorithms for solving this problem are known, but they are not much faster than $O(n^3)$, and are very complex (so complex that many of them are inferior to the trivial algorithm for all reasonable constraints by the hidden constant). Currently, the best known algorithm works in $O\\left(n^3 \\frac{ \\log^3 \\log n }{ \\log^2 n} \\right)$ time (T. Chan 2007 \"More algorithms for all-pairs shortest paths in weighted graphs\")\n\nThis algorithm by Chan, as well as many other results in this area, actually describe **fast matrix multiplication** (where matrix multiplication means modified multiplication: minimum is used instead of addition, and addition is used instead of multiplication). The problem of finding the submatrix with the largest sum can be reduced to the problem of finding the shortest paths between all pairs of vertices, and this problem, in turn, can be reduced to such a multiplication of matrices.\n\n### Search for a subarray with a maximum/minimum average\n\nThis problem lies in finding such a segment $a[l, r]$, such that the average value is maximal:\n\n$$ \\max_{l \\le r} \\frac{ 1 }{ r-l+1 } \\sum_{i=l}^{r} a[i].$$\n\nOf course, if no other conditions are imposed on the required segment $[l, r]$, then the solution will always be a segment of length $1$ at the maximum element of the array. \nThe problem only makes sense, if there are additional restrictions (for example, the length of the desired segment is bounded below).\n\nIn this case, we apply the **standard technique** when working with the problems of the average value: we will select the desired maximum average value by **binary search**.\n\nTo do this, we need to learn how to solve the following subproblem: given the number $x$, and we need to check whether there is a subarray of array $a[]$ (of course, satisfying all additional constraints of the problem), where the average value is greater than $x$.\n\nTo solve this subproblem, subtract $x$ from each element of array $a[]$. Then our subproblem actually turns into this one: whether or not there are positive sum subarrays in this array. And we already know how to solve this problem.\n\nThus, we obtained the solution for the asymptotic $O(T(n) \\log W)$, where $W$ is the required accuracy, $T(n)$ is the time of solving the subtask for an array of length $n$ (which may vary depending on the specific additional restrictions imposed).\n\n### Solving the online problem\n\nThe condition of the problem is as follows: given an array of $n$ numbers, and a number $L$. There are queries of the form $(l,r)$, and in response to each query, it is required to find a subarray of the segment $[l, r]$ of length not less than $L$ with the maximum possible arithmetic mean.\n\nThe algorithm for solving this problem is quite complex. KADR (Yaroslav Tverdokhleb) described his algorithm on the [Russian forum](http://e-maxx.ru/forum/viewtopic.php?id=410).\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: maximum_average_segment\n---\n\n# Search the subarray with the maximum/minimum sum\n\nHere, we consider the problem of finding a subarray with maximum sum, as well as some of its variations (including the algorithm for solving this problem online).\n\n## Problem statement\n\nGiven an array of numbers $a[1 \\ldots n]$. It is required to find a subarray $a[l \\ldots r]$ with the maximal sum:\n\n$$ \\max_{ 1 \\le l \\le r \\le n } \\sum_{i=l}^{r} a[i].$$\n\nFor example, if all integers in array $a[]$ were non-negative, then the answer would be the array itself.\nHowever, the solution is non-trivial when the array can contain both positive and negative numbers.\n\nIt is clear that the problem of finding the **minimum** subarray is essentially the same, you just need to change the signs of all numbers.\n\n## Algorithm 1\n\nHere we consider an almost obvious algorithm. (Next, we'll look at another algorithm, which is a little harder to come up with, but its implementation is even shorter.)\n\n### Algorithm description\n\nThe algorithm is very simple.\n\nWe introduce for convenience the **notation**: $s[i] = \\sum_{j=1}^{i} a[j]$. That is, the array $s[i]$ is an array of partial sums of array $a[]$. Also, set $s[0] = 0$.\n\nLet us now iterate over the index $r = 1 \\ldots n$, and learn how to quickly find the optimal $l$ for each current value $r$, at which the maximum sum is reached on the subarray $[l, r]$.\n\nFormally, this means that for the current $r$ we need to find an $l$ (not exceeding $r$), so that the value of $s[r] - s[l-1]$ is maximal. After a trivial transformation, we can see that we need to find in the array $s[]$ a minimum on the segment $[0, r-1]$.\n\nFrom here, we immediately obtain a solution: we simply store where the current minimum is in the array $s[]$. Using this minimum, we find the current optimal index $l$ in $O(1)$, and when moving from the current index $r$ to the next one, we simply update this minimum.\n\nObviously, this algorithm works in $O(n)$ and is asymptotically optimal.\n\n### Implementation\n\nTo implement it, we don't even need to explicitly store an array of partial sums $s[]$ \u2014 we will only need the current element from it.\n\nThe implementation is given in 0-indexed arrays, not in 1-numbering as described above.\n\nWe first give a solution that finds a simple numerical answer without finding the indices of the desired segment:\n\n```cpp\nint ans = a[0], sum = 0, min_sum = 0;\n\nfor (int r = 0; r < n; ++r) {\n    sum += a[r];\n    ans = max(ans, sum - min_sum);\n    min_sum = min(min_sum, sum);\n}\n```\n\nNow we give a full version of the solution, which additionally also finds the boundaries of the desired segment:\n\n```cpp\nint ans = a[0], ans_l = 0, ans_r = 0;\nint sum = 0, min_sum = 0, min_pos = -1;\n\nfor (int r = 0; r < n; ++r) {\n    sum += a[r];\n    int cur = sum - min_sum;\n    if (cur > ans) {\n        ans = cur;\n        ans_l = min_pos + 1;\n        ans_r = r;\n    }\n    if (sum < min_sum) {\n        min_sum = sum;\n        min_pos = r;\n    }\n}\n```\n\n## Algorithm 2\n\nHere we consider a different algorithm. It is a little more difficult to understand, but it is more elegant than the above, and its implementation is a little bit shorter. This algorithm was proposed by Jay Kadane in 1984.\n\n### Algorithm description\n\nThe algorithm itself is as follows. Let's go through the array and accumulate the current partial sum in some variable $s$. If at some point $s$ is negative, we just assign $s=0$. It is argued that the maximum all the values that the variable $s$ is assigned to during the algorithm will be the answer to the problem.\n\n**Proof:**\n\nConsider the first index when the sum of $s$ becomes negative. This means that starting with a zero partial sum, we eventually obtain a negative partial sum \u2014 so this whole prefix of the array, as well as any suffix, has a negative sum. Therefore, this subarray never contributes to the partial sum of any subarray of which it is a prefix, and can simply be dropped.\n\nHowever, this is not enough to prove the algorithm. In the algorithm, we are actually limited in finding the answer only to such segments that begin immediately after the places when $s<0$ happened.\n\nBut, in fact, consider an arbitrary segment $[l, r]$, and $l$ is not in such a \"critical\" position (i.e. $l > p+1$, where $p$ is the last such position, in which $s<0$). Since the last critical position is strictly earlier than in $l-1$, it turns out that the sum of $a[p+1 \\ldots l-1]$ is non-negative. This means that by moving $l$ to position $p+1$, we will increase the answer or, in extreme cases, we will not change it.\n\nOne way or another, it turns out that when searching for an answer, you can limit yourself to only segments that begin immediately after the positions in which $s<0$ appeared. This proves that the algorithm is correct.\n\n### Implementation\n\nAs in algorithm 1, we first gave a simplified implementation that looks for only a numerical answer without finding the boundaries of the desired segment:\n\n```cpp\nint ans = a[0], sum = 0;\n\nfor (int r = 0; r < n; ++r) {\n    sum += a[r];\n    ans = max(ans, sum);\n    sum = max(sum, 0);\n}\n```\n\nA complete solution, maintaining the indexes of the boundaries of the corresponding segment:\n\n```cpp\nint ans = a[0], ans_l = 0, ans_r = 0;\nint sum = 0, minus_pos = -1;\n\nfor (int r = 0; r < n; ++r) {\n    sum += a[r];\n    if (sum > ans) {\n        ans = sum;\n        ans_l = minus_pos + 1;\n        ans_r = r;\n    }\n    if (sum < 0) {\n        sum = 0;\n        minus_pos = r;\n    }\n}\n```\n\n## Related tasks\n\n### Finding the maximum/minimum subarray with constraints\n\nIf the problem condition imposes additional restrictions on the required segment $[l, r]$ (for example, that the length $r-l+1$ of the segment must be within the specified limits), then the described algorithm is likely to be easily generalized to these cases \u2014 anyway, the problem will still be to find the minimum in the array $s[]$ with the specified additional restrictions.\n\n### Two-dimensional case of the problem: search for maximum/minimum submatrix\n\nThe problem described in this article is naturally generalized to large dimensions. For example, in a two-dimensional case, it turns into a search for such a submatrix $[l_1 \\ldots r_1, l_2 \\ldots r_2]$ of a given matrix, which has the maximum sum of numbers in it.\n\nUsing the solution for the one-dimensional case, it is easy to obtain a solution in $O(n^3)$ for the two-dimensions case:\nwe iterate over all possible values of $l_1$ and $r_1$, and calculate the sums from $l_1$ to $r_1$ in each row of the matrix. Now we have the one-dimensional problem of finding the indices $l_2$ and $r_2$ in this array, which can already be solved in linear time.\n\n**Faster** algorithms for solving this problem are known, but they are not much faster than $O(n^3)$, and are very complex (so complex that many of them are inferior to the trivial algorithm for all reasonable constraints by the hidden constant). Currently, the best known algorithm works in $O\\left(n^3 \\frac{ \\log^3 \\log n }{ \\log^2 n} \\right)$ time (T. Chan 2007 \"More algorithms for all-pairs shortest paths in weighted graphs\")\n\nThis algorithm by Chan, as well as many other results in this area, actually describe **fast matrix multiplication** (where matrix multiplication means modified multiplication: minimum is used instead of addition, and addition is used instead of multiplication). The problem of finding the submatrix with the largest sum can be reduced to the problem of finding the shortest paths between all pairs of vertices, and this problem, in turn, can be reduced to such a multiplication of matrices.\n\n### Search for a subarray with a maximum/minimum average\n\nThis problem lies in finding such a segment $a[l, r]$, such that the average value is maximal:\n\n$$ \\max_{l \\le r} \\frac{ 1 }{ r-l+1 } \\sum_{i=l}^{r} a[i].$$\n\nOf course, if no other conditions are imposed on the required segment $[l, r]$, then the solution will always be a segment of length $1$ at the maximum element of the array. \nThe problem only makes sense, if there are additional restrictions (for example, the length of the desired segment is bounded below).\n\nIn this case, we apply the **standard technique** when working with the problems of the average value: we will select the desired maximum average value by **binary search**.\n\nTo do this, we need to learn how to solve the following subproblem: given the number $x$, and we need to check whether there is a subarray of array $a[]$ (of course, satisfying all additional constraints of the problem), where the average value is greater than $x$.\n\nTo solve this subproblem, subtract $x$ from each element of array $a[]$. Then our subproblem actually turns into this one: whether or not there are positive sum subarrays in this array. And we already know how to solve this problem.\n\nThus, we obtained the solution for the asymptotic $O(T(n) \\log W)$, where $W$ is the required accuracy, $T(n)$ is the time of solving the subtask for an array of length $n$ (which may vary depending on the specific additional restrictions imposed).\n\n### Solving the online problem\n\nThe condition of the problem is as follows: given an array of $n$ numbers, and a number $L$. There are queries of the form $(l,r)$, and in response to each query, it is required to find a subarray of the segment $[l, r]$ of length not less than $L$ with the maximum possible arithmetic mean.\n\nThe algorithm for solving this problem is quite complex. KADR (Yaroslav Tverdokhleb) described his algorithm on the [Russian forum](http://e-maxx.ru/forum/viewtopic.php?id=410).\n", "problem_ids": [], "title": "Search the subarray with the maximum/minimum sum"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: joseph_problem\n---\n\n# Josephus Problem\n\n## Statement\n\nWe are given the natural numbers $n$ and $k$.\nAll natural numbers from $1$ to $n$ are written in a circle. \nFirst, count the $k$-th number starting from the first one and delete it.\nThen $k$ numbers are counted starting from the next one and the $k$-th one is removed again, and so on.\nThe process stops when one number remains.\nIt is required to find the last number.\n\nThis task was set by **Flavius Josephus** in the 1st century (though in a somewhat narrower formulation: for $k = 2$).\n\nThis problem can be solved by modeling the procedure.\nBrute force modeling will work $O(n^{2})$. Using a [Segment Tree](/data_structures/segment_tree.html), we can improve it to $O(n \\log n)$.\nWe want something better though.\n\n## Modeling a $O(n)$ solution\n\nWe will try to find a pattern expressing the answer for the problem $J_{n, k}$ through the solution of the previous problems.\n\nUsing brute force modeling we can construct a table of values, for example, the following:\n\n$$\\begin{array}{ccccccccccc}\nn\\setminus k & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\\\\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\\n2 & 2 & 1 & 2 & 1 & 2 & 1 & 2 & 1 & 2 & 1 \\\\\n3 & 3 & 3 & 2 & 2 & 1 & 1 & 3 & 3 & 2 & 2 \\\\\n4 & 4 & 1 & 1 & 2 & 2 & 3 & 2 & 3 & 3 & 4 \\\\\n5 & 5 & 3 & 4 & 1 & 2 & 4 & 4 & 1 & 2 & 4 \\\\\n6 & 6 & 5 & 1 & 5 & 1 & 4 & 5 & 3 & 5 & 2 \\\\\n7 & 7 & 7 & 4 & 2 & 6 & 3 & 5 & 4 & 7 & 5 \\\\\n8 & 8 & 1 & 7 & 6 & 3 & 1 & 4 & 4 & 8 & 7 \\\\\n9 & 9 & 3 & 1 & 1 & 8 & 7 & 2 & 3 & 8 & 8 \\\\\n10 & 10 & 5 & 4 & 5 & 3 & 3 & 9 & 1 & 7 & 8 \\\\\n\\end{array}$$\n\nAnd here we can clearly see the following **pattern**:\n\n$$J_{n,k} = \\left( (J_{n-1,k} + k - 1) \\bmod n \\right) + 1$$\n\n$$J_{1,k} = 1$$\n\nHere, 1-indexing makes for a somewhat messy formula; if you instead number the positions from 0, you get a very elegant formula:\n\n$$J_{n,k} = (J_{n-1,k} + k) \\bmod n$$\n\nSo, we found a solution to the problem of Josephus, working in $O(n)$ operations.\n\n## Implementation\n\nSimple **recursive implementation** (in 1-indexing)\n\n```{.cpp file=josephus_rec}\nint josephus(int n, int k) {\n    return n > 1 ? (josephus(n-1, k) + k - 1) % n + 1 : 1;\n}\n```\n\n**Non-recursive form** :\n\n```{.cpp file=josephus_iter}\nint josephus(int n, int k) {\n    int res = 0;\n    for (int i = 1; i <= n; ++i)\n  \t  res = (res + k) % i;\n    return res + 1;\n}\n```\n\nThis formula can also be found analytically.\nAgain here we assume 0-indexing.\nAfter we delete the first number, we have $n-1$ numbers left.\nWhen we repeat the procedure, we will start with the number that had originally the index $k \\bmod n$.\n$J_{n-1, k}$ would be the answer for the remaining circle, if we start counting at $0$, but because we actually start with $k$ we have $J_{n, k} = (J_{n-1,k} + k) \\ \\bmod n$.\n\n## Modeling a $O(k \\log n)$ solution\n\nFor relatively small $k$ we can come up with a better solution than the above recursive solution in $O(n)$.\nIf $k$ is a lot smaller than $n$, then we can delete multiple numbers ($\\lfloor \\frac{n}{k} \\rfloor$) in one run without looping over.\nAfterwards we have $n - \\lfloor \\frac{n}{k} \\rfloor$ numbers left, and we start with the $(\\lfloor \\frac{n}{k} \\rfloor \\cdot k)$-th number.\nSo we have to shift by that many.\nWe can notice that $\\lfloor \\frac{n}{k} \\rfloor \\cdot k$ is simply $-n \\bmod k$.\nAnd because we removed every $k$-th number, we have to add the number of numbers that we removed before the result index.\nWhich we can compute by dividing the result index by $k - 1$.\n\nAlso, we need to handle the case when $n$ becomes less than $k$. In this case, the above optimization would cause an infinite loop.\n\n**Implementation** (for convenience in 0-indexing):\n\n```{.cpp file=josephus_fast0}\nint josephus(int n, int k) {\n    if (n == 1)\n        return 0;\n    if (k == 1)\n        return n-1;\n    if (k > n)\n        return (josephus(n-1, k) + k) % n;\n    int cnt = n / k;\n    int res = josephus(n - cnt, k);\n    res -= n % k;\n    if (res < 0)\n        res += n;\n    else\n        res += res / (k - 1);\n    return res;\n}\n```\n\nLet us estimate the **complexity** of this algorithm. Immediately note that the case $n < k$ is analyzed by the old solution, which will work in this case for $O(k)$. Now consider the algorithm itself. In fact, after every iteration, instead of $n$ numbers, we are left with $n \\left( 1 - \\frac{1}{k} \\right)$ numbers, so the total number of iterations $x$ of the algorithm can be found roughly from the following equation:\n\n$$ n \\left(1 - \\frac{1}{k} \\right) ^ x = 1, $$\n\non taking logarithm on both sides, we obtain:\n\n$$\\ln n + x \\ln \\left(1 - \\frac{1}{k} \\right) = 0,$$ \n$$x = - \\frac{\\ln n}{\\ln \\left(1 - \\frac{1}{k} \\right)},$$\n\nusing the decomposition of the logarithm into Taylor series, we obtain an approximate estimate:\n\n$$x \\approx k \\ln n$$\n\nThus, the complexity of the algorithm is actually $O (k \\log n)$.\n\n## Analytical solution for $k = 2$\n\nIn this particular case (in which this task was set by Josephus Flavius) the problem is solved much easier.\n\nIn the case of even $n$ we get that all even numbers will be crossed out, and then there will be a problem remaining for $\\frac{n}{2}$, then the answer for $n$ will be obtained from the answer for $\\frac{n}{2}$ by multiplying by two and subtracting one (by shifting positions):\n\n$$ J_{2n, 2} = 2 J_{n, 2} - 1 $$\n\nSimilarly, in the case of an odd $n$, all even numbers will be crossed out, then the first number, and the problem for $\\frac{n-1}{2}$ will remain, and taking into account the shift of positions, we obtain the second formula:\n\n$$J_{2n+1,2} = 2 J_{n, 2} + 1 $$\n\nWe can use this recurrent dependency directly in our implementation. This pattern can be translated into another form: $J_{n, 2}$ represents a sequence of all odd numbers, \"restarting\" from one whenever $n$ turns out to be a power of two. This can be written as a single formula:\n\n$$J_{n, 2} = 1 + 2 \\left(n-2^{\\lfloor \\log_2 n \\rfloor} \\right)$$\n\n## Analytical solution for $k > 2$\n\nDespite the simple form of the problem and a large number of articles on this and related problems, a simple analytical representation of the solution of Josephus' problem has not yet been found. For small $k$, some formulas are derived, but apparently they are all difficult to apply in practice (for example, see Halbeisen, Hungerbuhler \"The Josephus Problem\" and Odlyzko, Wilf \"Functional iteration and the Josephus problem\").\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: joseph_problem\n---\n\n# Josephus Problem\n\n## Statement\n\nWe are given the natural numbers $n$ and $k$.\nAll natural numbers from $1$ to $n$ are written in a circle. \nFirst, count the $k$-th number starting from the first one and delete it.\nThen $k$ numbers are counted starting from the next one and the $k$-th one is removed again, and so on.\nThe process stops when one number remains.\nIt is required to find the last number.\n\nThis task was set by **Flavius Josephus** in the 1st century (though in a somewhat narrower formulation: for $k = 2$).\n\nThis problem can be solved by modeling the procedure.\nBrute force modeling will work $O(n^{2})$. Using a [Segment Tree](/data_structures/segment_tree.html), we can improve it to $O(n \\log n)$.\nWe want something better though.\n\n## Modeling a $O(n)$ solution\n\nWe will try to find a pattern expressing the answer for the problem $J_{n, k}$ through the solution of the previous problems.\n\nUsing brute force modeling we can construct a table of values, for example, the following:\n\n$$\\begin{array}{ccccccccccc}\nn\\setminus k & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\\\\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\\n2 & 2 & 1 & 2 & 1 & 2 & 1 & 2 & 1 & 2 & 1 \\\\\n3 & 3 & 3 & 2 & 2 & 1 & 1 & 3 & 3 & 2 & 2 \\\\\n4 & 4 & 1 & 1 & 2 & 2 & 3 & 2 & 3 & 3 & 4 \\\\\n5 & 5 & 3 & 4 & 1 & 2 & 4 & 4 & 1 & 2 & 4 \\\\\n6 & 6 & 5 & 1 & 5 & 1 & 4 & 5 & 3 & 5 & 2 \\\\\n7 & 7 & 7 & 4 & 2 & 6 & 3 & 5 & 4 & 7 & 5 \\\\\n8 & 8 & 1 & 7 & 6 & 3 & 1 & 4 & 4 & 8 & 7 \\\\\n9 & 9 & 3 & 1 & 1 & 8 & 7 & 2 & 3 & 8 & 8 \\\\\n10 & 10 & 5 & 4 & 5 & 3 & 3 & 9 & 1 & 7 & 8 \\\\\n\\end{array}$$\n\nAnd here we can clearly see the following **pattern**:\n\n$$J_{n,k} = \\left( (J_{n-1,k} + k - 1) \\bmod n \\right) + 1$$\n\n$$J_{1,k} = 1$$\n\nHere, 1-indexing makes for a somewhat messy formula; if you instead number the positions from 0, you get a very elegant formula:\n\n$$J_{n,k} = (J_{n-1,k} + k) \\bmod n$$\n\nSo, we found a solution to the problem of Josephus, working in $O(n)$ operations.\n\n## Implementation\n\nSimple **recursive implementation** (in 1-indexing)\n\n```{.cpp file=josephus_rec}\nint josephus(int n, int k) {\n    return n > 1 ? (josephus(n-1, k) + k - 1) % n + 1 : 1;\n}\n```\n\n**Non-recursive form** :\n\n```{.cpp file=josephus_iter}\nint josephus(int n, int k) {\n    int res = 0;\n    for (int i = 1; i <= n; ++i)\n  \t  res = (res + k) % i;\n    return res + 1;\n}\n```\n\nThis formula can also be found analytically.\nAgain here we assume 0-indexing.\nAfter we delete the first number, we have $n-1$ numbers left.\nWhen we repeat the procedure, we will start with the number that had originally the index $k \\bmod n$.\n$J_{n-1, k}$ would be the answer for the remaining circle, if we start counting at $0$, but because we actually start with $k$ we have $J_{n, k} = (J_{n-1,k} + k) \\ \\bmod n$.\n\n## Modeling a $O(k \\log n)$ solution\n\nFor relatively small $k$ we can come up with a better solution than the above recursive solution in $O(n)$.\nIf $k$ is a lot smaller than $n$, then we can delete multiple numbers ($\\lfloor \\frac{n}{k} \\rfloor$) in one run without looping over.\nAfterwards we have $n - \\lfloor \\frac{n}{k} \\rfloor$ numbers left, and we start with the $(\\lfloor \\frac{n}{k} \\rfloor \\cdot k)$-th number.\nSo we have to shift by that many.\nWe can notice that $\\lfloor \\frac{n}{k} \\rfloor \\cdot k$ is simply $-n \\bmod k$.\nAnd because we removed every $k$-th number, we have to add the number of numbers that we removed before the result index.\nWhich we can compute by dividing the result index by $k - 1$.\n\nAlso, we need to handle the case when $n$ becomes less than $k$. In this case, the above optimization would cause an infinite loop.\n\n**Implementation** (for convenience in 0-indexing):\n\n```{.cpp file=josephus_fast0}\nint josephus(int n, int k) {\n    if (n == 1)\n        return 0;\n    if (k == 1)\n        return n-1;\n    if (k > n)\n        return (josephus(n-1, k) + k) % n;\n    int cnt = n / k;\n    int res = josephus(n - cnt, k);\n    res -= n % k;\n    if (res < 0)\n        res += n;\n    else\n        res += res / (k - 1);\n    return res;\n}\n```\n\nLet us estimate the **complexity** of this algorithm. Immediately note that the case $n < k$ is analyzed by the old solution, which will work in this case for $O(k)$. Now consider the algorithm itself. In fact, after every iteration, instead of $n$ numbers, we are left with $n \\left( 1 - \\frac{1}{k} \\right)$ numbers, so the total number of iterations $x$ of the algorithm can be found roughly from the following equation:\n\n$$ n \\left(1 - \\frac{1}{k} \\right) ^ x = 1, $$\n\non taking logarithm on both sides, we obtain:\n\n$$\\ln n + x \\ln \\left(1 - \\frac{1}{k} \\right) = 0,$$ \n$$x = - \\frac{\\ln n}{\\ln \\left(1 - \\frac{1}{k} \\right)},$$\n\nusing the decomposition of the logarithm into Taylor series, we obtain an approximate estimate:\n\n$$x \\approx k \\ln n$$\n\nThus, the complexity of the algorithm is actually $O (k \\log n)$.\n\n## Analytical solution for $k = 2$\n\nIn this particular case (in which this task was set by Josephus Flavius) the problem is solved much easier.\n\nIn the case of even $n$ we get that all even numbers will be crossed out, and then there will be a problem remaining for $\\frac{n}{2}$, then the answer for $n$ will be obtained from the answer for $\\frac{n}{2}$ by multiplying by two and subtracting one (by shifting positions):\n\n$$ J_{2n, 2} = 2 J_{n, 2} - 1 $$\n\nSimilarly, in the case of an odd $n$, all even numbers will be crossed out, then the first number, and the problem for $\\frac{n-1}{2}$ will remain, and taking into account the shift of positions, we obtain the second formula:\n\n$$J_{2n+1,2} = 2 J_{n, 2} + 1 $$\n\nWe can use this recurrent dependency directly in our implementation. This pattern can be translated into another form: $J_{n, 2}$ represents a sequence of all odd numbers, \"restarting\" from one whenever $n$ turns out to be a power of two. This can be written as a single formula:\n\n$$J_{n, 2} = 1 + 2 \\left(n-2^{\\lfloor \\log_2 n \\rfloor} \\right)$$\n\n## Analytical solution for $k > 2$\n\nDespite the simple form of the problem and a large number of articles on this and related problems, a simple analytical representation of the solution of Josephus' problem has not yet been found. For small $k$, some formulas are derived, but apparently they are all difficult to apply in practice (for example, see Halbeisen, Hungerbuhler \"The Josephus Problem\" and Odlyzko, Wilf \"Functional iteration and the Josephus problem\").\n", "problem_ids": [], "title": "Josephus Problem"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: stern_brocot_farey\n---\n\n# The Stern-Brocot tree and Farey sequences\n\n## Stern-Brocot tree\n\nThe Stern-Brocot tree is an elegant construction to represent the set of all positive fractions. It was independently discovered by German mathematician Moritz Stern in 1858 and by French watchmaker Achille Brocot in 1861. However, some sources attribute the discovery to ancient Greek mathematician Eratosthenes.\n\nThe construction starts at the zeroth iteration with the two fractions\n\n$$\n    \\frac{0}{1}, \\frac{1}{0}\n$$\n\nwhere it should be noted that the second quantity is not strictly a fraction, but it can be interpreted as an irreducible fraction representing infinity.\n\nAt every subsequent iteration, consider all adjacent fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ and insert their [mediant](https://en.wikipedia.org/wiki/Mediant_(mathematics)) $\\frac{a+c}{b+d}$ between them.\n\nThe first few iterations look like this:\n\n$$\n    \\begin{array}{c}\n    \\dfrac{0}{1}, \\dfrac{1}{1}, \\dfrac{1}{0} \\\\\n    \\dfrac{0}{1}, \\dfrac{1}{2}, \\dfrac{1}{1}, \\dfrac{2}{1}, \\dfrac{1}{0} \\\\\n    \\dfrac{0}{1}, \\dfrac{1}{3}, \\dfrac{1}{2}, \\dfrac{2}{3}, \\dfrac{1}{1}, \\dfrac{3}{2}, \\dfrac{2}{1}, \\dfrac{3}{1}, \\dfrac{1}{0}\n    \\end{array}\n$$\n\nContinuing this process to infinity this covers *all* positive fractions. Additionally, all fractions will be *unique* and *irreducible*. Finally, the fractions will also appear in ascending order.\n\nBefore proving these properties, let us actually show a visualization of the Stern-Brocot tree, rather than the list representation. Every fraction in the tree has two children. Each child is the mediant of the closest ancestor on the left and closest ancestor to the right.\n\n<center>![Stern-Brocot tree](https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/SternBrocotTree.svg/1024px-SternBrocotTree.svg.png)</center>\n\n## Proofs\n\n**Ordering.** Proving ordering is simple. We note that the mediant of two fractions is always in-between the fractions\n\n$$\n    \\frac{a}{b} \\le \\frac{a+c}{b+d} \\le \\frac{c}{d}\n$$\n\ngiven that\n\n$$\n    \\frac{a}{b} \\le \\frac{c}{d}.\n$$\n\nThe two inequalities can be easily shown by rewriting the fractions with common denominators.\n\nAs the ordering is ascending in the zeroth iteration, it will be maintained at every subsequent iteration.\n\n**Irreducibility.** To prove this we will show that for any two adjacent fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ we have that\n\n$$\n    bc - ad = 1.\n$$\n\nRecall that a Diophantine equation with two variables $ax+by=c$ has a solution iff $c$ is a multiple of $\\gcd(a,b)$. In our case this implies that $\\gcd(a,b) = \\gcd(c,d) = 1$, which is what we want to show.\n\nClearly at the zeroth iteration $bc - ad = 1$. What remains to be shown is that mediants retain this property.\n\nAssume our two adjacent fractions uphold $bc - ad = 1$, after the mediant is added to the list\n\n$$\n    \\frac{a}{b}, \\frac{a+c}{b+d}, \\frac{c}{d}\n$$\n\nthe new expressions become\n\n$$\\begin{align}\n    b(a+c) - a(b+d) &= 1 \\\\\n    c(b+d) - d(a+c) &= 1\n\\end{align}$$\n\nwhich, using that $bc-ad=1$, can be easily shown to be true.\n\nFrom this we see that the property is always maintained and thus all fractions are irreducible.\n\n**The presence of all fractions.** This proof is closely related to locating a fraction in the Stern-Brocot tree. From the ordering property we have that left subtree of a fraction contains only fractions smaller than the parent fraction, and the right subtree contains only fractions larger than the parent fraction. This means we can search for a fraction by traversing the tree from the root, going left if the target is smaller than the fraction and going right if the target is larger.\n\nPick an arbitrary positive target fraction $\\frac{x}{y}$. It is obviously between $\\frac{0}{1}$ and $\\frac{1}{0}$, so the only way for the fraction to not be in the tree is if it takes an infinite number of steps to get to it.\n\nIf that is the case we would at all iterations have\n\n$$\n    \\frac{a}{b} \\lt \\frac{x}{y} \\lt \\frac{c}{d}\n$$\n\nwhich (using the fact than an integer $z \\gt 0 \\iff z \\ge 1$) can be rewritten as\n\n$$\n\\begin{align}\n    bx - ay &\\ge 1 \\\\\n    cy - dx &\\ge 1.\n\\end{align}\n$$\n\nNow multiply the first inequality by $c+d$ and the second with $a+b$ and add them to get\n\n$$\n    (c+d)(bx - ay) + (a+b)(cy - dx) \\ge a+b+c+d.\n$$\n\nExpanding this and using the previously shown property $bc-ad=1$ we get that\n\n$$\n    x+y \\ge a+b+c+d.\n$$\n\nAnd given that at every iteration at least one of $a,b,c,d$ will increase, the fraction searching process will contain no more than $x+y$ iterations. This contradicts the assumption that the path to $\\frac{x}{y}$ was infinite and hence $\\frac{x}{y}$ must be part of the tree.\n\n## Tree Building Algorithm\n\nTo build any subtree of the Stern-Brocot tree, it suffices to know the left and right ancestor. On the first level, the left and right ancestors are $\\frac{0}{1}$ and $\\frac{1}{0}$ respectively. Using these, we calculate the mediant and proceed one level deeper, with the mediant replacing the right ancestor in the left subtree, and vice versa.\n\nThis pseudocode tries to build the entire infinite tree:\n\n```cpp\nvoid build(int a = 0, int b = 1, int c = 1, int d = 0, int level = 1) {\n    int x = a + c, y = b + d;\n\n    ... output the current fraction x/y at the current level in the tree\n    \n    build(a, b, x, y, level + 1);\n    build(x, y, c, d, level + 1);\n}\n```\n\n## Fraction Search Algorithm\n\nThe search algorithm was already described in the proof that all fractions appear in the tree, but we will repeat it here. The algorithm is a binary search algorithm. Initially we stand at the root of the tree and we compare our target with the current fraction. If they are the same we are done and stop the process. If our target is smaller we move to the left child, otherwise we move to the right child.\n\n### Naive search\n\nHere is an implementation that returns the path to a given fraction $\\frac{p}{q}$ as a sequence of `'L'` and `'R'` characters, meaning traversal to the left and right child respectively. This sequence of characters uniquely defines all positive fractions and is called the Stern-Brocot number system.\n\n```cpp\nstring find(int p, int q) {\n    int pL = 0, qL = 1;\n    int pR = 1, qR = 0;\n    int pM = 1, qM = 1;\n    string res;\n    while(pM != p || qM != q) {\n        if(p * qM < pM * q) {\n            res += 'L';\n            tie(pR, qR) = {pM, qM};\n        } else {\n            res += 'R';\n            tie(pL, qL) = {pM, qM};\n        }\n        tie(pM, qM) = pair{pL + pR, qL + qR};\n    }\n    return res;\n}\n```\n\nIrrational numbers in the Stern-Brocot number system corresponds to infinite sequences of characters. Along the endless path towards the irrational number the algorithm will find reduced fractions with gradually increasing denominators that provides increasingly better approximations of the irrational number. So by taking a prefix of the infinite sequence approximations with any desired precision can be achieved. This application is important in watch-making, which explains why the tree was discovered in that domain.\n\nNote that for a fraction $\\frac{p}{q}$, the length of the resulting sequence could be as large as $O(p+q)$, for example when the fraction is of form $\\frac{p}{1}$. This means that the algorithm above **should not be used, unless this is an acceptable complexity**! \n\n### Logarithmic search\n\nFortunately, it is possible to enhance the algorithm above to guarantee $O(\\log (p+q))$ complexity. For this we should note that if the current boundary fractions are $\\frac{p_L}{q_L}$ and $\\frac{p_R}{q_R}$, then by doing $a$ steps to the right we move to the fraction $\\frac{p_L + a p_R}{q_L + a q_R}$, and by doing $a$ steps to the left, we move to the fraction $\\frac{a p_L + p_R}{a q_L + q_R}$. \n\nTherefore, instead of doing steps of `L` or `R` one by one, we can do $k$ steps in the same direction at once, after which we would switch to going into other direction, and so on. In this way, we can find the path to the fraction $\\frac{p}{q}$ as its run-length encoding.\n\nAs the directions alternate this way, we will always know which one to take. So, for convenience we may represent a path to a fraction $\\frac{p}{q}$ as a sequence of fractions\n\n$$\n\\frac{p_0}{q_0}, \\frac{p_1}{q_1}, \\frac{p_2}{q_2}, \\dots, \\frac{p_n}{q_n}, \\frac{p_{n+1}}{q_{n+1}} = \\frac{p}{q}\n$$\n\nsuch that $\\frac{p_{k-1}}{q_{k-1}}$ and $\\frac{p_k}{q_k}$ are the boundaries of the search interval on the $k$-th step, starting with $\\frac{p_0}{q_0} = \\frac{0}{1}$ and $\\frac{p_1}{q_1} = \\frac{1}{0}$. Then, after the $k$-th step we move to a fraction\n\n$$\n\\frac{p_{k+1}}{q_{k+1}} = \\frac{p_{k-1} + a_k p_k}{q_{k-1} + a_k q_k},\n$$\n\nwhere $a_k$ is a positive integer number. If you're familiar with [continued fractions](), you would recognize that the sequence $\\frac{p_i}{q_i}$ is the sequence of the convergent fractions of $\\frac{p}{q}$ and the sequence $[a_1; a_2, \\dots, a_{n}, 1]$ represents the continued fraction of $\\frac{p}{q}$.\n\nThis allows to find the run-length encoding of the path to $\\frac{p}{q}$ in the manner which follows the algorithm for computing continued fraction representation of the fraction $\\frac{p}{q}$:\n\n```cpp\nauto find(int p, int q) {\n    bool right = true;\n    vector<pair<int, char>> res;\n    while(q) {\n        res.emplace_back(p / q, right ? 'R' : 'L');\n        tie(p, q) = pair{q, p % q};\n        right ^= 1;\n    }\n    res.back().first--;\n    return res;\n}\n```\n\nHowever, this approach only works if we already know $\\frac{p}{q}$ and want to find its place in the Stern-Brocot tree.\n\nOn practice, it is often the case that $\\frac{p}{q}$ is not known in advance, but we are able to check for specific $\\frac{x}{y}$ whether $\\frac{x}{y} < \\frac{p}{q}$.\n\nKnowing this, we can emulate the search on Stern-Brocot tree by maintaining the current boundaries $\\frac{p_{k-1}}{q_{k-1}}$ and $\\frac{p_k}{q_k}$, and finding each $a_k$ via binary search. The algorithm then is a bit more technical and potentially have a complexity of $O(\\log^2(x+y))$, unless the problem formulation allows you to find $a_k$ faster (for example, using `floor` of some known expression).\n\n## Farey Sequence\n\nThe Farey sequence of order $n$ is the sorted sequence of fractions between $0$ and $1$ whose denominators do not exceed $n$.\n\nThe sequences are named after English geologist John Farey, who in 1816 conjectured that any fraction in a Farey sequence is the mediant of its neighbors. This was proven some time later by Cauchy, but independent of both of them, the mathematician Haros had come to almost the same conclusion in 1802.\n\nThe Farey sequences have many interesting properties on their own, but the connection to the Stern-Brocot tree is the most obvious. In fact, the Farey sequences can be obtained by trimming branches from the tree.\n\nFrom the algorithm for building the Stern-Brocot tree, we get an algorithm for the Farey sequences. Start with the list of fractions $\\frac{0}{1}, \\frac{1}{0}$. At every subsequent iteration, insert the mediant only if the denominator does not exceed $n$. At some point the list will stop changing and the desired Farey sequence will have been found.\n\n### Length of a Farey Sequence\n\nA Farey sequence of order $n$ contains all elements of the Farey sequence of order $n-1$ as well as all irreducible fractions with denominator $n$, but the latter is just the totient $\\varphi(n)$. So the length $L_n$ of the Farey sequence of order $n$ is\n\n$$\n    L_n = L_{n-1} + \\varphi(n)\n$$\n\nor equivalently, by unraveling the recursion we get\n\n$$\n    L_n = 1 + \\sum_{k=1}^n \\varphi(k).\n$$\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: stern_brocot_farey\n---\n\n# The Stern-Brocot tree and Farey sequences\n\n## Stern-Brocot tree\n\nThe Stern-Brocot tree is an elegant construction to represent the set of all positive fractions. It was independently discovered by German mathematician Moritz Stern in 1858 and by French watchmaker Achille Brocot in 1861. However, some sources attribute the discovery to ancient Greek mathematician Eratosthenes.\n\nThe construction starts at the zeroth iteration with the two fractions\n\n$$\n    \\frac{0}{1}, \\frac{1}{0}\n$$\n\nwhere it should be noted that the second quantity is not strictly a fraction, but it can be interpreted as an irreducible fraction representing infinity.\n\nAt every subsequent iteration, consider all adjacent fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ and insert their [mediant](https://en.wikipedia.org/wiki/Mediant_(mathematics)) $\\frac{a+c}{b+d}$ between them.\n\nThe first few iterations look like this:\n\n$$\n    \\begin{array}{c}\n    \\dfrac{0}{1}, \\dfrac{1}{1}, \\dfrac{1}{0} \\\\\n    \\dfrac{0}{1}, \\dfrac{1}{2}, \\dfrac{1}{1}, \\dfrac{2}{1}, \\dfrac{1}{0} \\\\\n    \\dfrac{0}{1}, \\dfrac{1}{3}, \\dfrac{1}{2}, \\dfrac{2}{3}, \\dfrac{1}{1}, \\dfrac{3}{2}, \\dfrac{2}{1}, \\dfrac{3}{1}, \\dfrac{1}{0}\n    \\end{array}\n$$\n\nContinuing this process to infinity this covers *all* positive fractions. Additionally, all fractions will be *unique* and *irreducible*. Finally, the fractions will also appear in ascending order.\n\nBefore proving these properties, let us actually show a visualization of the Stern-Brocot tree, rather than the list representation. Every fraction in the tree has two children. Each child is the mediant of the closest ancestor on the left and closest ancestor to the right.\n\n<center>![Stern-Brocot tree](https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/SternBrocotTree.svg/1024px-SternBrocotTree.svg.png)</center>\n\n## Proofs\n\n**Ordering.** Proving ordering is simple. We note that the mediant of two fractions is always in-between the fractions\n\n$$\n    \\frac{a}{b} \\le \\frac{a+c}{b+d} \\le \\frac{c}{d}\n$$\n\ngiven that\n\n$$\n    \\frac{a}{b} \\le \\frac{c}{d}.\n$$\n\nThe two inequalities can be easily shown by rewriting the fractions with common denominators.\n\nAs the ordering is ascending in the zeroth iteration, it will be maintained at every subsequent iteration.\n\n**Irreducibility.** To prove this we will show that for any two adjacent fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ we have that\n\n$$\n    bc - ad = 1.\n$$\n\nRecall that a Diophantine equation with two variables $ax+by=c$ has a solution iff $c$ is a multiple of $\\gcd(a,b)$. In our case this implies that $\\gcd(a,b) = \\gcd(c,d) = 1$, which is what we want to show.\n\nClearly at the zeroth iteration $bc - ad = 1$. What remains to be shown is that mediants retain this property.\n\nAssume our two adjacent fractions uphold $bc - ad = 1$, after the mediant is added to the list\n\n$$\n    \\frac{a}{b}, \\frac{a+c}{b+d}, \\frac{c}{d}\n$$\n\nthe new expressions become\n\n$$\\begin{align}\n    b(a+c) - a(b+d) &= 1 \\\\\n    c(b+d) - d(a+c) &= 1\n\\end{align}$$\n\nwhich, using that $bc-ad=1$, can be easily shown to be true.\n\nFrom this we see that the property is always maintained and thus all fractions are irreducible.\n\n**The presence of all fractions.** This proof is closely related to locating a fraction in the Stern-Brocot tree. From the ordering property we have that left subtree of a fraction contains only fractions smaller than the parent fraction, and the right subtree contains only fractions larger than the parent fraction. This means we can search for a fraction by traversing the tree from the root, going left if the target is smaller than the fraction and going right if the target is larger.\n\nPick an arbitrary positive target fraction $\\frac{x}{y}$. It is obviously between $\\frac{0}{1}$ and $\\frac{1}{0}$, so the only way for the fraction to not be in the tree is if it takes an infinite number of steps to get to it.\n\nIf that is the case we would at all iterations have\n\n$$\n    \\frac{a}{b} \\lt \\frac{x}{y} \\lt \\frac{c}{d}\n$$\n\nwhich (using the fact than an integer $z \\gt 0 \\iff z \\ge 1$) can be rewritten as\n\n$$\n\\begin{align}\n    bx - ay &\\ge 1 \\\\\n    cy - dx &\\ge 1.\n\\end{align}\n$$\n\nNow multiply the first inequality by $c+d$ and the second with $a+b$ and add them to get\n\n$$\n    (c+d)(bx - ay) + (a+b)(cy - dx) \\ge a+b+c+d.\n$$\n\nExpanding this and using the previously shown property $bc-ad=1$ we get that\n\n$$\n    x+y \\ge a+b+c+d.\n$$\n\nAnd given that at every iteration at least one of $a,b,c,d$ will increase, the fraction searching process will contain no more than $x+y$ iterations. This contradicts the assumption that the path to $\\frac{x}{y}$ was infinite and hence $\\frac{x}{y}$ must be part of the tree.\n\n## Tree Building Algorithm\n\nTo build any subtree of the Stern-Brocot tree, it suffices to know the left and right ancestor. On the first level, the left and right ancestors are $\\frac{0}{1}$ and $\\frac{1}{0}$ respectively. Using these, we calculate the mediant and proceed one level deeper, with the mediant replacing the right ancestor in the left subtree, and vice versa.\n\nThis pseudocode tries to build the entire infinite tree:\n\n```cpp\nvoid build(int a = 0, int b = 1, int c = 1, int d = 0, int level = 1) {\n    int x = a + c, y = b + d;\n\n    ... output the current fraction x/y at the current level in the tree\n    \n    build(a, b, x, y, level + 1);\n    build(x, y, c, d, level + 1);\n}\n```\n\n## Fraction Search Algorithm\n\nThe search algorithm was already described in the proof that all fractions appear in the tree, but we will repeat it here. The algorithm is a binary search algorithm. Initially we stand at the root of the tree and we compare our target with the current fraction. If they are the same we are done and stop the process. If our target is smaller we move to the left child, otherwise we move to the right child.\n\n### Naive search\n\nHere is an implementation that returns the path to a given fraction $\\frac{p}{q}$ as a sequence of `'L'` and `'R'` characters, meaning traversal to the left and right child respectively. This sequence of characters uniquely defines all positive fractions and is called the Stern-Brocot number system.\n\n```cpp\nstring find(int p, int q) {\n    int pL = 0, qL = 1;\n    int pR = 1, qR = 0;\n    int pM = 1, qM = 1;\n    string res;\n    while(pM != p || qM != q) {\n        if(p * qM < pM * q) {\n            res += 'L';\n            tie(pR, qR) = {pM, qM};\n        } else {\n            res += 'R';\n            tie(pL, qL) = {pM, qM};\n        }\n        tie(pM, qM) = pair{pL + pR, qL + qR};\n    }\n    return res;\n}\n```\n\nIrrational numbers in the Stern-Brocot number system corresponds to infinite sequences of characters. Along the endless path towards the irrational number the algorithm will find reduced fractions with gradually increasing denominators that provides increasingly better approximations of the irrational number. So by taking a prefix of the infinite sequence approximations with any desired precision can be achieved. This application is important in watch-making, which explains why the tree was discovered in that domain.\n\nNote that for a fraction $\\frac{p}{q}$, the length of the resulting sequence could be as large as $O(p+q)$, for example when the fraction is of form $\\frac{p}{1}$. This means that the algorithm above **should not be used, unless this is an acceptable complexity**! \n\n### Logarithmic search\n\nFortunately, it is possible to enhance the algorithm above to guarantee $O(\\log (p+q))$ complexity. For this we should note that if the current boundary fractions are $\\frac{p_L}{q_L}$ and $\\frac{p_R}{q_R}$, then by doing $a$ steps to the right we move to the fraction $\\frac{p_L + a p_R}{q_L + a q_R}$, and by doing $a$ steps to the left, we move to the fraction $\\frac{a p_L + p_R}{a q_L + q_R}$. \n\nTherefore, instead of doing steps of `L` or `R` one by one, we can do $k$ steps in the same direction at once, after which we would switch to going into other direction, and so on. In this way, we can find the path to the fraction $\\frac{p}{q}$ as its run-length encoding.\n\nAs the directions alternate this way, we will always know which one to take. So, for convenience we may represent a path to a fraction $\\frac{p}{q}$ as a sequence of fractions\n\n$$\n\\frac{p_0}{q_0}, \\frac{p_1}{q_1}, \\frac{p_2}{q_2}, \\dots, \\frac{p_n}{q_n}, \\frac{p_{n+1}}{q_{n+1}} = \\frac{p}{q}\n$$\n\nsuch that $\\frac{p_{k-1}}{q_{k-1}}$ and $\\frac{p_k}{q_k}$ are the boundaries of the search interval on the $k$-th step, starting with $\\frac{p_0}{q_0} = \\frac{0}{1}$ and $\\frac{p_1}{q_1} = \\frac{1}{0}$. Then, after the $k$-th step we move to a fraction\n\n$$\n\\frac{p_{k+1}}{q_{k+1}} = \\frac{p_{k-1} + a_k p_k}{q_{k-1} + a_k q_k},\n$$\n\nwhere $a_k$ is a positive integer number. If you're familiar with [continued fractions](), you would recognize that the sequence $\\frac{p_i}{q_i}$ is the sequence of the convergent fractions of $\\frac{p}{q}$ and the sequence $[a_1; a_2, \\dots, a_{n}, 1]$ represents the continued fraction of $\\frac{p}{q}$.\n\nThis allows to find the run-length encoding of the path to $\\frac{p}{q}$ in the manner which follows the algorithm for computing continued fraction representation of the fraction $\\frac{p}{q}$:\n\n```cpp\nauto find(int p, int q) {\n    bool right = true;\n    vector<pair<int, char>> res;\n    while(q) {\n        res.emplace_back(p / q, right ? 'R' : 'L');\n        tie(p, q) = pair{q, p % q};\n        right ^= 1;\n    }\n    res.back().first--;\n    return res;\n}\n```\n\nHowever, this approach only works if we already know $\\frac{p}{q}$ and want to find its place in the Stern-Brocot tree.\n\nOn practice, it is often the case that $\\frac{p}{q}$ is not known in advance, but we are able to check for specific $\\frac{x}{y}$ whether $\\frac{x}{y} < \\frac{p}{q}$.\n\nKnowing this, we can emulate the search on Stern-Brocot tree by maintaining the current boundaries $\\frac{p_{k-1}}{q_{k-1}}$ and $\\frac{p_k}{q_k}$, and finding each $a_k$ via binary search. The algorithm then is a bit more technical and potentially have a complexity of $O(\\log^2(x+y))$, unless the problem formulation allows you to find $a_k$ faster (for example, using `floor` of some known expression).\n\n## Farey Sequence\n\nThe Farey sequence of order $n$ is the sorted sequence of fractions between $0$ and $1$ whose denominators do not exceed $n$.\n\nThe sequences are named after English geologist John Farey, who in 1816 conjectured that any fraction in a Farey sequence is the mediant of its neighbors. This was proven some time later by Cauchy, but independent of both of them, the mathematician Haros had come to almost the same conclusion in 1802.\n\nThe Farey sequences have many interesting properties on their own, but the connection to the Stern-Brocot tree is the most obvious. In fact, the Farey sequences can be obtained by trimming branches from the tree.\n\nFrom the algorithm for building the Stern-Brocot tree, we get an algorithm for the Farey sequences. Start with the list of fractions $\\frac{0}{1}, \\frac{1}{0}$. At every subsequent iteration, insert the mediant only if the denominator does not exceed $n$. At some point the list will stop changing and the desired Farey sequence will have been found.\n\n### Length of a Farey Sequence\n\nA Farey sequence of order $n$ contains all elements of the Farey sequence of order $n-1$ as well as all irreducible fractions with denominator $n$, but the latter is just the totient $\\varphi(n)$. So the length $L_n$ of the Farey sequence of order $n$ is\n\n$$\n    L_n = L_{n-1} + \\varphi(n)\n$$\n\nor equivalently, by unraveling the recursion we get\n\n$$\n    L_n = 1 + \\sum_{k=1}^n \\varphi(k).\n$$\n", "problem_ids": [], "title": "The Stern-Brocot tree and Farey sequences"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: 15_puzzle\n---\n\n# 15 Puzzle Game: Existence Of The Solution\n\nThis game is played on a $4 \\times 4$ board. On this board there are $15$ playing tiles numbered from 1 to 15. One cell is left empty (denoted by 0). You need to get the board to the position presented below by repeatedly moving one of the tiles to the free space:\n\n$$\\begin{matrix} 1 & 2 & 3 & 4 \\\\ 5 & 6 & 7 & 8 \\\\ 9 & 10 & 11 & 12 \\\\ 13 & 14 & 15 & 0 \\end{matrix}$$\n\nThe game \"15 Puzzle\u201d was created by Noyes Chapman in 1880.\n\n## Existence Of The Solution\n\nLet's consider this problem: given a position on the board, determine whether a sequence of moves which leads to a solution exists.\n\nSuppose we have some position on the board:\n\n$$\\begin{matrix} a_1 & a_2 & a_3 & a_4 \\\\ a_5 & a_6 & a_7 & a_8 \\\\ a_9 & a_{10} & a_{11} & a_{12} \\\\ a_{13} & a_{14} & a_{15} & a_{16} \\end{matrix}$$\n\nwhere one of the elements equals zero and indicates an empty cell $a_z  = 0$\n\nLet\u2019s consider the permutation:\n\n$$a_1 a_2 ... a_{z-1} a_{z+1} ... a_{15} a_{16}$$\n\ni.e. the permutation of numbers corresponding to the position on the board without a zero element\n\nLet $N$ be the number of inversions in this permutation (i.e. the number of such elements $a_i$  and $a_j$  that $i < j$, but $a_i  > a_j$).\n\nSuppose $K$ is an index of a row where the empty element is located (i.e. using our convention, $K = (z - 1) \\div \\ 4 + 1$).\n\nThen, **the solution exists iff $N + K$ is even**.\n\n## Implementation\n\nThe algorithm above can be illustrated with the following program code:\n\n```cpp\nint a[16];\nfor (int i=0; i<16; ++i)\n    cin >> a[i];\n\nint inv = 0;\nfor (int i=0; i<16; ++i)\n    if (a[i])\n        for (int j=0; j<i; ++j)\n            if (a[j] > a[i])\n                ++inv;\nfor (int i=0; i<16; ++i)\n    if (a[i] == 0)\n        inv += 1 + i / 4;\n\nputs ((inv & 1) ? \"No Solution\" : \"Solution Exists\");\n```\n\n## Proof\n\nIn 1879 Johnson proved that if $N + K$ is odd, then the solution doesn\u2019t exist, and in the same year Story proved that all positions when $N + K$ is even have a solution.\n\nHowever, all these proofs were quite complex.\n\nIn 1999 Archer proposed a much simpler proof (you can download his article [here](http://www.cs.cmu.edu/afs/cs/academic/class/15859-f01/www/notes/15-puzzle.pdf)).\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: 15_puzzle\n---\n\n# 15 Puzzle Game: Existence Of The Solution\n\nThis game is played on a $4 \\times 4$ board. On this board there are $15$ playing tiles numbered from 1 to 15. One cell is left empty (denoted by 0). You need to get the board to the position presented below by repeatedly moving one of the tiles to the free space:\n\n$$\\begin{matrix} 1 & 2 & 3 & 4 \\\\ 5 & 6 & 7 & 8 \\\\ 9 & 10 & 11 & 12 \\\\ 13 & 14 & 15 & 0 \\end{matrix}$$\n\nThe game \"15 Puzzle\u201d was created by Noyes Chapman in 1880.\n\n## Existence Of The Solution\n\nLet's consider this problem: given a position on the board, determine whether a sequence of moves which leads to a solution exists.\n\nSuppose we have some position on the board:\n\n$$\\begin{matrix} a_1 & a_2 & a_3 & a_4 \\\\ a_5 & a_6 & a_7 & a_8 \\\\ a_9 & a_{10} & a_{11} & a_{12} \\\\ a_{13} & a_{14} & a_{15} & a_{16} \\end{matrix}$$\n\nwhere one of the elements equals zero and indicates an empty cell $a_z  = 0$\n\nLet\u2019s consider the permutation:\n\n$$a_1 a_2 ... a_{z-1} a_{z+1} ... a_{15} a_{16}$$\n\ni.e. the permutation of numbers corresponding to the position on the board without a zero element\n\nLet $N$ be the number of inversions in this permutation (i.e. the number of such elements $a_i$  and $a_j$  that $i < j$, but $a_i  > a_j$).\n\nSuppose $K$ is an index of a row where the empty element is located (i.e. using our convention, $K = (z - 1) \\div \\ 4 + 1$).\n\nThen, **the solution exists iff $N + K$ is even**.\n\n## Implementation\n\nThe algorithm above can be illustrated with the following program code:\n\n```cpp\nint a[16];\nfor (int i=0; i<16; ++i)\n    cin >> a[i];\n\nint inv = 0;\nfor (int i=0; i<16; ++i)\n    if (a[i])\n        for (int j=0; j<i; ++j)\n            if (a[j] > a[i])\n                ++inv;\nfor (int i=0; i<16; ++i)\n    if (a[i] == 0)\n        inv += 1 + i / 4;\n\nputs ((inv & 1) ? \"No Solution\" : \"Solution Exists\");\n```\n\n## Proof\n\nIn 1879 Johnson proved that if $N + K$ is odd, then the solution doesn\u2019t exist, and in the same year Story proved that all positions when $N + K$ is even have a solution.\n\nHowever, all these proofs were quite complex.\n\nIn 1999 Archer proposed a much simpler proof (you can download his article [here](http://www.cs.cmu.edu/afs/cs/academic/class/15859-f01/www/notes/15-puzzle.pdf)).\n\n## Practice Problems\n\n* [Hackerrank - N-puzzle](https://www.hackerrank.com/challenges/n-puzzle)\n", "problem_ids": [], "title": "15 Puzzle Game: Existence Of The Solution"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: dijkstra\n---\n\n# Dijkstra Algorithm\n\nYou are given a directed or undirected weighted graph with $n$ vertices and $m$ edges. The weights of all edges are non-negative. You are also given a starting vertex $s$. This article discusses finding the lengths of the shortest paths from a starting vertex $s$ to all other vertices, and output the shortest paths themselves.\n\nThis problem is also called **single-source shortest paths problem**.\n\n## Algorithm\n\nHere is an algorithm described by the Dutch computer scientist Edsger W. Dijkstra in 1959.\n\nLet's create an array $d[]$ where for each vertex $v$ we store the current length of the shortest path from $s$ to $v$ in $d[v]$.\nInitially $d[s] = 0$, and for all other vertices this length equals infinity.\nIn the implementation a sufficiently large number (which is guaranteed to be greater than any possible path length) is chosen as infinity.\n\n$$d[v] = \\infty,~ v \\ne s$$\n\nIn addition, we maintain a Boolean array $u[]$ which stores for each vertex $v$ whether it's marked. Initially all vertices are unmarked:\n\n$$u[v] = {\\rm false}$$\n\nThe Dijkstra's algorithm runs for $n$ iterations. At each iteration a vertex $v$ is chosen as unmarked vertex which has the least value $d[v]$:\n\nEvidently, in the first iteration the starting vertex $s$ will be selected.\n\nThe selected vertex $v$ is marked. Next, from vertex $v$ **relaxations** are performed: all edges of the form $(v,\\text{to})$ are considered, and for each vertex $\\text{to}$ the algorithm tries to improve the value $d[\\text{to}]$. If the length of the current edge equals $len$, the code for relaxation is:\n\n$$d[\\text{to}] = \\min (d[\\text{to}], d[v] + len)$$\n\nAfter all such edges are considered, the current iteration ends. Finally, after $n$ iterations, all vertices will be marked, and the algorithm terminates. We claim that the found values $d[v]$ are the lengths of shortest paths from $s$ to all vertices $v$.\n\nNote that if some vertices are unreachable from the starting vertex $s$, the values $d[v]$ for them will remain infinite. Obviously, the last few iterations of the algorithm will choose those vertices, but no useful work will be done for them. Therefore, the algorithm can be stopped as soon as the selected vertex has infinite distance to it.\n\n### Restoring Shortest Paths \n\nUsually one needs to know not only the lengths of shortest paths but also the shortest paths themselves. Let's see how to maintain sufficient information to restore the shortest path from $s$ to any vertex. We'll maintain an array of predecessors $p[]$ in which for each vertex $v \\ne s$, $p[v]$ is the penultimate vertex in the shortest path from $s$ to $v$. Here we use the fact that if we take the shortest path to some vertex $v$ and remove $v$ from this path, we'll get a path ending in at vertex $p[v]$, and this path will be the shortest for the vertex $p[v]$. This array of predecessors can be used to restore the shortest path to any vertex: starting with $v$, repeatedly take the predecessor of the current vertex until we reach the starting vertex $s$ to get the required shortest path with vertices listed in reverse order. So, the shortest path $P$ to the vertex $v$ is equal to:\n\n$$P = (s, \\ldots, p[p[p[v]]], p[p[v]], p[v], v)$$\n\nBuilding this array of predecessors is very simple: for each successful relaxation, i.e. when for some selected vertex $v$, there is an improvement in the distance to some vertex $\\text{to}$, we update the predecessor vertex for $\\text{to}$ with vertex $v$:\n\n$$p[\\text{to}] = v$$\n\n## Proof\n\nThe main assertion on which Dijkstra's algorithm correctness is based is the following:\n\n**After any vertex $v$ becomes marked, the current distance to it $d[v]$ is the shortest, and will no longer change.**\n\nThe proof is done by induction. For the first iteration this statement is obvious: the only marked vertex is $s$, and the distance to is $d[s] = 0$ is indeed the length of the shortest path to $s$. Now suppose this statement is true for all previous iterations, i.e. for all already marked vertices; let's prove that it is not violated after the current iteration completes. Let $v$ be the vertex selected in the current iteration, i.e. $v$ is the vertex that the algorithm will mark. Now we have to prove that $d[v]$ is indeed equal to the length of the shortest path to it $l[v]$.\n\nConsider the shortest path $P$ to the vertex $v$. This path can be split into two parts: $P_1$ which consists of only marked nodes (at least the starting vertex $s$ is part of $P_1$), and the rest of the path $P_2$ (it may include a marked vertex, but it always starts with an unmarked vertex). Let's denote the first vertex of the path $P_2$ as $p$, and the last vertex of the path $P_1$ as $q$.\n\nFirst we prove our statement for the vertex $p$, i.e. let's prove that $d[p] = l[p]$.\nThis is almost obvious: on one of the previous iterations we chose the vertex $q$ and performed relaxation from it.\nSince (by virtue of the choice of vertex $p$) the shortest path to $p$ is the shortest path to $q$ plus edge $(p,q)$, the relaxation from $q$ set the value of $d[p]$ to the length of the shortest path $l[p]$.\n\nSince the edges' weights are non-negative, the length of the shortest path $l[p]$ (which we just proved to be equal to $d[p]$) does not exceed the length $l[v]$ of the shortest path to the vertex $v$. Given that $l[v] \\le d[v]$ (because Dijkstra's algorithm could not have found a shorter way than the shortest possible one), we get the inequality:\n\n$$d[p] = l[p] \\le l[v] \\le d[v]$$\n\nOn the other hand, since both vertices $p$ and $v$ are unmarked, and the current iteration chose vertex $v$, not $p$, we get another inequality:\n\n$$d[p] \\ge d[v]$$\n\nFrom these two inequalities we conclude that $d[p] = d[v]$, and then from previously found equations we get:\n\n$$d[v] = l[v]$$\n\nQ.E.D.\n\n## Implementation\n\nDijkstra's algorithm performs $n$ iterations. On each iteration it selects an unmarked vertex $v$ with the lowest value $d[v]$, marks it and checks all the edges $(v, \\text{to})$ attempting to improve the value $d[\\text{to}]$.\n\nThe running time of the algorithm consists of:\n\n* $n$ searches for a vertex with the smallest value $d[v]$ among $O(n)$ unmarked vertices\n* $m$ relaxation attempts\n\nFor the simplest implementation of these operations on each iteration vertex search requires $O(n)$ operations, and each relaxation can be performed in $O(1)$. Hence, the resulting asymptotic behavior of the algorithm is:\n\n$$O(n^2+m)$$ \n\nThis complexity is optimal for dense graph, i.e. when $m \\approx n^2$.\nHowever in sparse graphs, when $m$ is much smaller than the maximal number of edges $n^2$, the problem can be solved in $O(n \\log n + m)$ complexity. The algorithm and implementation can be found on the article [Dijkstra on sparse graphs](dijkstra_sparse.md).\n\n\n```{.cpp file=dijkstra_dense}\nconst int INF = 1000000000;\nvector<vector<pair<int, int>>> adj;\n\nvoid dijkstra(int s, vector<int> & d, vector<int> & p) {\n    int n = adj.size();\n    d.assign(n, INF);\n    p.assign(n, -1);\n    vector<bool> u(n, false);\n\n    d[s] = 0;\n    for (int i = 0; i < n; i++) {\n        int v = -1;\n        for (int j = 0; j < n; j++) {\n            if (!u[j] && (v == -1 || d[j] < d[v]))\n                v = j;\n        }\n        \n        if (d[v] == INF)\n            break;\n        \n        u[v] = true;\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n            \n            if (d[v] + len < d[to]) {\n                d[to] = d[v] + len;\n                p[to] = v;\n            }\n        }\n    }\n}\n```\n\nHere the graph $\\text{adj}$ is stored as adjacency list: for each vertex $v$ $\\text{adj}[v]$ contains the list of edges going from this vertex, i.e. the list of `pair<int,int>` where the first element in the pair is the vertex at the other end of the edge, and the second element is the edge weight.\n\nThe function takes the starting vertex $s$ and two vectors that will be used as return values.\n\nFirst of all, the code initializes arrays: distances $d[]$, labels $u[]$ and predecessors $p[]$. Then it performs $n$ iterations. At each iteration the vertex $v$ is selected which has the smallest distance $d[v]$ among all the unmarked vertices. If the distance to selected vertex $v$ is equal to infinity, the algorithm stops. Otherwise the vertex is marked, and all the edges going out from this vertex are checked. If relaxation along the edge is possible (i.e. distance $d[\\text{to}]$ can be improved), the distance $d[\\text{to}]$ and predecessor $p[\\text{to}]$ are updated.\n\nAfter performing all the iterations array $d[]$ stores the lengths of the shortest paths to all vertices, and array $p[]$ stores the predecessors of all vertices (except starting vertex $s$). The path to any vertex $t$ can be restored in the following way:\n\n```{.cpp file=dijkstra_restore_path}\nvector<int> restore_path(int s, int t, vector<int> const& p) {\n    vector<int> path;\n\n    for (int v = t; v != s; v = p[v])\n        path.push_back(v);\n    path.push_back(s);\n\n    reverse(path.begin(), path.end());\n    return path;\n}\n```\n\n## References\n\n* Edsger Dijkstra. A note on two problems in connexion with graphs [1959]\n* Thomas Cormen, Charles Leiserson, Ronald Rivest, Clifford Stein. Introduction to Algorithms [2005]\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: dijkstra\n---\n\n# Dijkstra Algorithm\n\nYou are given a directed or undirected weighted graph with $n$ vertices and $m$ edges. The weights of all edges are non-negative. You are also given a starting vertex $s$. This article discusses finding the lengths of the shortest paths from a starting vertex $s$ to all other vertices, and output the shortest paths themselves.\n\nThis problem is also called **single-source shortest paths problem**.\n\n## Algorithm\n\nHere is an algorithm described by the Dutch computer scientist Edsger W. Dijkstra in 1959.\n\nLet's create an array $d[]$ where for each vertex $v$ we store the current length of the shortest path from $s$ to $v$ in $d[v]$.\nInitially $d[s] = 0$, and for all other vertices this length equals infinity.\nIn the implementation a sufficiently large number (which is guaranteed to be greater than any possible path length) is chosen as infinity.\n\n$$d[v] = \\infty,~ v \\ne s$$\n\nIn addition, we maintain a Boolean array $u[]$ which stores for each vertex $v$ whether it's marked. Initially all vertices are unmarked:\n\n$$u[v] = {\\rm false}$$\n\nThe Dijkstra's algorithm runs for $n$ iterations. At each iteration a vertex $v$ is chosen as unmarked vertex which has the least value $d[v]$:\n\nEvidently, in the first iteration the starting vertex $s$ will be selected.\n\nThe selected vertex $v$ is marked. Next, from vertex $v$ **relaxations** are performed: all edges of the form $(v,\\text{to})$ are considered, and for each vertex $\\text{to}$ the algorithm tries to improve the value $d[\\text{to}]$. If the length of the current edge equals $len$, the code for relaxation is:\n\n$$d[\\text{to}] = \\min (d[\\text{to}], d[v] + len)$$\n\nAfter all such edges are considered, the current iteration ends. Finally, after $n$ iterations, all vertices will be marked, and the algorithm terminates. We claim that the found values $d[v]$ are the lengths of shortest paths from $s$ to all vertices $v$.\n\nNote that if some vertices are unreachable from the starting vertex $s$, the values $d[v]$ for them will remain infinite. Obviously, the last few iterations of the algorithm will choose those vertices, but no useful work will be done for them. Therefore, the algorithm can be stopped as soon as the selected vertex has infinite distance to it.\n\n### Restoring Shortest Paths \n\nUsually one needs to know not only the lengths of shortest paths but also the shortest paths themselves. Let's see how to maintain sufficient information to restore the shortest path from $s$ to any vertex. We'll maintain an array of predecessors $p[]$ in which for each vertex $v \\ne s$, $p[v]$ is the penultimate vertex in the shortest path from $s$ to $v$. Here we use the fact that if we take the shortest path to some vertex $v$ and remove $v$ from this path, we'll get a path ending in at vertex $p[v]$, and this path will be the shortest for the vertex $p[v]$. This array of predecessors can be used to restore the shortest path to any vertex: starting with $v$, repeatedly take the predecessor of the current vertex until we reach the starting vertex $s$ to get the required shortest path with vertices listed in reverse order. So, the shortest path $P$ to the vertex $v$ is equal to:\n\n$$P = (s, \\ldots, p[p[p[v]]], p[p[v]], p[v], v)$$\n\nBuilding this array of predecessors is very simple: for each successful relaxation, i.e. when for some selected vertex $v$, there is an improvement in the distance to some vertex $\\text{to}$, we update the predecessor vertex for $\\text{to}$ with vertex $v$:\n\n$$p[\\text{to}] = v$$\n\n## Proof\n\nThe main assertion on which Dijkstra's algorithm correctness is based is the following:\n\n**After any vertex $v$ becomes marked, the current distance to it $d[v]$ is the shortest, and will no longer change.**\n\nThe proof is done by induction. For the first iteration this statement is obvious: the only marked vertex is $s$, and the distance to is $d[s] = 0$ is indeed the length of the shortest path to $s$. Now suppose this statement is true for all previous iterations, i.e. for all already marked vertices; let's prove that it is not violated after the current iteration completes. Let $v$ be the vertex selected in the current iteration, i.e. $v$ is the vertex that the algorithm will mark. Now we have to prove that $d[v]$ is indeed equal to the length of the shortest path to it $l[v]$.\n\nConsider the shortest path $P$ to the vertex $v$. This path can be split into two parts: $P_1$ which consists of only marked nodes (at least the starting vertex $s$ is part of $P_1$), and the rest of the path $P_2$ (it may include a marked vertex, but it always starts with an unmarked vertex). Let's denote the first vertex of the path $P_2$ as $p$, and the last vertex of the path $P_1$ as $q$.\n\nFirst we prove our statement for the vertex $p$, i.e. let's prove that $d[p] = l[p]$.\nThis is almost obvious: on one of the previous iterations we chose the vertex $q$ and performed relaxation from it.\nSince (by virtue of the choice of vertex $p$) the shortest path to $p$ is the shortest path to $q$ plus edge $(p,q)$, the relaxation from $q$ set the value of $d[p]$ to the length of the shortest path $l[p]$.\n\nSince the edges' weights are non-negative, the length of the shortest path $l[p]$ (which we just proved to be equal to $d[p]$) does not exceed the length $l[v]$ of the shortest path to the vertex $v$. Given that $l[v] \\le d[v]$ (because Dijkstra's algorithm could not have found a shorter way than the shortest possible one), we get the inequality:\n\n$$d[p] = l[p] \\le l[v] \\le d[v]$$\n\nOn the other hand, since both vertices $p$ and $v$ are unmarked, and the current iteration chose vertex $v$, not $p$, we get another inequality:\n\n$$d[p] \\ge d[v]$$\n\nFrom these two inequalities we conclude that $d[p] = d[v]$, and then from previously found equations we get:\n\n$$d[v] = l[v]$$\n\nQ.E.D.\n\n## Implementation\n\nDijkstra's algorithm performs $n$ iterations. On each iteration it selects an unmarked vertex $v$ with the lowest value $d[v]$, marks it and checks all the edges $(v, \\text{to})$ attempting to improve the value $d[\\text{to}]$.\n\nThe running time of the algorithm consists of:\n\n* $n$ searches for a vertex with the smallest value $d[v]$ among $O(n)$ unmarked vertices\n* $m$ relaxation attempts\n\nFor the simplest implementation of these operations on each iteration vertex search requires $O(n)$ operations, and each relaxation can be performed in $O(1)$. Hence, the resulting asymptotic behavior of the algorithm is:\n\n$$O(n^2+m)$$ \n\nThis complexity is optimal for dense graph, i.e. when $m \\approx n^2$.\nHowever in sparse graphs, when $m$ is much smaller than the maximal number of edges $n^2$, the problem can be solved in $O(n \\log n + m)$ complexity. The algorithm and implementation can be found on the article [Dijkstra on sparse graphs](dijkstra_sparse.md).\n\n\n```{.cpp file=dijkstra_dense}\nconst int INF = 1000000000;\nvector<vector<pair<int, int>>> adj;\n\nvoid dijkstra(int s, vector<int> & d, vector<int> & p) {\n    int n = adj.size();\n    d.assign(n, INF);\n    p.assign(n, -1);\n    vector<bool> u(n, false);\n\n    d[s] = 0;\n    for (int i = 0; i < n; i++) {\n        int v = -1;\n        for (int j = 0; j < n; j++) {\n            if (!u[j] && (v == -1 || d[j] < d[v]))\n                v = j;\n        }\n        \n        if (d[v] == INF)\n            break;\n        \n        u[v] = true;\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n            \n            if (d[v] + len < d[to]) {\n                d[to] = d[v] + len;\n                p[to] = v;\n            }\n        }\n    }\n}\n```\n\nHere the graph $\\text{adj}$ is stored as adjacency list: for each vertex $v$ $\\text{adj}[v]$ contains the list of edges going from this vertex, i.e. the list of `pair<int,int>` where the first element in the pair is the vertex at the other end of the edge, and the second element is the edge weight.\n\nThe function takes the starting vertex $s$ and two vectors that will be used as return values.\n\nFirst of all, the code initializes arrays: distances $d[]$, labels $u[]$ and predecessors $p[]$. Then it performs $n$ iterations. At each iteration the vertex $v$ is selected which has the smallest distance $d[v]$ among all the unmarked vertices. If the distance to selected vertex $v$ is equal to infinity, the algorithm stops. Otherwise the vertex is marked, and all the edges going out from this vertex are checked. If relaxation along the edge is possible (i.e. distance $d[\\text{to}]$ can be improved), the distance $d[\\text{to}]$ and predecessor $p[\\text{to}]$ are updated.\n\nAfter performing all the iterations array $d[]$ stores the lengths of the shortest paths to all vertices, and array $p[]$ stores the predecessors of all vertices (except starting vertex $s$). The path to any vertex $t$ can be restored in the following way:\n\n```{.cpp file=dijkstra_restore_path}\nvector<int> restore_path(int s, int t, vector<int> const& p) {\n    vector<int> path;\n\n    for (int v = t; v != s; v = p[v])\n        path.push_back(v);\n    path.push_back(s);\n\n    reverse(path.begin(), path.end());\n    return path;\n}\n```\n\n## References\n\n* Edsger Dijkstra. A note on two problems in connexion with graphs [1959]\n* Thomas Cormen, Charles Leiserson, Ronald Rivest, Clifford Stein. Introduction to Algorithms [2005]\n\n## Practice Problems\n* [Timus - Ivan's Car](http://acm.timus.ru/problem.aspx?space=1&num=1930) [Difficulty:Medium]\n* [Timus - Sightseeing Trip](http://acm.timus.ru/problem.aspx?space=1&num=1004)\n* [SPOJ - SHPATH](http://www.spoj.com/problems/SHPATH/) [Difficulty:Easy]\n* [Codeforces - Dijkstra?](http://codeforces.com/problemset/problem/20/C) [Difficulty:Easy]\n* [Codeforces - Shortest Path](http://codeforces.com/problemset/problem/59/E)\n* [Codeforces - Jzzhu and Cities](http://codeforces.com/problemset/problem/449/B)\n* [Codeforces - The Classic Problem](http://codeforces.com/problemset/problem/464/E)\n* [Codeforces - President and Roads](http://codeforces.com/problemset/problem/567/E)\n* [Codeforces - Complete The Graph](http://codeforces.com/problemset/problem/715/B)\n* [TopCoder - SkiResorts](https://community.topcoder.com/stat?c=problem_statement&pm=12468)\n* [TopCoder - MaliciousPath](https://community.topcoder.com/stat?c=problem_statement&pm=13596)\n* [SPOJ - Ada and Trip](http://www.spoj.com/problems/ADATRIP/)\n* [LA - 3850 - Here We Go(relians) Again](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1851)\n* [GYM - Destination Unknown (D)](http://codeforces.com/gym/100625)\n* [UVA 12950 - Even Obsession](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=4829)\n* [GYM - Journey to Grece (A)](http://codeforces.com/gym/100753)\n* [UVA 13030 - Brain Fry](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=866&page=show_problem&problem=4918)\n* [UVA 1027 - Toll](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3468)\n* [UVA 11377 - Airport Setup](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2372)\n* [Codeforces - Dynamic Shortest Path](http://codeforces.com/problemset/problem/843/D)\n* [UVA 11813 - Shopping](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2913)\n* [UVA 11833 - Route Change](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=226&page=show_problem&problem=2933)\n* [SPOJ - Easy Dijkstra Problem](http://www.spoj.com/problems/EZDIJKST/en/)\n* [LA - 2819 - Cave Raider](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=820)\n* [UVA 12144 - Almost Shortest Path](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3296)\n* [UVA 12047 - Highest Paid Toll](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3198)\n* [UVA 11514 - Batman](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2509)\n* [Codeforces - Team Rocket Rises Again](http://codeforces.com/contest/757/problem/F)\n* [UVA - 11338 - Minefield](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2313)\n* [UVA 11374 - Airport Express](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2369)\n* [UVA 11097 - Poor My Problem](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2038)\n* [UVA 13172 - The music teacher](https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=5083)\n* [Codeforces - Dirty Arkady's Kitchen](http://codeforces.com/contest/827/problem/F)\n* [SPOJ - Delivery Route](http://www.spoj.com/problems/DELIVER/)\n* [SPOJ - Costly Chess](http://www.spoj.com/problems/CCHESS/)\n* [CSES - Shortest Routes 1](https://cses.fi/problemset/task/1671)\n* [CSES - Flight Discount](https://cses.fi/problemset/task/1195)\n* [CSES - Flight Routes](https://cses.fi/problemset/task/1196)\n\n", "problem_ids": ["20_C", "59_E", "449_B", "464_E", "567_E", "715_B", "843_D", "757_F", "827_F"], "title": "Dijkstra Algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: tree_painting\n---\n\n# Paint the edges of the tree\n\nThis is a fairly common task. Given a tree $G$ with $N$ vertices. There are two types of queries: the first one is to paint an edge, the second one is to query the number of colored edges between two vertices.\n\nHere we will describe a fairly simple solution (using a [segment tree](../data_structures/segment_tree.md)) that will answer each query in $O(\\log N)$ time.\nThe preprocessing step will take $O(N)$ time.\n\n## Algorithm\n\nFirst, we need to find the [LCA](lca.md) to reduce each query of the second kind $(i,j)$ into two queries $(l,i)$ and $(l,j)$, where $l$ is the LCA of $i$ and $j$.\nThe answer of the query $(i,j)$ will be the sum of both subqueries.\nBoth these queries have a special structure, the first vertex is an ancestor of the second one.\nFor the rest of the article we will only talk about these special kind of queries.\n\nWe will start by describing the **preprocessing** step.\nRun a depth-first search from the root of the tree and record the Euler tour of this depth-first search (each vertex is added to the list when the search visits it first and every time we return from one of its children).\nThe same technique can be used in the LCA preprocessing.\n\nThis list will contain each edge (in the sense that if $i$ and $j$ are the ends of the edge, then there will be a place in the list where $i$ and $j$ are neighbors in the list), and it appear exactly two times: in the forward direction (from $i$ to $j$, where vertex $i$ is closer to the root than vertex $j$) and in the opposite direction (from $j$ to $i$).\n\nWe will build two lists for these edges.\nThe first one will store the color of all edges in the forward direction, and the second one the color of all edges in the opposite direction.\nWe will use $1$ if the edge is colored, and $0$ otherwise.\nOver these two lists we will build each a segment tree (for sum with a single modification), let's call them $T1$ and $T2$.\n\nLet us answer a query of the form $(i,j)$, where $i$ is the ancestor of $j$.\nWe need to determine how many edges are painted on the path between $i$ and $j$.\nLet's find $i$ and $j$ in the Euler tour for the first time, let it be the positions $p$ and $q$ (this can be done in $O(1)$ if we calculate these positions in advance during preprocessing).\nThen the **answer** to the query is the sum $T1[p..q-1]$ minus the sum $T2[p..q-1]$.\n\n**Why?**\nConsider the segment $[p;q]$ in the Euler tour.\nIt contains all edges of the path we need from $i$ to $j$ but also contains a set of edges that lie on other paths from $i$.\nHowever there is one big difference between the edges we need and the rest of the edges: the edges we need will be listed only once in the forward direction, and all the other edges appear twice: once in the forward and once in the opposite direction.\nHence, the difference $T1[p..q-1] - T2[p..q-1]$ will give us the correct answer (minus one is necessary because otherwise, we will capture an extra edge going out from vertex $j$).\nThe sum query in the segment tree is executed in $O(\\log N)$.\n\nAnswering the **first type of query** (painting an edge) is even easier - we just need to update $T1$ and $T2$, namely to perform a single update of the element that corresponds to our edge (finding the edge in the list, again, is possible in $O(1)$, if you perform this search during preprocessing).\nA single modification in the segment tree is performed in $O(\\log N)$.\n\n## Implementation\n\nHere is the full implementation of the solution, including LCA computation:\n\n```cpp\nconst int INF = 1000 * 1000 * 1000;\n\ntypedef vector<vector<int>> graph;\n\nvector<int> dfs_list;\nvector<int> edges_list;\nvector<int> h;\n\nvoid dfs(int v, const graph& g, const graph& edge_ids, int cur_h = 1) {\n    h[v] = cur_h;\n    dfs_list.push_back(v);\n    for (size_t i = 0; i < g[v].size(); ++i) {\n        if (h[g[v][i]] == -1) {\n            edges_list.push_back(edge_ids[v][i]);\n            dfs(g[v][i], g, edge_ids, cur_h + 1);\n            edges_list.push_back(edge_ids[v][i]);\n            dfs_list.push_back(v);\n        }\n    }\n}\n\nvector<int> lca_tree;\nvector<int> first;\n\nvoid lca_tree_build(int i, int l, int r) {\n    if (l == r) {\n        lca_tree[i] = dfs_list[l];\n    } else {\n        int m = (l + r) >> 1;\n        lca_tree_build(i + i, l, m);\n        lca_tree_build(i + i + 1, m + 1, r);\n        int lt = lca_tree[i + i], rt = lca_tree[i + i + 1];\n        lca_tree[i] = h[lt] < h[rt] ? lt : rt;\n    }\n}\n\nvoid lca_prepare(int n) {\n    lca_tree.assign(dfs_list.size() * 8, -1);\n    lca_tree_build(1, 0, (int)dfs_list.size() - 1);\n\n    first.assign(n, -1);\n    for (int i = 0; i < (int)dfs_list.size(); ++i) {\n        int v = dfs_list[i];\n        if (first[v] == -1)\n            first[v] = i;\n    }\n}\n\nint lca_tree_query(int i, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r)\n        return lca_tree[i];\n    int m = (tl + tr) >> 1;\n    if (r <= m)\n        return lca_tree_query(i + i, tl, m, l, r);\n    if (l > m)\n        return lca_tree_query(i + i + 1, m + 1, tr, l, r);\n    int lt = lca_tree_query(i + i, tl, m, l, m);\n    int rt = lca_tree_query(i + i + 1, m + 1, tr, m + 1, r);\n    return h[lt] < h[rt] ? lt : rt;\n}\n\nint lca(int a, int b) {\n    if (first[a] > first[b])\n        swap(a, b);\n    return lca_tree_query(1, 0, (int)dfs_list.size() - 1, first[a], first[b]);\n}\n\nvector<int> first1, first2;\nvector<char> edge_used;\nvector<int> tree1, tree2;\n\nvoid query_prepare(int n) {\n    first1.resize(n - 1, -1);\n    first2.resize(n - 1, -1);\n    for (int i = 0; i < (int)edges_list.size(); ++i) {\n        int j = edges_list[i];\n        if (first1[j] == -1)\n            first1[j] = i;\n        else\n            first2[j] = i;\n    }\n\n    edge_used.resize(n - 1);\n    tree1.resize(edges_list.size() * 8);\n    tree2.resize(edges_list.size() * 8);\n}\n\nvoid sum_tree_update(vector<int>& tree, int i, int l, int r, int j, int delta) {\n    tree[i] += delta;\n    if (l < r) {\n        int m = (l + r) >> 1;\n        if (j <= m)\n            sum_tree_update(tree, i + i, l, m, j, delta);\n        else\n            sum_tree_update(tree, i + i + 1, m + 1, r, j, delta);\n    }\n}\n\nint sum_tree_query(const vector<int>& tree, int i, int tl, int tr, int l, int r) {\n    if (l > r || tl > tr)\n        return 0;\n    if (tl == l && tr == r)\n        return tree[i];\n    int m = (tl + tr) >> 1;\n    if (r <= m)\n        return sum_tree_query(tree, i + i, tl, m, l, r);\n    if (l > m)\n        return sum_tree_query(tree, i + i + 1, m + 1, tr, l, r);\n    return sum_tree_query(tree, i + i, tl, m, l, m) +\n           sum_tree_query(tree, i + i + 1, m + 1, tr, m + 1, r);\n}\n\nint query(int v1, int v2) {\n    return sum_tree_query(tree1, 1, 0, (int)edges_list.size() - 1, first[v1], first[v2] - 1) -\n           sum_tree_query(tree2, 1, 0, (int)edges_list.size() - 1, first[v1], first[v2] - 1);\n}\n\nint main() {\n    // reading the graph\n    int n;\n    scanf(\"%d\", &n);\n    graph g(n), edge_ids(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int v1, v2;\n        scanf(\"%d%d\", &v1, &v2);\n        --v1, --v2;\n        g[v1].push_back(v2);\n        g[v2].push_back(v1);\n        edge_ids[v1].push_back(i);\n        edge_ids[v2].push_back(i);\n    }\n\n    h.assign(n, -1);\n    dfs(0, g, edge_ids);\n    lca_prepare(n);\n    query_prepare(n);\n\n    for (;;) {\n        if () {\n            // request for painting edge x;\n            // if start = true, then the edge is painted, otherwise the painting\n            // is removed\n            edge_used[x] = start;\n            sum_tree_update(tree1, 1, 0, (int)edges_list.size() - 1, first1[x],\n                            start ? 1 : -1);\n            sum_tree_update(tree2, 1, 0, (int)edges_list.size() - 1, first2[x],\n                            start ? 1 : -1);\n        } else {\n            // query the number of colored edges on the path between v1 and v2\n            int l = lca(v1, v2);\n            int result = query(l, v1) + query(l, v2);\n            // result - the answer to the request\n        }\n    }\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: tree_painting\n---\n\n# Paint the edges of the tree\n\nThis is a fairly common task. Given a tree $G$ with $N$ vertices. There are two types of queries: the first one is to paint an edge, the second one is to query the number of colored edges between two vertices.\n\nHere we will describe a fairly simple solution (using a [segment tree](../data_structures/segment_tree.md)) that will answer each query in $O(\\log N)$ time.\nThe preprocessing step will take $O(N)$ time.\n\n## Algorithm\n\nFirst, we need to find the [LCA](lca.md) to reduce each query of the second kind $(i,j)$ into two queries $(l,i)$ and $(l,j)$, where $l$ is the LCA of $i$ and $j$.\nThe answer of the query $(i,j)$ will be the sum of both subqueries.\nBoth these queries have a special structure, the first vertex is an ancestor of the second one.\nFor the rest of the article we will only talk about these special kind of queries.\n\nWe will start by describing the **preprocessing** step.\nRun a depth-first search from the root of the tree and record the Euler tour of this depth-first search (each vertex is added to the list when the search visits it first and every time we return from one of its children).\nThe same technique can be used in the LCA preprocessing.\n\nThis list will contain each edge (in the sense that if $i$ and $j$ are the ends of the edge, then there will be a place in the list where $i$ and $j$ are neighbors in the list), and it appear exactly two times: in the forward direction (from $i$ to $j$, where vertex $i$ is closer to the root than vertex $j$) and in the opposite direction (from $j$ to $i$).\n\nWe will build two lists for these edges.\nThe first one will store the color of all edges in the forward direction, and the second one the color of all edges in the opposite direction.\nWe will use $1$ if the edge is colored, and $0$ otherwise.\nOver these two lists we will build each a segment tree (for sum with a single modification), let's call them $T1$ and $T2$.\n\nLet us answer a query of the form $(i,j)$, where $i$ is the ancestor of $j$.\nWe need to determine how many edges are painted on the path between $i$ and $j$.\nLet's find $i$ and $j$ in the Euler tour for the first time, let it be the positions $p$ and $q$ (this can be done in $O(1)$ if we calculate these positions in advance during preprocessing).\nThen the **answer** to the query is the sum $T1[p..q-1]$ minus the sum $T2[p..q-1]$.\n\n**Why?**\nConsider the segment $[p;q]$ in the Euler tour.\nIt contains all edges of the path we need from $i$ to $j$ but also contains a set of edges that lie on other paths from $i$.\nHowever there is one big difference between the edges we need and the rest of the edges: the edges we need will be listed only once in the forward direction, and all the other edges appear twice: once in the forward and once in the opposite direction.\nHence, the difference $T1[p..q-1] - T2[p..q-1]$ will give us the correct answer (minus one is necessary because otherwise, we will capture an extra edge going out from vertex $j$).\nThe sum query in the segment tree is executed in $O(\\log N)$.\n\nAnswering the **first type of query** (painting an edge) is even easier - we just need to update $T1$ and $T2$, namely to perform a single update of the element that corresponds to our edge (finding the edge in the list, again, is possible in $O(1)$, if you perform this search during preprocessing).\nA single modification in the segment tree is performed in $O(\\log N)$.\n\n## Implementation\n\nHere is the full implementation of the solution, including LCA computation:\n\n```cpp\nconst int INF = 1000 * 1000 * 1000;\n\ntypedef vector<vector<int>> graph;\n\nvector<int> dfs_list;\nvector<int> edges_list;\nvector<int> h;\n\nvoid dfs(int v, const graph& g, const graph& edge_ids, int cur_h = 1) {\n    h[v] = cur_h;\n    dfs_list.push_back(v);\n    for (size_t i = 0; i < g[v].size(); ++i) {\n        if (h[g[v][i]] == -1) {\n            edges_list.push_back(edge_ids[v][i]);\n            dfs(g[v][i], g, edge_ids, cur_h + 1);\n            edges_list.push_back(edge_ids[v][i]);\n            dfs_list.push_back(v);\n        }\n    }\n}\n\nvector<int> lca_tree;\nvector<int> first;\n\nvoid lca_tree_build(int i, int l, int r) {\n    if (l == r) {\n        lca_tree[i] = dfs_list[l];\n    } else {\n        int m = (l + r) >> 1;\n        lca_tree_build(i + i, l, m);\n        lca_tree_build(i + i + 1, m + 1, r);\n        int lt = lca_tree[i + i], rt = lca_tree[i + i + 1];\n        lca_tree[i] = h[lt] < h[rt] ? lt : rt;\n    }\n}\n\nvoid lca_prepare(int n) {\n    lca_tree.assign(dfs_list.size() * 8, -1);\n    lca_tree_build(1, 0, (int)dfs_list.size() - 1);\n\n    first.assign(n, -1);\n    for (int i = 0; i < (int)dfs_list.size(); ++i) {\n        int v = dfs_list[i];\n        if (first[v] == -1)\n            first[v] = i;\n    }\n}\n\nint lca_tree_query(int i, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r)\n        return lca_tree[i];\n    int m = (tl + tr) >> 1;\n    if (r <= m)\n        return lca_tree_query(i + i, tl, m, l, r);\n    if (l > m)\n        return lca_tree_query(i + i + 1, m + 1, tr, l, r);\n    int lt = lca_tree_query(i + i, tl, m, l, m);\n    int rt = lca_tree_query(i + i + 1, m + 1, tr, m + 1, r);\n    return h[lt] < h[rt] ? lt : rt;\n}\n\nint lca(int a, int b) {\n    if (first[a] > first[b])\n        swap(a, b);\n    return lca_tree_query(1, 0, (int)dfs_list.size() - 1, first[a], first[b]);\n}\n\nvector<int> first1, first2;\nvector<char> edge_used;\nvector<int> tree1, tree2;\n\nvoid query_prepare(int n) {\n    first1.resize(n - 1, -1);\n    first2.resize(n - 1, -1);\n    for (int i = 0; i < (int)edges_list.size(); ++i) {\n        int j = edges_list[i];\n        if (first1[j] == -1)\n            first1[j] = i;\n        else\n            first2[j] = i;\n    }\n\n    edge_used.resize(n - 1);\n    tree1.resize(edges_list.size() * 8);\n    tree2.resize(edges_list.size() * 8);\n}\n\nvoid sum_tree_update(vector<int>& tree, int i, int l, int r, int j, int delta) {\n    tree[i] += delta;\n    if (l < r) {\n        int m = (l + r) >> 1;\n        if (j <= m)\n            sum_tree_update(tree, i + i, l, m, j, delta);\n        else\n            sum_tree_update(tree, i + i + 1, m + 1, r, j, delta);\n    }\n}\n\nint sum_tree_query(const vector<int>& tree, int i, int tl, int tr, int l, int r) {\n    if (l > r || tl > tr)\n        return 0;\n    if (tl == l && tr == r)\n        return tree[i];\n    int m = (tl + tr) >> 1;\n    if (r <= m)\n        return sum_tree_query(tree, i + i, tl, m, l, r);\n    if (l > m)\n        return sum_tree_query(tree, i + i + 1, m + 1, tr, l, r);\n    return sum_tree_query(tree, i + i, tl, m, l, m) +\n           sum_tree_query(tree, i + i + 1, m + 1, tr, m + 1, r);\n}\n\nint query(int v1, int v2) {\n    return sum_tree_query(tree1, 1, 0, (int)edges_list.size() - 1, first[v1], first[v2] - 1) -\n           sum_tree_query(tree2, 1, 0, (int)edges_list.size() - 1, first[v1], first[v2] - 1);\n}\n\nint main() {\n    // reading the graph\n    int n;\n    scanf(\"%d\", &n);\n    graph g(n), edge_ids(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int v1, v2;\n        scanf(\"%d%d\", &v1, &v2);\n        --v1, --v2;\n        g[v1].push_back(v2);\n        g[v2].push_back(v1);\n        edge_ids[v1].push_back(i);\n        edge_ids[v2].push_back(i);\n    }\n\n    h.assign(n, -1);\n    dfs(0, g, edge_ids);\n    lca_prepare(n);\n    query_prepare(n);\n\n    for (;;) {\n        if () {\n            // request for painting edge x;\n            // if start = true, then the edge is painted, otherwise the painting\n            // is removed\n            edge_used[x] = start;\n            sum_tree_update(tree1, 1, 0, (int)edges_list.size() - 1, first1[x],\n                            start ? 1 : -1);\n            sum_tree_update(tree2, 1, 0, (int)edges_list.size() - 1, first2[x],\n                            start ? 1 : -1);\n        } else {\n            // query the number of colored edges on the path between v1 and v2\n            int l = lca(v1, v2);\n            int result = query(l, v1) + query(l, v2);\n            // result - the answer to the request\n        }\n    }\n}\n```\n", "problem_ids": [], "title": "Paint the edges of the tree"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: flow_with_limits\n---\n\n# Flows with demands\n\nIn a normal flow network the flow of an edge is only limited by the capacity $c(e)$ from above and by 0 from below.\nIn this article we will discuss flow networks, where we additionally require the flow of each edge to have a certain amount, i.e. we bound the flow from below by a **demand** function $d(e)$:\n\n$$ d(e) \\le f(e) \\le c(e)$$\n\nSo next each edge has a minimal flow value, that we have to pass along the edge.\n\nThis is a generalization of the normal flow problem, since setting $d(e) = 0$ for all edges $e$ gives a normal flow network.\nNotice, that in the normal flow network it is extremely trivial to find a valid flow, just setting $f(e) = 0$ is already a valid one.\nHowever if the flow of each edge has to satisfy a demand, than suddenly finding a valid flow is already pretty complicated.\n\nWe will consider two problems:\n\n1. finding an arbitrary flow that satisfies all constraints\n2. finding a minimal flow that satisfies all constraints\n\n## Finding an arbitrary flow\n\nWe make the following changes in the network.\nWe add a new source $s'$ and a new sink $t'$, a new edge from the source $s'$ to every other vertex, a new edge for every vertex to the sink $t'$, and one edge from $t$ to $s$.\nAdditionally we define the new capacity function $c'$ as:\n\n- $c'((s', v)) = \\sum_{u \\in V} d((u, v))$ for each edge $(s', v)$.\n- $c'((v, t')) = \\sum_{w \\in V} d((v, w))$ for each edge $(v, t')$.\n- $c'((u, v)) = c((u, v)) - d((u, v))$ for each edge $(u, v)$ in the old network.\n- $c'((t, s)) = \\infty$\n\nIf the new network has a saturating flow (a flow where each edge outgoing from $s'$ is completely filled, which is equivalent to every edge incoming to $t'$ is completely filled), then the network with demands has a valid flow, and the actual flow can be easily reconstructed from the new network.\nOtherwise there doesn't exist a flow that satisfies all conditions.\nSince a saturating flow has to be a maximum flow, it can be found by any maximum flow algorithm, like the [Edmonds-Karp algorithm](edmonds_karp.md) or the [Push-relabel algorithm](push-relabel.md).\n\nThe correctness of these transformations is more difficult to understand.\nWe can think of it in the following way:\nEach edge $e = (u, v)$ with $d(e) > 0$ is originally replaced by two edges: one with the capacity $d(i)$ , and the other with $c(i) - d(i)$.\nWe want to find a flow that saturates the first edge (i.e. the flow along this edge must be equal to its capacity).\nThe second edge is less important - the flow along it can be anything, assuming that it doesn't exceed its capacity.\nConsider each edge that has to be saturated, and we perform the following operation:\nwe draw the edge from the new source $s'$ to its end $v$, draw the edge from its start $u$ to the new sink $t'$, remove the edge itself, and from the old sink $t$ to the old source $s$ we draw an edge of infinite capacity.\nBy these actions we simulate the fact that this edge is saturated - from $v$ there will be an additionally $d(e)$ flow outgoing (we simulate it with a new source that feeds the right amount of flow to $v$), and $u$ will also push $d(e)$ additional flow (but instead along the old edge, this flow will go directly to the new sink $t'$).\nA flow with the value $d(e)$, that originally flowed along the path $s - \\dots - u - v - \\dots t$ can now take the new path $s' - v - \\dots - t - s - \\dots - u - t'$.\nThe only thing that got simplified in the definition of the new network, is that if procedure created multiple edges between the same pair of vertices, then they are combined to one single edge with the summed capacity.\n\n## Minimal flow\n\nNote that along the edge $(t, s)$ (from the old sink to the old source) with the capacity $\\infty$ flows the entire flow of the corresponding old network.\nI.e. the capacity of this edge effects the flow value of the old network.\nBy giving this edge a sufficient large capacity (i.e. $\\infty$), the flow of the old network is unlimited.\nBy limiting this edge by smaller capacities, the flow value will decrease.\nHowever if we limit this edge by a too small value, than the network will not have a saturated solution, e.g. the corresponding solution for the original network will not satisfy the demand of the edges.\nObviously here can use a binary search to find the lowest value with which all constraints are still satisfied.\nThis gives the minimal flow of the original network.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: flow_with_limits\n---\n\n# Flows with demands\n\nIn a normal flow network the flow of an edge is only limited by the capacity $c(e)$ from above and by 0 from below.\nIn this article we will discuss flow networks, where we additionally require the flow of each edge to have a certain amount, i.e. we bound the flow from below by a **demand** function $d(e)$:\n\n$$ d(e) \\le f(e) \\le c(e)$$\n\nSo next each edge has a minimal flow value, that we have to pass along the edge.\n\nThis is a generalization of the normal flow problem, since setting $d(e) = 0$ for all edges $e$ gives a normal flow network.\nNotice, that in the normal flow network it is extremely trivial to find a valid flow, just setting $f(e) = 0$ is already a valid one.\nHowever if the flow of each edge has to satisfy a demand, than suddenly finding a valid flow is already pretty complicated.\n\nWe will consider two problems:\n\n1. finding an arbitrary flow that satisfies all constraints\n2. finding a minimal flow that satisfies all constraints\n\n## Finding an arbitrary flow\n\nWe make the following changes in the network.\nWe add a new source $s'$ and a new sink $t'$, a new edge from the source $s'$ to every other vertex, a new edge for every vertex to the sink $t'$, and one edge from $t$ to $s$.\nAdditionally we define the new capacity function $c'$ as:\n\n- $c'((s', v)) = \\sum_{u \\in V} d((u, v))$ for each edge $(s', v)$.\n- $c'((v, t')) = \\sum_{w \\in V} d((v, w))$ for each edge $(v, t')$.\n- $c'((u, v)) = c((u, v)) - d((u, v))$ for each edge $(u, v)$ in the old network.\n- $c'((t, s)) = \\infty$\n\nIf the new network has a saturating flow (a flow where each edge outgoing from $s'$ is completely filled, which is equivalent to every edge incoming to $t'$ is completely filled), then the network with demands has a valid flow, and the actual flow can be easily reconstructed from the new network.\nOtherwise there doesn't exist a flow that satisfies all conditions.\nSince a saturating flow has to be a maximum flow, it can be found by any maximum flow algorithm, like the [Edmonds-Karp algorithm](edmonds_karp.md) or the [Push-relabel algorithm](push-relabel.md).\n\nThe correctness of these transformations is more difficult to understand.\nWe can think of it in the following way:\nEach edge $e = (u, v)$ with $d(e) > 0$ is originally replaced by two edges: one with the capacity $d(i)$ , and the other with $c(i) - d(i)$.\nWe want to find a flow that saturates the first edge (i.e. the flow along this edge must be equal to its capacity).\nThe second edge is less important - the flow along it can be anything, assuming that it doesn't exceed its capacity.\nConsider each edge that has to be saturated, and we perform the following operation:\nwe draw the edge from the new source $s'$ to its end $v$, draw the edge from its start $u$ to the new sink $t'$, remove the edge itself, and from the old sink $t$ to the old source $s$ we draw an edge of infinite capacity.\nBy these actions we simulate the fact that this edge is saturated - from $v$ there will be an additionally $d(e)$ flow outgoing (we simulate it with a new source that feeds the right amount of flow to $v$), and $u$ will also push $d(e)$ additional flow (but instead along the old edge, this flow will go directly to the new sink $t'$).\nA flow with the value $d(e)$, that originally flowed along the path $s - \\dots - u - v - \\dots t$ can now take the new path $s' - v - \\dots - t - s - \\dots - u - t'$.\nThe only thing that got simplified in the definition of the new network, is that if procedure created multiple edges between the same pair of vertices, then they are combined to one single edge with the summed capacity.\n\n## Minimal flow\n\nNote that along the edge $(t, s)$ (from the old sink to the old source) with the capacity $\\infty$ flows the entire flow of the corresponding old network.\nI.e. the capacity of this edge effects the flow value of the old network.\nBy giving this edge a sufficient large capacity (i.e. $\\infty$), the flow of the old network is unlimited.\nBy limiting this edge by smaller capacities, the flow value will decrease.\nHowever if we limit this edge by a too small value, than the network will not have a saturated solution, e.g. the corresponding solution for the original network will not satisfy the demand of the edges.\nObviously here can use a binary search to find the lowest value with which all constraints are still satisfied.\nThis gives the minimal flow of the original network.\n", "problem_ids": [], "title": "Flows with demands"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: fixed_length_paths\n---\n\n# Number of paths of fixed length / Shortest paths of fixed length\n\nThe following article describes solutions to these two problems built on the same idea:\nreduce the problem to the construction of matrix and compute the solution with the usual matrix multiplication or with a modified multiplication.\n\n## Number of paths of a fixed length\n\nWe are given a directed, unweighted graph $G$ with $n$ vertices and we are given an integer $k$.\nThe task is the following:\nfor each pair of vertices $(i, j)$ we have to find the number of paths of length $k$ between these vertices.\nPaths don't have to be simple, i.e. vertices and edges can be visited any number of times in a single path.\n\nWe assume that the graph is specified with an adjacency matrix, i.e. the matrix $G[][]$ of size $n \\times n$, where each element $G[i][j]$ equal to $1$ if the vertex $i$ is connected with $j$ by an edge, and $0$ is they are not connected by an edge.\nThe following algorithm works also in the case of multiple edges:\nif some pair of vertices $(i, j)$ is connected with $m$ edges, then we can record this in the adjacency matrix by setting $G[i][j] = m$.\nAlso the algorithm works if the graph contains loops (a loop is an edge that connect a vertex with itself).\n\nIt is obvious that the constructed adjacency matrix if the answer to the problem for the case $k = 1$.\nIt contains the number of paths of length $1$ between each pair of vertices.\n\nWe will build the solution iteratively:\nLet's assume we know the answer for some $k$.\nHere we describe a method how we can construct the answer for $k + 1$.\nDenote by $C_k$ the matrix for the case $k$, and by $C_{k+1}$ the matrix we want to construct.\nWith the following formula we can compute every entry of $C_{k+1}$:\n\n$$C_{k+1}[i][j] = \\sum_{p = 1}^{n} C_k[i][p] \\cdot G[p][j]$$\n\nIt is easy to see that the formula computes nothing other than the product of the matrices $C_k$ and $G$:\n\n$$C_{k+1} = C_k \\cdot G$$\n\nThus the solution of the problem can be represented as follows:\n\n$$C_k = \\underbrace{G \\cdot G \\cdots G}_{k \\text{ times}} = G^k$$\n\nIt remains to note that the matrix products can be raised to a high power efficiently using [Binary exponentiation](../algebra/binary-exp.md).\nThis gives a solution with $O(n^3 \\log k)$ complexity.\n\n## Shortest paths of a fixed length\n\nWe are given a directed weighted graph $G$ with $n$ vertices and an integer $k$.\nFor each pair of vertices $(i, j)$ we have to find the length of the shortest path between $i$ and $j$ that consists of exactly $k$ edges.\n\nWe assume that the graph is specified by an adjacency matrix, i.e. via the matrix $G[][]$ of size $n \\times n$ where each element $G[i][j]$ contains the length of the edges from the vertex $i$ to the vertex $j$.\nIf there is no edge between two vertices, then the corresponding element of the matrix will be assigned to infinity $\\infty$.\n\nIt is obvious that in this form the adjacency matrix is the answer to the problem for $k = 1$.\nIt contains the lengths of shortest paths between each pair of vertices, or $\\infty$ if a path consisting of one edge doesn't exist.\n\nAgain we can build the solution to the problem iteratively:\nLet's assume we know the answer for some $k$.\nWe show how we can compute the answer for $k+1$.\nLet us denote $L_k$ the matrix for $k$ and $L_{k+1}$ the matrix we want to build.\nThen the following formula computes each entry of $L_{k+1}$:\n\n$$L_{k+1}[i][j] = \\min_{p = 1 \\ldots n} \\left(L_k[i][p] + G[p][j]\\right)$$\n\nWhen looking closer at this formula, we can draw an analogy with the matrix multiplication:\nin fact the matrix $L_k$ is multiplied by the matrix $G$, the only difference is that instead in the multiplication operation we take the minimum instead of the sum.\n\n$$L_{k+1} = L_k \\odot G,$$\n\nwhere the operation $\\odot$ is defined as follows:\n\n$$A \\odot B = C~~\\Longleftrightarrow~~C_{i j} = \\min_{p = 1 \\ldots n}\\left(A_{i p} + B_{p j}\\right)$$\n\nThus the solution of the task can be represented using the modified multiplication:\n\n$$L_k = \\underbrace{G \\odot \\ldots \\odot G}_{k~\\text{times}} = G^{\\odot k}$$\n\nIt remains to note that we also can compute this exponentiation efficiently with [Binary exponentiation](../algebra/binary-exp.md), because the modified multiplication is obviously associative.\nSo also this solution has $O(n^3 \\log k)$ complexity.\n\n## Generalization of the problems for paths with length up to $k$ {data-toc-label=\"Generalization of the problems for paths with length up to k\"}\n\nThe above solutions solve the problems for a fixed $k$.\nHowever the solutions can be adapted for solving problems for which the paths are allowed to contain no more than $k$ edges.\n\nThis can be done by slightly modifying the input graph.\n\nWe duplicate each vertex:\nfor each vertex $v$ we create one more vertex $v'$ and add the edge $(v, v')$ and the loop $(v', v')$.\nThe number of paths between $i$ and $j$ with at most $k$ edges is the same number as the number of paths between $i$ and $j'$ with exactly $k + 1$ edges, since there is a bijection that maps every path $[p_0 = i,~p_1,~\\ldots,~p_{m-1},~p_m = j]$ of length $m \\le k$ to the path $[p_0 = i,~p_1,~\\ldots,~p_{m-1},~p_m = j, j', \\ldots, j']$ of length $k + 1$.\n\nThe same trick can be applied to compute the shortest paths with at most $k$ edges.\nWe again duplicate each vertex and add the two mentioned edges with weight $0$.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: fixed_length_paths\n---\n\n# Number of paths of fixed length / Shortest paths of fixed length\n\nThe following article describes solutions to these two problems built on the same idea:\nreduce the problem to the construction of matrix and compute the solution with the usual matrix multiplication or with a modified multiplication.\n\n## Number of paths of a fixed length\n\nWe are given a directed, unweighted graph $G$ with $n$ vertices and we are given an integer $k$.\nThe task is the following:\nfor each pair of vertices $(i, j)$ we have to find the number of paths of length $k$ between these vertices.\nPaths don't have to be simple, i.e. vertices and edges can be visited any number of times in a single path.\n\nWe assume that the graph is specified with an adjacency matrix, i.e. the matrix $G[][]$ of size $n \\times n$, where each element $G[i][j]$ equal to $1$ if the vertex $i$ is connected with $j$ by an edge, and $0$ is they are not connected by an edge.\nThe following algorithm works also in the case of multiple edges:\nif some pair of vertices $(i, j)$ is connected with $m$ edges, then we can record this in the adjacency matrix by setting $G[i][j] = m$.\nAlso the algorithm works if the graph contains loops (a loop is an edge that connect a vertex with itself).\n\nIt is obvious that the constructed adjacency matrix if the answer to the problem for the case $k = 1$.\nIt contains the number of paths of length $1$ between each pair of vertices.\n\nWe will build the solution iteratively:\nLet's assume we know the answer for some $k$.\nHere we describe a method how we can construct the answer for $k + 1$.\nDenote by $C_k$ the matrix for the case $k$, and by $C_{k+1}$ the matrix we want to construct.\nWith the following formula we can compute every entry of $C_{k+1}$:\n\n$$C_{k+1}[i][j] = \\sum_{p = 1}^{n} C_k[i][p] \\cdot G[p][j]$$\n\nIt is easy to see that the formula computes nothing other than the product of the matrices $C_k$ and $G$:\n\n$$C_{k+1} = C_k \\cdot G$$\n\nThus the solution of the problem can be represented as follows:\n\n$$C_k = \\underbrace{G \\cdot G \\cdots G}_{k \\text{ times}} = G^k$$\n\nIt remains to note that the matrix products can be raised to a high power efficiently using [Binary exponentiation](../algebra/binary-exp.md).\nThis gives a solution with $O(n^3 \\log k)$ complexity.\n\n## Shortest paths of a fixed length\n\nWe are given a directed weighted graph $G$ with $n$ vertices and an integer $k$.\nFor each pair of vertices $(i, j)$ we have to find the length of the shortest path between $i$ and $j$ that consists of exactly $k$ edges.\n\nWe assume that the graph is specified by an adjacency matrix, i.e. via the matrix $G[][]$ of size $n \\times n$ where each element $G[i][j]$ contains the length of the edges from the vertex $i$ to the vertex $j$.\nIf there is no edge between two vertices, then the corresponding element of the matrix will be assigned to infinity $\\infty$.\n\nIt is obvious that in this form the adjacency matrix is the answer to the problem for $k = 1$.\nIt contains the lengths of shortest paths between each pair of vertices, or $\\infty$ if a path consisting of one edge doesn't exist.\n\nAgain we can build the solution to the problem iteratively:\nLet's assume we know the answer for some $k$.\nWe show how we can compute the answer for $k+1$.\nLet us denote $L_k$ the matrix for $k$ and $L_{k+1}$ the matrix we want to build.\nThen the following formula computes each entry of $L_{k+1}$:\n\n$$L_{k+1}[i][j] = \\min_{p = 1 \\ldots n} \\left(L_k[i][p] + G[p][j]\\right)$$\n\nWhen looking closer at this formula, we can draw an analogy with the matrix multiplication:\nin fact the matrix $L_k$ is multiplied by the matrix $G$, the only difference is that instead in the multiplication operation we take the minimum instead of the sum.\n\n$$L_{k+1} = L_k \\odot G,$$\n\nwhere the operation $\\odot$ is defined as follows:\n\n$$A \\odot B = C~~\\Longleftrightarrow~~C_{i j} = \\min_{p = 1 \\ldots n}\\left(A_{i p} + B_{p j}\\right)$$\n\nThus the solution of the task can be represented using the modified multiplication:\n\n$$L_k = \\underbrace{G \\odot \\ldots \\odot G}_{k~\\text{times}} = G^{\\odot k}$$\n\nIt remains to note that we also can compute this exponentiation efficiently with [Binary exponentiation](../algebra/binary-exp.md), because the modified multiplication is obviously associative.\nSo also this solution has $O(n^3 \\log k)$ complexity.\n\n## Generalization of the problems for paths with length up to $k$ {data-toc-label=\"Generalization of the problems for paths with length up to k\"}\n\nThe above solutions solve the problems for a fixed $k$.\nHowever the solutions can be adapted for solving problems for which the paths are allowed to contain no more than $k$ edges.\n\nThis can be done by slightly modifying the input graph.\n\nWe duplicate each vertex:\nfor each vertex $v$ we create one more vertex $v'$ and add the edge $(v, v')$ and the loop $(v', v')$.\nThe number of paths between $i$ and $j$ with at most $k$ edges is the same number as the number of paths between $i$ and $j'$ with exactly $k + 1$ edges, since there is a bijection that maps every path $[p_0 = i,~p_1,~\\ldots,~p_{m-1},~p_m = j]$ of length $m \\le k$ to the path $[p_0 = i,~p_1,~\\ldots,~p_{m-1},~p_m = j, j', \\ldots, j']$ of length $k + 1$.\n\nThe same trick can be applied to compute the shortest paths with at most $k$ edges.\nWe again duplicate each vertex and add the two mentioned edges with weight $0$.\n", "problem_ids": [], "title": "Number of paths of fixed length / Shortest paths of fixed length"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: kuhn_matching\n---\n\n# Kuhn's Algorithm for Maximum Bipartite Matching\n\n## Problem\nYou are given a bipartite graph $G$ containing $n$ vertices and $m$ edges. Find the maximum matching, i.e., select as many edges as possible so \nthat no selected edge shares a vertex with any other selected edge.\n\n## Algorithm Description\n\n### Required Definitions\n\n* A **matching** $M$ is a set of pairwise non-adjacent edges of a graph (in other words, no more than one edge from the set should be incident to any vertex of the graph $M$). \nThe **cardinality** of a matching is the number of edges in it.\nAll those vertices that have an adjacent edge from the matching (i.e., which have degree exactly one in the subgraph formed by $M$) are called **saturated** \nby this matching.\n\n* A **maximal matching** is a matching $M$ of a graph $G$ that is not a subset of any other matching.\n\n* A **maximum matching** (also known as maximum-cardinality matching) is a matching that contains the largest possible number of edges. Every maximum matching is a maximal matching.\n\n* A **path** of length $k$ here means a *simple* path (i.e. not containing repeated vertices or edges) containing $k$ edges, unless specified otherwise.\n\n* An **alternating path** (in a bipartite graph, with respect to some matching) is a path in which the edges alternately belong / do not belong to the matching.\n\n* An **augmenting path** (in a bipartite graph, with respect to some matching) is an alternating path whose initial and final vertices are unsaturated, i.e., \nthey do not belong in the matching. \n\n* The **symmetric difference** (also known as the **disjunctive union**) of sets $A$ and $B$, represented by $A \\oplus B$, is the set of all elements that belong to exactly one of $A$ or $B$, but not to both. \nThat is, $A \\oplus B = (A - B) \\cup (B - A) = (A \\cup B) - (A \\cap B)$.\n\n### Berge's lemma\n\nThis lemma was proven by the French mathematician **Claude Berge** in 1957, although it already was observed by the Danish mathematician **Julius Petersen** in 1891 and \nthe Hungarian mathematician **Den\u00e9s K\u0151nig** in 1931.\n\n#### Formulation \nA matching $M$ is maximum $\\Leftrightarrow$ there is no augmenting path relative to the matching $M$.\n\n#### Proof\n\nBoth sides of the bi-implication will be proven by contradiction.\n\n1.  A matching $M$ is maximum $\\Rightarrow$ there is no augmenting path relative to the matching $M$.\n  \n    Let there be an augmenting path $P$ relative to the given maximum matching $M$. This augmenting path $P$ will necessarily be of odd length, having one more edge not in $M$ than the number of edges it has that are also in $M$. \n    We create a new matching $M'$ by including all edges in the original matching $M$ except those also in the $P$, and the edges in $P$ that are not in $M$. \n    This is a valid matching because the initial and final vertices of $P$ are unsaturated by $M$, and the rest of the vertices are saturated only by the matching $P \\cap M$.\n    This new matching $M'$ will have one more edge than $M$, and so $M$ could not have been maximum. \n    \n    Formally, given an augmenting path $P$ w.r.t. some maximum matching $M$, the matching $M' = P \\oplus M$ is such that $|M'| = |M| + 1$, a contradiction.\n  \n2.  A matching $M$ is maximum $\\Leftarrow$ there is no augmenting path relative to the matching $M$.\n\n    Let there be a matching $M'$ of greater cardinality than $M$. We consider the symmetric difference $Q = M \\oplus M'$. The subgraph $Q$ is no longer necessarily a matching. \n    Any vertex in $Q$ has a maximum degree of $2$, which means that all connected components in it are one of the three - \n\n      * an isolated vertex\n      * a (simple) path whose edges are alternately from $M$ and $M'$\n      * a cycle of even length whose edges are alternately from $M$ and $M'$\n \n    Since $M'$ has a cardinality greater than $M$, $Q$ has more edges from $M'$ than $M$. By the Pigeonhole principle, at least one connected component will be a path having \n    more edges from $M'$ than $M$. Because any such path is alternating, it will have initial and final vertices unsaturated by $M$, making it an augmenting path for $M$, \n    which contradicts the premise. &ensp; $\\blacksquare$\n  \n### Kuhn's algorithm\n  \nKuhn's algorithm is a direct application of Berge's lemma. It is essentially described as follows: \n\nFirst, we take an empty matching. Then, while the algorithm is able to find an augmenting path, we update the matching by alternating it along this path and repeat the process of finding the augmenting path.  As soon as it is not possible to find such a path, we stop the process - the current matching is the maximum. \n\nIt remains to detail the way to find augmenting paths. Kuhn's algorithm simply searches for any of these paths using [depth-first](depth-first-search.md) or [breadth-first](breadth-first-search.md) traversal. The algorithm \nlooks through all the vertices of the graph in turn, starting each traversal from it, trying to find an augmenting path starting at this vertex.\n\nThe algorithm is more convenient to describe if we assume that the input graph is already split into two parts (although, in fact, the algorithm can be implemented in such a way \nthat the input graph is not explicitly split into two parts).\n\nThe algorithm looks at all the vertices $v$ of the first part of the graph: $v = 1 \\ldots n_1$. If the current vertex $v$ is already saturated with the current matching \n(i.e., some edge adjacent to it has already been selected), then skip this vertex. Otherwise, the algorithm tries to saturate this vertex, for which it starts \na search for an augmenting path starting from this vertex.\n\nThe search for an augmenting path is carried out using a special depth-first or breadth-first traversal (usually depth-first traversal is used for ease of implementation). \nInitially, the depth-first traversal is at the current unsaturated vertex $v$ of the first part. Let's look through all edges from this vertex. Let the current edge be an edge \n$(v, to)$. If the vertex $to$ is not yet saturated with matching, then we have succeeded in finding an augmenting path: it consists of a single edge $(v, to)$; \nin this case, we simply include this edge in the matching and stop searching for the augmenting path from the vertex $v$. Otherwise, if $to$ is already saturated with some edge \n$(to, p)$, \nthen will go along this edge: thus we will try to find an augmenting path passing through the edges $(v, to),(to, p), \\ldots$. \nTo do this, simply go to the vertex $p$ in our traversal - now we try to find an augmenting path from this vertex.\n\nSo, this traversal, launched from the vertex $v$, will either find an augmenting path, and thereby saturate the vertex $v$, or it will not find such an augmenting path (and, therefore, this vertex $v$ cannot be saturated).\n\nAfter all the vertices $v = 1 \\ldots n_1$ have been scanned, the current matching will be maximum.\n  \n### Running time\n\nKuhn's algorithm can be thought of as a series of $n$ depth/breadth-first traversal runs on the entire graph. Therefore, the whole algorithm is executed in time $O(nm)$, which\nin the worst case is $O(n^3)$.\n\nHowever, this estimate can be improved slightly. It turns out that for Kuhn's algorithm, it is important which part of the graph is chosen as the first and which as the second. \nIndeed, in the implementation described above, the depth/breadth-first traversal starts only from the vertices of the first part, so the entire algorithm is executed in \ntime $O(n_1m)$, where $n_1$ is the number of vertices of the first part. In the worst case, this is $O(n_1 ^ 2 n_2)$ (where $n_2$ is the number of vertices of the second part). \nThis shows that it is more profitable when the first part contains fewer vertices than the second. On very unbalanced graphs (when $n_1$ and $n_2$ are very different), \nthis translates into a significant difference in runtimes.\n\n## Implementation\n\n### Standard implementation\nLet us present here an implementation of the above algorithm based on depth-first traversal and accepting a bipartite graph in the form of a graph explicitly split into two parts.\nThis implementation is very concise, and perhaps it should be remembered in this form.\n\nHere $n$ is the number of vertices in the first part, $k$ - in the second part, $g[v]$ is the list of edges from the top of the first part (i.e. the list of numbers of the \nvertices to which these edges lead from $v$). The vertices in both parts are numbered independently, i.e. vertices in the first part are numbered $1 \\ldots n$, and those in the \nsecond are numbered $1 \\ldots k$.\n\nThen there are two auxiliary arrays: $\\rm mt$ and $\\rm used$. The first - $\\rm mt$ - contains information about the current matching. For convenience of programming, \nthis information is contained only for the vertices of the second part: $\\textrm{mt[} i \\rm]$ - this is the number of the vertex of the first part connected by an edge with the vertex $i$ of \nthe second part (or $-1$, if no matching edge comes out of it). The second array is $\\rm used$: the usual array of \"visits\" to the vertices in the depth-first traversal \n(it is needed just so that the depth-first traversal does not enter the same vertex twice).\n\nA function $\\textrm{try_kuhn}$ is a depth-first traversal. It returns $\\rm true$ if it was able to find an augmenting path from the vertex $v$, and it is considered that this \nfunction has already performed the alternation of matching along the found chain.\n\nInside the function, all the edges outgoing from the vertex $v$ of the first part are scanned, and then the following is checked: if this edge leads to an unsaturated vertex \n$to$, or if this vertex $to$ is saturated, but it is possible to find an increasing chain by recursively starting from $\\textrm{mt[}to \\rm ]$, then we say that we have found an \naugmenting path, and before returning from the function with the result $\\rm true$, we alternate the current edge: we redirect the edge adjacent to $to$ to the vertex $v$.\n\nThe main program first indicates that the current matching is empty (the list $\\rm mt$ is filled with numbers $-1$). Then the vertex $v$ of the first part is searched by $\\textrm{try_kuhn}$, \nand a depth-first traversal is started from it, having previously zeroed the array $\\rm used$.\n\nIt is worth noting that the size of the matching is easy to get as the number of calls $\\textrm{try_kuhn}$ in the main program that returned the result $\\rm true$. The desired \nmaximum matching itself is contained in the array $\\rm mt$.\n\n```cpp\nint n, k;\nvector<vector<int>> g;\nvector<int> mt;\nvector<bool> used;\n\nbool try_kuhn(int v) {\n    if (used[v])\n        return false;\n    used[v] = true;\n    for (int to : g[v]) {\n        if (mt[to] == -1 || try_kuhn(mt[to])) {\n            mt[to] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    //... reading the graph ...\n\n    mt.assign(k, -1);\n    for (int v = 0; v < n; ++v) {\n        used.assign(n, false);\n        try_kuhn(v);\n    }\n\n    for (int i = 0; i < k; ++i)\n        if (mt[i] != -1)\n            printf(\"%d %d\\n\", mt[i] + 1, i + 1);\n}\n```\n    \nWe repeat once again that Kuhn's algorithm is easy to implement in such a way that it works on graphs that are known to be bipartite, but their explicit splitting into two parts \nhas not been given. In this case, it will be necessary to abandon the convenient division into two parts, and store all the information for all vertices of the graph. For this, \nan array of lists $g$ is now specified not only for the vertices of the first part, but for all the vertices of the graph (of course, now the vertices of both parts are numbered \nin a common numbering - from $1$ to $n$). Arrays $\\rm mt$ and are $\\rm used$ are now also defined for the vertices of both parts, and, accordingly, they need to be kept in this state.\n\n### Improved implementation\n\nLet us modify the algorithm as follows. Before the main loop of the algorithm, we will find an **arbitrary matching** by some simple algorithm (a simple **heuristic algorithm**), \nand only then we will execute a loop with calls to the $\\textrm{try_kuhn}()$ function, which will improve this matching. As a result, the algorithm will work noticeably faster on \nrandom graphs - because in most graphs, you can easily find a matching of a sufficiently large size using heuristics, and then improve the found matching to the maximum using \nthe usual Kuhn's algorithm. Thus, we will save on launching a depth-first traversal from those vertices that we have already included using the heuristic into the current matching.\n\nFor example, you can simply iterate over all the vertices of the first part, and for each of them, find an arbitrary edge that can be added to the matching, and add it. \nEven such a simple heuristic can speed up Kuhn's algorithm several times.\n\nPlease note that the main loop will have to be slightly modified. Since when calling the function $\\textrm{try_kuhn}$ in the main loop, it is assumed that the current vertex is \nnot yet included in the matching, you need to add an appropriate check.\n\nIn the implementation, only the code in the $\\textrm{main}()$ function will change:\n\n```cpp\nint main() {\n    // ... reading the graph ...\n\n    mt.assign(k, -1);\n    vector<bool> used1(n, false);\n    for (int v = 0; v < n; ++v) {\n        for (int to : g[v]) {\n            if (mt[to] == -1) {\n                mt[to] = v;\n                used1[v] = true;\n                break;\n            }\n        }\n    }\n    for (int v = 0; v < n; ++v) {\n        if (used1[v])\n            continue;\n        used.assign(n, false);\n        try_kuhn(v);\n    }\n\n    for (int i = 0; i < k; ++i)\n        if (mt[i] != -1)\n            printf(\"%d %d\\n\", mt[i] + 1, i + 1);\n}\n```\n\n**Another good heuristic** is as follows. At each step, it will search for the vertex of the smallest degree (but not isolated), select any edge from it and add it to the matching,\nthen remove both these vertices with all incident edges from the graph. Such greed works very well on random graphs; in many cases it even builds the maximum matching (although \nthere is a test case against it, on which it will find a matching that is much smaller than the maximum).\n\n## Notes\n\n* Kuhn's algorithm is a subroutine in the **Hungarian algorithm**, also known as the **Kuhn-Munkres algorithm**.\n* Kuhn's algorithm runs in $O(nm)$ time. It is generally simple to implement, however, more efficient algorithms exist for the maximum bipartite matching problem - such as the \n    **Hopcroft-Karp-Karzanov algorithm**, which runs in $O(\\sqrt{n}m)$ time.\n* The [minimum vertex cover problem](https://en.wikipedia.org/wiki/Vertex_cover) is NP-hard for general graphs.  However, [K\u0151nig's theorem](https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory)) gives that, for bipartite graphs, the cardinality of the maximum matching equals the cardinality of the minimum vertex cover.  Hence, we can use maximum bipartite matching algorithms to solve the minimum vertex cover problem in polynomial time for bipartite graphs.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: kuhn_matching\n---\n\n# Kuhn's Algorithm for Maximum Bipartite Matching\n\n## Problem\nYou are given a bipartite graph $G$ containing $n$ vertices and $m$ edges. Find the maximum matching, i.e., select as many edges as possible so \nthat no selected edge shares a vertex with any other selected edge.\n\n## Algorithm Description\n\n### Required Definitions\n\n* A **matching** $M$ is a set of pairwise non-adjacent edges of a graph (in other words, no more than one edge from the set should be incident to any vertex of the graph $M$). \nThe **cardinality** of a matching is the number of edges in it.\nAll those vertices that have an adjacent edge from the matching (i.e., which have degree exactly one in the subgraph formed by $M$) are called **saturated** \nby this matching.\n\n* A **maximal matching** is a matching $M$ of a graph $G$ that is not a subset of any other matching.\n\n* A **maximum matching** (also known as maximum-cardinality matching) is a matching that contains the largest possible number of edges. Every maximum matching is a maximal matching.\n\n* A **path** of length $k$ here means a *simple* path (i.e. not containing repeated vertices or edges) containing $k$ edges, unless specified otherwise.\n\n* An **alternating path** (in a bipartite graph, with respect to some matching) is a path in which the edges alternately belong / do not belong to the matching.\n\n* An **augmenting path** (in a bipartite graph, with respect to some matching) is an alternating path whose initial and final vertices are unsaturated, i.e., \nthey do not belong in the matching. \n\n* The **symmetric difference** (also known as the **disjunctive union**) of sets $A$ and $B$, represented by $A \\oplus B$, is the set of all elements that belong to exactly one of $A$ or $B$, but not to both. \nThat is, $A \\oplus B = (A - B) \\cup (B - A) = (A \\cup B) - (A \\cap B)$.\n\n### Berge's lemma\n\nThis lemma was proven by the French mathematician **Claude Berge** in 1957, although it already was observed by the Danish mathematician **Julius Petersen** in 1891 and \nthe Hungarian mathematician **Den\u00e9s K\u0151nig** in 1931.\n\n#### Formulation \nA matching $M$ is maximum $\\Leftrightarrow$ there is no augmenting path relative to the matching $M$.\n\n#### Proof\n\nBoth sides of the bi-implication will be proven by contradiction.\n\n1.  A matching $M$ is maximum $\\Rightarrow$ there is no augmenting path relative to the matching $M$.\n  \n    Let there be an augmenting path $P$ relative to the given maximum matching $M$. This augmenting path $P$ will necessarily be of odd length, having one more edge not in $M$ than the number of edges it has that are also in $M$. \n    We create a new matching $M'$ by including all edges in the original matching $M$ except those also in the $P$, and the edges in $P$ that are not in $M$. \n    This is a valid matching because the initial and final vertices of $P$ are unsaturated by $M$, and the rest of the vertices are saturated only by the matching $P \\cap M$.\n    This new matching $M'$ will have one more edge than $M$, and so $M$ could not have been maximum. \n    \n    Formally, given an augmenting path $P$ w.r.t. some maximum matching $M$, the matching $M' = P \\oplus M$ is such that $|M'| = |M| + 1$, a contradiction.\n  \n2.  A matching $M$ is maximum $\\Leftarrow$ there is no augmenting path relative to the matching $M$.\n\n    Let there be a matching $M'$ of greater cardinality than $M$. We consider the symmetric difference $Q = M \\oplus M'$. The subgraph $Q$ is no longer necessarily a matching. \n    Any vertex in $Q$ has a maximum degree of $2$, which means that all connected components in it are one of the three - \n\n      * an isolated vertex\n      * a (simple) path whose edges are alternately from $M$ and $M'$\n      * a cycle of even length whose edges are alternately from $M$ and $M'$\n \n    Since $M'$ has a cardinality greater than $M$, $Q$ has more edges from $M'$ than $M$. By the Pigeonhole principle, at least one connected component will be a path having \n    more edges from $M'$ than $M$. Because any such path is alternating, it will have initial and final vertices unsaturated by $M$, making it an augmenting path for $M$, \n    which contradicts the premise. &ensp; $\\blacksquare$\n  \n### Kuhn's algorithm\n  \nKuhn's algorithm is a direct application of Berge's lemma. It is essentially described as follows: \n\nFirst, we take an empty matching. Then, while the algorithm is able to find an augmenting path, we update the matching by alternating it along this path and repeat the process of finding the augmenting path.  As soon as it is not possible to find such a path, we stop the process - the current matching is the maximum. \n\nIt remains to detail the way to find augmenting paths. Kuhn's algorithm simply searches for any of these paths using [depth-first](depth-first-search.md) or [breadth-first](breadth-first-search.md) traversal. The algorithm \nlooks through all the vertices of the graph in turn, starting each traversal from it, trying to find an augmenting path starting at this vertex.\n\nThe algorithm is more convenient to describe if we assume that the input graph is already split into two parts (although, in fact, the algorithm can be implemented in such a way \nthat the input graph is not explicitly split into two parts).\n\nThe algorithm looks at all the vertices $v$ of the first part of the graph: $v = 1 \\ldots n_1$. If the current vertex $v$ is already saturated with the current matching \n(i.e., some edge adjacent to it has already been selected), then skip this vertex. Otherwise, the algorithm tries to saturate this vertex, for which it starts \na search for an augmenting path starting from this vertex.\n\nThe search for an augmenting path is carried out using a special depth-first or breadth-first traversal (usually depth-first traversal is used for ease of implementation). \nInitially, the depth-first traversal is at the current unsaturated vertex $v$ of the first part. Let's look through all edges from this vertex. Let the current edge be an edge \n$(v, to)$. If the vertex $to$ is not yet saturated with matching, then we have succeeded in finding an augmenting path: it consists of a single edge $(v, to)$; \nin this case, we simply include this edge in the matching and stop searching for the augmenting path from the vertex $v$. Otherwise, if $to$ is already saturated with some edge \n$(to, p)$, \nthen will go along this edge: thus we will try to find an augmenting path passing through the edges $(v, to),(to, p), \\ldots$. \nTo do this, simply go to the vertex $p$ in our traversal - now we try to find an augmenting path from this vertex.\n\nSo, this traversal, launched from the vertex $v$, will either find an augmenting path, and thereby saturate the vertex $v$, or it will not find such an augmenting path (and, therefore, this vertex $v$ cannot be saturated).\n\nAfter all the vertices $v = 1 \\ldots n_1$ have been scanned, the current matching will be maximum.\n  \n### Running time\n\nKuhn's algorithm can be thought of as a series of $n$ depth/breadth-first traversal runs on the entire graph. Therefore, the whole algorithm is executed in time $O(nm)$, which\nin the worst case is $O(n^3)$.\n\nHowever, this estimate can be improved slightly. It turns out that for Kuhn's algorithm, it is important which part of the graph is chosen as the first and which as the second. \nIndeed, in the implementation described above, the depth/breadth-first traversal starts only from the vertices of the first part, so the entire algorithm is executed in \ntime $O(n_1m)$, where $n_1$ is the number of vertices of the first part. In the worst case, this is $O(n_1 ^ 2 n_2)$ (where $n_2$ is the number of vertices of the second part). \nThis shows that it is more profitable when the first part contains fewer vertices than the second. On very unbalanced graphs (when $n_1$ and $n_2$ are very different), \nthis translates into a significant difference in runtimes.\n\n## Implementation\n\n### Standard implementation\nLet us present here an implementation of the above algorithm based on depth-first traversal and accepting a bipartite graph in the form of a graph explicitly split into two parts.\nThis implementation is very concise, and perhaps it should be remembered in this form.\n\nHere $n$ is the number of vertices in the first part, $k$ - in the second part, $g[v]$ is the list of edges from the top of the first part (i.e. the list of numbers of the \nvertices to which these edges lead from $v$). The vertices in both parts are numbered independently, i.e. vertices in the first part are numbered $1 \\ldots n$, and those in the \nsecond are numbered $1 \\ldots k$.\n\nThen there are two auxiliary arrays: $\\rm mt$ and $\\rm used$. The first - $\\rm mt$ - contains information about the current matching. For convenience of programming, \nthis information is contained only for the vertices of the second part: $\\textrm{mt[} i \\rm]$ - this is the number of the vertex of the first part connected by an edge with the vertex $i$ of \nthe second part (or $-1$, if no matching edge comes out of it). The second array is $\\rm used$: the usual array of \"visits\" to the vertices in the depth-first traversal \n(it is needed just so that the depth-first traversal does not enter the same vertex twice).\n\nA function $\\textrm{try_kuhn}$ is a depth-first traversal. It returns $\\rm true$ if it was able to find an augmenting path from the vertex $v$, and it is considered that this \nfunction has already performed the alternation of matching along the found chain.\n\nInside the function, all the edges outgoing from the vertex $v$ of the first part are scanned, and then the following is checked: if this edge leads to an unsaturated vertex \n$to$, or if this vertex $to$ is saturated, but it is possible to find an increasing chain by recursively starting from $\\textrm{mt[}to \\rm ]$, then we say that we have found an \naugmenting path, and before returning from the function with the result $\\rm true$, we alternate the current edge: we redirect the edge adjacent to $to$ to the vertex $v$.\n\nThe main program first indicates that the current matching is empty (the list $\\rm mt$ is filled with numbers $-1$). Then the vertex $v$ of the first part is searched by $\\textrm{try_kuhn}$, \nand a depth-first traversal is started from it, having previously zeroed the array $\\rm used$.\n\nIt is worth noting that the size of the matching is easy to get as the number of calls $\\textrm{try_kuhn}$ in the main program that returned the result $\\rm true$. The desired \nmaximum matching itself is contained in the array $\\rm mt$.\n\n```cpp\nint n, k;\nvector<vector<int>> g;\nvector<int> mt;\nvector<bool> used;\n\nbool try_kuhn(int v) {\n    if (used[v])\n        return false;\n    used[v] = true;\n    for (int to : g[v]) {\n        if (mt[to] == -1 || try_kuhn(mt[to])) {\n            mt[to] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    //... reading the graph ...\n\n    mt.assign(k, -1);\n    for (int v = 0; v < n; ++v) {\n        used.assign(n, false);\n        try_kuhn(v);\n    }\n\n    for (int i = 0; i < k; ++i)\n        if (mt[i] != -1)\n            printf(\"%d %d\\n\", mt[i] + 1, i + 1);\n}\n```\n    \nWe repeat once again that Kuhn's algorithm is easy to implement in such a way that it works on graphs that are known to be bipartite, but their explicit splitting into two parts \nhas not been given. In this case, it will be necessary to abandon the convenient division into two parts, and store all the information for all vertices of the graph. For this, \nan array of lists $g$ is now specified not only for the vertices of the first part, but for all the vertices of the graph (of course, now the vertices of both parts are numbered \nin a common numbering - from $1$ to $n$). Arrays $\\rm mt$ and are $\\rm used$ are now also defined for the vertices of both parts, and, accordingly, they need to be kept in this state.\n\n### Improved implementation\n\nLet us modify the algorithm as follows. Before the main loop of the algorithm, we will find an **arbitrary matching** by some simple algorithm (a simple **heuristic algorithm**), \nand only then we will execute a loop with calls to the $\\textrm{try_kuhn}()$ function, which will improve this matching. As a result, the algorithm will work noticeably faster on \nrandom graphs - because in most graphs, you can easily find a matching of a sufficiently large size using heuristics, and then improve the found matching to the maximum using \nthe usual Kuhn's algorithm. Thus, we will save on launching a depth-first traversal from those vertices that we have already included using the heuristic into the current matching.\n\nFor example, you can simply iterate over all the vertices of the first part, and for each of them, find an arbitrary edge that can be added to the matching, and add it. \nEven such a simple heuristic can speed up Kuhn's algorithm several times.\n\nPlease note that the main loop will have to be slightly modified. Since when calling the function $\\textrm{try_kuhn}$ in the main loop, it is assumed that the current vertex is \nnot yet included in the matching, you need to add an appropriate check.\n\nIn the implementation, only the code in the $\\textrm{main}()$ function will change:\n\n```cpp\nint main() {\n    // ... reading the graph ...\n\n    mt.assign(k, -1);\n    vector<bool> used1(n, false);\n    for (int v = 0; v < n; ++v) {\n        for (int to : g[v]) {\n            if (mt[to] == -1) {\n                mt[to] = v;\n                used1[v] = true;\n                break;\n            }\n        }\n    }\n    for (int v = 0; v < n; ++v) {\n        if (used1[v])\n            continue;\n        used.assign(n, false);\n        try_kuhn(v);\n    }\n\n    for (int i = 0; i < k; ++i)\n        if (mt[i] != -1)\n            printf(\"%d %d\\n\", mt[i] + 1, i + 1);\n}\n```\n\n**Another good heuristic** is as follows. At each step, it will search for the vertex of the smallest degree (but not isolated), select any edge from it and add it to the matching,\nthen remove both these vertices with all incident edges from the graph. Such greed works very well on random graphs; in many cases it even builds the maximum matching (although \nthere is a test case against it, on which it will find a matching that is much smaller than the maximum).\n\n## Notes\n\n* Kuhn's algorithm is a subroutine in the **Hungarian algorithm**, also known as the **Kuhn-Munkres algorithm**.\n* Kuhn's algorithm runs in $O(nm)$ time. It is generally simple to implement, however, more efficient algorithms exist for the maximum bipartite matching problem - such as the \n    **Hopcroft-Karp-Karzanov algorithm**, which runs in $O(\\sqrt{n}m)$ time.\n* The [minimum vertex cover problem](https://en.wikipedia.org/wiki/Vertex_cover) is NP-hard for general graphs.  However, [K\u0151nig's theorem](https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory)) gives that, for bipartite graphs, the cardinality of the maximum matching equals the cardinality of the minimum vertex cover.  Hence, we can use maximum bipartite matching algorithms to solve the minimum vertex cover problem in polynomial time for bipartite graphs.\n\n## Practice Problems\n\n* [Kattis - Gopher II](https://open.kattis.com/problems/gopher2)\n* [Kattis - Borders](https://open.kattis.com/problems/borders)\n", "problem_ids": [], "title": "Kuhn's Algorithm for Maximum Bipartite Matching"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: strong_connected_components\n---\n\n# Finding strongly connected components / Building condensation graph\n\n## Definitions\nYou are given a directed graph $G$ with vertices $V$ and edges $E$. It is possible that there are loops and multiple edges. Let's denote $n$ as number of vertices and $m$ as number of edges in $G$.\n\n**Strongly connected component** is a maximal subset of vertices $C$ such that any two vertices of this subset are reachable from each other, i.e. for any $u, v \\in C$:\n\n$$u \\mapsto v, v \\mapsto u$$\n\nwhere $\\mapsto$ means reachability, i.e. existence of the path from first vertex to the second.\n\nIt is obvious, that strongly connected components do not intersect each other, i.e. this is a partition of all graph vertices. Thus we can give a definition of condensation graph $G^{SCC}$ as a graph containing every strongly connected component as one vertex. Each vertex of the condensation graph corresponds to the strongly connected component of graph $G$. There is an oriented edge between two vertices $C_i$ and $C_j$ of the condensation graph if and only if there are two vertices $u \\in C_i, v \\in C_j$ such that there is an edge in initial graph, i.e. $(u, v) \\in E$.\n\nThe most important property of the condensation graph is that it is **acyclic**. Indeed, suppose that there is an edge between $C$ and $C'$, let's prove that there is no edge from $C'$ to $C$. Suppose that $C' \\mapsto C$. Then there are two vertices $u' \\in C$ and $v' \\in C'$ such that $v' \\mapsto u'$. But since $u$ and $u'$ are in the same strongly connected component then there is a path between them; the same for $v$ and $v'$. As a result, if we join these paths we have that $v \\mapsto u$ and at the same time $u \\mapsto v$. Therefore $u$ and $v$ should be at the same strongly connected component, so this is contradiction. This completes the proof.\n\nThe algorithm described in the next section extracts all strongly connected components in a given graph. It is quite easy to build a condensation graph then.\n\n## Description of the algorithm\nDescribed algorithm was independently suggested by Kosaraju and Sharir at 1979. This is an easy-to-implement algorithm based on two series of [depth first search](depth-first-search.md), and working for $O(n + m)$ time.\n\n**On the first step** of the algorithm we are doing sequence of depth first searches, visiting the entire graph. We start at each vertex of the graph and run a depth first search from every non-visited vertex. For each vertex we are keeping track of **exit time** $tout[v]$. These exit times have a key role in an algorithm and this role is expressed in next theorem.\n\nFirst, let's make notations: let's define exit time $tout[C]$ from the strongly connected component $C$ as maximum of values $tout[v]$ by all $v \\in C$. Besides, during the proof of the theorem we will mention entry times $tin[v]$ in each vertex and in the same way consider $tin[C]$ for each strongly connected component $C$ as minimum of values $tin[v]$ by all $v \\in C$.\n\n**Theorem**. Let $C$ and $C'$ are two different strongly connected components and there is an edge $(C, C')$ in a condensation graph between these two vertices. Then $tout[C] > tout[C']$.\n\nThere are two main different cases at the proof depending on which component will be visited by depth first search first, i.e. depending on difference between $tin[C]$ and $tin[C']$:\n\n- The component $C$ was reached first. It means that depth first search comes at some vertex $v$ of component $C$ at some moment, but all other vertices of components $C$ and $C'$ were not visited yet. By condition there is an edge $(C, C')$ in a condensation graph, so not only the entire component $C$ is reachable from $v$ but the whole component $C'$ is reachable as well. It means that depth first search that is running from vertex $v$ will visit all vertices of components $C$ and $C'$, so they will be descendants for $v$ in a depth first search tree, i.e. for each vertex $u \\in C \\cup C', u \\ne v$ we have that $tout[v] > tout[u]$, as we claimed.\n\n- Assume that component $C'$ was visited first. Similarly, depth first search comes at some vertex $v$ of component $C'$ at some moment, but all other vertices of components $C$ and $C'$ were not visited yet. But by condition there is an edge $(C, C')$ in the condensation graph, so, because of acyclic property of condensation graph, there is no back path from $C'$ to $C$, i.e. depth first search from vertex $v$ will not reach vertices of $C$. It means that vertices of $C$ will be visited by depth first search later, so $tout[C] > tout[C']$. This completes the proof.\n\nProved theorem is **the base of algorithm** for finding strongly connected components. It follows that any edge $(C, C')$ in condensation graph comes from a component with a larger value of $tout$ to component with a smaller value.\n\nIf we sort all vertices $v \\in V$ in decreasing order of their exit time $tout[v]$ then the first vertex $u$ is going to be a vertex belonging to \"root\" strongly connected component, i.e. a vertex that has no incoming edges in the condensation graph. Now we want to run such search from this vertex $u$ so that it will visit all vertices in this strongly connected component, but not others; doing so, we can gradually select all strongly connected components: let's remove all vertices corresponding to the first selected component, and then let's find a vertex with the largest value of $tout$, and run this search from it, and so on.\n\nLet's consider transposed graph $G^T$, i.e. graph received from $G$ by reversing the direction of each edge.\nObviously, this graph will have the same strongly connected components as the initial graph.\nMoreover, the condensation graph $G^{SCC}$ will also get transposed.\nIt means that there will be no edges from our \"root\" component to other components.\n\nThus, for visiting the whole \"root\" strongly connected component, containing vertex $v$, is enough to run search from vertex $v$ in graph $G^T$. This search will visit all vertices of this strongly connected component and only them. As was mentioned before, we can remove these vertices from the graph then, and find the next vertex with a maximal value of $tout[v]$ and run search in transposed graph from it, and so on.\n\nThus, we built next **algorithm** for selecting strongly connected components:\n\n1st step. Run sequence of depth first search of graph $G$ which will return vertices with increasing exit time $tout$, i.e. some list $order$.\n\n2nd step. Build transposed graph $G^T$. Run a series of depth (breadth) first searches in the order determined by list $order$ (to be exact in reverse order, i.e. in decreasing order of exit times). Every set of vertices, reached after the next search, will be the next strongly connected component.\n\nAlgorithm asymptotic is $O(n + m)$, because it is just two depth (breadth) first searches.\n\nFinally, it is appropriate to mention [topological sort](topological-sort.md) here. First of all, step 1 of the algorithm represents reversed topological sort of graph $G$ (actually this is exactly what vertices' sort by exit time means). Secondly, the algorithm's scheme generates strongly connected components by decreasing order of their exit times, thus it generates components - vertices of condensation graph - in topological sort order.\n\n## Implementation\n```cpp\nvector<vector<int>> adj, adj_rev;\nvector<bool> used;\nvector<int> order, component;\n \nvoid dfs1(int v) {\n    used[v] = true;\n\n    for (auto u : adj[v])\n        if (!used[u])\n            dfs1(u);\n\n    order.push_back(v);\n}\n \nvoid dfs2(int v) {\n    used[v] = true;\n    component.push_back(v);\n\n    for (auto u : adj_rev[v])\n        if (!used[u])\n            dfs2(u);\n}\n \nint main() {\n    int n;\n    // ... read n ...\n\n    for (;;) {\n        int a, b;\n        // ... read next directed edge (a,b) ...\n        adj[a].push_back(b);\n        adj_rev[b].push_back(a);\n    }\n \n    used.assign(n, false);\n\n    for (int i = 0; i < n; i++)\n        if (!used[i])\n            dfs1(i);\n\n    used.assign(n, false);\n    reverse(order.begin(), order.end());\n\n    for (auto v : order)\n        if (!used[v]) {\n            dfs2 (v);\n\n            // ... processing next component ...\n\n            component.clear();\n        }\n}\n```\n\nHere, $g$ is graph, $gr$ is transposed graph. Function $dfs1$ implements depth first search on graph $G$, function $dfs2$ - on transposed graph $G^T$. Function $dfs1$ fills the list $order$ with vertices in increasing order of their exit times (actually, it is making a topological sort). Function $dfs2$ stores all reached vertices in list $component$, that is going to store next strongly connected component after each run.\n\n### Condensation Graph Implementation\n\n```cpp\n// continuing from previous code\n\nvector<int> roots(n, 0);\nvector<int> root_nodes;\nvector<vector<int>> adj_scc(n);\n\nfor (auto v : order)\n    if (!used[v]) {\n        dfs2(v);\n\n        int root = component.front();\n        for (auto u : component) roots[u] = root;\n        root_nodes.push_back(root);\n\n        component.clear();\n    }\n\n\nfor (int v = 0; v < n; v++)\n    for (auto u : adj[v]) {\n        int root_v = roots[v],\n            root_u = roots[u];\n\n        if (root_u != root_v)\n            adj_scc[root_v].push_back(root_u);\n    }\n```\n\nHere, we have selected the root of each component as the first node in its list. This node will represent its entire SCC in the condensation graph. `roots[v]` indicates the root node for the SCC to which node `v` belongs. `root_nodes` is the list of all root nodes (one per component) in the condensation graph. \n\n`adj_scc` is the adjacency list of the `root_nodes`. We can now traverse on `adj_scc` as our condensation graph, using only those nodes which belong to `root_nodes`.\n\n## Literature\n\n* Thomas Cormen, Charles Leiserson, Ronald Rivest, Clifford Stein. Introduction to Algorithms [2005].\n* M. Sharir. A strong-connectivity algorithm and its applications in data-flow analysis [1979].\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: strong_connected_components\n---\n\n# Finding strongly connected components / Building condensation graph\n\n## Definitions\nYou are given a directed graph $G$ with vertices $V$ and edges $E$. It is possible that there are loops and multiple edges. Let's denote $n$ as number of vertices and $m$ as number of edges in $G$.\n\n**Strongly connected component** is a maximal subset of vertices $C$ such that any two vertices of this subset are reachable from each other, i.e. for any $u, v \\in C$:\n\n$$u \\mapsto v, v \\mapsto u$$\n\nwhere $\\mapsto$ means reachability, i.e. existence of the path from first vertex to the second.\n\nIt is obvious, that strongly connected components do not intersect each other, i.e. this is a partition of all graph vertices. Thus we can give a definition of condensation graph $G^{SCC}$ as a graph containing every strongly connected component as one vertex. Each vertex of the condensation graph corresponds to the strongly connected component of graph $G$. There is an oriented edge between two vertices $C_i$ and $C_j$ of the condensation graph if and only if there are two vertices $u \\in C_i, v \\in C_j$ such that there is an edge in initial graph, i.e. $(u, v) \\in E$.\n\nThe most important property of the condensation graph is that it is **acyclic**. Indeed, suppose that there is an edge between $C$ and $C'$, let's prove that there is no edge from $C'$ to $C$. Suppose that $C' \\mapsto C$. Then there are two vertices $u' \\in C$ and $v' \\in C'$ such that $v' \\mapsto u'$. But since $u$ and $u'$ are in the same strongly connected component then there is a path between them; the same for $v$ and $v'$. As a result, if we join these paths we have that $v \\mapsto u$ and at the same time $u \\mapsto v$. Therefore $u$ and $v$ should be at the same strongly connected component, so this is contradiction. This completes the proof.\n\nThe algorithm described in the next section extracts all strongly connected components in a given graph. It is quite easy to build a condensation graph then.\n\n## Description of the algorithm\nDescribed algorithm was independently suggested by Kosaraju and Sharir at 1979. This is an easy-to-implement algorithm based on two series of [depth first search](depth-first-search.md), and working for $O(n + m)$ time.\n\n**On the first step** of the algorithm we are doing sequence of depth first searches, visiting the entire graph. We start at each vertex of the graph and run a depth first search from every non-visited vertex. For each vertex we are keeping track of **exit time** $tout[v]$. These exit times have a key role in an algorithm and this role is expressed in next theorem.\n\nFirst, let's make notations: let's define exit time $tout[C]$ from the strongly connected component $C$ as maximum of values $tout[v]$ by all $v \\in C$. Besides, during the proof of the theorem we will mention entry times $tin[v]$ in each vertex and in the same way consider $tin[C]$ for each strongly connected component $C$ as minimum of values $tin[v]$ by all $v \\in C$.\n\n**Theorem**. Let $C$ and $C'$ are two different strongly connected components and there is an edge $(C, C')$ in a condensation graph between these two vertices. Then $tout[C] > tout[C']$.\n\nThere are two main different cases at the proof depending on which component will be visited by depth first search first, i.e. depending on difference between $tin[C]$ and $tin[C']$:\n\n- The component $C$ was reached first. It means that depth first search comes at some vertex $v$ of component $C$ at some moment, but all other vertices of components $C$ and $C'$ were not visited yet. By condition there is an edge $(C, C')$ in a condensation graph, so not only the entire component $C$ is reachable from $v$ but the whole component $C'$ is reachable as well. It means that depth first search that is running from vertex $v$ will visit all vertices of components $C$ and $C'$, so they will be descendants for $v$ in a depth first search tree, i.e. for each vertex $u \\in C \\cup C', u \\ne v$ we have that $tout[v] > tout[u]$, as we claimed.\n\n- Assume that component $C'$ was visited first. Similarly, depth first search comes at some vertex $v$ of component $C'$ at some moment, but all other vertices of components $C$ and $C'$ were not visited yet. But by condition there is an edge $(C, C')$ in the condensation graph, so, because of acyclic property of condensation graph, there is no back path from $C'$ to $C$, i.e. depth first search from vertex $v$ will not reach vertices of $C$. It means that vertices of $C$ will be visited by depth first search later, so $tout[C] > tout[C']$. This completes the proof.\n\nProved theorem is **the base of algorithm** for finding strongly connected components. It follows that any edge $(C, C')$ in condensation graph comes from a component with a larger value of $tout$ to component with a smaller value.\n\nIf we sort all vertices $v \\in V$ in decreasing order of their exit time $tout[v]$ then the first vertex $u$ is going to be a vertex belonging to \"root\" strongly connected component, i.e. a vertex that has no incoming edges in the condensation graph. Now we want to run such search from this vertex $u$ so that it will visit all vertices in this strongly connected component, but not others; doing so, we can gradually select all strongly connected components: let's remove all vertices corresponding to the first selected component, and then let's find a vertex with the largest value of $tout$, and run this search from it, and so on.\n\nLet's consider transposed graph $G^T$, i.e. graph received from $G$ by reversing the direction of each edge.\nObviously, this graph will have the same strongly connected components as the initial graph.\nMoreover, the condensation graph $G^{SCC}$ will also get transposed.\nIt means that there will be no edges from our \"root\" component to other components.\n\nThus, for visiting the whole \"root\" strongly connected component, containing vertex $v$, is enough to run search from vertex $v$ in graph $G^T$. This search will visit all vertices of this strongly connected component and only them. As was mentioned before, we can remove these vertices from the graph then, and find the next vertex with a maximal value of $tout[v]$ and run search in transposed graph from it, and so on.\n\nThus, we built next **algorithm** for selecting strongly connected components:\n\n1st step. Run sequence of depth first search of graph $G$ which will return vertices with increasing exit time $tout$, i.e. some list $order$.\n\n2nd step. Build transposed graph $G^T$. Run a series of depth (breadth) first searches in the order determined by list $order$ (to be exact in reverse order, i.e. in decreasing order of exit times). Every set of vertices, reached after the next search, will be the next strongly connected component.\n\nAlgorithm asymptotic is $O(n + m)$, because it is just two depth (breadth) first searches.\n\nFinally, it is appropriate to mention [topological sort](topological-sort.md) here. First of all, step 1 of the algorithm represents reversed topological sort of graph $G$ (actually this is exactly what vertices' sort by exit time means). Secondly, the algorithm's scheme generates strongly connected components by decreasing order of their exit times, thus it generates components - vertices of condensation graph - in topological sort order.\n\n## Implementation\n```cpp\nvector<vector<int>> adj, adj_rev;\nvector<bool> used;\nvector<int> order, component;\n \nvoid dfs1(int v) {\n    used[v] = true;\n\n    for (auto u : adj[v])\n        if (!used[u])\n            dfs1(u);\n\n    order.push_back(v);\n}\n \nvoid dfs2(int v) {\n    used[v] = true;\n    component.push_back(v);\n\n    for (auto u : adj_rev[v])\n        if (!used[u])\n            dfs2(u);\n}\n \nint main() {\n    int n;\n    // ... read n ...\n\n    for (;;) {\n        int a, b;\n        // ... read next directed edge (a,b) ...\n        adj[a].push_back(b);\n        adj_rev[b].push_back(a);\n    }\n \n    used.assign(n, false);\n\n    for (int i = 0; i < n; i++)\n        if (!used[i])\n            dfs1(i);\n\n    used.assign(n, false);\n    reverse(order.begin(), order.end());\n\n    for (auto v : order)\n        if (!used[v]) {\n            dfs2 (v);\n\n            // ... processing next component ...\n\n            component.clear();\n        }\n}\n```\n\nHere, $g$ is graph, $gr$ is transposed graph. Function $dfs1$ implements depth first search on graph $G$, function $dfs2$ - on transposed graph $G^T$. Function $dfs1$ fills the list $order$ with vertices in increasing order of their exit times (actually, it is making a topological sort). Function $dfs2$ stores all reached vertices in list $component$, that is going to store next strongly connected component after each run.\n\n### Condensation Graph Implementation\n\n```cpp\n// continuing from previous code\n\nvector<int> roots(n, 0);\nvector<int> root_nodes;\nvector<vector<int>> adj_scc(n);\n\nfor (auto v : order)\n    if (!used[v]) {\n        dfs2(v);\n\n        int root = component.front();\n        for (auto u : component) roots[u] = root;\n        root_nodes.push_back(root);\n\n        component.clear();\n    }\n\n\nfor (int v = 0; v < n; v++)\n    for (auto u : adj[v]) {\n        int root_v = roots[v],\n            root_u = roots[u];\n\n        if (root_u != root_v)\n            adj_scc[root_v].push_back(root_u);\n    }\n```\n\nHere, we have selected the root of each component as the first node in its list. This node will represent its entire SCC in the condensation graph. `roots[v]` indicates the root node for the SCC to which node `v` belongs. `root_nodes` is the list of all root nodes (one per component) in the condensation graph. \n\n`adj_scc` is the adjacency list of the `root_nodes`. We can now traverse on `adj_scc` as our condensation graph, using only those nodes which belong to `root_nodes`.\n\n## Literature\n\n* Thomas Cormen, Charles Leiserson, Ronald Rivest, Clifford Stein. Introduction to Algorithms [2005].\n* M. Sharir. A strong-connectivity algorithm and its applications in data-flow analysis [1979].\n\n## Practice Problems\n\n* [SPOJ - Good Travels](http://www.spoj.com/problems/GOODA/)\n* [SPOJ - Lego](http://www.spoj.com/problems/LEGO/)\n* [Codechef - Chef and Round Run](https://www.codechef.com/AUG16/problems/CHEFRRUN)\n* [Dev Skills - A Song of Fire and Ice](https://devskill.com/CodingProblems/ViewProblem/79)\n* [UVA - 11838 - Come and Go](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2938)\n* [UVA 247 - Calling Circles](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=183)\n* [UVA 13057 - Prove Them All](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4955)\n* [UVA 12645 - Water Supply](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4393)\n* [UVA 11770 - Lighting Away](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2870)\n* [UVA 12926 - Trouble in Terrorist Town](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=862&page=show_problem&problem=4805)\n* [UVA 11324 - The Largest Clique](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2299)\n* [UVA 11709 - Trust groups](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2756)\n* [UVA 12745 - Wishmaster](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4598)\n* [SPOJ - True Friends](http://www.spoj.com/problems/TFRIENDS/)\n* [SPOJ - Capital City](http://www.spoj.com/problems/CAPCITY/)\n* [Codeforces - Scheme](http://codeforces.com/contest/22/problem/E)\n* [SPOJ - Ada and Panels](http://www.spoj.com/problems/ADAPANEL/)\n* [CSES - Flight Routes Check](https://cses.fi/problemset/task/1682)\n* [CSES - Planets and Kingdoms](https://cses.fi/problemset/task/1683)\n* [CSES -Coin Collector](https://cses.fi/problemset/task/1686)\n* [Codeforces - Checkposts](https://codeforces.com/problemset/problem/427/C)\n", "problem_ids": ["22_E", "427_C"], "title": "Finding strongly connected components / Building condensation graph"}, {"article": "---\ntags:\n  - Original\n---\n\n# Maximum flow - MPM algorithm\n\nMPM (Malhotra, Pramodh-Kumar and Maheshwari) algorithm solves the maximum flow problem in $O(V^3)$. This algorithm is similar to [Dinic's algorithm](dinic.md).\n\n## Algorithm\n\nLike Dinic's algorithm, MPM runs in phases, during each phase we find the blocking flow in the layered network of the residual network of $G$.\nThe main difference from Dinic's is how we find the blocking flow.\nConsider the layered network $L$.\nFor each node we define its' _inner potential_ and _outer potential_ as:\n\n$$\\begin{align}\np_{in}(v) &= \\sum\\limits_{(u, v)\\in L}(c(u, v) - f(u, v)) \\\\\\\\\np_{out}(v) &= \\sum\\limits_{(v, u)\\in L}(c(v, u) - f(v, u))\n\\end{align}$$\n\nAlso we set $p_{in}(s) = p_{out}(t) = \\infty$.\nGiven $p_{in}$ and $p_{out}$ we define the _potential_ as $p(v) = min(p_{in}(v), p_{out}(v))$.\nWe call a node $r$ a _reference node_ if $p(r) = min\\{p(v)\\}$.\nConsider a reference node $r$.\nWe claim that the flow can be increased by $p(r)$ in such a way that $p(r)$ becomes $0$.\nIt is true because $L$ is acyclic, so we can push the flow out of $r$ by outgoing edges and it will reach $t$ because each node has enough outer potential to push the flow out when it reaches it.\nSimilarly, we can pull the flow from $s$.\nThe construction of the blocked flow is based on this fact.\nOn each iteration we find a reference node and push the flow from $s$ to $t$ through $r$.\nThis process can be simulated by BFS.\nAll completely saturated arcs can be deleted from $L$ as they won't be used later in this phase anyway.\nLikewise, all the nodes different from $s$ and $t$ without outgoing or incoming arcs can be deleted.\n\nEach phase works in $O(V^2)$ because there are at most $V$ iterations (because at least the chosen reference node is deleted), and on each iteration we delete all the edges we passed through except at most $V$.\nSumming, we get $O(V^2 + E) = O(V^2)$.\nSince there are less than $V$ phases (see the proof [here](dinic.md)), MPM works in $O(V^3)$ total.\n\n## Implementation\n\n```{.cpp file=mpm}\nstruct MPM{\n    struct FlowEdge{\n        int v, u;\n        long long cap, flow;\n        FlowEdge(){}\n        FlowEdge(int _v, int _u, long long _cap, long long _flow)\n            : v(_v), u(_u), cap(_cap), flow(_flow){}\n        FlowEdge(int _v, int _u, long long _cap)\n            : v(_v), u(_u), cap(_cap), flow(0ll){}\n    };\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<char> alive;\n    vector<long long> pin, pout;\n    vector<list<int> > in, out;\n    vector<vector<int> > adj;\n    vector<long long> ex;\n    int n, m = 0;\n    int s, t;\n    vector<int> level;\n    vector<int> q;\n    int qh, qt;\n    void resize(int _n){\n        n = _n;\n        ex.resize(n);\n        q.resize(n);\n        pin.resize(n);\n        pout.resize(n);\n        adj.resize(n);\n        level.resize(n);\n        in.resize(n);\n        out.resize(n);\n    }\n    MPM(){}\n    MPM(int _n, int _s, int _t){resize(_n); s = _s; t = _t;}\n    void add_edge(int v, int u, long long cap){\n        edges.push_back(FlowEdge(v, u, cap));\n        edges.push_back(FlowEdge(u, v, 0));\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n    bool bfs(){\n        while(qh < qt){\n            int v = q[qh++];\n            for(int id : adj[v]){\n                if(edges[id].cap - edges[id].flow < 1)continue;\n                if(level[edges[id].u] != -1)continue;\n                level[edges[id].u] = level[v] + 1;\n                q[qt++] = edges[id].u;\n            }\n        }\n        return level[t] != -1;\n    }\n    long long pot(int v){\n        return min(pin[v], pout[v]);\n    }\n    void remove_node(int v){\n        for(int i : in[v]){\n            int u = edges[i].v;\n            auto it = find(out[u].begin(), out[u].end(), i);\n            out[u].erase(it);\n            pout[u] -= edges[i].cap - edges[i].flow;\n        }\n        for(int i : out[v]){\n            int u = edges[i].u;\n            auto it = find(in[u].begin(), in[u].end(), i);\n            in[u].erase(it);\n            pin[u] -= edges[i].cap - edges[i].flow;\n        }\n    }\n    void push(int from, int to, long long f, bool forw){\n        qh = qt = 0;\n        ex.assign(n, 0);\n        ex[from] = f;\n        q[qt++] = from;\n        while(qh < qt){\n            int v = q[qh++];\n            if(v == to)\n                break;\n            long long must = ex[v];\n            auto it = forw ? out[v].begin() : in[v].begin();\n            while(true){\n                int u = forw ? edges[*it].u : edges[*it].v;\n                long long pushed = min(must, edges[*it].cap - edges[*it].flow);\n                if(pushed == 0)break;\n                if(forw){\n                    pout[v] -= pushed;\n                    pin[u] -= pushed;\n                }\n                else{\n                    pin[v] -= pushed;\n                    pout[u] -= pushed;\n                }\n                if(ex[u] == 0)\n                    q[qt++] = u;\n                ex[u] += pushed;\n                edges[*it].flow += pushed;\n                edges[(*it)^1].flow -= pushed;\n                must -= pushed;\n                if(edges[*it].cap - edges[*it].flow == 0){\n                    auto jt = it;\n                    ++jt;\n                    if(forw){\n                        in[u].erase(find(in[u].begin(), in[u].end(), *it));\n                        out[v].erase(it);\n                    }\n                    else{\n                        out[u].erase(find(out[u].begin(), out[u].end(), *it));\n                        in[v].erase(it);\n                    }\n                    it = jt;\n                }\n                else break;\n                if(!must)break;\n            }\n        }\n    }\n    long long flow(){\n        long long ans = 0;\n        while(true){\n            pin.assign(n, 0);\n            pout.assign(n, 0);\n            level.assign(n, -1);\n            alive.assign(n, true);\n            level[s] = 0;\n            qh = 0; qt = 1;\n            q[0] = s;\n            if(!bfs())\n                break;\n            for(int i = 0; i < n; i++){\n                out[i].clear();\n                in[i].clear();\n            }\n            for(int i = 0; i < m; i++){\n                if(edges[i].cap - edges[i].flow == 0)\n                    continue;\n                int v = edges[i].v, u = edges[i].u;\n                if(level[v] + 1 == level[u] && (level[u] < level[t] || u == t)){\n                    in[u].push_back(i);\n                    out[v].push_back(i);\n                    pin[u] += edges[i].cap - edges[i].flow;\n                    pout[v] += edges[i].cap - edges[i].flow;\n                }\n            }\n            pin[s] = pout[t] = flow_inf;\n            while(true){\n                int v = -1;\n                for(int i = 0; i < n; i++){\n                    if(!alive[i])continue;\n                    if(v == -1 || pot(i) < pot(v))\n                        v = i;\n                }\n                if(v == -1)\n                    break;\n                if(pot(v) == 0){\n                    alive[v] = false;\n                    remove_node(v);\n                    continue;\n                }\n                long long f = pot(v);\n                ans += f;\n                push(v, s, f, false);\n                push(v, t, f, true);\n                alive[v] = false;\n                remove_node(v);\n            }\n        }\n        return ans;\n    }\n};\n```\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Maximum flow - MPM algorithm\n\nMPM (Malhotra, Pramodh-Kumar and Maheshwari) algorithm solves the maximum flow problem in $O(V^3)$. This algorithm is similar to [Dinic's algorithm](dinic.md).\n\n## Algorithm\n\nLike Dinic's algorithm, MPM runs in phases, during each phase we find the blocking flow in the layered network of the residual network of $G$.\nThe main difference from Dinic's is how we find the blocking flow.\nConsider the layered network $L$.\nFor each node we define its' _inner potential_ and _outer potential_ as:\n\n$$\\begin{align}\np_{in}(v) &= \\sum\\limits_{(u, v)\\in L}(c(u, v) - f(u, v)) \\\\\\\\\np_{out}(v) &= \\sum\\limits_{(v, u)\\in L}(c(v, u) - f(v, u))\n\\end{align}$$\n\nAlso we set $p_{in}(s) = p_{out}(t) = \\infty$.\nGiven $p_{in}$ and $p_{out}$ we define the _potential_ as $p(v) = min(p_{in}(v), p_{out}(v))$.\nWe call a node $r$ a _reference node_ if $p(r) = min\\{p(v)\\}$.\nConsider a reference node $r$.\nWe claim that the flow can be increased by $p(r)$ in such a way that $p(r)$ becomes $0$.\nIt is true because $L$ is acyclic, so we can push the flow out of $r$ by outgoing edges and it will reach $t$ because each node has enough outer potential to push the flow out when it reaches it.\nSimilarly, we can pull the flow from $s$.\nThe construction of the blocked flow is based on this fact.\nOn each iteration we find a reference node and push the flow from $s$ to $t$ through $r$.\nThis process can be simulated by BFS.\nAll completely saturated arcs can be deleted from $L$ as they won't be used later in this phase anyway.\nLikewise, all the nodes different from $s$ and $t$ without outgoing or incoming arcs can be deleted.\n\nEach phase works in $O(V^2)$ because there are at most $V$ iterations (because at least the chosen reference node is deleted), and on each iteration we delete all the edges we passed through except at most $V$.\nSumming, we get $O(V^2 + E) = O(V^2)$.\nSince there are less than $V$ phases (see the proof [here](dinic.md)), MPM works in $O(V^3)$ total.\n\n## Implementation\n\n```{.cpp file=mpm}\nstruct MPM{\n    struct FlowEdge{\n        int v, u;\n        long long cap, flow;\n        FlowEdge(){}\n        FlowEdge(int _v, int _u, long long _cap, long long _flow)\n            : v(_v), u(_u), cap(_cap), flow(_flow){}\n        FlowEdge(int _v, int _u, long long _cap)\n            : v(_v), u(_u), cap(_cap), flow(0ll){}\n    };\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<char> alive;\n    vector<long long> pin, pout;\n    vector<list<int> > in, out;\n    vector<vector<int> > adj;\n    vector<long long> ex;\n    int n, m = 0;\n    int s, t;\n    vector<int> level;\n    vector<int> q;\n    int qh, qt;\n    void resize(int _n){\n        n = _n;\n        ex.resize(n);\n        q.resize(n);\n        pin.resize(n);\n        pout.resize(n);\n        adj.resize(n);\n        level.resize(n);\n        in.resize(n);\n        out.resize(n);\n    }\n    MPM(){}\n    MPM(int _n, int _s, int _t){resize(_n); s = _s; t = _t;}\n    void add_edge(int v, int u, long long cap){\n        edges.push_back(FlowEdge(v, u, cap));\n        edges.push_back(FlowEdge(u, v, 0));\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n    bool bfs(){\n        while(qh < qt){\n            int v = q[qh++];\n            for(int id : adj[v]){\n                if(edges[id].cap - edges[id].flow < 1)continue;\n                if(level[edges[id].u] != -1)continue;\n                level[edges[id].u] = level[v] + 1;\n                q[qt++] = edges[id].u;\n            }\n        }\n        return level[t] != -1;\n    }\n    long long pot(int v){\n        return min(pin[v], pout[v]);\n    }\n    void remove_node(int v){\n        for(int i : in[v]){\n            int u = edges[i].v;\n            auto it = find(out[u].begin(), out[u].end(), i);\n            out[u].erase(it);\n            pout[u] -= edges[i].cap - edges[i].flow;\n        }\n        for(int i : out[v]){\n            int u = edges[i].u;\n            auto it = find(in[u].begin(), in[u].end(), i);\n            in[u].erase(it);\n            pin[u] -= edges[i].cap - edges[i].flow;\n        }\n    }\n    void push(int from, int to, long long f, bool forw){\n        qh = qt = 0;\n        ex.assign(n, 0);\n        ex[from] = f;\n        q[qt++] = from;\n        while(qh < qt){\n            int v = q[qh++];\n            if(v == to)\n                break;\n            long long must = ex[v];\n            auto it = forw ? out[v].begin() : in[v].begin();\n            while(true){\n                int u = forw ? edges[*it].u : edges[*it].v;\n                long long pushed = min(must, edges[*it].cap - edges[*it].flow);\n                if(pushed == 0)break;\n                if(forw){\n                    pout[v] -= pushed;\n                    pin[u] -= pushed;\n                }\n                else{\n                    pin[v] -= pushed;\n                    pout[u] -= pushed;\n                }\n                if(ex[u] == 0)\n                    q[qt++] = u;\n                ex[u] += pushed;\n                edges[*it].flow += pushed;\n                edges[(*it)^1].flow -= pushed;\n                must -= pushed;\n                if(edges[*it].cap - edges[*it].flow == 0){\n                    auto jt = it;\n                    ++jt;\n                    if(forw){\n                        in[u].erase(find(in[u].begin(), in[u].end(), *it));\n                        out[v].erase(it);\n                    }\n                    else{\n                        out[u].erase(find(out[u].begin(), out[u].end(), *it));\n                        in[v].erase(it);\n                    }\n                    it = jt;\n                }\n                else break;\n                if(!must)break;\n            }\n        }\n    }\n    long long flow(){\n        long long ans = 0;\n        while(true){\n            pin.assign(n, 0);\n            pout.assign(n, 0);\n            level.assign(n, -1);\n            alive.assign(n, true);\n            level[s] = 0;\n            qh = 0; qt = 1;\n            q[0] = s;\n            if(!bfs())\n                break;\n            for(int i = 0; i < n; i++){\n                out[i].clear();\n                in[i].clear();\n            }\n            for(int i = 0; i < m; i++){\n                if(edges[i].cap - edges[i].flow == 0)\n                    continue;\n                int v = edges[i].v, u = edges[i].u;\n                if(level[v] + 1 == level[u] && (level[u] < level[t] || u == t)){\n                    in[u].push_back(i);\n                    out[v].push_back(i);\n                    pin[u] += edges[i].cap - edges[i].flow;\n                    pout[v] += edges[i].cap - edges[i].flow;\n                }\n            }\n            pin[s] = pout[t] = flow_inf;\n            while(true){\n                int v = -1;\n                for(int i = 0; i < n; i++){\n                    if(!alive[i])continue;\n                    if(v == -1 || pot(i) < pot(v))\n                        v = i;\n                }\n                if(v == -1)\n                    break;\n                if(pot(v) == 0){\n                    alive[v] = false;\n                    remove_node(v);\n                    continue;\n                }\n                long long f = pot(v);\n                ans += f;\n                push(v, s, f, false);\n                push(v, t, f, true);\n                alive[v] = false;\n                remove_node(v);\n            }\n        }\n        return ans;\n    }\n};\n```\n", "problem_ids": [], "title": "Maximum flow - MPM algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: topological_sort\n---\n\n# Topological Sorting\n\nYou are given a directed graph with $n$ vertices and $m$ edges.\nYou have to find an **order of the vertices**, so that every edge leads from the vertex with a smaller index to a vertex with a larger one.\n\nIn other words, you want to find a permutation of the vertices (**topological order**) which corresponds to the order defined by all edges of the graph.\n\nHere is one given graph together with its topological order:\n\n<center>\n![example directed graph](topological_1.png)\n![one topological order](topological_2.png)\n</center>\n\nTopological order can be **non-unique** (for example, if there exist three vertices $a$, $b$, $c$ for which there exist paths from $a$ to $b$ and from $a$ to $c$ but not paths from $b$ to $c$ or from $c$ to $b$).\nThe example graph also has multiple topological orders, a second topological order is the following:\n<center>\n![second topological order](topological_3.png)\n</center>\n\nA Topological order may **not exist** at all.\nIt only exists, if the directed graph contains no cycles.\nOtherwise because there is a contradiction: if there is a cycle containing the vertices $a$ and $b$, then $a$ needs to have a smaller index than $b$ (since you can reach $b$ from $a$) and also a bigger one (as you can reach $a$ from $b$).\nThe algorithm described in this article also shows by construction, that every acyclic directed graph contains at least one topological order.\n\nA common problem in which topological sorting occurs is the following. There are $n$ variables with unknown values. For some variables we know that one of them is less than the other. You have to check whether these constraints are contradictory, and if not, output the variables in ascending order (if several answers are possible, output any of them). It is easy to notice that this is exactly the problem of finding topological order of a graph with $n$ vertices.\n\n## The Algorithm\n\nTo solve this problem we will use [depth-first search](depth-first-search.md).\n\nLet's assume that the graph is acyclic. What does the depth-first search do?\n\nWhen starting from some vertex $v$, DFS tries to traverse along all edges outgoing from $v$.\nIt stops at the edges for which the ends have been already been visited previously, and traverses along the rest of the edges and continues recursively at their ends.\n\nThus, by the time of the function call $\\text{dfs}(v)$ has finished, all vertices that are reachable from $v$ have been either directly (via one edge) or indirectly visited by the search.\n\nLet's append the vertex $v$ to a list, when we finish $\\text{dfs}(v)$. Since all reachable vertices have already been visited, they will already be in the list when we append $v$.\nLet's do this for every vertex in the graph, with one or multiple depth-first search runs.\nFor every directed edge $v \\rightarrow u$ in the graph, $u$ will appear earlier in this list than $v$, because $u$ is reachable from $v$.\nSo if we just label the vertices in this list with $n-1, n-2, \\dots, 1, 0$, we have found a topological order of the graph.\nIn other words, the list represents the reversed topological order.\n\nThese explanations can also be presented in terms of exit times of the DFS algorithm.\nThe exit time for vertex $v$ is the time at which the function call $\\text{dfs}(v)$ finished (the times can be numbered from $0$ to $n-1$).\nIt is easy to understand that exit time of any vertex $v$ is always greater than the exit time of any vertex reachable from it (since they were visited either before the call $\\text{dfs}(v)$ or during it). Thus, the desired topological ordering are the vertices in descending order of their exit times.\n\n## Implementation\n\nHere is an implementation which assumes that the graph is acyclic, i.e. the desired topological ordering exists. If necessary, you can easily check that the graph is acyclic, as described in the article on [depth-first search](depth-first-search.md).\n\n```cpp\nint n; // number of vertices\nvector<vector<int>> adj; // adjacency list of graph\nvector<bool> visited;\nvector<int> ans;\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u])\n            dfs(u);\n    }\n    ans.push_back(v);\n}\n \nvoid topological_sort() {\n    visited.assign(n, false);\n    ans.clear();\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i])\n            dfs(i);\n    }\n    reverse(ans.begin(), ans.end());\n}\n```\n\nThe main function of the solution is `topological_sort`, which initializes DFS variables, launches DFS and receives the answer in the vector `ans`.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: topological_sort\n---\n\n# Topological Sorting\n\nYou are given a directed graph with $n$ vertices and $m$ edges.\nYou have to find an **order of the vertices**, so that every edge leads from the vertex with a smaller index to a vertex with a larger one.\n\nIn other words, you want to find a permutation of the vertices (**topological order**) which corresponds to the order defined by all edges of the graph.\n\nHere is one given graph together with its topological order:\n\n<center>\n![example directed graph](topological_1.png)\n![one topological order](topological_2.png)\n</center>\n\nTopological order can be **non-unique** (for example, if there exist three vertices $a$, $b$, $c$ for which there exist paths from $a$ to $b$ and from $a$ to $c$ but not paths from $b$ to $c$ or from $c$ to $b$).\nThe example graph also has multiple topological orders, a second topological order is the following:\n<center>\n![second topological order](topological_3.png)\n</center>\n\nA Topological order may **not exist** at all.\nIt only exists, if the directed graph contains no cycles.\nOtherwise because there is a contradiction: if there is a cycle containing the vertices $a$ and $b$, then $a$ needs to have a smaller index than $b$ (since you can reach $b$ from $a$) and also a bigger one (as you can reach $a$ from $b$).\nThe algorithm described in this article also shows by construction, that every acyclic directed graph contains at least one topological order.\n\nA common problem in which topological sorting occurs is the following. There are $n$ variables with unknown values. For some variables we know that one of them is less than the other. You have to check whether these constraints are contradictory, and if not, output the variables in ascending order (if several answers are possible, output any of them). It is easy to notice that this is exactly the problem of finding topological order of a graph with $n$ vertices.\n\n## The Algorithm\n\nTo solve this problem we will use [depth-first search](depth-first-search.md).\n\nLet's assume that the graph is acyclic. What does the depth-first search do?\n\nWhen starting from some vertex $v$, DFS tries to traverse along all edges outgoing from $v$.\nIt stops at the edges for which the ends have been already been visited previously, and traverses along the rest of the edges and continues recursively at their ends.\n\nThus, by the time of the function call $\\text{dfs}(v)$ has finished, all vertices that are reachable from $v$ have been either directly (via one edge) or indirectly visited by the search.\n\nLet's append the vertex $v$ to a list, when we finish $\\text{dfs}(v)$. Since all reachable vertices have already been visited, they will already be in the list when we append $v$.\nLet's do this for every vertex in the graph, with one or multiple depth-first search runs.\nFor every directed edge $v \\rightarrow u$ in the graph, $u$ will appear earlier in this list than $v$, because $u$ is reachable from $v$.\nSo if we just label the vertices in this list with $n-1, n-2, \\dots, 1, 0$, we have found a topological order of the graph.\nIn other words, the list represents the reversed topological order.\n\nThese explanations can also be presented in terms of exit times of the DFS algorithm.\nThe exit time for vertex $v$ is the time at which the function call $\\text{dfs}(v)$ finished (the times can be numbered from $0$ to $n-1$).\nIt is easy to understand that exit time of any vertex $v$ is always greater than the exit time of any vertex reachable from it (since they were visited either before the call $\\text{dfs}(v)$ or during it). Thus, the desired topological ordering are the vertices in descending order of their exit times.\n\n## Implementation\n\nHere is an implementation which assumes that the graph is acyclic, i.e. the desired topological ordering exists. If necessary, you can easily check that the graph is acyclic, as described in the article on [depth-first search](depth-first-search.md).\n\n```cpp\nint n; // number of vertices\nvector<vector<int>> adj; // adjacency list of graph\nvector<bool> visited;\nvector<int> ans;\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u])\n            dfs(u);\n    }\n    ans.push_back(v);\n}\n \nvoid topological_sort() {\n    visited.assign(n, false);\n    ans.clear();\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i])\n            dfs(i);\n    }\n    reverse(ans.begin(), ans.end());\n}\n```\n\nThe main function of the solution is `topological_sort`, which initializes DFS variables, launches DFS and receives the answer in the vector `ans`.\n\n## Practice Problems\n\n- [SPOJ TOPOSORT - Topological Sorting [difficulty: easy]](http://www.spoj.com/problems/TOPOSORT/)\n- [UVA 10305 - Ordering Tasks [difficulty: easy]](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1246)\n- [UVA 124 - Following Orders [difficulty: easy]](https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=60)\n- [UVA 200 - Rare Order [difficulty: easy]](https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=136)\n- [Codeforces 510C - Fox and Names [difficulty: easy]](http://codeforces.com/problemset/problem/510/C)\n- [SPOJ RPLA - Answer the boss!](https://www.spoj.com/problems/RPLA/)\n- [CSES - Course Schedule](https://cses.fi/problemset/task/1679)\n- [CSES - Longest Flight Route](https://cses.fi/problemset/task/1680)\n- [CSES - Game Routes](https://cses.fi/problemset/task/1681)\n", "problem_ids": [], "title": "Topological Sorting"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: prufer_code_cayley_formula\n---\n\n# Pr\u00fcfer code\n\nIn this article we will look at the so-called **Pr\u00fcfer code** (or Pr\u00fcfer sequence), which is a way of encoding a labeled tree into a sequence of numbers in a unique way.\n\nWith the help of the Pr\u00fcfer code we will prove **Cayley's formula** (which specified the number of spanning trees in a complete graph).\nAlso we show the solution to the problem of counting the number of ways of adding edges to a graph to make it connected.\n\n**Note**, we will not consider trees consisting of a single vertex - this is a special case in which multiple statements clash.\n\n## Pr\u00fcfer code\n\nThe Pr\u00fcfer code is a way of encoding a labeled tree with $n$ vertices using a sequence of $n - 2$ integers in the interval $[0; n-1]$.\nThis encoding also acts as a **bijection** between all spanning trees of a complete graph and the numerical sequences.\n\nAlthough using the Pr\u00fcfer code for storing and operating on tree is impractical due the specification of the representation, the Pr\u00fcfer codes are used frequently: mostly in solving combinatorial problems.\n\nThe inventor - Heinz Pr\u00fcfer - proposed this code in 1918 as a proof for Cayley's formula.\n\n### Building the Pr\u00fcfer code for a given tree\n\nThe Pr\u00fcfer code is constructed as follows.\nWe will repeat the following procedure $n - 2$ times:\nwe select the leaf of the tree with the smallest number, remove it from the tree, and write down the number of the vertex that was connected to it.\nAfter $n - 2$ iterations there will only remain $2$ vertices, and the algorithm ends.\n\nThus the Pr\u00fcfer code for a given tree is a sequence of $n - 2$ numbers, where each number is the number of the connected vertex, i.e. this number is in the interval $[0, n-1]$.\n\nThe algorithm for computing the Pr\u00fcfer code can be implemented easily with $O(n \\log n)$ time complexity, simply by using a data structure to extract the minimum (for instance `set` or `priority_queue` in C++), which contains a list of all the current leafs.\n\n```{.cpp file=pruefer_code_slow}\nvector<vector<int>> adj;\n\nvector<int> pruefer_code() {\n    int n = adj.size();\n    set<int> leafs;\n    vector<int> degree(n);\n    vector<bool> killed(n, false);\n    for (int i = 0; i < n; i++) {\n        degree[i] = adj[i].size();\n        if (degree[i] == 1)\n            leafs.insert(i);\n    }\n\n    vector<int> code(n - 2);\n    for (int i = 0; i < n - 2; i++) {\n        int leaf = *leafs.begin();\n        leafs.erase(leafs.begin());\n        killed[leaf] = true;\n\n        int v;\n        for (int u : adj[leaf]) {\n            if (!killed[u])\n                v = u;\n        }\n\n        code[i] = v;\n        if (--degree[v] == 1)\n            leafs.insert(v);\n    }\n\n    return code;\n}\n```\n\nHowever the construction can also be implemented in linear time.\nSuch an approach is described in the next section.\n\n### Building the Pr\u00fcfer code for a given tree in linear time\n\nThe essence of the algorithm is to use a **moving pointer**, which will always point to the current leaf vertex that we want to remove.\n\nAt first glance this seems impossible, because during the process of constructing the Pr\u00fcfer code the leaf number can increase and decrease.\nHowever after a closer look, this is actually not true.\nThe number of leafs will not increase. Either the number decreases by one (we remove one leaf vertex and don't gain a new one), or it stay the same (we remove one leaf vertex and gain another one).\nIn the first case there is no other way than searching for the next smallest leaf vertex.\nIn the second case, however, we can decide in $O(1)$ time, if we can continue using the vertex that became a new leaf vertex, or if we have to search for the next smallest leaf vertex.\nAnd in quite a lot of times we can continue with the new leaf vertex.\n\nTo do this we will use a variable $\\text{ptr}$, which will indicate that in the set of vertices between $0$ and $\\text{ptr}$ is at most one leaf vertex, namely the current one.\nAll other vertices in that range are either already removed from the tree, or have still more than one adjacent vertices.\nAt the same time we say, that we haven't removed any leaf vertices bigger than $\\text{ptr}$ yet.\n\nThis variable is already very helpful in the first case.\nAfter removing the current leaf node, we know that there cannot be a leaf node between $0$ and $\\text{ptr}$, therefore we can start the search for the next one directly at $\\text{ptr} + 1$, and we don't have to start the search back at vertex $0$.\nAnd in the second case, we can further distinguish two cases:\nEither the newly gained leaf vertex is smaller than $\\text{ptr}$, then this must be the next leaf vertex, since we know that there are no other vertices smaller than $\\text{ptr}$.\nOr the newly gained leaf vertex is bigger.\nBut then we also know that it has to be bigger than $\\text{ptr}$, and can start the search again at $\\text{ptr} + 1$.\n\nEven though we might have to perform multiple linear searches for the next leaf vertex, the pointer $\\text{ptr}$ only increases and therefore the time complexity in total is $O(n)$.\n\n```{.cpp file=pruefer_code_fast}\nvector<vector<int>> adj;\nvector<int> parent;\n\nvoid dfs(int v) {\n    for (int u : adj[v]) {\n        if (u != parent[v]) {\n            parent[u] = v;\n            dfs(u);\n        }\n    }\n}\n\nvector<int> pruefer_code() {\n    int n = adj.size();\n    parent.resize(n);\n    parent[n-1] = -1;\n    dfs(n-1);\n\n    int ptr = -1;\n    vector<int> degree(n);\n    for (int i = 0; i < n; i++) {\n        degree[i] = adj[i].size();\n        if (degree[i] == 1 && ptr == -1)\n            ptr = i;\n    }\n\n    vector<int> code(n - 2);\n    int leaf = ptr;\n    for (int i = 0; i < n - 2; i++) {\n        int next = parent[leaf];\n        code[i] = next;\n        if (--degree[next] == 1 && next < ptr) {\n            leaf = next;\n        } else {\n            ptr++;\n            while (degree[ptr] != 1)\n                ptr++;\n            leaf = ptr;\n        }\n    }\n\n    return code;\n}\n```\n\nIn the code we first find for each its ancestor `parent[i]`, i.e. the ancestor that this vertex will have once we remove it from the tree.\nWe can find this ancestor by rooting the tree at the vertex $n-1$.\nThis is possible because the vertex $n-1$ will never be removed from the tree.\nWe also compute the degree for each vertex.\n`ptr` is the pointer that indicates the minimum size of the remaining leaf vertices (except the current one `leaf`).\nWe will either assign the current leaf vertex with `next`, if this one is also a leaf vertex and it is smaller than `ptr`, or we start a linear search for the smallest leaf vertex by increasing the pointer.\n\nIt can be easily seen, that this code has the complexity $O(n)$.\n\n### Some properties of the Pr\u00fcfer code\n\n- After constructing the Pr\u00fcfer code two vertices will remain.\n  One of them is the highest vertex $n-1$, but nothing else can be said about the other one.\n- Each vertex appears in the Pr\u00fcfer code exactly a fixed number of times - its degree minus one.\n  This can be easily checked, since the degree will get smaller every time we record its label in the code, and we remove it once the degree is $1$.\n  For the two remaining vertices this fact is also true.\n\n### Restoring the tree using the Pr\u00fcfer code\n\nTo restore the tree it suffice to only focus on the property discussed in the last section.\nWe already know the degree of all the vertices in the desired tree.\nTherefore we can find all leaf vertices, and also the first leaf that was removed in the first step (it has to be the smallest leaf).\nThis leaf vertex was connected to the vertex corresponding to the number in the first cell of the Pr\u00fcfer code.\n\nThus we found the first edge removed by when then the Pr\u00fcfer code was generated.\nWe can add this edge to the answer and reduce the degrees at both ends of the edge.\n\nWe will repeat this operation until we have used all numbers of the Pr\u00fcfer code:\nwe look for the minimum vertex with degree equal to $1$, connect it with the next vertex from the Pr\u00fcfer code, and reduce the degree.\n\nIn the end we only have two vertices left with degree equal to $1$.\nThese are the vertices that didn't got removed by the Pr\u00fcfer code process.\nWe connect them to get the last edge of the tree.\nOne of them will always be the vertex $n-1$.\n\nThis algorithm can be **implemented** easily in $O(n \\log n)$: we use a data structure that supports extracting the minimum (for example `set<>` or `priority_queue<>` in C++) to store all the leaf vertices.\n\nThe following implementation returns the list of edges corresponding to the tree.\n\n```{.cpp file=pruefer_decode_slow}\nvector<pair<int, int>> pruefer_decode(vector<int> const& code) {\n    int n = code.size() + 2;\n    vector<int> degree(n, 1);\n    for (int i : code)\n        degree[i]++;\n\n    set<int> leaves;\n    for (int i = 0; i < n; i++) {\n        if (degree[i] == 1)\n            leaves.insert(i);\n    }\n\n    vector<pair<int, int>> edges;\n    for (int v : code) {\n        int leaf = *leaves.begin();\n        leaves.erase(leaves.begin());\n\n        edges.emplace_back(leaf, v);\n        if (--degree[v] == 1)\n            leaves.insert(v);\n    }\n    edges.emplace_back(*leaves.begin(), n-1);\n    return edges;\n}\n```\n\n### Restoring the tree using the Pr\u00fcfer code in linear time\n\nTo obtain the tree in linear time we can apply the same technique used to obtain the Pr\u00fcfer code in linear time.\n\nWe don't need a data structure to extract the minimum.\nInstead we can notice that, after processing the current edge, only one vertex becomes a leaf.\nTherefore we can either continue with this vertex, or we find a smaller one with a linear search by moving a pointer.\n\n```{.cpp file=pruefer_decode_fast}\nvector<pair<int, int>> pruefer_decode(vector<int> const& code) {\n    int n = code.size() + 2;\n    vector<int> degree(n, 1);\n    for (int i : code)\n        degree[i]++;\n\n    int ptr = 0;\n    while (degree[ptr] != 1)\n        ptr++;\n    int leaf = ptr;\n\n    vector<pair<int, int>> edges;\n    for (int v : code) {\n        edges.emplace_back(leaf, v);\n        if (--degree[v] == 1 && v < ptr) {\n            leaf = v;\n        } else {\n            ptr++;\n            while (degree[ptr] != 1)\n                ptr++;\n            leaf = ptr;\n        }\n    }\n    edges.emplace_back(leaf, n-1);\n    return edges;\n}\n```\n\n### Bijection between trees and Pr\u00fcfer codes\n\nFor each tree there exists a Pr\u00fcfer code corresponding to it.\nAnd for each Pr\u00fcfer code we can restore the original tree.\n\nIt follows that also every Pr\u00fcfer code (i.e. a sequence of $n-2$ numbers in the range $[0; n - 1]$) corresponds to a tree.\n\nTherefore all trees and all Pr\u00fcfer codes form a bijection (a **one-to-one correspondence**).\n\n## Cayley's formula\n\nCayley's formula states that the **number of spanning trees in a complete labeled graph** with $n$ vertices is equal to:\n\n$$n^{n-2}$$\n\nThere are multiple proofs for this formula.\nUsing the Pr\u00fcfer code concept this statement comes without any surprise.\n\nIn fact any Pr\u00fcfer code with $n-2$ numbers from the interval $[0; n-1]$ corresponds to some tree with $n$ vertices.\nSo we have $n^{n-2}$ different such Pr\u00fcfer codes.\nSince each such tree is a spanning tree of a complete graph with $n$ vertices, the number of such spanning trees is also $n^{n-2}$.\n\n## Number of ways to make a graph connected\n\nThe concept of Pr\u00fcfer codes are even more powerful.\nIt allows to create a lot more general formulas than Cayley's formula.\n\nIn this problem we are given a graph with $n$ vertices and $m$ edges.\nThe graph currently has $k$ components.\nWe want to compute the number of ways of adding $k-1$ edges so that the graph becomes connected (obviously $k-1$ is the minimum number necessary to make the graph connected).\n\nLet us derive a formula for solving this problem.\n\nWe use $s_1, \\dots, s_k$ for the sizes of the connected components in the graph.\nWe cannot add edges within a connected component.\nTherefore it turns out that this problem is very similar to the search for the number of spanning trees of a complete graph with $k$ vertices.\nThe only difference is that each vertex has actually the size $s_i$: each edge connecting the vertex $i$, actually multiplies the answer by $s_i$.\n\nThus in order to calculate the number of possible ways it is important to count how often each of the $k$ vertices is used in the connecting tree.\nTo obtain a formula for the problem it is necessary to sum the answer over all possible degrees.\n\nLet $d_1, \\dots, d_k$ be the degrees of the vertices in the tree after connecting the vertices.\nThe sum of the degrees is twice the number of edges:\n\n$$\\sum_{i=1}^k d_i = 2k - 2$$\n\nIf the vertex $i$ has degree $d_i$, then it appears $d_i - 1$ times in the Pr\u00fcfer code.\nThe Pr\u00fcfer code for a tree with $k$ vertices has length $k-2$.\nSo the number of ways to choose a code with $k-2$ numbers where the number $i$ appears exactly $d_i - 1$ times is equal to the **multinomial coefficient**\n\n$$\\binom{k-2}{d_1-1, d_2-1, \\dots, d_k-1} = \\frac{(k-2)!}{(d_1-1)! (d_2-1)! \\cdots (d_k-1)!}.$$\n\nThe fact that each edge adjacent to the vertex $i$ multiplies the answer by $s_i$ we receive the answer, assuming that the degrees of the vertices are $d_1, \\dots, d_k$:\n\n$$s_1^{d_1} \\cdot s_2^{d_2} \\cdots s_k^{d_k} \\cdot \\binom{k-2}{d_1-1, d_2-1, \\dots, d_k-1}$$\n\nTo get the final answer we need to sum this for all possible ways to choose the degrees:\n\n$$\\sum_{\\substack{d_i \\ge 1 \\\\\\\\ \\sum_{i=1}^k d_i = 2k -2}} s_1^{d_1} \\cdot s_2^{d_2} \\cdots s_k^{d_k} \\cdot \\binom{k-2}{d_1-1, d_2-1, \\dots, d_k-1}$$\n\nCurrently this looks like a really horrible answer, however we can use the **multinomial theorem**, which says:\n\n$$(x_1 + \\dots + x_m)^p = \\sum_{\\substack{c_i \\ge 0 \\\\\\\\ \\sum_{i=1}^m c_i = p}} x_1^{c_1} \\cdot x_2^{c_2} \\cdots x_m^{c_m} \\cdot \\binom{p}{c_1, c_2, \\dots c_m}$$\n\nThis look already pretty similar.\nTo use it we only need to substitute with $e_i = d_i - 1$:\n\n$$\\sum_{\\substack{e_i \\ge 0 \\\\\\\\ \\sum_{i=1}^k e_i = k - 2}} s_1^{e_1+1} \\cdot s_2^{e_2+1} \\cdots s_k^{e_k+1} \\cdot \\binom{k-2}{e_1, e_2, \\dots, e_k}$$\n\nAfter applying the multinomial theorem we get the **answer to the problem**:\n\n$$s_1 \\cdot s_2 \\cdots s_k \\cdot (s_1 + s_2 + \\dots + s_k)^{k-2} = s_1 \\cdot s_2 \\cdots s_k \\cdot n^{k-2}$$\n\nBy accident this formula also holds for $k = 1$.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: prufer_code_cayley_formula\n---\n\n# Pr\u00fcfer code\n\nIn this article we will look at the so-called **Pr\u00fcfer code** (or Pr\u00fcfer sequence), which is a way of encoding a labeled tree into a sequence of numbers in a unique way.\n\nWith the help of the Pr\u00fcfer code we will prove **Cayley's formula** (which specified the number of spanning trees in a complete graph).\nAlso we show the solution to the problem of counting the number of ways of adding edges to a graph to make it connected.\n\n**Note**, we will not consider trees consisting of a single vertex - this is a special case in which multiple statements clash.\n\n## Pr\u00fcfer code\n\nThe Pr\u00fcfer code is a way of encoding a labeled tree with $n$ vertices using a sequence of $n - 2$ integers in the interval $[0; n-1]$.\nThis encoding also acts as a **bijection** between all spanning trees of a complete graph and the numerical sequences.\n\nAlthough using the Pr\u00fcfer code for storing and operating on tree is impractical due the specification of the representation, the Pr\u00fcfer codes are used frequently: mostly in solving combinatorial problems.\n\nThe inventor - Heinz Pr\u00fcfer - proposed this code in 1918 as a proof for Cayley's formula.\n\n### Building the Pr\u00fcfer code for a given tree\n\nThe Pr\u00fcfer code is constructed as follows.\nWe will repeat the following procedure $n - 2$ times:\nwe select the leaf of the tree with the smallest number, remove it from the tree, and write down the number of the vertex that was connected to it.\nAfter $n - 2$ iterations there will only remain $2$ vertices, and the algorithm ends.\n\nThus the Pr\u00fcfer code for a given tree is a sequence of $n - 2$ numbers, where each number is the number of the connected vertex, i.e. this number is in the interval $[0, n-1]$.\n\nThe algorithm for computing the Pr\u00fcfer code can be implemented easily with $O(n \\log n)$ time complexity, simply by using a data structure to extract the minimum (for instance `set` or `priority_queue` in C++), which contains a list of all the current leafs.\n\n```{.cpp file=pruefer_code_slow}\nvector<vector<int>> adj;\n\nvector<int> pruefer_code() {\n    int n = adj.size();\n    set<int> leafs;\n    vector<int> degree(n);\n    vector<bool> killed(n, false);\n    for (int i = 0; i < n; i++) {\n        degree[i] = adj[i].size();\n        if (degree[i] == 1)\n            leafs.insert(i);\n    }\n\n    vector<int> code(n - 2);\n    for (int i = 0; i < n - 2; i++) {\n        int leaf = *leafs.begin();\n        leafs.erase(leafs.begin());\n        killed[leaf] = true;\n\n        int v;\n        for (int u : adj[leaf]) {\n            if (!killed[u])\n                v = u;\n        }\n\n        code[i] = v;\n        if (--degree[v] == 1)\n            leafs.insert(v);\n    }\n\n    return code;\n}\n```\n\nHowever the construction can also be implemented in linear time.\nSuch an approach is described in the next section.\n\n### Building the Pr\u00fcfer code for a given tree in linear time\n\nThe essence of the algorithm is to use a **moving pointer**, which will always point to the current leaf vertex that we want to remove.\n\nAt first glance this seems impossible, because during the process of constructing the Pr\u00fcfer code the leaf number can increase and decrease.\nHowever after a closer look, this is actually not true.\nThe number of leafs will not increase. Either the number decreases by one (we remove one leaf vertex and don't gain a new one), or it stay the same (we remove one leaf vertex and gain another one).\nIn the first case there is no other way than searching for the next smallest leaf vertex.\nIn the second case, however, we can decide in $O(1)$ time, if we can continue using the vertex that became a new leaf vertex, or if we have to search for the next smallest leaf vertex.\nAnd in quite a lot of times we can continue with the new leaf vertex.\n\nTo do this we will use a variable $\\text{ptr}$, which will indicate that in the set of vertices between $0$ and $\\text{ptr}$ is at most one leaf vertex, namely the current one.\nAll other vertices in that range are either already removed from the tree, or have still more than one adjacent vertices.\nAt the same time we say, that we haven't removed any leaf vertices bigger than $\\text{ptr}$ yet.\n\nThis variable is already very helpful in the first case.\nAfter removing the current leaf node, we know that there cannot be a leaf node between $0$ and $\\text{ptr}$, therefore we can start the search for the next one directly at $\\text{ptr} + 1$, and we don't have to start the search back at vertex $0$.\nAnd in the second case, we can further distinguish two cases:\nEither the newly gained leaf vertex is smaller than $\\text{ptr}$, then this must be the next leaf vertex, since we know that there are no other vertices smaller than $\\text{ptr}$.\nOr the newly gained leaf vertex is bigger.\nBut then we also know that it has to be bigger than $\\text{ptr}$, and can start the search again at $\\text{ptr} + 1$.\n\nEven though we might have to perform multiple linear searches for the next leaf vertex, the pointer $\\text{ptr}$ only increases and therefore the time complexity in total is $O(n)$.\n\n```{.cpp file=pruefer_code_fast}\nvector<vector<int>> adj;\nvector<int> parent;\n\nvoid dfs(int v) {\n    for (int u : adj[v]) {\n        if (u != parent[v]) {\n            parent[u] = v;\n            dfs(u);\n        }\n    }\n}\n\nvector<int> pruefer_code() {\n    int n = adj.size();\n    parent.resize(n);\n    parent[n-1] = -1;\n    dfs(n-1);\n\n    int ptr = -1;\n    vector<int> degree(n);\n    for (int i = 0; i < n; i++) {\n        degree[i] = adj[i].size();\n        if (degree[i] == 1 && ptr == -1)\n            ptr = i;\n    }\n\n    vector<int> code(n - 2);\n    int leaf = ptr;\n    for (int i = 0; i < n - 2; i++) {\n        int next = parent[leaf];\n        code[i] = next;\n        if (--degree[next] == 1 && next < ptr) {\n            leaf = next;\n        } else {\n            ptr++;\n            while (degree[ptr] != 1)\n                ptr++;\n            leaf = ptr;\n        }\n    }\n\n    return code;\n}\n```\n\nIn the code we first find for each its ancestor `parent[i]`, i.e. the ancestor that this vertex will have once we remove it from the tree.\nWe can find this ancestor by rooting the tree at the vertex $n-1$.\nThis is possible because the vertex $n-1$ will never be removed from the tree.\nWe also compute the degree for each vertex.\n`ptr` is the pointer that indicates the minimum size of the remaining leaf vertices (except the current one `leaf`).\nWe will either assign the current leaf vertex with `next`, if this one is also a leaf vertex and it is smaller than `ptr`, or we start a linear search for the smallest leaf vertex by increasing the pointer.\n\nIt can be easily seen, that this code has the complexity $O(n)$.\n\n### Some properties of the Pr\u00fcfer code\n\n- After constructing the Pr\u00fcfer code two vertices will remain.\n  One of them is the highest vertex $n-1$, but nothing else can be said about the other one.\n- Each vertex appears in the Pr\u00fcfer code exactly a fixed number of times - its degree minus one.\n  This can be easily checked, since the degree will get smaller every time we record its label in the code, and we remove it once the degree is $1$.\n  For the two remaining vertices this fact is also true.\n\n### Restoring the tree using the Pr\u00fcfer code\n\nTo restore the tree it suffice to only focus on the property discussed in the last section.\nWe already know the degree of all the vertices in the desired tree.\nTherefore we can find all leaf vertices, and also the first leaf that was removed in the first step (it has to be the smallest leaf).\nThis leaf vertex was connected to the vertex corresponding to the number in the first cell of the Pr\u00fcfer code.\n\nThus we found the first edge removed by when then the Pr\u00fcfer code was generated.\nWe can add this edge to the answer and reduce the degrees at both ends of the edge.\n\nWe will repeat this operation until we have used all numbers of the Pr\u00fcfer code:\nwe look for the minimum vertex with degree equal to $1$, connect it with the next vertex from the Pr\u00fcfer code, and reduce the degree.\n\nIn the end we only have two vertices left with degree equal to $1$.\nThese are the vertices that didn't got removed by the Pr\u00fcfer code process.\nWe connect them to get the last edge of the tree.\nOne of them will always be the vertex $n-1$.\n\nThis algorithm can be **implemented** easily in $O(n \\log n)$: we use a data structure that supports extracting the minimum (for example `set<>` or `priority_queue<>` in C++) to store all the leaf vertices.\n\nThe following implementation returns the list of edges corresponding to the tree.\n\n```{.cpp file=pruefer_decode_slow}\nvector<pair<int, int>> pruefer_decode(vector<int> const& code) {\n    int n = code.size() + 2;\n    vector<int> degree(n, 1);\n    for (int i : code)\n        degree[i]++;\n\n    set<int> leaves;\n    for (int i = 0; i < n; i++) {\n        if (degree[i] == 1)\n            leaves.insert(i);\n    }\n\n    vector<pair<int, int>> edges;\n    for (int v : code) {\n        int leaf = *leaves.begin();\n        leaves.erase(leaves.begin());\n\n        edges.emplace_back(leaf, v);\n        if (--degree[v] == 1)\n            leaves.insert(v);\n    }\n    edges.emplace_back(*leaves.begin(), n-1);\n    return edges;\n}\n```\n\n### Restoring the tree using the Pr\u00fcfer code in linear time\n\nTo obtain the tree in linear time we can apply the same technique used to obtain the Pr\u00fcfer code in linear time.\n\nWe don't need a data structure to extract the minimum.\nInstead we can notice that, after processing the current edge, only one vertex becomes a leaf.\nTherefore we can either continue with this vertex, or we find a smaller one with a linear search by moving a pointer.\n\n```{.cpp file=pruefer_decode_fast}\nvector<pair<int, int>> pruefer_decode(vector<int> const& code) {\n    int n = code.size() + 2;\n    vector<int> degree(n, 1);\n    for (int i : code)\n        degree[i]++;\n\n    int ptr = 0;\n    while (degree[ptr] != 1)\n        ptr++;\n    int leaf = ptr;\n\n    vector<pair<int, int>> edges;\n    for (int v : code) {\n        edges.emplace_back(leaf, v);\n        if (--degree[v] == 1 && v < ptr) {\n            leaf = v;\n        } else {\n            ptr++;\n            while (degree[ptr] != 1)\n                ptr++;\n            leaf = ptr;\n        }\n    }\n    edges.emplace_back(leaf, n-1);\n    return edges;\n}\n```\n\n### Bijection between trees and Pr\u00fcfer codes\n\nFor each tree there exists a Pr\u00fcfer code corresponding to it.\nAnd for each Pr\u00fcfer code we can restore the original tree.\n\nIt follows that also every Pr\u00fcfer code (i.e. a sequence of $n-2$ numbers in the range $[0; n - 1]$) corresponds to a tree.\n\nTherefore all trees and all Pr\u00fcfer codes form a bijection (a **one-to-one correspondence**).\n\n## Cayley's formula\n\nCayley's formula states that the **number of spanning trees in a complete labeled graph** with $n$ vertices is equal to:\n\n$$n^{n-2}$$\n\nThere are multiple proofs for this formula.\nUsing the Pr\u00fcfer code concept this statement comes without any surprise.\n\nIn fact any Pr\u00fcfer code with $n-2$ numbers from the interval $[0; n-1]$ corresponds to some tree with $n$ vertices.\nSo we have $n^{n-2}$ different such Pr\u00fcfer codes.\nSince each such tree is a spanning tree of a complete graph with $n$ vertices, the number of such spanning trees is also $n^{n-2}$.\n\n## Number of ways to make a graph connected\n\nThe concept of Pr\u00fcfer codes are even more powerful.\nIt allows to create a lot more general formulas than Cayley's formula.\n\nIn this problem we are given a graph with $n$ vertices and $m$ edges.\nThe graph currently has $k$ components.\nWe want to compute the number of ways of adding $k-1$ edges so that the graph becomes connected (obviously $k-1$ is the minimum number necessary to make the graph connected).\n\nLet us derive a formula for solving this problem.\n\nWe use $s_1, \\dots, s_k$ for the sizes of the connected components in the graph.\nWe cannot add edges within a connected component.\nTherefore it turns out that this problem is very similar to the search for the number of spanning trees of a complete graph with $k$ vertices.\nThe only difference is that each vertex has actually the size $s_i$: each edge connecting the vertex $i$, actually multiplies the answer by $s_i$.\n\nThus in order to calculate the number of possible ways it is important to count how often each of the $k$ vertices is used in the connecting tree.\nTo obtain a formula for the problem it is necessary to sum the answer over all possible degrees.\n\nLet $d_1, \\dots, d_k$ be the degrees of the vertices in the tree after connecting the vertices.\nThe sum of the degrees is twice the number of edges:\n\n$$\\sum_{i=1}^k d_i = 2k - 2$$\n\nIf the vertex $i$ has degree $d_i$, then it appears $d_i - 1$ times in the Pr\u00fcfer code.\nThe Pr\u00fcfer code for a tree with $k$ vertices has length $k-2$.\nSo the number of ways to choose a code with $k-2$ numbers where the number $i$ appears exactly $d_i - 1$ times is equal to the **multinomial coefficient**\n\n$$\\binom{k-2}{d_1-1, d_2-1, \\dots, d_k-1} = \\frac{(k-2)!}{(d_1-1)! (d_2-1)! \\cdots (d_k-1)!}.$$\n\nThe fact that each edge adjacent to the vertex $i$ multiplies the answer by $s_i$ we receive the answer, assuming that the degrees of the vertices are $d_1, \\dots, d_k$:\n\n$$s_1^{d_1} \\cdot s_2^{d_2} \\cdots s_k^{d_k} \\cdot \\binom{k-2}{d_1-1, d_2-1, \\dots, d_k-1}$$\n\nTo get the final answer we need to sum this for all possible ways to choose the degrees:\n\n$$\\sum_{\\substack{d_i \\ge 1 \\\\\\\\ \\sum_{i=1}^k d_i = 2k -2}} s_1^{d_1} \\cdot s_2^{d_2} \\cdots s_k^{d_k} \\cdot \\binom{k-2}{d_1-1, d_2-1, \\dots, d_k-1}$$\n\nCurrently this looks like a really horrible answer, however we can use the **multinomial theorem**, which says:\n\n$$(x_1 + \\dots + x_m)^p = \\sum_{\\substack{c_i \\ge 0 \\\\\\\\ \\sum_{i=1}^m c_i = p}} x_1^{c_1} \\cdot x_2^{c_2} \\cdots x_m^{c_m} \\cdot \\binom{p}{c_1, c_2, \\dots c_m}$$\n\nThis look already pretty similar.\nTo use it we only need to substitute with $e_i = d_i - 1$:\n\n$$\\sum_{\\substack{e_i \\ge 0 \\\\\\\\ \\sum_{i=1}^k e_i = k - 2}} s_1^{e_1+1} \\cdot s_2^{e_2+1} \\cdots s_k^{e_k+1} \\cdot \\binom{k-2}{e_1, e_2, \\dots, e_k}$$\n\nAfter applying the multinomial theorem we get the **answer to the problem**:\n\n$$s_1 \\cdot s_2 \\cdots s_k \\cdot (s_1 + s_2 + \\dots + s_k)^{k-2} = s_1 \\cdot s_2 \\cdots s_k \\cdot n^{k-2}$$\n\nBy accident this formula also holds for $k = 1$.\n\n## Practice problems\n\n- [UVA #10843 - Anne's game](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=20&page=show_problem&problem=1784)\n- [Timus #1069 - Prufer Code](http://acm.timus.ru/problem.aspx?space=1&num=1069)\n- [Codeforces - Clues](http://codeforces.com/contest/156/problem/D)\n- [Topcoder - TheCitiesAndRoadsDivTwo](https://community.topcoder.com/stat?c=problem_statement&pm=10774&rd=14146)\n", "problem_ids": ["156_D"], "title": "Pr\u00fcfer code"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link:\n  - rib_connectivity\n  - vertex_connectivity\n---\n\n# Edge connectivity / Vertex connectivity\n\n## Definition\n\nGiven an undirected graph $G$ with $n$ vertices and $m$ edges.\nBoth the edge connectivity and the vertex connectivity are characteristics describing the graph.\n\n### Edge connectivity\n\nThe **edge connectivity** $\\lambda$ of the graph $G$ is the minimum number of edges that need to be deleted, such that the graph $G$ gets disconnected.\n\nFor example an already disconnected graph has an edge connectivity of $0$, a connected graph with at least one bridge has an edge connectivity of $1$, and a connected graph with no bridges has an edge connectivity of at least $2$.\n\nWe say that a set $S$ of edges **separates** the vertices $s$ and $t$, if, after removing all edges in $S$ from the graph $G$, the vertices $s$ and $t$ end up in different connected components.\n\nIt is clear, that the edge connectivity of a graph is equal to the minimum size of such a set separating two vertices $s$ and $t$, taken among all possible pairs $(s, t)$.\n\n### Vertex connectivity\n\nThe **vertex connectivity** $\\kappa$ of the graph $G$ is the minimum number of vertices that need to be deleted, such that the graph $G$ gets disconnected.\n\nFor example an already disconnected graph has the vertex connectivity $0$, and a connected graph with an articulation point has the vertex connectivity $1$.\nWe define that a complete graph has the vertex connectivity $n-1$.\nFor all other graphs the vertex connectivity doesn't exceed $n-2$, because you can find a pair of vertices which are not connected by an edge, and remove all other $n-2$ vertices.\n\nWe say that a set $T$ of vertices **separates** the vertices $s$ and $t$, if, after removing all vertices in $T$ from the graph $G$, the vertices end up in different connected components.\n\nIt is clear, that the vertex connectivity of a graph is equal to the minimal size of such a set separating two vertices $s$ and $t$, taken among all possible pairs $(s, t)$.\n\n## Properties\n\n### The Whitney inequalities\n\nThe **Whitney inequalities** (1932) gives a relation between the edge connectivity $\\lambda$, the vertex connectivity $\\kappa$ and the smallest degree of the vertices $\\delta$:\n\n$$\\kappa \\le \\lambda \\le \\delta$$\n\nIntuitively if we have a set of edges of size $\\lambda$, which make the graph disconnected, we can choose one of each end point, and create a set of vertices, that also disconnect the graph.\nAnd this set has size $\\le \\lambda$.\n\nAnd if we pick the vertex and the minimal degree $\\delta$, and remove all edges connected to it, then we also end up with a disconnected graph.\nTherefore the second inequality $\\lambda \\le \\delta$.\n\nIt is interesting to note, that the Whitney inequalities cannot be improved:\ni.e. for any triple of numbers satisfying this inequality there exists at least one corresponding graph.\nOne such graph can be constructed in the following way:\nThe graph will consists of $2(\\delta + 1)$ vertices, the first $\\delta + 1$ vertices form a clique (all pairs of vertices are connected via an edge), and the second $\\delta + 1$ vertices form a second clique.\nIn addition we connect the two cliques with $\\lambda$ edges, such that it uses $\\lambda$ different vertices in the first clique, and only $\\kappa$ vertices in the second clique.\nThe resulting graph will have the three characteristics.\n\n### The Ford-Fulkerson theorem\n\nThe **Ford-Fulkerson theorem** implies, that the biggest number of edge-disjoint paths connecting two vertices, is equal to the smallest number of edges separating these vertices.\n\n## Computing the values\n\n### Edge connectivity using maximum flow\n\nThis method is based on the Ford-Fulkerson theorem.\n\nWe iterate over all pairs of vertices $(s, t)$ and between each pair we find the largest number of disjoint paths between them.\nThis value can be found using a maximum flow algorithm:\nwe use $s$ as the source, $t$ as the sink, and assign each edge a capacity of $1$.\nThen the maximum flow is the number of disjoint paths.\n\nThe complexity for the algorithm using [Edmonds-Karp](../graph/edmonds_karp.md) is $O(V^2 V E^2) = O(V^3 E^2)$. \nBut we should note, that this includes a hidden factor, since it is practically impossible to create a graph such that the maximum flow algorithm will be slow for all sources and sinks.\nEspecially the algorithm will run pretty fast for random graphs.\n\n### Special algorithm for edge connectivity \n\nThe task of finding the edge connectivity if equal to the task of finding the **global minimum cut**.\n\nSpecial algorithms have been developed for this task.\nOne of them is the Stoer-Wagner algorithm, which works in $O(V^3)$ or $O(V E)$ time.\n\n### Vertex connectivity\n\nAgain we iterate over all pairs of vertices $s$ and $t$, and for each pair we find the minimum number of vertices that separates $s$ and $t$.\n\nBy doing this, we can apply the same maximum flow approach as described in the previous sections.\n\nWe split each vertex $x$ with $x \\neq s$ and $x \\neq t$ into two vertices $x_1$ and $x_2$.\nWe connect these to vertices with a directed edge $(x_1, x_2)$ with the capacity $1$, and replace all edges $(u, v)$ by the two directed edges $(u_2, v_1)$ and $(v_2, u_1)$, both with the capacity of 1.\nThe by the construction the value of the maximum flow will be equal to the minimum number of vertices that are needed to separate $s$ and $t$.\n\nThis approach has the same complexity as the flow approach for finding the edge connectivity.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link:\n  - rib_connectivity\n  - vertex_connectivity\n---\n\n# Edge connectivity / Vertex connectivity\n\n## Definition\n\nGiven an undirected graph $G$ with $n$ vertices and $m$ edges.\nBoth the edge connectivity and the vertex connectivity are characteristics describing the graph.\n\n### Edge connectivity\n\nThe **edge connectivity** $\\lambda$ of the graph $G$ is the minimum number of edges that need to be deleted, such that the graph $G$ gets disconnected.\n\nFor example an already disconnected graph has an edge connectivity of $0$, a connected graph with at least one bridge has an edge connectivity of $1$, and a connected graph with no bridges has an edge connectivity of at least $2$.\n\nWe say that a set $S$ of edges **separates** the vertices $s$ and $t$, if, after removing all edges in $S$ from the graph $G$, the vertices $s$ and $t$ end up in different connected components.\n\nIt is clear, that the edge connectivity of a graph is equal to the minimum size of such a set separating two vertices $s$ and $t$, taken among all possible pairs $(s, t)$.\n\n### Vertex connectivity\n\nThe **vertex connectivity** $\\kappa$ of the graph $G$ is the minimum number of vertices that need to be deleted, such that the graph $G$ gets disconnected.\n\nFor example an already disconnected graph has the vertex connectivity $0$, and a connected graph with an articulation point has the vertex connectivity $1$.\nWe define that a complete graph has the vertex connectivity $n-1$.\nFor all other graphs the vertex connectivity doesn't exceed $n-2$, because you can find a pair of vertices which are not connected by an edge, and remove all other $n-2$ vertices.\n\nWe say that a set $T$ of vertices **separates** the vertices $s$ and $t$, if, after removing all vertices in $T$ from the graph $G$, the vertices end up in different connected components.\n\nIt is clear, that the vertex connectivity of a graph is equal to the minimal size of such a set separating two vertices $s$ and $t$, taken among all possible pairs $(s, t)$.\n\n## Properties\n\n### The Whitney inequalities\n\nThe **Whitney inequalities** (1932) gives a relation between the edge connectivity $\\lambda$, the vertex connectivity $\\kappa$ and the smallest degree of the vertices $\\delta$:\n\n$$\\kappa \\le \\lambda \\le \\delta$$\n\nIntuitively if we have a set of edges of size $\\lambda$, which make the graph disconnected, we can choose one of each end point, and create a set of vertices, that also disconnect the graph.\nAnd this set has size $\\le \\lambda$.\n\nAnd if we pick the vertex and the minimal degree $\\delta$, and remove all edges connected to it, then we also end up with a disconnected graph.\nTherefore the second inequality $\\lambda \\le \\delta$.\n\nIt is interesting to note, that the Whitney inequalities cannot be improved:\ni.e. for any triple of numbers satisfying this inequality there exists at least one corresponding graph.\nOne such graph can be constructed in the following way:\nThe graph will consists of $2(\\delta + 1)$ vertices, the first $\\delta + 1$ vertices form a clique (all pairs of vertices are connected via an edge), and the second $\\delta + 1$ vertices form a second clique.\nIn addition we connect the two cliques with $\\lambda$ edges, such that it uses $\\lambda$ different vertices in the first clique, and only $\\kappa$ vertices in the second clique.\nThe resulting graph will have the three characteristics.\n\n### The Ford-Fulkerson theorem\n\nThe **Ford-Fulkerson theorem** implies, that the biggest number of edge-disjoint paths connecting two vertices, is equal to the smallest number of edges separating these vertices.\n\n## Computing the values\n\n### Edge connectivity using maximum flow\n\nThis method is based on the Ford-Fulkerson theorem.\n\nWe iterate over all pairs of vertices $(s, t)$ and between each pair we find the largest number of disjoint paths between them.\nThis value can be found using a maximum flow algorithm:\nwe use $s$ as the source, $t$ as the sink, and assign each edge a capacity of $1$.\nThen the maximum flow is the number of disjoint paths.\n\nThe complexity for the algorithm using [Edmonds-Karp](../graph/edmonds_karp.md) is $O(V^2 V E^2) = O(V^3 E^2)$. \nBut we should note, that this includes a hidden factor, since it is practically impossible to create a graph such that the maximum flow algorithm will be slow for all sources and sinks.\nEspecially the algorithm will run pretty fast for random graphs.\n\n### Special algorithm for edge connectivity \n\nThe task of finding the edge connectivity if equal to the task of finding the **global minimum cut**.\n\nSpecial algorithms have been developed for this task.\nOne of them is the Stoer-Wagner algorithm, which works in $O(V^3)$ or $O(V E)$ time.\n\n### Vertex connectivity\n\nAgain we iterate over all pairs of vertices $s$ and $t$, and for each pair we find the minimum number of vertices that separates $s$ and $t$.\n\nBy doing this, we can apply the same maximum flow approach as described in the previous sections.\n\nWe split each vertex $x$ with $x \\neq s$ and $x \\neq t$ into two vertices $x_1$ and $x_2$.\nWe connect these to vertices with a directed edge $(x_1, x_2)$ with the capacity $1$, and replace all edges $(u, v)$ by the two directed edges $(u_2, v_1)$ and $(v_2, u_1)$, both with the capacity of 1.\nThe by the construction the value of the maximum flow will be equal to the minimum number of vertices that are needed to separate $s$ and $t$.\n\nThis approach has the same complexity as the flow approach for finding the edge connectivity.\n", "problem_ids": [], "title": "Edge connectivity / Vertex connectivity"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: dinic\n---\n\n# Maximum flow - Dinic's algorithm\n\nDinic's algorithm solves the maximum flow problem in $O(V^2E)$. The maximum flow problem is defined in this article [Maximum flow - Ford-Fulkerson and Edmonds-Karp](edmonds_karp.md). This algorithm was discovered by Yefim Dinitz in 1970.\n\n## Definitions\n\nA **residual network** $G^R$ of network $G$ is a network which contains two edges for each edge $(v, u)\\in G$:<br>\n\n- $(v, u)$ with capacity $c_{vu}^R = c_{vu} - f_{vu}$\n- $(u, v)$ with capacity $c_{uv}^R = f_{vu}$\n\nA **blocking flow** of some network is such a flow that every path from $s$ to $t$ contains at least one edge which is saturated by this flow. Note that a blocking flow is not necessarily maximal.\n\nA **layered network** of a network $G$ is a network built in the following way. Firstly, for each vertex $v$ we calculate $level[v]$ - the shortest path (unweighted) from $s$ to this vertex using only edges with positive capacity. Then we keep only those edges $(v, u)$ for which $level[v] + 1 = level[u]$. Obviously, this network is acyclic.\n\n## Algorithm\n\nThe algorithm consists of several phases. On each phase we construct the layered network of the residual network of $G$. Then we find an arbitrary blocking flow in the layered network and add it to the current flow.\n\n## Proof of correctness\n\nLet's show that if the algorithm terminates, it finds the maximum flow.\n\nIf the algorithm terminated, it couldn't find a blocking flow in the layered network. It means that the layered network doesn't have any path from $s$ to $t$.  It means that the residual network doesn't have any path from $s$ to $t$. It means that the flow is maximum.\n\n## Number of phases\n\nThe algorithm terminates in less than $V$ phases. To prove this, we must firstly prove two lemmas.\n\n**Lemma 1.** The distances from $s$ to each vertex don't decrease after each iteration, i. e. $level_{i+1}[v] \\ge level_i[v]$.\n\n**Proof.** Fix a phase $i$ and a vertex $v$. Consider any shortest path $P$ from $s$ to $v$ in $G_{i+1}^R$. The length of $P$ equals $level_{i+1}[v]$. Note that $G_{i+1}^R$ can only contain edges from $G_i^R$ and back edges for edges from $G_i^R$. If $P$ has no back edges for $G_i^R$, then $level_{i+1}[v] \\ge level_i[v]$ because $P$ is also a path in $G_i^R$. Now, suppose that $P$ has at least one back edge. Let the first such edge be $(u, w)$.Then $level_{i+1}[u] \\ge level_i[u]$ (because of the first case). The edge $(u, w)$ doesn't belong to $G_i^R$, so the edge $(w, u)$ was affected by the blocking flow on the previous iteration. It means that $level_i[u] = level_i[w] + 1$. Also, $level_{i+1}[w] = level_{i+1}[u] + 1$. From these two equations and $level_{i+1}[u] \\ge level_i[u]$ we obtain $level_{i+1}[w] \\ge level_i[w] + 2$. Now we can use the same idea for the rest of the path.\n\n**Lemma 2.** $level_{i+1}[t] > level_i[t]$\n\n**Proof.** From the previous lemma, $level_{i+1}[t] \\ge level_i[t]$. Suppose that $level_{i+1}[t] = level_i[t]$. Note that $G_{i+1}^R$ can only contain edges from $G_i^R$ and back edges for edges from $G_i^R$. It means that there is a shortest path in $G_i^R$ which wasn't blocked by the blocking flow. It's a contradiction.\n\nFrom these two lemmas we conclude that there are less than $V$ phases because $level[t]$ increases, but it can't be greater than $V - 1$.\n\n## Finding blocking flow\n\nIn order to find the blocking flow on each iteration, we may simply try pushing flow with DFS from $s$ to $t$ in the layered network while it can be pushed. In order to do it more quickly, we must remove the edges which can't be used to push anymore. To do this we can keep a pointer in each vertex which points to the next edge which can be used.\n\nA single DFS run takes $O(k+V)$ time, where $k$ is the number of pointer advances on this run. Summed up over all runs, number of pointer advances can not exceed $E$. On the other hand, total number of runs won't exceed $E$, as every run saturates at least one edge. In this way, total running time of finding a blocking flow is $O(VE)$.\n\n## Complexity\n\nThere are less than $V$ phases, so the total complexity is $O(V^2E)$.\n\n## Unit networks\n\nA **unit network** is a network in which for any vertex except $s$ and $t$ **either incoming or outgoing edge is unique and has unit capacity**. That's exactly the case with the network we build to solve the maximum matching problem with flows.\n\nOn unit networks Dinic's algorithm works in $O(E\\sqrt{V})$. Let's prove this.\n\nFirstly, each phase now works in $O(E)$ because each edge will be considered at most once.\n\nSecondly, suppose there have already been $\\sqrt{V}$ phases. Then all the augmenting paths with the length $\\le\\sqrt{V}$ have been found. Let $f$ be the current flow, $f'$ be the maximum flow. Consider their difference $f' - f$. It is a flow in $G^R$ of value $|f'| - |f|$ and on each edge it is either $0$ or $1$. It can be decomposed into $|f'| - |f|$ paths from $s$ to $t$ and possibly cycles. As the network is unit, they can't have common vertices, so the total number of vertices is $\\ge (|f'| - |f|)\\sqrt{V}$, but it is also $\\le V$, so in another $\\sqrt{V}$ iterations we will definitely find the maximum flow.\n\n### Unit capacities networks\n\nIn a more generic settings when all edges have unit capacities, _but the number of incoming and outgoing edges is unbounded_, the paths can't have common edges rather than common vertices. In a similar way it allows to prove the bound of $\\sqrt E$ on the number of iterations, hence the running time of Dinic algorithm on such networks is at most $O(E \\sqrt E)$.\n\nFinally, it is also possible to prove that the number of phases on unit capacity networks doesn't exceed $O(V^{2/3})$, providing an alternative estimate of $O(EV^{2/3})$ on the networks with particularly large number of edges.\n\n## Implementation\n\n```{.cpp file=dinic}\nstruct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<vector<int>> adj;\n    int n, m = 0;\n    int s, t;\n    vector<int> level, ptr;\n    queue<int> q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap - edges[id].flow < 1)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: dinic\n---\n\n# Maximum flow - Dinic's algorithm\n\nDinic's algorithm solves the maximum flow problem in $O(V^2E)$. The maximum flow problem is defined in this article [Maximum flow - Ford-Fulkerson and Edmonds-Karp](edmonds_karp.md). This algorithm was discovered by Yefim Dinitz in 1970.\n\n## Definitions\n\nA **residual network** $G^R$ of network $G$ is a network which contains two edges for each edge $(v, u)\\in G$:<br>\n\n- $(v, u)$ with capacity $c_{vu}^R = c_{vu} - f_{vu}$\n- $(u, v)$ with capacity $c_{uv}^R = f_{vu}$\n\nA **blocking flow** of some network is such a flow that every path from $s$ to $t$ contains at least one edge which is saturated by this flow. Note that a blocking flow is not necessarily maximal.\n\nA **layered network** of a network $G$ is a network built in the following way. Firstly, for each vertex $v$ we calculate $level[v]$ - the shortest path (unweighted) from $s$ to this vertex using only edges with positive capacity. Then we keep only those edges $(v, u)$ for which $level[v] + 1 = level[u]$. Obviously, this network is acyclic.\n\n## Algorithm\n\nThe algorithm consists of several phases. On each phase we construct the layered network of the residual network of $G$. Then we find an arbitrary blocking flow in the layered network and add it to the current flow.\n\n## Proof of correctness\n\nLet's show that if the algorithm terminates, it finds the maximum flow.\n\nIf the algorithm terminated, it couldn't find a blocking flow in the layered network. It means that the layered network doesn't have any path from $s$ to $t$.  It means that the residual network doesn't have any path from $s$ to $t$. It means that the flow is maximum.\n\n## Number of phases\n\nThe algorithm terminates in less than $V$ phases. To prove this, we must firstly prove two lemmas.\n\n**Lemma 1.** The distances from $s$ to each vertex don't decrease after each iteration, i. e. $level_{i+1}[v] \\ge level_i[v]$.\n\n**Proof.** Fix a phase $i$ and a vertex $v$. Consider any shortest path $P$ from $s$ to $v$ in $G_{i+1}^R$. The length of $P$ equals $level_{i+1}[v]$. Note that $G_{i+1}^R$ can only contain edges from $G_i^R$ and back edges for edges from $G_i^R$. If $P$ has no back edges for $G_i^R$, then $level_{i+1}[v] \\ge level_i[v]$ because $P$ is also a path in $G_i^R$. Now, suppose that $P$ has at least one back edge. Let the first such edge be $(u, w)$.Then $level_{i+1}[u] \\ge level_i[u]$ (because of the first case). The edge $(u, w)$ doesn't belong to $G_i^R$, so the edge $(w, u)$ was affected by the blocking flow on the previous iteration. It means that $level_i[u] = level_i[w] + 1$. Also, $level_{i+1}[w] = level_{i+1}[u] + 1$. From these two equations and $level_{i+1}[u] \\ge level_i[u]$ we obtain $level_{i+1}[w] \\ge level_i[w] + 2$. Now we can use the same idea for the rest of the path.\n\n**Lemma 2.** $level_{i+1}[t] > level_i[t]$\n\n**Proof.** From the previous lemma, $level_{i+1}[t] \\ge level_i[t]$. Suppose that $level_{i+1}[t] = level_i[t]$. Note that $G_{i+1}^R$ can only contain edges from $G_i^R$ and back edges for edges from $G_i^R$. It means that there is a shortest path in $G_i^R$ which wasn't blocked by the blocking flow. It's a contradiction.\n\nFrom these two lemmas we conclude that there are less than $V$ phases because $level[t]$ increases, but it can't be greater than $V - 1$.\n\n## Finding blocking flow\n\nIn order to find the blocking flow on each iteration, we may simply try pushing flow with DFS from $s$ to $t$ in the layered network while it can be pushed. In order to do it more quickly, we must remove the edges which can't be used to push anymore. To do this we can keep a pointer in each vertex which points to the next edge which can be used.\n\nA single DFS run takes $O(k+V)$ time, where $k$ is the number of pointer advances on this run. Summed up over all runs, number of pointer advances can not exceed $E$. On the other hand, total number of runs won't exceed $E$, as every run saturates at least one edge. In this way, total running time of finding a blocking flow is $O(VE)$.\n\n## Complexity\n\nThere are less than $V$ phases, so the total complexity is $O(V^2E)$.\n\n## Unit networks\n\nA **unit network** is a network in which for any vertex except $s$ and $t$ **either incoming or outgoing edge is unique and has unit capacity**. That's exactly the case with the network we build to solve the maximum matching problem with flows.\n\nOn unit networks Dinic's algorithm works in $O(E\\sqrt{V})$. Let's prove this.\n\nFirstly, each phase now works in $O(E)$ because each edge will be considered at most once.\n\nSecondly, suppose there have already been $\\sqrt{V}$ phases. Then all the augmenting paths with the length $\\le\\sqrt{V}$ have been found. Let $f$ be the current flow, $f'$ be the maximum flow. Consider their difference $f' - f$. It is a flow in $G^R$ of value $|f'| - |f|$ and on each edge it is either $0$ or $1$. It can be decomposed into $|f'| - |f|$ paths from $s$ to $t$ and possibly cycles. As the network is unit, they can't have common vertices, so the total number of vertices is $\\ge (|f'| - |f|)\\sqrt{V}$, but it is also $\\le V$, so in another $\\sqrt{V}$ iterations we will definitely find the maximum flow.\n\n### Unit capacities networks\n\nIn a more generic settings when all edges have unit capacities, _but the number of incoming and outgoing edges is unbounded_, the paths can't have common edges rather than common vertices. In a similar way it allows to prove the bound of $\\sqrt E$ on the number of iterations, hence the running time of Dinic algorithm on such networks is at most $O(E \\sqrt E)$.\n\nFinally, it is also possible to prove that the number of phases on unit capacity networks doesn't exceed $O(V^{2/3})$, providing an alternative estimate of $O(EV^{2/3})$ on the networks with particularly large number of edges.\n\n## Implementation\n\n```{.cpp file=dinic}\nstruct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<vector<int>> adj;\n    int n, m = 0;\n    int s, t;\n    vector<int> level, ptr;\n    queue<int> q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap - edges[id].flow < 1)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n```\n", "problem_ids": [], "title": "Maximum flow - Dinic's algorithm"}, {"article": "---\ntitle: Finding the Eulerian path in O(M)\ntags:\n  - Translated\ne_maxx_link: euler_path\n---\n# Finding the Eulerian path in $O(M)$\n\nA Eulerian path is a path in a graph that passes through all of its edges exactly once.\nA Eulerian cycle is a Eulerian path that is a cycle.\n\nThe problem is to find the Eulerian path in an **undirected multigraph with loops**.\n\n## Algorithm\n\nFirst we can check if there is an Eulerian path.\nWe can use the following theorem. An Eulerian cycle exists if and only if the degrees of all vertices are even.\nAnd an Eulerian path exists if and only if the number of vertices with odd degrees is two (or zero, in the case of the existence of a Eulerian cycle).\nIn addition, of course, the graph must be sufficiently connected (i.e., if you remove all isolated vertices from it, you should get a connected graph).\n\nTo find the Eulerian path / Eulerian cycle we can use the following strategy:\nWe find all simple cycles and combine them into one - this will be the Eulerian cycle.\nIf the graph is such that the Eulerian path is not a cycle, then add the missing edge, find the Eulerian cycle, then remove the extra edge.\n\nLooking for all cycles and combining them can be done with a simple recursive procedure:\n\n```nohighlight\nprocedure FindEulerPath(V)\n  1. iterate through all the edges outgoing from vertex V;\n       remove this edge from the graph,\n       and call FindEulerPath from the second end of this edge;\n  2. add vertex V to the answer.\n```\n\nThe complexity of this algorithm is obviously linear with respect to the number of edges.\n\nBut we can write the same algorithm in the non-recursive version:\n\n```nohighlight\nstack St;\nput start vertex in St;\nuntil St is empty\n  let V be the value at the top of St;\n  if degree(V) = 0, then\n    add V to the answer;\n    remove V from the top of St;\n  otherwise\n    find any edge coming out of V;\n    remove it from the graph;\n    put the second end of this edge in St;\n```\n\nIt is easy to check the equivalence of these two forms of the algorithm. However, the second form is obviously faster, and the code will be much more efficient.\n\n## The Domino problem\n\nWe give here a classical Eulerian cycle problem - the Domino problem.\n\nThere are $N$ dominoes, as it is known, on both ends of the Domino one number is written(usually from 1 to 6, but in our case it is not important). You want to put all the dominoes in a row so that the numbers on any two adjacent dominoes, written on their common side, coincide. Dominoes are allowed to turn.\n\nReformulate the problem. Let the numbers written on the bottoms be the vertices of the graph, and the dominoes be the edges of this graph (each Domino with numbers $(a,b)$ are the edges $(a,b)$ and $(b, a)$). Then our problem is reduced to the problem of finding the Eulerian path in this graph.\n\n## Implementation\n\nThe program below searches for and outputs a Eulerian loop or path in a graph, or outputs $-1$ if it does not exist.\n\nFirst, the program checks the degree of vertices: if there are no vertices with an odd degree, then the graph has an Euler cycle, if there are $2$ vertices with an odd degree, then in the graph there is only an Euler path (but no Euler cycle), if there are more than $2$ such vertices, then in the graph there is no Euler cycle or Euler path.\nTo find the Euler path (not a cycle), let's do this: if $V1$ and $V2$ are two vertices of odd degree, then just add an edge $(V1, V2)$, in the resulting graph we find the Euler cycle (it will obviously exist), and then remove the \"fictitious\" edge $(V1, V2)$ from the answer.\nWe will look for the Euler cycle exactly as described above (non-recursive version), and at the same time at the end of this algorithm we will check whether the graph was connected or not (if the graph was not connected, then at the end of the algorithm some edges will remain in the graph, and in this case we need to print $-1$).\nFinally, the program takes into account that there can be isolated vertices in the graph.\n\nNotice that we use an adjacency matrix in this problem.\nAlso this implementation handles finding the next with brute-force, which requires to iterate over the complete row in the matrix over and over.\nA better way would be to store the graph as an adjacency list, and remove edges in $O(1)$ and mark the reversed edges in separate list.\nThis way we can archive a $O(N)$ algorithm.\n\n```cpp\nint main() {\n    int n;\n    vector<vector<int>> g(n, vector<int>(n));\n    // reading the graph in the adjacency matrix\n\n    vector<int> deg(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j)\n            deg[i] += g[i][j];\n    }\n\n    int first = 0;\n    while (first < n && !deg[first])\n        ++first;\n    if (first == n) {\n        cout << -1;\n        return 0;\n    }\n\n    int v1 = -1, v2 = -1;\n    bool bad = false;\n    for (int i = 0; i < n; ++i) {\n        if (deg[i] & 1) {\n            if (v1 == -1)\n                v1 = i;\n            else if (v2 == -1)\n                v2 = i;\n            else\n                bad = true;\n        }\n    }\n\n    if (v1 != -1)\n        ++g[v1][v2], ++g[v2][v1];\n\n    stack<int> st;\n    st.push(first);\n    vector<int> res;\n    while (!st.empty()) {\n        int v = st.top();\n        int i;\n        for (i = 0; i < n; ++i)\n            if (g[v][i])\n                break;\n        if (i == n) {\n            res.push_back(v);\n            st.pop();\n        } else {\n            --g[v][i];\n            --g[i][v];\n            st.push(i);\n        }\n    }\n\n    if (v1 != -1) {\n        for (size_t i = 0; i + 1 < res.size(); ++i) {\n            if ((res[i] == v1 && res[i + 1] == v2) ||\n                (res[i] == v2 && res[i + 1] == v1)) {\n                vector<int> res2;\n                for (size_t j = i + 1; j < res.size(); ++j)\n                    res2.push_back(res[j]);\n                for (size_t j = 1; j <= i; ++j)\n                    res2.push_back(res[j]);\n                res = res2;\n                break;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (g[i][j])\n                bad = true;\n        }\n    }\n\n    if (bad) {\n        cout << -1;\n    } else {\n        for (int x : res)\n            cout << x << \" \";\n    }\n}\n```\n#", "full_article": "---\ntitle: Finding the Eulerian path in O(M)\ntags:\n  - Translated\ne_maxx_link: euler_path\n---\n# Finding the Eulerian path in $O(M)$\n\nA Eulerian path is a path in a graph that passes through all of its edges exactly once.\nA Eulerian cycle is a Eulerian path that is a cycle.\n\nThe problem is to find the Eulerian path in an **undirected multigraph with loops**.\n\n## Algorithm\n\nFirst we can check if there is an Eulerian path.\nWe can use the following theorem. An Eulerian cycle exists if and only if the degrees of all vertices are even.\nAnd an Eulerian path exists if and only if the number of vertices with odd degrees is two (or zero, in the case of the existence of a Eulerian cycle).\nIn addition, of course, the graph must be sufficiently connected (i.e., if you remove all isolated vertices from it, you should get a connected graph).\n\nTo find the Eulerian path / Eulerian cycle we can use the following strategy:\nWe find all simple cycles and combine them into one - this will be the Eulerian cycle.\nIf the graph is such that the Eulerian path is not a cycle, then add the missing edge, find the Eulerian cycle, then remove the extra edge.\n\nLooking for all cycles and combining them can be done with a simple recursive procedure:\n\n```nohighlight\nprocedure FindEulerPath(V)\n  1. iterate through all the edges outgoing from vertex V;\n       remove this edge from the graph,\n       and call FindEulerPath from the second end of this edge;\n  2. add vertex V to the answer.\n```\n\nThe complexity of this algorithm is obviously linear with respect to the number of edges.\n\nBut we can write the same algorithm in the non-recursive version:\n\n```nohighlight\nstack St;\nput start vertex in St;\nuntil St is empty\n  let V be the value at the top of St;\n  if degree(V) = 0, then\n    add V to the answer;\n    remove V from the top of St;\n  otherwise\n    find any edge coming out of V;\n    remove it from the graph;\n    put the second end of this edge in St;\n```\n\nIt is easy to check the equivalence of these two forms of the algorithm. However, the second form is obviously faster, and the code will be much more efficient.\n\n## The Domino problem\n\nWe give here a classical Eulerian cycle problem - the Domino problem.\n\nThere are $N$ dominoes, as it is known, on both ends of the Domino one number is written(usually from 1 to 6, but in our case it is not important). You want to put all the dominoes in a row so that the numbers on any two adjacent dominoes, written on their common side, coincide. Dominoes are allowed to turn.\n\nReformulate the problem. Let the numbers written on the bottoms be the vertices of the graph, and the dominoes be the edges of this graph (each Domino with numbers $(a,b)$ are the edges $(a,b)$ and $(b, a)$). Then our problem is reduced to the problem of finding the Eulerian path in this graph.\n\n## Implementation\n\nThe program below searches for and outputs a Eulerian loop or path in a graph, or outputs $-1$ if it does not exist.\n\nFirst, the program checks the degree of vertices: if there are no vertices with an odd degree, then the graph has an Euler cycle, if there are $2$ vertices with an odd degree, then in the graph there is only an Euler path (but no Euler cycle), if there are more than $2$ such vertices, then in the graph there is no Euler cycle or Euler path.\nTo find the Euler path (not a cycle), let's do this: if $V1$ and $V2$ are two vertices of odd degree, then just add an edge $(V1, V2)$, in the resulting graph we find the Euler cycle (it will obviously exist), and then remove the \"fictitious\" edge $(V1, V2)$ from the answer.\nWe will look for the Euler cycle exactly as described above (non-recursive version), and at the same time at the end of this algorithm we will check whether the graph was connected or not (if the graph was not connected, then at the end of the algorithm some edges will remain in the graph, and in this case we need to print $-1$).\nFinally, the program takes into account that there can be isolated vertices in the graph.\n\nNotice that we use an adjacency matrix in this problem.\nAlso this implementation handles finding the next with brute-force, which requires to iterate over the complete row in the matrix over and over.\nA better way would be to store the graph as an adjacency list, and remove edges in $O(1)$ and mark the reversed edges in separate list.\nThis way we can archive a $O(N)$ algorithm.\n\n```cpp\nint main() {\n    int n;\n    vector<vector<int>> g(n, vector<int>(n));\n    // reading the graph in the adjacency matrix\n\n    vector<int> deg(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j)\n            deg[i] += g[i][j];\n    }\n\n    int first = 0;\n    while (first < n && !deg[first])\n        ++first;\n    if (first == n) {\n        cout << -1;\n        return 0;\n    }\n\n    int v1 = -1, v2 = -1;\n    bool bad = false;\n    for (int i = 0; i < n; ++i) {\n        if (deg[i] & 1) {\n            if (v1 == -1)\n                v1 = i;\n            else if (v2 == -1)\n                v2 = i;\n            else\n                bad = true;\n        }\n    }\n\n    if (v1 != -1)\n        ++g[v1][v2], ++g[v2][v1];\n\n    stack<int> st;\n    st.push(first);\n    vector<int> res;\n    while (!st.empty()) {\n        int v = st.top();\n        int i;\n        for (i = 0; i < n; ++i)\n            if (g[v][i])\n                break;\n        if (i == n) {\n            res.push_back(v);\n            st.pop();\n        } else {\n            --g[v][i];\n            --g[i][v];\n            st.push(i);\n        }\n    }\n\n    if (v1 != -1) {\n        for (size_t i = 0; i + 1 < res.size(); ++i) {\n            if ((res[i] == v1 && res[i + 1] == v2) ||\n                (res[i] == v2 && res[i + 1] == v1)) {\n                vector<int> res2;\n                for (size_t j = i + 1; j < res.size(); ++j)\n                    res2.push_back(res[j]);\n                for (size_t j = 1; j <= i; ++j)\n                    res2.push_back(res[j]);\n                res = res2;\n                break;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (g[i][j])\n                bad = true;\n        }\n    }\n\n    if (bad) {\n        cout << -1;\n    } else {\n        for (int x : res)\n            cout << x << \" \";\n    }\n}\n```\n### Practice problems:\n\n- [CSES : Mail Delivery](https://cses.fi/problemset/task/1691)\n- [CSES : Teleporters Path](https://cses.fi/problemset/task/1693)\n", "problem_ids": [], "title": "Finding the Eulerian path in $O(M)$"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: bridge_searching_online\n---\n\n# Finding Bridges Online\n\nWe are given an undirected graph.\nA bridge is an edge whose removal makes the graph disconnected (or, more precisely, increases the number of connected components).\nOur task is to find all the bridges in the given graph.\n\nInformally this task can be put as follows:\nwe have to find all the \"important\" roads on the given road map, i.e. such roads that the removal of any of them will lead to some cities being unreachable from others.\n\nThere is already the article [Finding Bridges in $O(N+M)$](bridge-searching.md) which solves this task with a [Depth First Search](depth-first-search.md) traversal.\nThis algorithm will be much more complicated, but it has one big advantage:\nthe algorithm described in this article works online, which means that the input graph doesn't have to be known in advance.\nThe edges are added once at a time, and after each addition the algorithm recounts all the bridges in the current graph.\nIn other words the algorithm is designed to work efficiently on a dynamic, changing graph.\n\nMore rigorously the statement of the problem is as follows:\nInitially the graph is empty and consists of $n$ vertices.\nThen we receive pairs of vertices $(a, b)$, which denote an edge added to the graph.\nAfter each received edge, i.e. after adding each edge, output the current number of bridges in the graph.\n\nIt is also possible to maintain a list of all bridges as well as explicitly support the 2-edge-connected components.\n\nThe algorithm described below works in $O(n \\log n + m)$ time, where $m$ is the number of edges.\nThe algorithm is based on the data structure [Disjoint Set Union](../data_structures/disjoint_set_union.md).\nHowever the implementation in this article takes $O(n \\log n + m \\log n)$ time, because it uses the simplified version of the DSU without Union by Rank.\n\n## Algorithm\n\nFirst let's define a $k$-edge-connected component:\nit is a connected component that remains connected whenever you remove fewer than $k$ edges.\n\nIt is very easy to see, that the bridges partition the graph into 2-edge-connected components.\nIf we compress each of those 2-edge-connected components into vertices and only leave the bridges as edges in the compressed graph, then we obtain an acyclic graph, i.e. a forest.\n\nThe algorithm described below maintains this forest explicitly as well as the 2-edge-connected components.\n\nIt is clear that initially, when the graph is empty, it contains $n$ 2-edge-connected components, which by themselves are not connect.\n\nWhen adding the next edge $(a, b)$ there can occur three situations:\n\n*   Both vertices $a$ and $b$ are in the same 2-edge-connected component - then this edge is not a bridge, and does not change anything in the forest structure, so we can just skip this edge.\n\n    Thus, in this case the number of bridges does not change.\n\n*   The vertices $a$ and $b$ are in completely different connected components, i.e. each one is part of a different tree.\n    In this case, the edge $(a, b)$ becomes a new bridge, and these two trees are combined into one (and all the old bridges remain).\n\n    Thus, in this case the number of bridges increases by one.\n\n*   The vertices $a$ and $b$ are in one connected component, but in different 2-edge-connected components.\n    In this case, this edge forms a cycle along with some of the old bridges.\n    All these bridges end being bridges, and the resulting cycle must be compressed into a new 2-edge-connected component.\n\n    Thus, in this case the number of bridges decreases by two or more.\n\nConsequently the whole task is reduced to the effective implementation of all these operations over the forest of 2-edge-connected components.\n\n## Data Structures for storing the forest\n\nThe only data structure that we need is [Disjoint Set Union](../data_structures/disjoint_set_union.md).\nIn fact we will make two copies of this structure:\none will be to maintain the connected components, the other to maintain the 2-edge-connected components.\nAnd in addition we store the structure of the trees in the forest of 2-edge-connected components via pointers:\nEach 2-edge-connected component will store the index `par[]` of its ancestor in the tree.\n\nWe will now consistently disassemble every operation that we need to learn to implement:\n\n  * Check whether the two vertices lie in the same connected / 2-edge-connected component.\n    It is done with the usual DSU algorithm, we just find and compare the representatives of the DSUs.\n  \n  * Joining two trees for some edge $(a, b)$.\n    Since it could turn out that neither the vertex $a$ nor the vertex $b$ are the roots of their trees, the only way to connect these two trees is to re-root one of them.\n    For example you can re-root the tree of vertex $a$, and then attach it to another tree by setting the ancestor of $a$ to $b$.\n  \n    However the question about the effectiveness of the re-rooting operation arises:\n    in order to re-root the tree with the root $r$ to the vertex $v$, it is necessary to necessary to visit all vertices on the path between $v$ and $r$ and redirect the pointers `par[]` in the opposite direction, and also change the references to the ancestors in the DSU that is responsible for the connected components.\n  \n    Thus, the cost of re-rooting is $O(h)$, where $h$ is the height of the tree.\n    You can make an even worse estimate by saying that the cost is $O(\\text{size})$ where $\\text{size}$ is the number of vertices in the tree.\n    The final complexity will not differ.\n  \n    We now apply a standard technique: we re-root the tree that contains fewer vertices.\n    Then it is intuitively clear that the worst case is when two trees of approximately equal sizes are combined, but then the result is a tree of twice the size.\n    This does not allow this situation to happen many times.\n  \n    In general the total cost can be written in the form of a recurrence:\n    \n    \\[ T(n) = \\max_{k = 1 \\ldots n-1} \\left\\{ T(k) + T(n - k) + O(\\min(k, n - k))\\right\\} \\]\n    \n    $T(n)$ is the number of operations necessary to obtain a tree with $n$ vertices by means of re-rooting and unifying trees.\n    A tree of size $n$ can be created by combining two smaller trees of size $k$ and $n - k$.\n    This recurrence is has the solution $T(n) = O (n \\log n)$.\n  \n    Thus, the total time spent on all re-rooting operations will be $O(n \\log n)$ if we always re-root the smaller of the two trees.\n  \n    We will have to maintain the size of each connected component, but the data structure DSU makes this possible without difficulty.\n  \n  * Searching for the cycle formed by adding a new edge $(a, b)$.\n    Since $a$ and $b$ are already connected in the tree we need to find the [Lowest Common Ancestor](lca.md) of the vertices $a$ and $b$.\n    The cycle will consist of the paths from $b$ to the LCA, from the LCA to $b$ and the edge $a$ to $b$.\n  \n    After finding the cycle we compress all vertices of the detected cycle into one vertex.\n    This means that we already have a complexity proportional to the cycle length, which means that we also can use any LCA algorithm proportional to the length, and don't have to use any fast one.\n  \n    Since all information about the structure of the tree is available is the ancestor array `par[]`, the only reasonable LCA algorithm is the following:\n    mark the vertices $a$ and $b$ as visited, then we go to their ancestors `par[a]` and `par[b]` and mark them, then advance to their ancestors and so on, until we reach an already marked vertex.\n    This vertex is the LCA that we are looking for, and we can find the vertices on the cycle by traversing the path from $a$ and $b$ to the LCA again.\n  \n    It is obvious that the complexity of this algorithm is proportional to the length of the desired cycle.\n  \n  * Compression of the cycle by adding a new edge $(a, b)$ in a tree.\n  \n    We need to create a new 2-edge-connected component, which will consist of all vertices of the detected cycle (also the detected cycle itself could consist of some 2-edge-connected components, but this does not change anything).\n    In addition it is necessary to compress them in such a way that the structure of the tree is not disturbed, and all pointers `par[]` and two DSUs are still correct.\n  \n    The easiest way to achieve this is to compress all the vertices of the cycle to their LCA.\n    In fact the LCA is the highest of the vertices, i.e. its ancestor pointer `par[]` remains unchanged.\n    For all the other vertices of the loop the ancestors do not need to be updated, since these vertices simply cease to exists.\n    But in the DSU of the 2-edge-connected components all these vertices will simply point to the LCA.\n  \n    We will implement the DSU of the 2-edge-connected components without the Union by rank optimization, therefore we will get the complexity $O(\\log n)$ on average per query.\n    To achieve the complexity $O(1)$ on average per query, we need to combine the vertices of the cycle according to Union by rank, and then assign `par[]` accordingly.\n\n## Implementation\n\nHere is the final implementation of the whole algorithm.\n\nAs mentioned before, for the sake of simplicity the DSU of the 2-edge-connected components is written without Union by rank, therefore the resulting complexity will be $O(\\log n)$ on average.\n\nAlso in this implementation the bridges themselves are not stored, only their count `bridges`.\nHowever it will not be difficult to create a `set` of all bridges.\n\nInitially you call the function `init()`, which initializes the two DSUs (creating a separate set for each vertex, and setting the size equal to one), and sets the ancestors `par`.\n\nThe main function is `add_edge(a, b)`, which processes and adds a new edge.\n\n```cpp\nvector<int> par, dsu_2ecc, dsu_cc, dsu_cc_size;\nint bridges;\nint lca_iteration;\nvector<int> last_visit;\n \nvoid init(int n) {\n    par.resize(n);\n    dsu_2ecc.resize(n);\n    dsu_cc.resize(n);\n    dsu_cc_size.resize(n);\n    lca_iteration = 0;\n    last_visit.assign(n, 0);\n    for (int i=0; i<n; ++i) {\n        dsu_2ecc[i] = i;\n        dsu_cc[i] = i;\n        dsu_cc_size[i] = 1;\n        par[i] = -1;\n    }\n    bridges = 0;\n}\n \nint find_2ecc(int v) {\n    if (v == -1)\n        return -1;\n    return dsu_2ecc[v] == v ? v : dsu_2ecc[v] = find_2ecc(dsu_2ecc[v]);\n}\n \nint find_cc(int v) {\n    v = find_2ecc(v);\n    return dsu_cc[v] == v ? v : dsu_cc[v] = find_cc(dsu_cc[v]);\n}\n \nvoid make_root(int v) {\n    v = find_2ecc(v);\n    int root = v;\n    int child = -1;\n    while (v != -1) {\n        int p = find_2ecc(par[v]);\n        par[v] = child;\n        dsu_cc[v] = root;\n        child = v;\n        v = p;\n    }\n    dsu_cc_size[root] = dsu_cc_size[child];\n}\n\nvoid merge_path (int a, int b) {\n    ++lca_iteration;\n    vector<int> path_a, path_b;\n    int lca = -1;\n    while (lca == -1) {\n        if (a != -1) {\n            a = find_2ecc(a);\n            path_a.push_back(a);\n            if (last_visit[a] == lca_iteration){\n                lca = a;\n                break;\n                }\n            last_visit[a] = lca_iteration;\n            a = par[a];\n        }\n        if (b != -1) {\n            b = find_2ecc(b);\n            path_b.push_back(b);\n            if (last_visit[b] == lca_iteration){\n                lca = b;\n                break;\n                }\n            last_visit[b] = lca_iteration;\n            b = par[b];\n        }\n        \n    }\n\n    for (int v : path_a) {\n        dsu_2ecc[v] = lca;\n        if (v == lca)\n            break;\n        --bridges;\n    }\n    for (int v : path_b) {\n        dsu_2ecc[v] = lca;\n        if (v == lca)\n            break;\n        --bridges;\n    }\n}\n \nvoid add_edge(int a, int b) {\n    a = find_2ecc(a);\n    b = find_2ecc(b);\n    if (a == b)\n        return;\n \n    int ca = find_cc(a);\n    int cb = find_cc(b);\n\n    if (ca != cb) {\n        ++bridges;\n        if (dsu_cc_size[ca] > dsu_cc_size[cb]) {\n            swap(a, b);\n            swap(ca, cb);\n        }\n        make_root(a);\n        par[a] = dsu_cc[a] = b;\n        dsu_cc_size[cb] += dsu_cc_size[a];\n    } else {\n        merge_path(a, b);\n    }\n}\n```\n\nThe DSU for the 2-edge-connected components is stored in the vector `dsu_2ecc`, and the function returning the representative is `find_2ecc(v)`.\nThis function is used many times in the rest of the code, since after the compression of several vertices into one all these vertices cease to exist, and instead only the leader has the correct ancestor `par` in the forest of 2-edge-connected components.\n\nThe DSU for the connected components is stored in the vector `dsu_cc`, and there is also an additional vector `dsu_cc_size` to store the component sizes.\nThe function `find_cc(v)` returns the leader of the connectivity component (which is actually the root of the tree).\n\nThe re-rooting of a tree `make_root(v)` works as described above:\nif traverses from the vertex $v$ via the ancestors to the root vertex, each time redirecting the ancestor `par` in the opposite direction.\nThe link to the representative of the connected component `dsu_cc` is also updated, so that it points to the new root vertex.\nAfter re-rooting we have to assign the new root the correct size of the connected component.\nAlso we have to be careful that we call `find_2ecc()` to get the representatives of the 2-edge-connected component, rather than some other vertex that have already been compressed.\n\nThe cycle finding and compression function `merge_path(a, b)` is also implemented as described above.\nIt searches for the LCA of $a$ and $b$ be rising these nodes in parallel, until we meet a vertex for the second time.\nFor efficiency purposes we choose a unique identifier for each LCA finding call, and mark the traversed vertices with it.\nThis works in $O(1)$, while other approaches like using $set$ perform worse.\nThe passed paths are stored in the vectors `path_a` and `path_b`, and we use them to walk through them a second time up to the LCA, thereby obtaining all vertices of the cycle.\nAll the vertices of the cycle get compressed by attaching them to the LCA, hence the average complexity is $O(\\log n)$ (since we don't use Union by rank).\nAll the edges we pass have been bridges, so we subtract 1 for each edge in the cycle.\n\nFinally the query function `add_edge(a, b)` determines the connected components in which the vertices $a$ and $b$ lie.\nIf they lie in different connectivity components, then a smaller tree is re-rooted and then attached to the larger tree.\nOtherwise if the vertices $a$ and $b$ lie in one tree, but in different 2-edge-connected components, then the function `merge_path(a, b)` is called, which will detect the cycle and compress it into one 2-edge-connected component. \n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: bridge_searching_online\n---\n\n# Finding Bridges Online\n\nWe are given an undirected graph.\nA bridge is an edge whose removal makes the graph disconnected (or, more precisely, increases the number of connected components).\nOur task is to find all the bridges in the given graph.\n\nInformally this task can be put as follows:\nwe have to find all the \"important\" roads on the given road map, i.e. such roads that the removal of any of them will lead to some cities being unreachable from others.\n\nThere is already the article [Finding Bridges in $O(N+M)$](bridge-searching.md) which solves this task with a [Depth First Search](depth-first-search.md) traversal.\nThis algorithm will be much more complicated, but it has one big advantage:\nthe algorithm described in this article works online, which means that the input graph doesn't have to be known in advance.\nThe edges are added once at a time, and after each addition the algorithm recounts all the bridges in the current graph.\nIn other words the algorithm is designed to work efficiently on a dynamic, changing graph.\n\nMore rigorously the statement of the problem is as follows:\nInitially the graph is empty and consists of $n$ vertices.\nThen we receive pairs of vertices $(a, b)$, which denote an edge added to the graph.\nAfter each received edge, i.e. after adding each edge, output the current number of bridges in the graph.\n\nIt is also possible to maintain a list of all bridges as well as explicitly support the 2-edge-connected components.\n\nThe algorithm described below works in $O(n \\log n + m)$ time, where $m$ is the number of edges.\nThe algorithm is based on the data structure [Disjoint Set Union](../data_structures/disjoint_set_union.md).\nHowever the implementation in this article takes $O(n \\log n + m \\log n)$ time, because it uses the simplified version of the DSU without Union by Rank.\n\n## Algorithm\n\nFirst let's define a $k$-edge-connected component:\nit is a connected component that remains connected whenever you remove fewer than $k$ edges.\n\nIt is very easy to see, that the bridges partition the graph into 2-edge-connected components.\nIf we compress each of those 2-edge-connected components into vertices and only leave the bridges as edges in the compressed graph, then we obtain an acyclic graph, i.e. a forest.\n\nThe algorithm described below maintains this forest explicitly as well as the 2-edge-connected components.\n\nIt is clear that initially, when the graph is empty, it contains $n$ 2-edge-connected components, which by themselves are not connect.\n\nWhen adding the next edge $(a, b)$ there can occur three situations:\n\n*   Both vertices $a$ and $b$ are in the same 2-edge-connected component - then this edge is not a bridge, and does not change anything in the forest structure, so we can just skip this edge.\n\n    Thus, in this case the number of bridges does not change.\n\n*   The vertices $a$ and $b$ are in completely different connected components, i.e. each one is part of a different tree.\n    In this case, the edge $(a, b)$ becomes a new bridge, and these two trees are combined into one (and all the old bridges remain).\n\n    Thus, in this case the number of bridges increases by one.\n\n*   The vertices $a$ and $b$ are in one connected component, but in different 2-edge-connected components.\n    In this case, this edge forms a cycle along with some of the old bridges.\n    All these bridges end being bridges, and the resulting cycle must be compressed into a new 2-edge-connected component.\n\n    Thus, in this case the number of bridges decreases by two or more.\n\nConsequently the whole task is reduced to the effective implementation of all these operations over the forest of 2-edge-connected components.\n\n## Data Structures for storing the forest\n\nThe only data structure that we need is [Disjoint Set Union](../data_structures/disjoint_set_union.md).\nIn fact we will make two copies of this structure:\none will be to maintain the connected components, the other to maintain the 2-edge-connected components.\nAnd in addition we store the structure of the trees in the forest of 2-edge-connected components via pointers:\nEach 2-edge-connected component will store the index `par[]` of its ancestor in the tree.\n\nWe will now consistently disassemble every operation that we need to learn to implement:\n\n  * Check whether the two vertices lie in the same connected / 2-edge-connected component.\n    It is done with the usual DSU algorithm, we just find and compare the representatives of the DSUs.\n  \n  * Joining two trees for some edge $(a, b)$.\n    Since it could turn out that neither the vertex $a$ nor the vertex $b$ are the roots of their trees, the only way to connect these two trees is to re-root one of them.\n    For example you can re-root the tree of vertex $a$, and then attach it to another tree by setting the ancestor of $a$ to $b$.\n  \n    However the question about the effectiveness of the re-rooting operation arises:\n    in order to re-root the tree with the root $r$ to the vertex $v$, it is necessary to necessary to visit all vertices on the path between $v$ and $r$ and redirect the pointers `par[]` in the opposite direction, and also change the references to the ancestors in the DSU that is responsible for the connected components.\n  \n    Thus, the cost of re-rooting is $O(h)$, where $h$ is the height of the tree.\n    You can make an even worse estimate by saying that the cost is $O(\\text{size})$ where $\\text{size}$ is the number of vertices in the tree.\n    The final complexity will not differ.\n  \n    We now apply a standard technique: we re-root the tree that contains fewer vertices.\n    Then it is intuitively clear that the worst case is when two trees of approximately equal sizes are combined, but then the result is a tree of twice the size.\n    This does not allow this situation to happen many times.\n  \n    In general the total cost can be written in the form of a recurrence:\n    \n    \\[ T(n) = \\max_{k = 1 \\ldots n-1} \\left\\{ T(k) + T(n - k) + O(\\min(k, n - k))\\right\\} \\]\n    \n    $T(n)$ is the number of operations necessary to obtain a tree with $n$ vertices by means of re-rooting and unifying trees.\n    A tree of size $n$ can be created by combining two smaller trees of size $k$ and $n - k$.\n    This recurrence is has the solution $T(n) = O (n \\log n)$.\n  \n    Thus, the total time spent on all re-rooting operations will be $O(n \\log n)$ if we always re-root the smaller of the two trees.\n  \n    We will have to maintain the size of each connected component, but the data structure DSU makes this possible without difficulty.\n  \n  * Searching for the cycle formed by adding a new edge $(a, b)$.\n    Since $a$ and $b$ are already connected in the tree we need to find the [Lowest Common Ancestor](lca.md) of the vertices $a$ and $b$.\n    The cycle will consist of the paths from $b$ to the LCA, from the LCA to $b$ and the edge $a$ to $b$.\n  \n    After finding the cycle we compress all vertices of the detected cycle into one vertex.\n    This means that we already have a complexity proportional to the cycle length, which means that we also can use any LCA algorithm proportional to the length, and don't have to use any fast one.\n  \n    Since all information about the structure of the tree is available is the ancestor array `par[]`, the only reasonable LCA algorithm is the following:\n    mark the vertices $a$ and $b$ as visited, then we go to their ancestors `par[a]` and `par[b]` and mark them, then advance to their ancestors and so on, until we reach an already marked vertex.\n    This vertex is the LCA that we are looking for, and we can find the vertices on the cycle by traversing the path from $a$ and $b$ to the LCA again.\n  \n    It is obvious that the complexity of this algorithm is proportional to the length of the desired cycle.\n  \n  * Compression of the cycle by adding a new edge $(a, b)$ in a tree.\n  \n    We need to create a new 2-edge-connected component, which will consist of all vertices of the detected cycle (also the detected cycle itself could consist of some 2-edge-connected components, but this does not change anything).\n    In addition it is necessary to compress them in such a way that the structure of the tree is not disturbed, and all pointers `par[]` and two DSUs are still correct.\n  \n    The easiest way to achieve this is to compress all the vertices of the cycle to their LCA.\n    In fact the LCA is the highest of the vertices, i.e. its ancestor pointer `par[]` remains unchanged.\n    For all the other vertices of the loop the ancestors do not need to be updated, since these vertices simply cease to exists.\n    But in the DSU of the 2-edge-connected components all these vertices will simply point to the LCA.\n  \n    We will implement the DSU of the 2-edge-connected components without the Union by rank optimization, therefore we will get the complexity $O(\\log n)$ on average per query.\n    To achieve the complexity $O(1)$ on average per query, we need to combine the vertices of the cycle according to Union by rank, and then assign `par[]` accordingly.\n\n## Implementation\n\nHere is the final implementation of the whole algorithm.\n\nAs mentioned before, for the sake of simplicity the DSU of the 2-edge-connected components is written without Union by rank, therefore the resulting complexity will be $O(\\log n)$ on average.\n\nAlso in this implementation the bridges themselves are not stored, only their count `bridges`.\nHowever it will not be difficult to create a `set` of all bridges.\n\nInitially you call the function `init()`, which initializes the two DSUs (creating a separate set for each vertex, and setting the size equal to one), and sets the ancestors `par`.\n\nThe main function is `add_edge(a, b)`, which processes and adds a new edge.\n\n```cpp\nvector<int> par, dsu_2ecc, dsu_cc, dsu_cc_size;\nint bridges;\nint lca_iteration;\nvector<int> last_visit;\n \nvoid init(int n) {\n    par.resize(n);\n    dsu_2ecc.resize(n);\n    dsu_cc.resize(n);\n    dsu_cc_size.resize(n);\n    lca_iteration = 0;\n    last_visit.assign(n, 0);\n    for (int i=0; i<n; ++i) {\n        dsu_2ecc[i] = i;\n        dsu_cc[i] = i;\n        dsu_cc_size[i] = 1;\n        par[i] = -1;\n    }\n    bridges = 0;\n}\n \nint find_2ecc(int v) {\n    if (v == -1)\n        return -1;\n    return dsu_2ecc[v] == v ? v : dsu_2ecc[v] = find_2ecc(dsu_2ecc[v]);\n}\n \nint find_cc(int v) {\n    v = find_2ecc(v);\n    return dsu_cc[v] == v ? v : dsu_cc[v] = find_cc(dsu_cc[v]);\n}\n \nvoid make_root(int v) {\n    v = find_2ecc(v);\n    int root = v;\n    int child = -1;\n    while (v != -1) {\n        int p = find_2ecc(par[v]);\n        par[v] = child;\n        dsu_cc[v] = root;\n        child = v;\n        v = p;\n    }\n    dsu_cc_size[root] = dsu_cc_size[child];\n}\n\nvoid merge_path (int a, int b) {\n    ++lca_iteration;\n    vector<int> path_a, path_b;\n    int lca = -1;\n    while (lca == -1) {\n        if (a != -1) {\n            a = find_2ecc(a);\n            path_a.push_back(a);\n            if (last_visit[a] == lca_iteration){\n                lca = a;\n                break;\n                }\n            last_visit[a] = lca_iteration;\n            a = par[a];\n        }\n        if (b != -1) {\n            b = find_2ecc(b);\n            path_b.push_back(b);\n            if (last_visit[b] == lca_iteration){\n                lca = b;\n                break;\n                }\n            last_visit[b] = lca_iteration;\n            b = par[b];\n        }\n        \n    }\n\n    for (int v : path_a) {\n        dsu_2ecc[v] = lca;\n        if (v == lca)\n            break;\n        --bridges;\n    }\n    for (int v : path_b) {\n        dsu_2ecc[v] = lca;\n        if (v == lca)\n            break;\n        --bridges;\n    }\n}\n \nvoid add_edge(int a, int b) {\n    a = find_2ecc(a);\n    b = find_2ecc(b);\n    if (a == b)\n        return;\n \n    int ca = find_cc(a);\n    int cb = find_cc(b);\n\n    if (ca != cb) {\n        ++bridges;\n        if (dsu_cc_size[ca] > dsu_cc_size[cb]) {\n            swap(a, b);\n            swap(ca, cb);\n        }\n        make_root(a);\n        par[a] = dsu_cc[a] = b;\n        dsu_cc_size[cb] += dsu_cc_size[a];\n    } else {\n        merge_path(a, b);\n    }\n}\n```\n\nThe DSU for the 2-edge-connected components is stored in the vector `dsu_2ecc`, and the function returning the representative is `find_2ecc(v)`.\nThis function is used many times in the rest of the code, since after the compression of several vertices into one all these vertices cease to exist, and instead only the leader has the correct ancestor `par` in the forest of 2-edge-connected components.\n\nThe DSU for the connected components is stored in the vector `dsu_cc`, and there is also an additional vector `dsu_cc_size` to store the component sizes.\nThe function `find_cc(v)` returns the leader of the connectivity component (which is actually the root of the tree).\n\nThe re-rooting of a tree `make_root(v)` works as described above:\nif traverses from the vertex $v$ via the ancestors to the root vertex, each time redirecting the ancestor `par` in the opposite direction.\nThe link to the representative of the connected component `dsu_cc` is also updated, so that it points to the new root vertex.\nAfter re-rooting we have to assign the new root the correct size of the connected component.\nAlso we have to be careful that we call `find_2ecc()` to get the representatives of the 2-edge-connected component, rather than some other vertex that have already been compressed.\n\nThe cycle finding and compression function `merge_path(a, b)` is also implemented as described above.\nIt searches for the LCA of $a$ and $b$ be rising these nodes in parallel, until we meet a vertex for the second time.\nFor efficiency purposes we choose a unique identifier for each LCA finding call, and mark the traversed vertices with it.\nThis works in $O(1)$, while other approaches like using $set$ perform worse.\nThe passed paths are stored in the vectors `path_a` and `path_b`, and we use them to walk through them a second time up to the LCA, thereby obtaining all vertices of the cycle.\nAll the vertices of the cycle get compressed by attaching them to the LCA, hence the average complexity is $O(\\log n)$ (since we don't use Union by rank).\nAll the edges we pass have been bridges, so we subtract 1 for each edge in the cycle.\n\nFinally the query function `add_edge(a, b)` determines the connected components in which the vertices $a$ and $b$ lie.\nIf they lie in different connectivity components, then a smaller tree is re-rooted and then attached to the larger tree.\nOtherwise if the vertices $a$ and $b$ lie in one tree, but in different 2-edge-connected components, then the function `merge_path(a, b)` is called, which will detect the cycle and compress it into one 2-edge-connected component. \n", "problem_ids": [], "title": "Finding Bridges Online"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: negative_cycle\n---\n\n# Finding a negative cycle in the graph\n\nYou are given a directed weighted graph $G$ with $N$ vertices and $M$ edges. Find any cycle of negative weight in it, if such a cycle exists.\n\nIn another formulation of the problem you have to find all pairs of vertices which have a path of arbitrarily small weight between them.\n\nIt is convenient to use different algorithms to solve these two variations of the problem, so we'll discuss both of them here.\n\n## Using Bellman-Ford algorithm\n\nBellman-Ford algorithm allows you to check whether there exists a cycle of negative weight in the graph, and if it does, find one of these cycles.\n\nThe details of the algorithm are described in the article on the [Bellman-Ford](bellman_ford.md) algorithm.\nHere we'll describe only its application to this problem.\n\nDo $N$ iterations of Bellman-Ford algorithm. If there were no changes on the last iteration, there is no cycle of negative weight in the graph. Otherwise take a vertex the distance to which has changed, and go from it via its ancestors until a cycle is found. This cycle will be the desired cycle of negative weight.\n\n### Implementation\n\n```cpp\nstruct Edge {\n    int a, b, cost;\n};\n\nint n, m;\nvector<Edge> edges;\nconst int INF = 1000000000;\n\nvoid solve()\n{\n    vector<int> d(n);\n    vector<int> p(n, -1);\n    int x;\n    for (int i = 0; i < n; ++i) {\n        x = -1;\n        for (Edge e : edges) {\n            if (d[e.a] + e.cost < d[e.b]) {\n                d[e.b] = d[e.a] + e.cost;\n                p[e.b] = e.a;\n                x = e.b;\n            }\n        }\n    }\n\n    if (x == -1) {\n        cout << \"No negative cycle found.\";\n    } else {\n        for (int i = 0; i < n; ++i)\n            x = p[x];\n\n        vector<int> cycle;\n        for (int v = x;; v = p[v]) {\n            cycle.push_back(v);\n            if (v == x && cycle.size() > 1)\n                break;\n        }\n        reverse(cycle.begin(), cycle.end());\n\n        cout << \"Negative cycle: \";\n        for (int v : cycle)\n            cout << v << ' ';\n        cout << endl;\n    }\n}\n```\n\n## Using Floyd-Warshall algorithm\n\nThe Floyd-Warshall algorithm allows to solve the second variation of the problem - finding all pairs of vertices $(i, j)$ which don't have a shortest path between them (i.e. a path of arbitrarily small weight exists).\n\nAgain, the details can be found in the [Floyd-Warshall](all-pair-shortest-path-floyd-warshall.md) article, and here we describe only its application.\n\nRun Floyd-Warshall algorithm on the graph.\nInitially $d[v][v] = 0$ for each $v$.\nBut after running the algorithm $d[v][v]$ will be smaller than $0$ if there exists a negative length path from $v$ to $v$.\nWe can use this to also find all pairs of vertices that don't have a shortest path between them.\nWe iterate over all pairs of vertices $(i, j)$ and for each pair we check whether they have a shortest path between them.\nTo do this try all possibilities for an intermediate vertex $t$.\n$(i, j)$ doesn't have a shortest path, if one of the intermediate vertices $t$ has $d[t][t] < 0$ (i.e. $t$ is part of a cycle of negative weight), $t$ can be reached from $i$ and $j$ can be reached from $t$.\nThen the path from $i$ to $j$ can have arbitrarily small weight.\nWe will denote this with `-INF`.\n\n### Implementation\n\n```cpp\nfor (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n        for (int t = 0; t < n; ++t) {\n            if (d[i][t] < INF && d[t][t] < 0 && d[t][j] < INF)\n                d[i][j] = - INF; \n        }\n    }\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: negative_cycle\n---\n\n# Finding a negative cycle in the graph\n\nYou are given a directed weighted graph $G$ with $N$ vertices and $M$ edges. Find any cycle of negative weight in it, if such a cycle exists.\n\nIn another formulation of the problem you have to find all pairs of vertices which have a path of arbitrarily small weight between them.\n\nIt is convenient to use different algorithms to solve these two variations of the problem, so we'll discuss both of them here.\n\n## Using Bellman-Ford algorithm\n\nBellman-Ford algorithm allows you to check whether there exists a cycle of negative weight in the graph, and if it does, find one of these cycles.\n\nThe details of the algorithm are described in the article on the [Bellman-Ford](bellman_ford.md) algorithm.\nHere we'll describe only its application to this problem.\n\nDo $N$ iterations of Bellman-Ford algorithm. If there were no changes on the last iteration, there is no cycle of negative weight in the graph. Otherwise take a vertex the distance to which has changed, and go from it via its ancestors until a cycle is found. This cycle will be the desired cycle of negative weight.\n\n### Implementation\n\n```cpp\nstruct Edge {\n    int a, b, cost;\n};\n\nint n, m;\nvector<Edge> edges;\nconst int INF = 1000000000;\n\nvoid solve()\n{\n    vector<int> d(n);\n    vector<int> p(n, -1);\n    int x;\n    for (int i = 0; i < n; ++i) {\n        x = -1;\n        for (Edge e : edges) {\n            if (d[e.a] + e.cost < d[e.b]) {\n                d[e.b] = d[e.a] + e.cost;\n                p[e.b] = e.a;\n                x = e.b;\n            }\n        }\n    }\n\n    if (x == -1) {\n        cout << \"No negative cycle found.\";\n    } else {\n        for (int i = 0; i < n; ++i)\n            x = p[x];\n\n        vector<int> cycle;\n        for (int v = x;; v = p[v]) {\n            cycle.push_back(v);\n            if (v == x && cycle.size() > 1)\n                break;\n        }\n        reverse(cycle.begin(), cycle.end());\n\n        cout << \"Negative cycle: \";\n        for (int v : cycle)\n            cout << v << ' ';\n        cout << endl;\n    }\n}\n```\n\n## Using Floyd-Warshall algorithm\n\nThe Floyd-Warshall algorithm allows to solve the second variation of the problem - finding all pairs of vertices $(i, j)$ which don't have a shortest path between them (i.e. a path of arbitrarily small weight exists).\n\nAgain, the details can be found in the [Floyd-Warshall](all-pair-shortest-path-floyd-warshall.md) article, and here we describe only its application.\n\nRun Floyd-Warshall algorithm on the graph.\nInitially $d[v][v] = 0$ for each $v$.\nBut after running the algorithm $d[v][v]$ will be smaller than $0$ if there exists a negative length path from $v$ to $v$.\nWe can use this to also find all pairs of vertices that don't have a shortest path between them.\nWe iterate over all pairs of vertices $(i, j)$ and for each pair we check whether they have a shortest path between them.\nTo do this try all possibilities for an intermediate vertex $t$.\n$(i, j)$ doesn't have a shortest path, if one of the intermediate vertices $t$ has $d[t][t] < 0$ (i.e. $t$ is part of a cycle of negative weight), $t$ can be reached from $i$ and $j$ can be reached from $t$.\nThen the path from $i$ to $j$ can have arbitrarily small weight.\nWe will denote this with `-INF`.\n\n### Implementation\n\n```cpp\nfor (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n        for (int t = 0; t < n; ++t) {\n            if (d[i][t] < INF && d[t][t] < 0 && d[t][j] < INF)\n                d[i][j] = - INF; \n        }\n    }\n}\n```\n\n## Practice Problems\n\n- [UVA: Wormholes](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=499)\n- [SPOJ: Alice in Amsterdam, I mean Wonderland](http://www.spoj.com/problems/UCV2013B/)\n- [SPOJ: Johnsons Algorithm](http://www.spoj.com/problems/JHNSN/)\n", "problem_ids": [], "title": "Finding a negative cycle in the graph"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: dfs\n---\n\n# Depth First Search\n\nDepth First Search is one of the main graph algorithms.\n\nDepth First Search finds the lexicographical first path in the graph from a source vertex $u$ to each vertex.\nDepth First Search will also find the shortest paths in a tree (because there only exists one simple path), but on general graphs this is not the case.\n\nThe algorithm works in $O(m + n)$ time where $n$ is the number of vertices and $m$ is the number of edges.\n\n## Description of the algorithm\n\nThe idea behind DFS is to go as deep into the graph as possible, and backtrack once you are at a vertex without any unvisited adjacent vertices.\n\nIt is very easy to describe / implement the algorithm recursively:\nWe start the search at one vertex.\nAfter visiting a vertex, we further perform a DFS for each adjacent vertex that we haven't visited before.\nThis way we visit all vertices that are reachable from the starting vertex.\n\nFor more details check out the implementation.\n\n## Applications of Depth First Search\n\n  * Find any path in the graph from source vertex $u$ to all vertices.\n  \n  * Find lexicographical first path in the graph from source $u$ to all vertices.\n  \n  * Check if a vertex in a tree is an ancestor of some other vertex:\n  \n    At the beginning and end of each search call we remember the entry and exit \"time\" of each vertex.\n    Now you can find the answer for any pair of vertices $(i, j)$ in $O(1)$:\n    vertex $i$ is an ancestor of vertex $j$ if and only if $\\text{entry}[i] < \\text{entry}[j]$ and $\\text{exit}[i] > \\text{exit}[j]$.\n  \n  * Find the lowest common ancestor (LCA) of two vertices.\n  \n  * Topological sorting:\n  \n    Run a series of depth first searches so as to visit each vertex exactly once in $O(n + m)$ time.\n    The required topological ordering will be the vertices sorted in descending order of exit time.\n  \n  \n  * Check whether a given graph is acyclic and find cycles in a graph. (As mentioned above by counting back edges in every connected components).\n  \n  * Find strongly connected components in a directed graph:\n  \n    First do a topological sorting of the graph.\n    Then transpose the graph and run another series of depth first searches in the order defined by the topological sort. For each DFS call the component created by it is a strongly connected component.\n  \n  * Find bridges in an undirected graph:\n  \n    First convert the given graph into a directed graph by running a series of depth first searches and making each edge directed as we go through it, in the direction we went. Second, find the strongly connected components in this directed graph. Bridges are the edges whose ends belong to different strongly connected components.\n\n## Classification of edges of a graph\n\nWe can classify the edges using the entry and exit time of the end nodes $u$ and $v$ of the edges $(u,v)$.\nThese classifications are often used for problems like [finding bridges](bridge-searching.md) and [finding articulation points](cutpoints.md).\n\nWe perform a DFS and classify the encountered edges using the following rules:\n\nIf $v$ is not visited:\n\n* Tree Edge - If $v$ is visited after $u$ then edge $(u,v)$ is called a tree edge. In other words, if $v$ is visited for the first time and $u$ is currently being visited then $(u,v)$ is called tree edge.\nThese edges form a DFS tree and hence the name tree edges.\n\nIf $v$ is visited before $u$:\n\n* Back edges - If $v$ is an ancestor of $u$, then the edge $(u,v)$ is a back edge. $v$ is an ancestor exactly if we already entered $v$, but not exited it yet. Back edges complete a cycle as there is a path from ancestor $v$ to descendant $u$ (in the recursion of DFS) and an edge from descendant $u$ to ancestor $v$ (back edge), thus a cycle is formed. Cycles can be detected using back edges.\n\n* Forward Edges - If $v$ is a descendant of $u$, then edge $(u, v)$ is a forward edge. In other words, if we already visited and exited $v$ and $\\text{entry}[u] < \\text{entry}[v]$ then the edge $(u,v)$ forms a forward edge.\n* Cross Edges: if $v$ is neither an ancestor or descendant of $u$, then edge $(u, v)$ is a cross edge. In other words, if we already visited and exited $v$ and $\\text{entry}[u] > \\text{entry}[v]$ then $(u,v)$ is a cross edge.\n\nNote: Forward edges and cross edges only exist in directed graphs.\n\n## Implementation\n\n```cpp\nvector<vector<int>> adj; // graph represented as an adjacency list\nint n; // number of vertices\n\nvector<bool> visited;\n\nvoid dfs(int v) {\n\tvisited[v] = true;\n\tfor (int u : adj[v]) {\n\t\tif (!visited[u])\n\t\t\tdfs(u);\n    }\n}\n```\nThis is the most simple implementation of Depth First Search.\nAs described in the applications it might be useful to also compute the entry and exit times and vertex color.\nWe will color all vertices with the color 0, if we haven't visited them, with the color 1 if we visited them, and with the color 2, if we already exited the vertex.\n\nHere is a generic implementation that additionally computes those:\n\n```cpp\nvector<vector<int>> adj; // graph represented as an adjacency list\nint n; // number of vertices\n\nvector<int> color;\n\nvector<int> time_in, time_out;\nint dfs_timer = 0;\n\nvoid dfs(int v) {\n\ttime_in[v] = dfs_timer++;\n\tcolor[v] = 1;\n\tfor (int u : adj[v])\n\t\tif (color[u] == 0)\n\t\t\tdfs(u);\n\tcolor[v] = 2;\n\ttime_out[v] = dfs_timer++;\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: dfs\n---\n\n# Depth First Search\n\nDepth First Search is one of the main graph algorithms.\n\nDepth First Search finds the lexicographical first path in the graph from a source vertex $u$ to each vertex.\nDepth First Search will also find the shortest paths in a tree (because there only exists one simple path), but on general graphs this is not the case.\n\nThe algorithm works in $O(m + n)$ time where $n$ is the number of vertices and $m$ is the number of edges.\n\n## Description of the algorithm\n\nThe idea behind DFS is to go as deep into the graph as possible, and backtrack once you are at a vertex without any unvisited adjacent vertices.\n\nIt is very easy to describe / implement the algorithm recursively:\nWe start the search at one vertex.\nAfter visiting a vertex, we further perform a DFS for each adjacent vertex that we haven't visited before.\nThis way we visit all vertices that are reachable from the starting vertex.\n\nFor more details check out the implementation.\n\n## Applications of Depth First Search\n\n  * Find any path in the graph from source vertex $u$ to all vertices.\n  \n  * Find lexicographical first path in the graph from source $u$ to all vertices.\n  \n  * Check if a vertex in a tree is an ancestor of some other vertex:\n  \n    At the beginning and end of each search call we remember the entry and exit \"time\" of each vertex.\n    Now you can find the answer for any pair of vertices $(i, j)$ in $O(1)$:\n    vertex $i$ is an ancestor of vertex $j$ if and only if $\\text{entry}[i] < \\text{entry}[j]$ and $\\text{exit}[i] > \\text{exit}[j]$.\n  \n  * Find the lowest common ancestor (LCA) of two vertices.\n  \n  * Topological sorting:\n  \n    Run a series of depth first searches so as to visit each vertex exactly once in $O(n + m)$ time.\n    The required topological ordering will be the vertices sorted in descending order of exit time.\n  \n  \n  * Check whether a given graph is acyclic and find cycles in a graph. (As mentioned above by counting back edges in every connected components).\n  \n  * Find strongly connected components in a directed graph:\n  \n    First do a topological sorting of the graph.\n    Then transpose the graph and run another series of depth first searches in the order defined by the topological sort. For each DFS call the component created by it is a strongly connected component.\n  \n  * Find bridges in an undirected graph:\n  \n    First convert the given graph into a directed graph by running a series of depth first searches and making each edge directed as we go through it, in the direction we went. Second, find the strongly connected components in this directed graph. Bridges are the edges whose ends belong to different strongly connected components.\n\n## Classification of edges of a graph\n\nWe can classify the edges using the entry and exit time of the end nodes $u$ and $v$ of the edges $(u,v)$.\nThese classifications are often used for problems like [finding bridges](bridge-searching.md) and [finding articulation points](cutpoints.md).\n\nWe perform a DFS and classify the encountered edges using the following rules:\n\nIf $v$ is not visited:\n\n* Tree Edge - If $v$ is visited after $u$ then edge $(u,v)$ is called a tree edge. In other words, if $v$ is visited for the first time and $u$ is currently being visited then $(u,v)$ is called tree edge.\nThese edges form a DFS tree and hence the name tree edges.\n\nIf $v$ is visited before $u$:\n\n* Back edges - If $v$ is an ancestor of $u$, then the edge $(u,v)$ is a back edge. $v$ is an ancestor exactly if we already entered $v$, but not exited it yet. Back edges complete a cycle as there is a path from ancestor $v$ to descendant $u$ (in the recursion of DFS) and an edge from descendant $u$ to ancestor $v$ (back edge), thus a cycle is formed. Cycles can be detected using back edges.\n\n* Forward Edges - If $v$ is a descendant of $u$, then edge $(u, v)$ is a forward edge. In other words, if we already visited and exited $v$ and $\\text{entry}[u] < \\text{entry}[v]$ then the edge $(u,v)$ forms a forward edge.\n* Cross Edges: if $v$ is neither an ancestor or descendant of $u$, then edge $(u, v)$ is a cross edge. In other words, if we already visited and exited $v$ and $\\text{entry}[u] > \\text{entry}[v]$ then $(u,v)$ is a cross edge.\n\nNote: Forward edges and cross edges only exist in directed graphs.\n\n## Implementation\n\n```cpp\nvector<vector<int>> adj; // graph represented as an adjacency list\nint n; // number of vertices\n\nvector<bool> visited;\n\nvoid dfs(int v) {\n\tvisited[v] = true;\n\tfor (int u : adj[v]) {\n\t\tif (!visited[u])\n\t\t\tdfs(u);\n    }\n}\n```\nThis is the most simple implementation of Depth First Search.\nAs described in the applications it might be useful to also compute the entry and exit times and vertex color.\nWe will color all vertices with the color 0, if we haven't visited them, with the color 1 if we visited them, and with the color 2, if we already exited the vertex.\n\nHere is a generic implementation that additionally computes those:\n\n```cpp\nvector<vector<int>> adj; // graph represented as an adjacency list\nint n; // number of vertices\n\nvector<int> color;\n\nvector<int> time_in, time_out;\nint dfs_timer = 0;\n\nvoid dfs(int v) {\n\ttime_in[v] = dfs_timer++;\n\tcolor[v] = 1;\n\tfor (int u : adj[v])\n\t\tif (color[u] == 0)\n\t\t\tdfs(u);\n\tcolor[v] = 2;\n\ttime_out[v] = dfs_timer++;\n}\n```\n\n## Practice Problems\n\n* [SPOJ: ABCPATH](http://www.spoj.com/problems/ABCPATH/)\n* [SPOJ: EAGLE1](http://www.spoj.com/problems/EAGLE1/)\n* [Codeforces: Kefa and Park](http://codeforces.com/problemset/problem/580/C)\n* [Timus:Werewolf](http://acm.timus.ru/problem.aspx?space=1&num=1242)\n* [Timus:Penguin Avia](http://acm.timus.ru/problem.aspx?space=1&num=1709)\n* [Timus:Two Teams](http://acm.timus.ru/problem.aspx?space=1&num=1106)\n* [SPOJ - Ada and Island](http://www.spoj.com/problems/ADASEA/)\n* [UVA 657 - The die is cast](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=598)\n* [SPOJ - Sheep](http://www.spoj.com/problems/KOZE/)\n* [SPOJ - Path of the Rightenous Man](http://www.spoj.com/problems/RIOI_2_3/)\n* [SPOJ - Validate the Maze](http://www.spoj.com/problems/MAKEMAZE/)\n* [SPOJ - Ghosts having Fun](http://www.spoj.com/problems/GHOSTS/)\n* [Codeforces - Underground Lab](http://codeforces.com/contest/781/problem/C)\n* [DevSkill - Maze Tester (archived)](http://web.archive.org/web/20200319103915/https://www.devskill.com/CodingProblems/ViewProblem/3)\n* [DevSkill - Tourist (archived)](http://web.archive.org/web/20190426175135/https://devskill.com/CodingProblems/ViewProblem/17)\n* [Codeforces - Anton and Tree](http://codeforces.com/contest/734/problem/E)\n* [Codeforces - Transformation: From A to B](http://codeforces.com/contest/727/problem/A)\n* [Codeforces - One Way Reform](http://codeforces.com/contest/723/problem/E)\n* [Codeforces - Centroids](http://codeforces.com/contest/709/problem/E)\n* [Codeforces - Generate a String](http://codeforces.com/contest/710/problem/E)\n* [Codeforces - Broken Tree](http://codeforces.com/contest/758/problem/E)\n* [Codeforces - Dasha and Puzzle](http://codeforces.com/contest/761/problem/E)\n* [Codeforces - Making genome In Berland](http://codeforces.com/contest/638/problem/B)\n* [Codeforces - Road Improvement](http://codeforces.com/contest/638/problem/C)\n* [Codeforces - Garland](http://codeforces.com/contest/767/problem/C)\n* [Codeforces - Labeling Cities](http://codeforces.com/contest/794/problem/D)\n* [Codeforces - Send the Fool Futher!](http://codeforces.com/contest/802/problem/K)\n* [Codeforces - The tag Game](http://codeforces.com/contest/813/problem/C)\n* [Codeforces - Leha and Another game about graphs](http://codeforces.com/contest/841/problem/D)\n* [Codeforces - Shortest path problem](http://codeforces.com/contest/845/problem/G)\n* [Codeforces - Upgrading Tree](http://codeforces.com/contest/844/problem/E)\n* [Codeforces - From Y to Y](http://codeforces.com/contest/849/problem/C)\n* [Codeforces - Chemistry in Berland](http://codeforces.com/contest/846/problem/E)\n* [Codeforces - Wizards Tour](http://codeforces.com/contest/861/problem/F)\n* [Codeforces - Ring Road](http://codeforces.com/contest/24/problem/A)\n* [Codeforces - Mail Stamps](http://codeforces.com/contest/29/problem/C)\n* [Codeforces - Ant on the Tree](http://codeforces.com/contest/29/problem/D)\n* [SPOJ - Cactus](http://www.spoj.com/problems/CAC/)\n* [SPOJ - Mixing Chemicals](http://www.spoj.com/problems/AMR10J/)\n", "problem_ids": ["734_E", "709_E", "710_E", "758_E", "761_E", "638_C", "767_C", "844_E", "849_C", "846_E", "29_C", "29_D"], "title": "Depth First Search"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: mst_prim\n---\n\n# Minimum spanning tree - Prim's algorithm\n\nGiven a weighted, undirected graph $G$ with $n$ vertices and $m$ edges.\nYou want to find a spanning tree of this graph which connects all vertices and has the least weight (i.e. the sum of weights of edges is minimal).\nA spanning tree is a set of edges such that any vertex can reach any other by exactly one simple path.\nThe spanning tree with the least weight is called a minimum spanning tree.\n\nIn the left image you can see a weighted undirected graph, and in the right image you can see the corresponding minimum spanning tree.\n\n<center>![Random graph](MST_before.png) ![MST of this graph](MST_after.png)</center>\n\nIt is easy to see that any spanning tree will necessarily contain $n-1$ edges.\n\nThis problem appears quite naturally in a lot of problems.\nFor instance in the following problem:\nthere are $n$ cities and for each pair of cities we are given the cost to build a road between them (or we know that is physically impossible to build a road between them).\nWe have to build roads, such that we can get from each city to every other city, and the cost for building all roads is minimal.\n\n## Prim's Algorithm\n\nThis algorithm was originally discovered by the Czech mathematician Vojt\u011bch Jarn\u00edk in 1930.\nHowever this algorithm is mostly known as Prim's algorithm after the American mathematician Robert Clay Prim, who rediscovered and republished it in 1957.\nAdditionally Edsger Dijkstra published this algorithm in 1959.\n\n### Algorithm description\n\nHere we describe the algorithm in its simplest form.\nThe minimum spanning tree is built gradually by adding edges one at a time.\nAt first the spanning tree consists only of a single vertex (chosen arbitrarily).\nThen the minimum weight edge outgoing from this vertex is selected and added to the spanning tree.\nAfter that the spanning tree already consists of two vertices.\nNow select and add the edge with the minimum weight that has one end in an already selected vertex (i.e. a vertex that is already part of the spanning tree), and the other end in an unselected vertex.\nAnd so on, i.e. every time we select and add the edge with minimal weight that connects one selected vertex with one unselected vertex.\nThe process is repeated until the spanning tree contains all vertices (or equivalently until we have $n - 1$ edges).\n\nIn the end the constructed spanning tree will be minimal.\nIf the graph was originally not connected, then there doesn't exist a spanning tree, so the number of selected edges will be less than $n - 1$.\n\n### Proof\n\nLet the graph $G$ be connected, i.e. the answer exists.\nWe denote by $T$ the resulting graph found by Prim's algorithm, and by $S$ the minimum spanning tree.\nObviously $T$ is indeed a spanning tree and a subgraph of $G$.\nWe only need to show that the weights of $S$ and $T$ coincide.\n\nConsider the first time in the algorithm when we add an edge to $T$ that is not part of $S$.\nLet us denote this edge with $e$, its ends by $a$ and $b$, and the set of already selected vertices as $V$ ($a \\in V$ and $b \\notin V$, or vice versa).\n\nIn the minimal spanning tree $S$ the vertices $a$ and $b$ are connected by some path $P$.\nOn this path we can find an edge $f$ such that one end of $f$ lies in $V$ and the other end doesn't.\nSince the algorithm chose $e$ instead of $f$, it means that the weight of $f$ is greater or equal to the weight of $e$.\n\nWe add the edge $e$ to the minimum spanning tree $S$ and remove the edge $f$.\nBy adding $e$ we created a cycle, and since $f$ was also part of the only cycle, by removing it the resulting graph is again free of cycles.\nAnd because we only removed an edge from a cycle, the resulting graph is still connected.\n\nThe resulting spanning tree cannot have a larger total weight, since the weight of $e$ was not larger than the weight of $f$, and it also cannot have a smaller weight since $S$ was a minimum spanning tree.\nThis means that by replacing the edge $f$ with $e$ we generated a different minimum spanning tree.\nAnd $e$ has to have the same weight as $f$.\n\nThus all the edges we pick in Prim's algorithm have the same weights as the edges of any minimum spanning tree, which means that Prim's algorithm really generates a minimum spanning tree.\n\n## Implementation\n\nThe complexity of the algorithm depends on how we search for the next minimal edge among the appropriate edges.\nThere are multiple approaches leading to different complexities and different implementations.\n\n### Trivial implementations: $O(n m)$ and $O(n^2 + m \\log n)$\n\nIf we search the edge by iterating over all possible edges, then it takes $O(m)$ time to find the edge with the minimal weight.\nThe total complexity will be $O(n m)$.\nIn the worst case this is $O(n^3)$, really slow.\n\nThis algorithm can be improved if we only look at one edge from each already selected vertex.\nFor example we can sort the edges from each vertex in ascending order of their weights, and store a pointer to the first valid edge (i.e. an edge that goes to an non-selected vertex).\nThen after finding and selecting the minimal edge, we update the pointers.\nThis give a complexity of $O(n^2 + m)$, and for sorting the edges an additional $O(m \\log n)$, which gives the complexity $O(n^2 \\log n)$ in the worst case.\n\nBelow we consider two slightly different algorithms, one for dense and one for sparse graphs, both with a better complexity.\n\n### Dense graphs: $O(n^2)$\n\nWe approach this problem from a different angle:\nfor every not yet selected vertex we will store the minimum edge to an already selected vertex.\n\nThen during a step we only have to look at these minimum weight edges, which will have a complexity of $O(n)$.\n\nAfter adding an edge some minimum edge pointers have to be recalculated.\nNote that the weights only can decrease, i.e. the minimal weight edge of every not yet selected vertex might stay the same, or it will be updated by an edge to the newly selected vertex.\nTherefore this phase can also be done in $O(n)$.\n\nThus we received a version of Prim's algorithm with the complexity $O(n^2)$.\n\nIn particular this implementation is very convenient for the Euclidean Minimum Spanning Tree problem:\nwe have $n$ points on a plane and the distance between each pair of points is the Euclidean distance between them, and we want to find a minimum spanning tree for this complete graph.\nThis task can be solved by the described algorithm in $O(n^2)$ time and $O(n)$ memory, which is not possible with [Kruskal's algorithm](mst_kruskal.md).\n\n```cpp\nint n;\nvector<vector<int>> adj; // adjacency matrix of graph\nconst int INF = 1000000000; // weight INF means there is no edge\n\nstruct Edge {\n    int w = INF, to = -1;\n};\n\nvoid prim() {\n    int total_weight = 0;\n    vector<bool> selected(n, false);\n    vector<Edge> min_e(n);\n    min_e[0].w = 0;\n\n    for (int i=0; i<n; ++i) {\n        int v = -1;\n        for (int j = 0; j < n; ++j) {\n            if (!selected[j] && (v == -1 || min_e[j].w < min_e[v].w))\n                v = j;\n        }\n\n        if (min_e[v].w == INF) {\n            cout << \"No MST!\" << endl;\n            exit(0);\n        }\n\n        selected[v] = true;\n        total_weight += min_e[v].w;\n        if (min_e[v].to != -1)\n            cout << v << \" \" << min_e[v].to << endl;\n\n        for (int to = 0; to < n; ++to) {\n            if (adj[v][to] < min_e[to].w)\n                min_e[to] = {adj[v][to], v};\n        }\n    }\n\n    cout << total_weight << endl;\n}\n```\n\nThe adjacency matrix `adj[][]` of size $n \\times n$ stores the weights of the edges, and it uses the weight `INF` if there doesn't exist an edge between two vertices.\nThe algorithm uses two arrays: the flag `selected[]`, which indicates which vertices we already have selected, and the array `min_e[]` which stores the edge with minimal weight to an selected vertex for each not-yet-selected vertex (it stores the weight and the end vertex).\nThe algorithm does $n$ steps, in each iteration the vertex with the smallest edge weight is selected, and the `min_e[]` of all other vertices gets updated.\n\n### Sparse graphs: $O(m \\log n)$\n\nIn the above described algorithm it is possible to interpret the operations of finding the minimum and modifying some values as set operations.\nThese two classical operations are supported by many data structure, for example by `set` in C++ (which are implemented via red-black trees).\n\nThe main algorithm remains the same, but now we can find the minimum edge in $O(\\log n)$ time.\nOn the other hand recomputing the pointers will now take $O(n \\log n)$ time, which is worse than in the previous algorithm.\n\nBut when we consider that we only need to update $O(m)$ times in total, and perform $O(n)$ searches for the minimal edge, then the total complexity will be $O(m \\log n)$.\nFor sparse graphs this is better than the above algorithm, but for dense graphs this will be slower.\n\n```cpp\nconst int INF = 1000000000;\n\nstruct Edge {\n    int w = INF, to = -1;\n    bool operator<(Edge const& other) const {\n        return make_pair(w, to) < make_pair(other.w, other.to);\n    }\n};\n\nint n;\nvector<vector<Edge>> adj;\n\nvoid prim() {\n    int total_weight = 0;\n    vector<Edge> min_e(n);\n    min_e[0].w = 0;\n    set<Edge> q;\n    q.insert({0, 0});\n    vector<bool> selected(n, false);\n    for (int i = 0; i < n; ++i) {\n        if (q.empty()) {\n            cout << \"No MST!\" << endl;\n            exit(0);\n        }\n\n        int v = q.begin()->to;\n        selected[v] = true;\n        total_weight += q.begin()->w;\n        q.erase(q.begin());\n\n        if (min_e[v].to != -1)\n            cout << v << \" \" << min_e[v].to << endl;\n\n        for (Edge e : adj[v]) {\n            if (!selected[e.to] && e.w < min_e[e.to].w) {\n                q.erase({min_e[e.to].w, e.to});\n                min_e[e.to] = {e.w, v};\n                q.insert({e.w, e.to});\n            }\n        }\n    }\n\n    cout << total_weight << endl;\n}\n```\n\nHere the graph is represented via a adjacency list `adj[]`, where `adj[v]` contains all edges (in form of weight and target pairs) for the vertex `v`.\n`min_e[v]` will store the weight of the smallest edge from vertex `v` to an already selected vertex (again in the form of a weight and target pair).\nIn addition the queue `q` is filled with all not yet selected vertices in the order of increasing weights `min_e`.\nThe algorithm does `n` steps, on each of which it selects the vertex `v` with the smallest weight `min_e` (by extracting it from the beginning of the queue), and then looks through all the edges from this vertex and updates the values in `min_e` (during an update we also need to also remove the old edge from the queue `q` and put in the new edge).\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: mst_prim\n---\n\n# Minimum spanning tree - Prim's algorithm\n\nGiven a weighted, undirected graph $G$ with $n$ vertices and $m$ edges.\nYou want to find a spanning tree of this graph which connects all vertices and has the least weight (i.e. the sum of weights of edges is minimal).\nA spanning tree is a set of edges such that any vertex can reach any other by exactly one simple path.\nThe spanning tree with the least weight is called a minimum spanning tree.\n\nIn the left image you can see a weighted undirected graph, and in the right image you can see the corresponding minimum spanning tree.\n\n<center>![Random graph](MST_before.png) ![MST of this graph](MST_after.png)</center>\n\nIt is easy to see that any spanning tree will necessarily contain $n-1$ edges.\n\nThis problem appears quite naturally in a lot of problems.\nFor instance in the following problem:\nthere are $n$ cities and for each pair of cities we are given the cost to build a road between them (or we know that is physically impossible to build a road between them).\nWe have to build roads, such that we can get from each city to every other city, and the cost for building all roads is minimal.\n\n## Prim's Algorithm\n\nThis algorithm was originally discovered by the Czech mathematician Vojt\u011bch Jarn\u00edk in 1930.\nHowever this algorithm is mostly known as Prim's algorithm after the American mathematician Robert Clay Prim, who rediscovered and republished it in 1957.\nAdditionally Edsger Dijkstra published this algorithm in 1959.\n\n### Algorithm description\n\nHere we describe the algorithm in its simplest form.\nThe minimum spanning tree is built gradually by adding edges one at a time.\nAt first the spanning tree consists only of a single vertex (chosen arbitrarily).\nThen the minimum weight edge outgoing from this vertex is selected and added to the spanning tree.\nAfter that the spanning tree already consists of two vertices.\nNow select and add the edge with the minimum weight that has one end in an already selected vertex (i.e. a vertex that is already part of the spanning tree), and the other end in an unselected vertex.\nAnd so on, i.e. every time we select and add the edge with minimal weight that connects one selected vertex with one unselected vertex.\nThe process is repeated until the spanning tree contains all vertices (or equivalently until we have $n - 1$ edges).\n\nIn the end the constructed spanning tree will be minimal.\nIf the graph was originally not connected, then there doesn't exist a spanning tree, so the number of selected edges will be less than $n - 1$.\n\n### Proof\n\nLet the graph $G$ be connected, i.e. the answer exists.\nWe denote by $T$ the resulting graph found by Prim's algorithm, and by $S$ the minimum spanning tree.\nObviously $T$ is indeed a spanning tree and a subgraph of $G$.\nWe only need to show that the weights of $S$ and $T$ coincide.\n\nConsider the first time in the algorithm when we add an edge to $T$ that is not part of $S$.\nLet us denote this edge with $e$, its ends by $a$ and $b$, and the set of already selected vertices as $V$ ($a \\in V$ and $b \\notin V$, or vice versa).\n\nIn the minimal spanning tree $S$ the vertices $a$ and $b$ are connected by some path $P$.\nOn this path we can find an edge $f$ such that one end of $f$ lies in $V$ and the other end doesn't.\nSince the algorithm chose $e$ instead of $f$, it means that the weight of $f$ is greater or equal to the weight of $e$.\n\nWe add the edge $e$ to the minimum spanning tree $S$ and remove the edge $f$.\nBy adding $e$ we created a cycle, and since $f$ was also part of the only cycle, by removing it the resulting graph is again free of cycles.\nAnd because we only removed an edge from a cycle, the resulting graph is still connected.\n\nThe resulting spanning tree cannot have a larger total weight, since the weight of $e$ was not larger than the weight of $f$, and it also cannot have a smaller weight since $S$ was a minimum spanning tree.\nThis means that by replacing the edge $f$ with $e$ we generated a different minimum spanning tree.\nAnd $e$ has to have the same weight as $f$.\n\nThus all the edges we pick in Prim's algorithm have the same weights as the edges of any minimum spanning tree, which means that Prim's algorithm really generates a minimum spanning tree.\n\n## Implementation\n\nThe complexity of the algorithm depends on how we search for the next minimal edge among the appropriate edges.\nThere are multiple approaches leading to different complexities and different implementations.\n\n### Trivial implementations: $O(n m)$ and $O(n^2 + m \\log n)$\n\nIf we search the edge by iterating over all possible edges, then it takes $O(m)$ time to find the edge with the minimal weight.\nThe total complexity will be $O(n m)$.\nIn the worst case this is $O(n^3)$, really slow.\n\nThis algorithm can be improved if we only look at one edge from each already selected vertex.\nFor example we can sort the edges from each vertex in ascending order of their weights, and store a pointer to the first valid edge (i.e. an edge that goes to an non-selected vertex).\nThen after finding and selecting the minimal edge, we update the pointers.\nThis give a complexity of $O(n^2 + m)$, and for sorting the edges an additional $O(m \\log n)$, which gives the complexity $O(n^2 \\log n)$ in the worst case.\n\nBelow we consider two slightly different algorithms, one for dense and one for sparse graphs, both with a better complexity.\n\n### Dense graphs: $O(n^2)$\n\nWe approach this problem from a different angle:\nfor every not yet selected vertex we will store the minimum edge to an already selected vertex.\n\nThen during a step we only have to look at these minimum weight edges, which will have a complexity of $O(n)$.\n\nAfter adding an edge some minimum edge pointers have to be recalculated.\nNote that the weights only can decrease, i.e. the minimal weight edge of every not yet selected vertex might stay the same, or it will be updated by an edge to the newly selected vertex.\nTherefore this phase can also be done in $O(n)$.\n\nThus we received a version of Prim's algorithm with the complexity $O(n^2)$.\n\nIn particular this implementation is very convenient for the Euclidean Minimum Spanning Tree problem:\nwe have $n$ points on a plane and the distance between each pair of points is the Euclidean distance between them, and we want to find a minimum spanning tree for this complete graph.\nThis task can be solved by the described algorithm in $O(n^2)$ time and $O(n)$ memory, which is not possible with [Kruskal's algorithm](mst_kruskal.md).\n\n```cpp\nint n;\nvector<vector<int>> adj; // adjacency matrix of graph\nconst int INF = 1000000000; // weight INF means there is no edge\n\nstruct Edge {\n    int w = INF, to = -1;\n};\n\nvoid prim() {\n    int total_weight = 0;\n    vector<bool> selected(n, false);\n    vector<Edge> min_e(n);\n    min_e[0].w = 0;\n\n    for (int i=0; i<n; ++i) {\n        int v = -1;\n        for (int j = 0; j < n; ++j) {\n            if (!selected[j] && (v == -1 || min_e[j].w < min_e[v].w))\n                v = j;\n        }\n\n        if (min_e[v].w == INF) {\n            cout << \"No MST!\" << endl;\n            exit(0);\n        }\n\n        selected[v] = true;\n        total_weight += min_e[v].w;\n        if (min_e[v].to != -1)\n            cout << v << \" \" << min_e[v].to << endl;\n\n        for (int to = 0; to < n; ++to) {\n            if (adj[v][to] < min_e[to].w)\n                min_e[to] = {adj[v][to], v};\n        }\n    }\n\n    cout << total_weight << endl;\n}\n```\n\nThe adjacency matrix `adj[][]` of size $n \\times n$ stores the weights of the edges, and it uses the weight `INF` if there doesn't exist an edge between two vertices.\nThe algorithm uses two arrays: the flag `selected[]`, which indicates which vertices we already have selected, and the array `min_e[]` which stores the edge with minimal weight to an selected vertex for each not-yet-selected vertex (it stores the weight and the end vertex).\nThe algorithm does $n$ steps, in each iteration the vertex with the smallest edge weight is selected, and the `min_e[]` of all other vertices gets updated.\n\n### Sparse graphs: $O(m \\log n)$\n\nIn the above described algorithm it is possible to interpret the operations of finding the minimum and modifying some values as set operations.\nThese two classical operations are supported by many data structure, for example by `set` in C++ (which are implemented via red-black trees).\n\nThe main algorithm remains the same, but now we can find the minimum edge in $O(\\log n)$ time.\nOn the other hand recomputing the pointers will now take $O(n \\log n)$ time, which is worse than in the previous algorithm.\n\nBut when we consider that we only need to update $O(m)$ times in total, and perform $O(n)$ searches for the minimal edge, then the total complexity will be $O(m \\log n)$.\nFor sparse graphs this is better than the above algorithm, but for dense graphs this will be slower.\n\n```cpp\nconst int INF = 1000000000;\n\nstruct Edge {\n    int w = INF, to = -1;\n    bool operator<(Edge const& other) const {\n        return make_pair(w, to) < make_pair(other.w, other.to);\n    }\n};\n\nint n;\nvector<vector<Edge>> adj;\n\nvoid prim() {\n    int total_weight = 0;\n    vector<Edge> min_e(n);\n    min_e[0].w = 0;\n    set<Edge> q;\n    q.insert({0, 0});\n    vector<bool> selected(n, false);\n    for (int i = 0; i < n; ++i) {\n        if (q.empty()) {\n            cout << \"No MST!\" << endl;\n            exit(0);\n        }\n\n        int v = q.begin()->to;\n        selected[v] = true;\n        total_weight += q.begin()->w;\n        q.erase(q.begin());\n\n        if (min_e[v].to != -1)\n            cout << v << \" \" << min_e[v].to << endl;\n\n        for (Edge e : adj[v]) {\n            if (!selected[e.to] && e.w < min_e[e.to].w) {\n                q.erase({min_e[e.to].w, e.to});\n                min_e[e.to] = {e.w, v};\n                q.insert({e.w, e.to});\n            }\n        }\n    }\n\n    cout << total_weight << endl;\n}\n```\n\nHere the graph is represented via a adjacency list `adj[]`, where `adj[v]` contains all edges (in form of weight and target pairs) for the vertex `v`.\n`min_e[v]` will store the weight of the smallest edge from vertex `v` to an already selected vertex (again in the form of a weight and target pair).\nIn addition the queue `q` is filled with all not yet selected vertices in the order of increasing weights `min_e`.\nThe algorithm does `n` steps, on each of which it selects the vertex `v` with the smallest weight `min_e` (by extracting it from the beginning of the queue), and then looks through all the edges from this vertex and updates the values in `min_e` (during an update we also need to also remove the old edge from the queue `q` and put in the new edge).\n", "problem_ids": [], "title": "Minimum spanning tree - Prim's algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: levit_algorithm\n---\n\n# D\u00b4Esopo-Pape algorithm\n\nGiven a graph with $n$ vertices and $m$ edges with weights $w_i$ and a starting vertex $v_0$.\nThe task is to find the shortest path from the vertex $v_0$ to every other vertex.\n\nThe algorithm from D\u00b4Esopo-Pape will work faster than [Dijkstra's algorithm](dijkstra.md) and the [Bellman-Ford algorithm](bellman_ford.md) in most cases, and will also work for negative edges.\nHowever not for negative cycles.\n\n## Description\n\nLet the array $d$ contain the shortest path lengths, i.e. $d_i$ is the current length of the shortest path from the vertex $v_0$ to the vertex $i$.\nInitially this array is filled with infinity for every vertex, except $d_{v_0} = 0$.\nAfter the algorithm finishes, this array will contain the shortest distances.\n\nLet the array $p$ contain the current ancestors, i.e. $p_i$ is the direct ancestor of the vertex $i$ on the current shortest path from $v_0$ to $i$.\nJust like the array $d$, the array $p$ changes gradually during the algorithm and at the end takes its final values.\n\nNow to the algorithm.\nAt each step three sets of vertices are maintained:\n\n- $M_0$ - vertices, for which the distance has already been calculated (although it might not be the final distance)\n- $M_1$ - vertices, for which the distance currently is calculated\n- $M_2$ - vertices, for which the distance has not yet been calculated\n\nThe vertices in the set $M_1$ are stored in a bidirectional queue (deque).\n\nAt each step of the algorithm we take a vertex from the set $M_1$ (from the front of the queue).\nLet $u$ be the selected vertex.\nWe put this vertex $u$ into the set $M_0$.\nThen we iterate over all edges coming out of this vertex.\nLet $v$ be the second end of the current edge, and $w$ its weight.\n\n- If $v$ belongs to $M_2$, then $v$ is inserted into the set $M_1$ by inserting it at the back of the queue.\n$d_v$ is set to $d_u + w$.\n- If $v$ belongs to $M_1$, then we try to improve the value of $d_v$: $d_v = \\min(d_v, d_u + w)$.\nSince $v$ is already in $M_1$, we don't need to insert it into $M_1$ and the queue.\n- If $v$ belongs to $M_0$, and if $d_v$ can be improved $d_v > d_u + w$, then we improve $d_v$ and insert the vertex $v$ back to the set $M_1$, placing it at the beginning of the queue.\n\nAnd of course, with each update in the array $d$ we also have to update the corresponding element in the array $p$.\n\n## Implementation\n\nWe will use an array $m$ to store in which set each vertex is currently.\n\n```{.cpp file=desopo_pape}\nstruct Edge {\n    int to, w;\n};\n\nint n;\nvector<vector<Edge>> adj;\n\nconst int INF = 1e9;\n\nvoid shortest_paths(int v0, vector<int>& d, vector<int>& p) {\n    d.assign(n, INF);\n    d[v0] = 0;\n    vector<int> m(n, 2);\n    deque<int> q;\n    q.push_back(v0);\n    p.assign(n, -1);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop_front();\n        m[u] = 0;\n        for (Edge e : adj[u]) {\n            if (d[e.to] > d[u] + e.w) {\n                d[e.to] = d[u] + e.w;\n                p[e.to] = u;\n                if (m[e.to] == 2) {\n                    m[e.to] = 1;\n                    q.push_back(e.to);\n                } else if (m[e.to] == 0) {\n                    m[e.to] = 1;\n                    q.push_front(e.to);\n                }\n            }\n        }\n    }\n}\n```\n\n## Complexity\n\nThe algorithm usually performs quite fast - in most cases, even faster than Dijkstra's algorithm.\nHowever there exist cases for which the algorithm takes exponential time, making it unsuitable in the worst-case. See discussions on [Stack Overflow](https://stackoverflow.com/a/67642821) and [Codeforces](https://codeforces.com/blog/entry/3793) for reference.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: levit_algorithm\n---\n\n# D\u00b4Esopo-Pape algorithm\n\nGiven a graph with $n$ vertices and $m$ edges with weights $w_i$ and a starting vertex $v_0$.\nThe task is to find the shortest path from the vertex $v_0$ to every other vertex.\n\nThe algorithm from D\u00b4Esopo-Pape will work faster than [Dijkstra's algorithm](dijkstra.md) and the [Bellman-Ford algorithm](bellman_ford.md) in most cases, and will also work for negative edges.\nHowever not for negative cycles.\n\n## Description\n\nLet the array $d$ contain the shortest path lengths, i.e. $d_i$ is the current length of the shortest path from the vertex $v_0$ to the vertex $i$.\nInitially this array is filled with infinity for every vertex, except $d_{v_0} = 0$.\nAfter the algorithm finishes, this array will contain the shortest distances.\n\nLet the array $p$ contain the current ancestors, i.e. $p_i$ is the direct ancestor of the vertex $i$ on the current shortest path from $v_0$ to $i$.\nJust like the array $d$, the array $p$ changes gradually during the algorithm and at the end takes its final values.\n\nNow to the algorithm.\nAt each step three sets of vertices are maintained:\n\n- $M_0$ - vertices, for which the distance has already been calculated (although it might not be the final distance)\n- $M_1$ - vertices, for which the distance currently is calculated\n- $M_2$ - vertices, for which the distance has not yet been calculated\n\nThe vertices in the set $M_1$ are stored in a bidirectional queue (deque).\n\nAt each step of the algorithm we take a vertex from the set $M_1$ (from the front of the queue).\nLet $u$ be the selected vertex.\nWe put this vertex $u$ into the set $M_0$.\nThen we iterate over all edges coming out of this vertex.\nLet $v$ be the second end of the current edge, and $w$ its weight.\n\n- If $v$ belongs to $M_2$, then $v$ is inserted into the set $M_1$ by inserting it at the back of the queue.\n$d_v$ is set to $d_u + w$.\n- If $v$ belongs to $M_1$, then we try to improve the value of $d_v$: $d_v = \\min(d_v, d_u + w)$.\nSince $v$ is already in $M_1$, we don't need to insert it into $M_1$ and the queue.\n- If $v$ belongs to $M_0$, and if $d_v$ can be improved $d_v > d_u + w$, then we improve $d_v$ and insert the vertex $v$ back to the set $M_1$, placing it at the beginning of the queue.\n\nAnd of course, with each update in the array $d$ we also have to update the corresponding element in the array $p$.\n\n## Implementation\n\nWe will use an array $m$ to store in which set each vertex is currently.\n\n```{.cpp file=desopo_pape}\nstruct Edge {\n    int to, w;\n};\n\nint n;\nvector<vector<Edge>> adj;\n\nconst int INF = 1e9;\n\nvoid shortest_paths(int v0, vector<int>& d, vector<int>& p) {\n    d.assign(n, INF);\n    d[v0] = 0;\n    vector<int> m(n, 2);\n    deque<int> q;\n    q.push_back(v0);\n    p.assign(n, -1);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop_front();\n        m[u] = 0;\n        for (Edge e : adj[u]) {\n            if (d[e.to] > d[u] + e.w) {\n                d[e.to] = d[u] + e.w;\n                p[e.to] = u;\n                if (m[e.to] == 2) {\n                    m[e.to] = 1;\n                    q.push_back(e.to);\n                } else if (m[e.to] == 0) {\n                    m[e.to] = 1;\n                    q.push_front(e.to);\n                }\n            }\n        }\n    }\n}\n```\n\n## Complexity\n\nThe algorithm usually performs quite fast - in most cases, even faster than Dijkstra's algorithm.\nHowever there exist cases for which the algorithm takes exponential time, making it unsuitable in the worst-case. See discussions on [Stack Overflow](https://stackoverflow.com/a/67642821) and [Codeforces](https://codeforces.com/blog/entry/3793) for reference.\n", "problem_ids": [], "title": "D\u00b4Esopo-Pape algorithm"}, {"article": "---\ntags:\n  - Original\n---\n\n# Second Best Minimum Spanning Tree\n\nA Minimum Spanning Tree $T$ is a tree for the given graph $G$ which spans over all vertices of the given graph and has the minimum weight sum of all the edges, from all the possible spanning trees.\nA second best MST $T'$ is a spanning tree, that has the second minimum weight sum of all the edges, from all the possible spanning trees of the graph $G$.\n\n## Observation\n\nLet $T$ be the Minimum Spanning Tree of a graph $G$.\nIt can be observed, that the second best Minimum Spanning Tree differs from $T$ by only one edge replacement. (For a proof of this statement refer to problem 23-1 [here](http://www-bcf.usc.edu/~shanghua/teaching/Spring2010/public_html/files/HW2_Solutions_A.pdf)).\n\nSo we need to find an edge $e_{new}$ which is in not in $T$, and replace it with an edge in $T$ (let it be $e_{old}$) such that the new graph $T' = (T \\cup \\{e_{new}\\}) \\setminus \\{e_{old}\\}$ is a spanning tree and the weight difference ($e_{new} - e_{old}$) is minimum.\n\n\n## Using Kruskal's Algorithm\n\nWe can use Kruskal's algorithm to find the MST first, and then just try to remove a single edge from it and replace it with another.\n\n1. Sort the edges in $O(E \\log E)$, then find a MST using Kruskal in $O(E)$.\n2. For each edge in the MST (we will have $V-1$ edges in it) temporarily exclude it from the edge list so that it cannot be chosen.\n3. Then, again try to find a MST in $O(E)$ using the remaining edges.\n4. Do this for all the edges in MST, and take the best of all.\n\nNote: we don\u2019t need to sort the edges again in for Step 3.\n\nSo, the overall time complexity will be $O(E \\log V + E + V E)$ = $O(V E)$.\n\n\n## Modeling into a Lowest Common Ancestor (LCA) problem\n\nIn the previous approach we tried all possibilities of removing one edge of the MST.\nHere we will do the exact opposite.\nWe try to add every edge that is not already in the MST.\n\n1. Sort the edges in $O(E \\log E)$, then find a MST using Kruskal in $O(E)$.\n2. For each edge $e$ not already in the MST, temporarily add it to the MST, creating a cycle. The cycle will pass through the LCA.\n3. Find the edge $k$ with maximal weight in the cycle that is not equal to $e$, by following the parents of the nodes of edge $e$, up to the LCA.\n4. Remove $k$ temporarily, creating a new spanning tree.\n5. Compute the weight difference $\\delta = weight(e) - weight(k)$, and remember it together with the changed edge.\n6. Repeat step 2 for all other edges, and return the spanning tree with the smallest weight difference to the MST.\n\nThe time complexity of the algorithm depends on how we compute the $k$s, which are the maximum weight edges in step 2 of this algorithm.\nOne way to compute them efficiently in $O(E \\log V)$ is to transform the problem into a Lowest Common Ancestor (LCA) problem.\n\nWe will preprocess the LCA by rooting the MST and will also compute the maximum edge weights for each node on the paths to their ancestors. \nThis can be done using [Binary Lifting](lca_binary_lifting.md) for LCA.\n\nThe final time complexity of this approach is $O(E \\log V)$.\n\nFor example:\n\n<center>![MST](second_best_mst_1.png) ![Second best MST](second_best_mst_2.png) <br>\n\n*In the image left is the MST and right is the second best MST.*\n</center>\n\n\nIn the given graph suppose we root the MST at the blue vertex on the top, and then run our algorithm by start picking the edges not in MST.\nLet the edge picked first be the edge $(u, v)$ with weight 36.\nAdding this edge to the tree forms a cycle 36 - 7 - 2 - 34.\n\nNow we will find the maximum weight edge in this cycle by finding the $\\text{LCA}(u, v) = p$.\nWe compute the maximum weight edge on the paths from $u$ to $p$ and from $v$ to $p$.\nNote: the $\\text{LCA}(u, v)$ can also be equal to $u$ or $v$ in some case.\nIn this example we will get the edge with weight 34 as maximum edge weight in the cycle.\nBy removing the edge we get a new spanning tree, that has a weight difference of only 2.\n\nAfter doing this also with all other edges that are not part of the initial MST, we can see that this spanning tree was also the second best spanning tree overall.\nChoosing the edge with weight 14 will increase the weight of the tree by 7, choosing the edge with weight 27 increases it by 14, choosing the edge with weight 28 increases it by 21, and choosing the edge with weight 39 will increase the tree by 5.\n\n## Implementation\n```cpp\nstruct edge {\n    int s, e, w, id;\n    bool operator<(const struct edge& other) { return w < other.w; }\n};\ntypedef struct edge Edge;\n\nconst int N = 2e5 + 5;\nlong long res = 0, ans = 1e18;\nint n, m, a, b, w, id, l = 21;\nvector<Edge> edges;\nvector<int> h(N, 0), parent(N, -1), size(N, 0), present(N, 0);\nvector<vector<pair<int, int>>> adj(N), dp(N, vector<pair<int, int>>(l));\nvector<vector<int>> up(N, vector<int>(l, -1));\n\npair<int, int> combine(pair<int, int> a, pair<int, int> b) {\n    vector<int> v = {a.first, a.second, b.first, b.second};\n    int topTwo = -3, topOne = -2;\n    for (int c : v) {\n        if (c > topOne) {\n            topTwo = topOne;\n            topOne = c;\n        } else if (c > topTwo && c < topOne) {\n            topTwo = c;\n        }\n    }\n    return {topOne, topTwo};\n}\n\nvoid dfs(int u, int par, int d) {\n    h[u] = 1 + h[par];\n    up[u][0] = par;\n    dp[u][0] = {d, -1};\n    for (auto v : adj[u]) {\n        if (v.first != par) {\n            dfs(v.first, u, v.second);\n        }\n    }\n}\n\npair<int, int> lca(int u, int v) {\n    pair<int, int> ans = {-2, -3};\n    if (h[u] < h[v]) {\n        swap(u, v);\n    }\n    for (int i = l - 1; i >= 0; i--) {\n        if (h[u] - h[v] >= (1 << i)) {\n            ans = combine(ans, dp[u][i]);\n            u = up[u][i];\n        }\n    }\n    if (u == v) {\n        return ans;\n    }\n    for (int i = l - 1; i >= 0; i--) {\n        if (up[u][i] != -1 && up[v][i] != -1 && up[u][i] != up[v][i]) {\n            ans = combine(ans, combine(dp[u][i], dp[v][i]));\n            u = up[u][i];\n            v = up[v][i];\n        }\n    }\n    ans = combine(ans, combine(dp[u][0], dp[v][0]));\n    return ans;\n}\n\nint main(void) {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        size[i] = 1;\n    }\n    for (int i = 1; i <= m; i++) {\n        cin >> a >> b >> w; // 1-indexed\n        edges.push_back({a, b, w, i - 1});\n    }\n    sort(edges.begin(), edges.end());\n    for (int i = 0; i <= m - 1; i++) {\n        a = edges[i].s;\n        b = edges[i].e;\n        w = edges[i].w;\n        id = edges[i].id;\n        if (unite_set(a, b)) { \n            adj[a].emplace_back(b, w);\n            adj[b].emplace_back(a, w);\n            present[id] = 1;\n            res += w;\n        }\n    }\n    dfs(1, 0, 0);\n    for (int i = 1; i <= l - 1; i++) {\n        for (int j = 1; j <= n; ++j) {\n            if (up[j][i - 1] != -1) {\n                int v = up[j][i - 1];\n                up[j][i] = up[v][i - 1];\n                dp[j][i] = combine(dp[j][i - 1], dp[v][i - 1]);\n            }\n        }\n    }\n    for (int i = 0; i <= m - 1; i++) {\n        id = edges[i].id;\n        w = edges[i].w;\n        if (!present[id]) {\n            auto rem = lca(edges[i].s, edges[i].e);\n            if (rem.first != w) {\n                if (ans > res + w - rem.first) {\n                    ans = res + w - rem.first;\n                }\n            } else if (rem.second != -1) {\n                if (ans > res + w - rem.second) {\n                    ans = res + w - rem.second;\n                }\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n```\n\n## References\n\n1. Competitive Programming-3, by Steven Halim\n2. [web.mit.edu](http://web.mit.edu/6.263/www/quiz1-f05-sol.pdf)\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Second Best Minimum Spanning Tree\n\nA Minimum Spanning Tree $T$ is a tree for the given graph $G$ which spans over all vertices of the given graph and has the minimum weight sum of all the edges, from all the possible spanning trees.\nA second best MST $T'$ is a spanning tree, that has the second minimum weight sum of all the edges, from all the possible spanning trees of the graph $G$.\n\n## Observation\n\nLet $T$ be the Minimum Spanning Tree of a graph $G$.\nIt can be observed, that the second best Minimum Spanning Tree differs from $T$ by only one edge replacement. (For a proof of this statement refer to problem 23-1 [here](http://www-bcf.usc.edu/~shanghua/teaching/Spring2010/public_html/files/HW2_Solutions_A.pdf)).\n\nSo we need to find an edge $e_{new}$ which is in not in $T$, and replace it with an edge in $T$ (let it be $e_{old}$) such that the new graph $T' = (T \\cup \\{e_{new}\\}) \\setminus \\{e_{old}\\}$ is a spanning tree and the weight difference ($e_{new} - e_{old}$) is minimum.\n\n\n## Using Kruskal's Algorithm\n\nWe can use Kruskal's algorithm to find the MST first, and then just try to remove a single edge from it and replace it with another.\n\n1. Sort the edges in $O(E \\log E)$, then find a MST using Kruskal in $O(E)$.\n2. For each edge in the MST (we will have $V-1$ edges in it) temporarily exclude it from the edge list so that it cannot be chosen.\n3. Then, again try to find a MST in $O(E)$ using the remaining edges.\n4. Do this for all the edges in MST, and take the best of all.\n\nNote: we don\u2019t need to sort the edges again in for Step 3.\n\nSo, the overall time complexity will be $O(E \\log V + E + V E)$ = $O(V E)$.\n\n\n## Modeling into a Lowest Common Ancestor (LCA) problem\n\nIn the previous approach we tried all possibilities of removing one edge of the MST.\nHere we will do the exact opposite.\nWe try to add every edge that is not already in the MST.\n\n1. Sort the edges in $O(E \\log E)$, then find a MST using Kruskal in $O(E)$.\n2. For each edge $e$ not already in the MST, temporarily add it to the MST, creating a cycle. The cycle will pass through the LCA.\n3. Find the edge $k$ with maximal weight in the cycle that is not equal to $e$, by following the parents of the nodes of edge $e$, up to the LCA.\n4. Remove $k$ temporarily, creating a new spanning tree.\n5. Compute the weight difference $\\delta = weight(e) - weight(k)$, and remember it together with the changed edge.\n6. Repeat step 2 for all other edges, and return the spanning tree with the smallest weight difference to the MST.\n\nThe time complexity of the algorithm depends on how we compute the $k$s, which are the maximum weight edges in step 2 of this algorithm.\nOne way to compute them efficiently in $O(E \\log V)$ is to transform the problem into a Lowest Common Ancestor (LCA) problem.\n\nWe will preprocess the LCA by rooting the MST and will also compute the maximum edge weights for each node on the paths to their ancestors. \nThis can be done using [Binary Lifting](lca_binary_lifting.md) for LCA.\n\nThe final time complexity of this approach is $O(E \\log V)$.\n\nFor example:\n\n<center>![MST](second_best_mst_1.png) ![Second best MST](second_best_mst_2.png) <br>\n\n*In the image left is the MST and right is the second best MST.*\n</center>\n\n\nIn the given graph suppose we root the MST at the blue vertex on the top, and then run our algorithm by start picking the edges not in MST.\nLet the edge picked first be the edge $(u, v)$ with weight 36.\nAdding this edge to the tree forms a cycle 36 - 7 - 2 - 34.\n\nNow we will find the maximum weight edge in this cycle by finding the $\\text{LCA}(u, v) = p$.\nWe compute the maximum weight edge on the paths from $u$ to $p$ and from $v$ to $p$.\nNote: the $\\text{LCA}(u, v)$ can also be equal to $u$ or $v$ in some case.\nIn this example we will get the edge with weight 34 as maximum edge weight in the cycle.\nBy removing the edge we get a new spanning tree, that has a weight difference of only 2.\n\nAfter doing this also with all other edges that are not part of the initial MST, we can see that this spanning tree was also the second best spanning tree overall.\nChoosing the edge with weight 14 will increase the weight of the tree by 7, choosing the edge with weight 27 increases it by 14, choosing the edge with weight 28 increases it by 21, and choosing the edge with weight 39 will increase the tree by 5.\n\n## Implementation\n```cpp\nstruct edge {\n    int s, e, w, id;\n    bool operator<(const struct edge& other) { return w < other.w; }\n};\ntypedef struct edge Edge;\n\nconst int N = 2e5 + 5;\nlong long res = 0, ans = 1e18;\nint n, m, a, b, w, id, l = 21;\nvector<Edge> edges;\nvector<int> h(N, 0), parent(N, -1), size(N, 0), present(N, 0);\nvector<vector<pair<int, int>>> adj(N), dp(N, vector<pair<int, int>>(l));\nvector<vector<int>> up(N, vector<int>(l, -1));\n\npair<int, int> combine(pair<int, int> a, pair<int, int> b) {\n    vector<int> v = {a.first, a.second, b.first, b.second};\n    int topTwo = -3, topOne = -2;\n    for (int c : v) {\n        if (c > topOne) {\n            topTwo = topOne;\n            topOne = c;\n        } else if (c > topTwo && c < topOne) {\n            topTwo = c;\n        }\n    }\n    return {topOne, topTwo};\n}\n\nvoid dfs(int u, int par, int d) {\n    h[u] = 1 + h[par];\n    up[u][0] = par;\n    dp[u][0] = {d, -1};\n    for (auto v : adj[u]) {\n        if (v.first != par) {\n            dfs(v.first, u, v.second);\n        }\n    }\n}\n\npair<int, int> lca(int u, int v) {\n    pair<int, int> ans = {-2, -3};\n    if (h[u] < h[v]) {\n        swap(u, v);\n    }\n    for (int i = l - 1; i >= 0; i--) {\n        if (h[u] - h[v] >= (1 << i)) {\n            ans = combine(ans, dp[u][i]);\n            u = up[u][i];\n        }\n    }\n    if (u == v) {\n        return ans;\n    }\n    for (int i = l - 1; i >= 0; i--) {\n        if (up[u][i] != -1 && up[v][i] != -1 && up[u][i] != up[v][i]) {\n            ans = combine(ans, combine(dp[u][i], dp[v][i]));\n            u = up[u][i];\n            v = up[v][i];\n        }\n    }\n    ans = combine(ans, combine(dp[u][0], dp[v][0]));\n    return ans;\n}\n\nint main(void) {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        size[i] = 1;\n    }\n    for (int i = 1; i <= m; i++) {\n        cin >> a >> b >> w; // 1-indexed\n        edges.push_back({a, b, w, i - 1});\n    }\n    sort(edges.begin(), edges.end());\n    for (int i = 0; i <= m - 1; i++) {\n        a = edges[i].s;\n        b = edges[i].e;\n        w = edges[i].w;\n        id = edges[i].id;\n        if (unite_set(a, b)) { \n            adj[a].emplace_back(b, w);\n            adj[b].emplace_back(a, w);\n            present[id] = 1;\n            res += w;\n        }\n    }\n    dfs(1, 0, 0);\n    for (int i = 1; i <= l - 1; i++) {\n        for (int j = 1; j <= n; ++j) {\n            if (up[j][i - 1] != -1) {\n                int v = up[j][i - 1];\n                up[j][i] = up[v][i - 1];\n                dp[j][i] = combine(dp[j][i - 1], dp[v][i - 1]);\n            }\n        }\n    }\n    for (int i = 0; i <= m - 1; i++) {\n        id = edges[i].id;\n        w = edges[i].w;\n        if (!present[id]) {\n            auto rem = lca(edges[i].s, edges[i].e);\n            if (rem.first != w) {\n                if (ans > res + w - rem.first) {\n                    ans = res + w - rem.first;\n                }\n            } else if (rem.second != -1) {\n                if (ans > res + w - rem.second) {\n                    ans = res + w - rem.second;\n                }\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n```\n\n## References\n\n1. Competitive Programming-3, by Steven Halim\n2. [web.mit.edu](http://web.mit.edu/6.263/www/quiz1-f05-sol.pdf)\n\n## Problems\n* [Codeforces - Minimum spanning tree for each edge](https://codeforces.com/problemset/problem/609/E)\n", "problem_ids": ["609_E"], "title": "Second Best Minimum Spanning Tree"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: assignment_mincostflow\n---\n\n# Solving assignment problem using min-cost-flow\n\nThe **assignment problem** has two equivalent statements:\n\n   - Given a square matrix $A[1..N, 1..N]$, you need to select $N$ elements in it so that exactly one element is selected in each row and column, and the sum of the values of these elements is the smallest.\n   - There are $N$ orders and $N$ machines. The cost of manufacturing on each machine is known for each order.  Only one order can be performed on each machine. It is required to assign all orders to the machines so that the total cost is minimized.\n\nHere we will consider the solution of the problem based on the algorithm for finding the [minimum cost flow (min-cost-flow)](min_cost_flow.md), solving the assignment problem in $\\mathcal{O}(N^3)$.\n\n## Description\n\nLet's build a bipartite network: there is a source $S$, a drain $T$, in the first part there are $N$ vertices (corresponding to rows of the matrix, or orders), in the second there are also $N$ vertices (corresponding to the columns of the matrix, or machines). Between each vertex $i$ of the first set and each vertex $j$ of the second set, we draw an edge with bandwidth 1 and cost $A_{ij}$. From the source $S$ we draw edges to all vertices $i$ of the first set with bandwidth 1 and cost 0. We draw an edge with bandwidth 1 and cost 0 from each vertex of the second set $j$ to the drain $T$.\n\nWe find in the resulting network the maximum flow of the minimum cost. Obviously, the value of the flow will be $N$. Further, for each vertex $i$ of the first segment there is exactly one vertex $j$ of the second segment, such that the flow $F_{ij}$ = 1. Finally, this is a one-to-one correspondence between the vertices of the first segment and the vertices of the second part, which is the solution to the problem (since the found flow has a minimal cost, then the sum of the costs of the selected edges will be the lowest possible, which is the optimality criterion).\n\nThe complexity of this solution of the assignment problem depends on the algorithm by which the search for the maximum flow of the minimum cost is performed. The complexity will be $\\mathcal{O}(N^3)$ using [Dijkstra](dijkstra.md) or $\\mathcal{O}(N^4)$ using [Bellman-Ford](bellman_ford.md). This is due to the fact that the flow is of size $O(N)$ and each iteration of Dijkstra algorithm can be performed in $O(N^2)$, while it is $O(N^3)$ for Bellman-Ford.\n\n## Implementation\n\nThe implementation given here is long, it can probably be significantly reduced.\nIt uses the [SPFA algorithm](bellman_ford.md) for finding shortest paths.\n\n```cpp\nconst int INF = 1000 * 1000 * 1000;\n\nvector<int> assignment(vector<vector<int>> a) {\n    int n = a.size();\n    int m = n * 2 + 2;\n    vector<vector<int>> f(m, vector<int>(m));\n    int s = m - 2, t = m - 1;\n    int cost = 0;\n    while (true) {\n        vector<int> dist(m, INF);\n        vector<int> p(m);\n        vector<bool> inq(m, false);\n        queue<int> q;\n        dist[s] = 0;\n        p[s] = -1;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            inq[v] = false;\n            if (v == s) {\n                for (int i = 0; i < n; ++i) {\n                    if (f[s][i] == 0) {\n                        dist[i] = 0;\n                        p[i] = s;\n                        inq[i] = true;\n                        q.push(i);\n                    }\n                }\n            } else {\n                if (v < n) {\n                    for (int j = n; j < n + n; ++j) {\n                        if (f[v][j] < 1 && dist[j] > dist[v] + a[v][j - n]) {\n                            dist[j] = dist[v] + a[v][j - n];\n                            p[j] = v;\n                            if (!inq[j]) {\n                                q.push(j);\n                                inq[j] = true;\n                            }\n                        }\n                    }\n                } else {\n                    for (int j = 0; j < n; ++j) {\n                        if (f[v][j] < 0 && dist[j] > dist[v] - a[j][v - n]) {\n                            dist[j] = dist[v] - a[j][v - n];\n                            p[j] = v;\n                            if (!inq[j]) {\n                                q.push(j);\n                                inq[j] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int curcost = INF;\n        for (int i = n; i < n + n; ++i) {\n            if (f[i][t] == 0 && dist[i] < curcost) {\n                curcost = dist[i];\n                p[t] = i;\n            }\n        }\n        if (curcost == INF)\n            break;\n        cost += curcost;\n        for (int cur = t; cur != -1; cur = p[cur]) {\n            int prev = p[cur];\n            if (prev != -1)\n                f[cur][prev] = -(f[prev][cur] = 1);\n        }\n    }\n\n    vector<int> answer(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (f[i][j + n] == 1)\n                answer[i] = j;\n        }\n    }\n    return answer;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: assignment_mincostflow\n---\n\n# Solving assignment problem using min-cost-flow\n\nThe **assignment problem** has two equivalent statements:\n\n   - Given a square matrix $A[1..N, 1..N]$, you need to select $N$ elements in it so that exactly one element is selected in each row and column, and the sum of the values of these elements is the smallest.\n   - There are $N$ orders and $N$ machines. The cost of manufacturing on each machine is known for each order.  Only one order can be performed on each machine. It is required to assign all orders to the machines so that the total cost is minimized.\n\nHere we will consider the solution of the problem based on the algorithm for finding the [minimum cost flow (min-cost-flow)](min_cost_flow.md), solving the assignment problem in $\\mathcal{O}(N^3)$.\n\n## Description\n\nLet's build a bipartite network: there is a source $S$, a drain $T$, in the first part there are $N$ vertices (corresponding to rows of the matrix, or orders), in the second there are also $N$ vertices (corresponding to the columns of the matrix, or machines). Between each vertex $i$ of the first set and each vertex $j$ of the second set, we draw an edge with bandwidth 1 and cost $A_{ij}$. From the source $S$ we draw edges to all vertices $i$ of the first set with bandwidth 1 and cost 0. We draw an edge with bandwidth 1 and cost 0 from each vertex of the second set $j$ to the drain $T$.\n\nWe find in the resulting network the maximum flow of the minimum cost. Obviously, the value of the flow will be $N$. Further, for each vertex $i$ of the first segment there is exactly one vertex $j$ of the second segment, such that the flow $F_{ij}$ = 1. Finally, this is a one-to-one correspondence between the vertices of the first segment and the vertices of the second part, which is the solution to the problem (since the found flow has a minimal cost, then the sum of the costs of the selected edges will be the lowest possible, which is the optimality criterion).\n\nThe complexity of this solution of the assignment problem depends on the algorithm by which the search for the maximum flow of the minimum cost is performed. The complexity will be $\\mathcal{O}(N^3)$ using [Dijkstra](dijkstra.md) or $\\mathcal{O}(N^4)$ using [Bellman-Ford](bellman_ford.md). This is due to the fact that the flow is of size $O(N)$ and each iteration of Dijkstra algorithm can be performed in $O(N^2)$, while it is $O(N^3)$ for Bellman-Ford.\n\n## Implementation\n\nThe implementation given here is long, it can probably be significantly reduced.\nIt uses the [SPFA algorithm](bellman_ford.md) for finding shortest paths.\n\n```cpp\nconst int INF = 1000 * 1000 * 1000;\n\nvector<int> assignment(vector<vector<int>> a) {\n    int n = a.size();\n    int m = n * 2 + 2;\n    vector<vector<int>> f(m, vector<int>(m));\n    int s = m - 2, t = m - 1;\n    int cost = 0;\n    while (true) {\n        vector<int> dist(m, INF);\n        vector<int> p(m);\n        vector<bool> inq(m, false);\n        queue<int> q;\n        dist[s] = 0;\n        p[s] = -1;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            inq[v] = false;\n            if (v == s) {\n                for (int i = 0; i < n; ++i) {\n                    if (f[s][i] == 0) {\n                        dist[i] = 0;\n                        p[i] = s;\n                        inq[i] = true;\n                        q.push(i);\n                    }\n                }\n            } else {\n                if (v < n) {\n                    for (int j = n; j < n + n; ++j) {\n                        if (f[v][j] < 1 && dist[j] > dist[v] + a[v][j - n]) {\n                            dist[j] = dist[v] + a[v][j - n];\n                            p[j] = v;\n                            if (!inq[j]) {\n                                q.push(j);\n                                inq[j] = true;\n                            }\n                        }\n                    }\n                } else {\n                    for (int j = 0; j < n; ++j) {\n                        if (f[v][j] < 0 && dist[j] > dist[v] - a[j][v - n]) {\n                            dist[j] = dist[v] - a[j][v - n];\n                            p[j] = v;\n                            if (!inq[j]) {\n                                q.push(j);\n                                inq[j] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int curcost = INF;\n        for (int i = n; i < n + n; ++i) {\n            if (f[i][t] == 0 && dist[i] < curcost) {\n                curcost = dist[i];\n                p[t] = i;\n            }\n        }\n        if (curcost == INF)\n            break;\n        cost += curcost;\n        for (int cur = t; cur != -1; cur = p[cur]) {\n            int prev = p[cur];\n            if (prev != -1)\n                f[cur][prev] = -(f[prev][cur] = 1);\n        }\n    }\n\n    vector<int> answer(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (f[i][j + n] == 1)\n                answer[i] = j;\n        }\n    }\n    return answer;\n}\n```\n", "problem_ids": [], "title": "Solving assignment problem using min-cost-flow"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: connected_components\n---\n\n# Search for connected components in a graph\n\nGiven an undirected graph $G$ with $n$ nodes and $m$ edges. We are required to find in it all the connected components, i.e, several groups of vertices such that within a group each vertex can be reached from another and no path exists between different groups.\n\n## An algorithm for solving the problem\n\n* To solve the problem, we can use Depth First Search or Breadth First Search.\n\n* In fact, we will be doing a series of rounds of DFS: The first round will start from first node and all the nodes in the first connected component will be traversed (found). Then we find the first unvisited node of the remaining nodes, and run Depth First Search on it, thus finding a second connected component. And so on, until all the nodes are visited.\n\n* The total asymptotic running time of this algorithm is $O(n + m)$ : In fact, this algorithm will not run on the same vertex twice, which means that each edge will be seen exactly two times (at one end and at the other end).\n\n## Implementation\n\n``` cpp\nint n;\nvector<vector<int>> adj;\nvector<bool> used;\nvector<int> comp;\n\nvoid dfs(int v) {\n    used[v] = true ;\n    comp.push_back(v);\n    for (int u : adj[v]) {\n        if (!used[u])\n            dfs(u);\n    }\n}\n\nvoid find_comps() {\n    fill(used.begin(), used.end(), 0);\n    for (int v = 0; v < n; ++v) {\n        if (!used[v]) {\n            comp.clear();\n            dfs(v);\n            cout << \"Component:\" ;\n            for (int u : comp)\n                cout << ' ' << u;\n            cout << endl ;\n        }\n    }\n}\n```\n\n* The most important function that is used is `find_comps()` which finds and displays connected components of the graph.\n\n* The graph is stored in adjacency list representation, i.e `adj[v]` contains a list of vertices that have edges from the vertex `v`.\n\n* Vector `comp` contains a list of nodes in the current connected component.\n\n## Iterative implementation of the code \n\nDeeply recursive functions are in general bad.\nEvery single recursive call will require a little bit of memory in the stack, and per default programs only have a limited amount of stack space.\nSo when you do a recursive DFS over a connected graph with millions of nodes, you might run into stack overflows.\n\nIt is always possible to translate a recursive program into an iterative program, by manually maintaining a stack data structure.\nSince this data structure is allocated on the heap, no stack overflow will occur.\n\n```cpp\nint n;\nvector<vector<int>> adj;\nvector<bool> used;\nvector<int> comp;\n\nvoid dfs(int v) {\n    stack<int> st;\n    st.push(v);\n    \n    while (!st.empty()) {\n        int curr = st.top();\n        st.pop();\n        if (!used[curr]) {\n            used[curr] = true;\n            comp.push_back(curr);\n            for (int i = adj[curr].size() - 1; i >= 0; i--) {\n                st.push(adj[curr][i]);\n            }\n        }\n    }\n}\n\nvoid find_comps() {\n    fill(used.begin(), used.end(), 0);\n    for (int v = 0; v < n ; ++v) {\n        if (!used[v]) {\n            comp.clear();\n            dfs(v);\n            cout << \"Component:\" ;\n            for (int u : comp)\n                cout << ' ' << u;\n            cout << endl ;\n        }\n    }\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: connected_components\n---\n\n# Search for connected components in a graph\n\nGiven an undirected graph $G$ with $n$ nodes and $m$ edges. We are required to find in it all the connected components, i.e, several groups of vertices such that within a group each vertex can be reached from another and no path exists between different groups.\n\n## An algorithm for solving the problem\n\n* To solve the problem, we can use Depth First Search or Breadth First Search.\n\n* In fact, we will be doing a series of rounds of DFS: The first round will start from first node and all the nodes in the first connected component will be traversed (found). Then we find the first unvisited node of the remaining nodes, and run Depth First Search on it, thus finding a second connected component. And so on, until all the nodes are visited.\n\n* The total asymptotic running time of this algorithm is $O(n + m)$ : In fact, this algorithm will not run on the same vertex twice, which means that each edge will be seen exactly two times (at one end and at the other end).\n\n## Implementation\n\n``` cpp\nint n;\nvector<vector<int>> adj;\nvector<bool> used;\nvector<int> comp;\n\nvoid dfs(int v) {\n    used[v] = true ;\n    comp.push_back(v);\n    for (int u : adj[v]) {\n        if (!used[u])\n            dfs(u);\n    }\n}\n\nvoid find_comps() {\n    fill(used.begin(), used.end(), 0);\n    for (int v = 0; v < n; ++v) {\n        if (!used[v]) {\n            comp.clear();\n            dfs(v);\n            cout << \"Component:\" ;\n            for (int u : comp)\n                cout << ' ' << u;\n            cout << endl ;\n        }\n    }\n}\n```\n\n* The most important function that is used is `find_comps()` which finds and displays connected components of the graph.\n\n* The graph is stored in adjacency list representation, i.e `adj[v]` contains a list of vertices that have edges from the vertex `v`.\n\n* Vector `comp` contains a list of nodes in the current connected component.\n\n## Iterative implementation of the code \n\nDeeply recursive functions are in general bad.\nEvery single recursive call will require a little bit of memory in the stack, and per default programs only have a limited amount of stack space.\nSo when you do a recursive DFS over a connected graph with millions of nodes, you might run into stack overflows.\n\nIt is always possible to translate a recursive program into an iterative program, by manually maintaining a stack data structure.\nSince this data structure is allocated on the heap, no stack overflow will occur.\n\n```cpp\nint n;\nvector<vector<int>> adj;\nvector<bool> used;\nvector<int> comp;\n\nvoid dfs(int v) {\n    stack<int> st;\n    st.push(v);\n    \n    while (!st.empty()) {\n        int curr = st.top();\n        st.pop();\n        if (!used[curr]) {\n            used[curr] = true;\n            comp.push_back(curr);\n            for (int i = adj[curr].size() - 1; i >= 0; i--) {\n                st.push(adj[curr][i]);\n            }\n        }\n    }\n}\n\nvoid find_comps() {\n    fill(used.begin(), used.end(), 0);\n    for (int v = 0; v < n ; ++v) {\n        if (!used[v]) {\n            comp.clear();\n            dfs(v);\n            cout << \"Component:\" ;\n            for (int u : comp)\n                cout << ' ' << u;\n            cout << endl ;\n        }\n    }\n}\n```\n\n## Practice Problems\n - [SPOJ: CCOMPS](http://www.spoj.com/problems/CCOMPS/)\n - [SPOJ: CT23E](http://www.spoj.com/problems/CT23E/)\n - [CODECHEF: GERALD07](https://www.codechef.com/MARCH14/problems/GERALD07)\n - [CSES : Building Roads](https://cses.fi/problemset/task/1666)\n", "problem_ids": [], "title": "Search for connected components in a graph"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: rmq_linear\n---\n\n# Solve RMQ (Range Minimum Query) by finding LCA (Lowest Common Ancestor)\n\nGiven an array `A[0..N-1]`.\nFor each query of the form `[L, R]` we want to find the minimum in the array `A` starting from position `L` and ending with position `R`.\nWe will assume that the array `A` doesn't change in the process, i.e. this article describes a solution to the static RMQ problem\n\nHere is a description of an asymptotically optimal solution.\nIt stands apart from other solutions for the RMQ problem, since it is very different from them:\nit reduces the RMQ problem to the LCA problem, and then uses the [Farach-Colton and Bender algorithm](lca_farachcoltonbender.md), which reduces the LCA problem back to a specialized RMQ problem and solves that.\n\n## Algorithm\n\nWe construct a **Cartesian tree** from the array `A`.\nA Cartesian tree of an array `A` is a binary tree with the min-heap property (the value of parent node has to be smaller or equal than the value of its children) such that the in-order traversal of the tree visits the nodes in the same order as they are in the array `A`.\n\nIn other words, a Cartesian tree is a recursive data structure.\nThe array `A` will be partitioned into 3 parts: the prefix of the array up to the minimum, the minimum, and the remaining suffix.\nThe root of the tree will be a node corresponding to the minimum element of the array `A`, the left subtree will be the Cartesian tree of the prefix, and the right subtree will be a Cartesian tree of the suffix.\n\nIn the following image you can see one array of length 10 and the corresponding Cartesian tree.\n<center>![Image of Cartesian Tree](CartesianTree.png)</center>\n\nThe range minimum query `[l, r]` is equivalent to the lowest common ancestor query `[l', r']`, where `l'` is the node corresponding to the element `A[l]` and `r'` the node corresponding to the element `A[r]`.\nIndeed the node corresponding to the smallest element in the range has to be an ancestor of all nodes in the range, therefor also from `l'` and `r'`.\nThis automatically follows from the min-heap property.\nAnd is also has to be the lowest ancestor, because otherwise `l'` and `r'` would be both in the left or in the right subtree, which generates a contradiction since in such a case the minimum wouldn't even be in the range.\n\nIn the following image you can see the LCA queries for the RMQ queries `[1, 3]` and `[5, 9]`.\nIn the first query the LCA of the nodes `A[1]` and `A[3]` is the node corresponding to `A[2]` which has the value 2, and in the second query the LCA of `A[5]` and `A[9]` is the node corresponding to `A[8]` which has the value 3.\n<center>![LCA queries in the Cartesian Tree](CartesianTreeLCA.png)</center>\n\nSuch a tree can be built in $O(N)$ time and the Farach-Colton and Benders algorithm can preprocess the tree in $O(N)$ and find the LCA in $O(1)$.\n\n## Construction of a Cartesian tree\n\nWe will build the Cartesian tree by adding the elements one after another.\nIn each step we maintain a valid Cartesian tree of all the processed elements.\nIt is easy to see, that adding an element `s[i]` can only change the nodes in the most right path - starting at the root and repeatedly taking the right child - of the tree.\nThe subtree of the node with the smallest, but greater or equal than `s[i]`, value becomes the left subtree of `s[i]`, and the tree with root `s[i]` will become the new right subtree of the node with the biggest, but smaller than `s[i]` value.\n\nThis can be implemented by using a stack to store the indices of the most right nodes.\n\n```cpp\nvector<int> parent(n, -1);\nstack<int> s;\nfor (int i = 0; i < n; i++) {\n    int last = -1;\n    while (!s.empty() && A[s.top()] >= A[i]) {\n        last = s.top();\n        s.pop();\n    }\n    if (!s.empty())\n        parent[i] = s.top();\n    if (last >= 0)\n        parent[last] = i;\n    s.push(i);\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: rmq_linear\n---\n\n# Solve RMQ (Range Minimum Query) by finding LCA (Lowest Common Ancestor)\n\nGiven an array `A[0..N-1]`.\nFor each query of the form `[L, R]` we want to find the minimum in the array `A` starting from position `L` and ending with position `R`.\nWe will assume that the array `A` doesn't change in the process, i.e. this article describes a solution to the static RMQ problem\n\nHere is a description of an asymptotically optimal solution.\nIt stands apart from other solutions for the RMQ problem, since it is very different from them:\nit reduces the RMQ problem to the LCA problem, and then uses the [Farach-Colton and Bender algorithm](lca_farachcoltonbender.md), which reduces the LCA problem back to a specialized RMQ problem and solves that.\n\n## Algorithm\n\nWe construct a **Cartesian tree** from the array `A`.\nA Cartesian tree of an array `A` is a binary tree with the min-heap property (the value of parent node has to be smaller or equal than the value of its children) such that the in-order traversal of the tree visits the nodes in the same order as they are in the array `A`.\n\nIn other words, a Cartesian tree is a recursive data structure.\nThe array `A` will be partitioned into 3 parts: the prefix of the array up to the minimum, the minimum, and the remaining suffix.\nThe root of the tree will be a node corresponding to the minimum element of the array `A`, the left subtree will be the Cartesian tree of the prefix, and the right subtree will be a Cartesian tree of the suffix.\n\nIn the following image you can see one array of length 10 and the corresponding Cartesian tree.\n<center>![Image of Cartesian Tree](CartesianTree.png)</center>\n\nThe range minimum query `[l, r]` is equivalent to the lowest common ancestor query `[l', r']`, where `l'` is the node corresponding to the element `A[l]` and `r'` the node corresponding to the element `A[r]`.\nIndeed the node corresponding to the smallest element in the range has to be an ancestor of all nodes in the range, therefor also from `l'` and `r'`.\nThis automatically follows from the min-heap property.\nAnd is also has to be the lowest ancestor, because otherwise `l'` and `r'` would be both in the left or in the right subtree, which generates a contradiction since in such a case the minimum wouldn't even be in the range.\n\nIn the following image you can see the LCA queries for the RMQ queries `[1, 3]` and `[5, 9]`.\nIn the first query the LCA of the nodes `A[1]` and `A[3]` is the node corresponding to `A[2]` which has the value 2, and in the second query the LCA of `A[5]` and `A[9]` is the node corresponding to `A[8]` which has the value 3.\n<center>![LCA queries in the Cartesian Tree](CartesianTreeLCA.png)</center>\n\nSuch a tree can be built in $O(N)$ time and the Farach-Colton and Benders algorithm can preprocess the tree in $O(N)$ and find the LCA in $O(1)$.\n\n## Construction of a Cartesian tree\n\nWe will build the Cartesian tree by adding the elements one after another.\nIn each step we maintain a valid Cartesian tree of all the processed elements.\nIt is easy to see, that adding an element `s[i]` can only change the nodes in the most right path - starting at the root and repeatedly taking the right child - of the tree.\nThe subtree of the node with the smallest, but greater or equal than `s[i]`, value becomes the left subtree of `s[i]`, and the tree with root `s[i]` will become the new right subtree of the node with the biggest, but smaller than `s[i]` value.\n\nThis can be implemented by using a stack to store the indices of the most right nodes.\n\n```cpp\nvector<int> parent(n, -1);\nstack<int> s;\nfor (int i = 0; i < n; i++) {\n    int last = -1;\n    while (!s.empty() && A[s.top()] >= A[i]) {\n        last = s.top();\n        s.pop();\n    }\n    if (!s.empty())\n        parent[i] = s.top();\n    if (last >= 0)\n        parent[last] = i;\n    s.push(i);\n}\n```\n", "problem_ids": [], "title": "Solve RMQ (Range Minimum Query) by finding LCA (Lowest Common Ancestor)"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: lca_linear_offline\n---\n\n# Lowest Common Ancestor - Tarjan's off-line algorithm\n\nWe have a tree $G$ with $n$ nodes and we have $m$ queries of the form $(u, v)$.\nFor each query $(u, v)$ we want to find the lowest common ancestor of the vertices $u$ and $v$, i.e. the node that is an ancestor of both $u$ and $v$ and has the greatest depth in the tree.\nThe node $v$ is also an ancestor of $v$, so the LCA can also be one of the two nodes.\n\nIn this article we will solve the problem off-line, i.e. we assume that all queries are known in advance, and we therefore answer the queries in any order we like.\nThe following algorithm allows to answer all $m$ queries in $O(n + m)$ total time, i.e. for sufficiently large $m$ in $O(1)$ for each query.\n\n## Algorithm\n\nThe algorithm is named after Robert Tarjan, who discovered it in 1979 and also made many other contributions to the [Disjoint Set Union](../data_structures/disjoint_set_union.md) data structure, which will be heavily used in this algorithm.\n\nThe algorithm answers all queries with one [DFS](depth-first-search.md) traversal of the tree.\nNamely a query $(u, v)$ is answered at node $u$, if node $v$ has already been visited previously, or vice versa.\n\nSo let's assume we are currently at node $v$, we have already made recursive DFS calls, and also already visited the second node $u$ from the query $(u, v)$.\nLet's learn how to find the LCA of these two nodes.\n\nNote that $\\text{LCA}(u, v)$ is either the node $v$ or one of its ancestors.\nSo we need to find the lowest node among the ancestors of $v$ (including $v$), for which the node $u$ is a descendant. \nAlso note that for a fixed $v$ the visited nodes of the tree split into a set of disjoint sets. \nEach ancestor $p$ of node $v$ has his own set containing this node and all subtrees with roots in those of its children who are not part of the path from $v$ to the root of the tree.\nThe set which contains the node $u$ determines the $\\text{LCA}(u, v)$:\nthe LCA is the representative of the set, namely the node on lies on the path between $v$ and the root of the tree.\n\nWe only need to learn to efficiently maintain all these sets.\nFor this purpose we apply the data structure DSU.\nTo be able to apply Union by rank, we store the real representative (the value on the path between $v$ and the root of the tree) of each set in the array `ancestor`.\n\nLet's discuss the implementation of the DFS.\nLet's assume we are currently visiting the node $v$.\nWe place the node in a new set in the DSU, `ancestor[v] = v`.\nAs usual we process all children of $v$.\nFor this we must first recursively call DFS from that node, and then add this node with all its subtree to the set of $v$.\nThis can be done with the function `union_sets` and the following assignment `ancestor[find_set(v)] = v` (this is necessary, because `union_sets` might change the representative of the set).\n\nFinally after processing all children we can answer all queries of the form $(u, v)$ for which $u$ has been already visited.\nThe answer to the query, i.e. the LCA of $u$ and $v$, will be the node `ancestor[find_set(u)]`.\nIt is easy to see that a query will only be answered once.\n\nLet's us determine the time complexity of this algorithm. \nFirstly we have $O(n)$ because of the DFS.\nSecondly  we have the function calls of `union_sets` which happen $n$ times, resulting also in $O(n)$.\nAnd thirdly we have the calls of `find_set` for every query, which gives $O(m)$.\nSo in total the time complexity is $O(n + m)$, which means that for sufficiently large $m$ this corresponds to $O(1)$ for answering one query.\n\n## Implementation\n\nHere is an implementation of this algorithm.\nThe implementation of DSU has been not included, as it can be used without any modifications.\n\n```cpp\nvector<vector<int>> adj;\nvector<vector<int>> queries;\nvector<int> ancestor;\nvector<bool> visited;\n\nvoid dfs(int v)\n{\n    visited[v] = true;\n    ancestor[v] = v;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs(u);\n            union_sets(v, u);\n            ancestor[find_set(v)] = v;\n        }\n    }\n    for (int other_node : queries[v]) {\n        if (visited[other_node])\n            cout << \"LCA of \" << v << \" and \" << other_node\n                 << \" is \" << ancestor[find_set(other_node)] << \".\\n\";\n    }\n}\n\nvoid compute_LCAs() {\n    // initialize n, adj and DSU\n    // for (each query (u, v)) {\n    //    queries[u].push_back(v);\n    //    queries[v].push_back(u);\n    // }\n\n    ancestor.resize(n);\n    visited.assign(n, false);\n    dfs(0);\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: lca_linear_offline\n---\n\n# Lowest Common Ancestor - Tarjan's off-line algorithm\n\nWe have a tree $G$ with $n$ nodes and we have $m$ queries of the form $(u, v)$.\nFor each query $(u, v)$ we want to find the lowest common ancestor of the vertices $u$ and $v$, i.e. the node that is an ancestor of both $u$ and $v$ and has the greatest depth in the tree.\nThe node $v$ is also an ancestor of $v$, so the LCA can also be one of the two nodes.\n\nIn this article we will solve the problem off-line, i.e. we assume that all queries are known in advance, and we therefore answer the queries in any order we like.\nThe following algorithm allows to answer all $m$ queries in $O(n + m)$ total time, i.e. for sufficiently large $m$ in $O(1)$ for each query.\n\n## Algorithm\n\nThe algorithm is named after Robert Tarjan, who discovered it in 1979 and also made many other contributions to the [Disjoint Set Union](../data_structures/disjoint_set_union.md) data structure, which will be heavily used in this algorithm.\n\nThe algorithm answers all queries with one [DFS](depth-first-search.md) traversal of the tree.\nNamely a query $(u, v)$ is answered at node $u$, if node $v$ has already been visited previously, or vice versa.\n\nSo let's assume we are currently at node $v$, we have already made recursive DFS calls, and also already visited the second node $u$ from the query $(u, v)$.\nLet's learn how to find the LCA of these two nodes.\n\nNote that $\\text{LCA}(u, v)$ is either the node $v$ or one of its ancestors.\nSo we need to find the lowest node among the ancestors of $v$ (including $v$), for which the node $u$ is a descendant. \nAlso note that for a fixed $v$ the visited nodes of the tree split into a set of disjoint sets. \nEach ancestor $p$ of node $v$ has his own set containing this node and all subtrees with roots in those of its children who are not part of the path from $v$ to the root of the tree.\nThe set which contains the node $u$ determines the $\\text{LCA}(u, v)$:\nthe LCA is the representative of the set, namely the node on lies on the path between $v$ and the root of the tree.\n\nWe only need to learn to efficiently maintain all these sets.\nFor this purpose we apply the data structure DSU.\nTo be able to apply Union by rank, we store the real representative (the value on the path between $v$ and the root of the tree) of each set in the array `ancestor`.\n\nLet's discuss the implementation of the DFS.\nLet's assume we are currently visiting the node $v$.\nWe place the node in a new set in the DSU, `ancestor[v] = v`.\nAs usual we process all children of $v$.\nFor this we must first recursively call DFS from that node, and then add this node with all its subtree to the set of $v$.\nThis can be done with the function `union_sets` and the following assignment `ancestor[find_set(v)] = v` (this is necessary, because `union_sets` might change the representative of the set).\n\nFinally after processing all children we can answer all queries of the form $(u, v)$ for which $u$ has been already visited.\nThe answer to the query, i.e. the LCA of $u$ and $v$, will be the node `ancestor[find_set(u)]`.\nIt is easy to see that a query will only be answered once.\n\nLet's us determine the time complexity of this algorithm. \nFirstly we have $O(n)$ because of the DFS.\nSecondly  we have the function calls of `union_sets` which happen $n$ times, resulting also in $O(n)$.\nAnd thirdly we have the calls of `find_set` for every query, which gives $O(m)$.\nSo in total the time complexity is $O(n + m)$, which means that for sufficiently large $m$ this corresponds to $O(1)$ for answering one query.\n\n## Implementation\n\nHere is an implementation of this algorithm.\nThe implementation of DSU has been not included, as it can be used without any modifications.\n\n```cpp\nvector<vector<int>> adj;\nvector<vector<int>> queries;\nvector<int> ancestor;\nvector<bool> visited;\n\nvoid dfs(int v)\n{\n    visited[v] = true;\n    ancestor[v] = v;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs(u);\n            union_sets(v, u);\n            ancestor[find_set(v)] = v;\n        }\n    }\n    for (int other_node : queries[v]) {\n        if (visited[other_node])\n            cout << \"LCA of \" << v << \" and \" << other_node\n                 << \" is \" << ancestor[find_set(other_node)] << \".\\n\";\n    }\n}\n\nvoid compute_LCAs() {\n    // initialize n, adj and DSU\n    // for (each query (u, v)) {\n    //    queries[u].push_back(v);\n    //    queries[v].push_back(u);\n    // }\n\n    ancestor.resize(n);\n    visited.assign(n, false);\n    dfs(0);\n}\n```\n", "problem_ids": [], "title": "Lowest Common Ancestor - Tarjan's off-line algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: dijkstra_sparse\n---\n\n# Dijkstra on sparse graphs\n\nFor the statement of the problem, the algorithm with implementation and proof can be found on the article [Dijkstra's algorithm](dijkstra.md).\n\n## Algorithm\n\nWe recall in the derivation of the complexity of Dijkstra's algorithm we used two factors:\nthe time of finding the unmarked vertex with the smallest distance $d[v]$, and the time of the relaxation, i.e. the time of changing the values $d[\\text{to}]$.\n\nIn the simplest implementation these operations require $O(n)$ and $O(1)$ time.\nTherefore, since we perform the first operation $O(n)$ times, and the second one $O(m)$ times, we obtained the complexity $O(n^2 + m)$.\n\nIt is clear, that this complexity is optimal for a dense graph, i.e. when $m \\approx n^2$.\nHowever in sparse graphs, when $m$ is much smaller than the maximal number of edges $n^2$, the complexity gets less optimal because of the first term.\nThus it is necessary to improve the execution time of the first operation (and of course without greatly affecting the second operation by much).\n\nTo accomplish that we can use a variation of multiple auxiliary data structures.\nThe most efficient is the **Fibonacci heap**, which allows the first operation to run in $O(\\log n)$, and the second operation in $O(1)$.\nTherefore we will get the complexity $O(n \\log n + m)$ for Dijkstra's algorithm, which is also the theoretical minimum for the shortest path search problem.\nTherefore this algorithm works optimal, and Fibonacci heaps are the optimal data structure.\nThere doesn't exist any data structure, that can perform both operations in $O(1)$, because this would also allow to sort a list of random numbers in linear time, which is impossible.\nInterestingly there exists an algorithm by Thorup that finds the shortest path in $O(m)$ time, however only works for integer weights, and uses a completely different idea.\nSo this doesn't lead to any contradictions.\nFibonacci heaps provide the optimal complexity for this task.\nHowever they are quite complex to implement, and also have a quite large hidden constant.\n\nAs a compromise you can use data structures, that perform both types of operations (extracting a minimum and updating an item) in $O(\\log n)$.\nThen the complexity of Dijkstra's algorithm is $O(n \\log n + m \\log n) = O(m \\log n)$.\n\nC++ provides two such data structures: `set` and `priority_queue`.\nThe first is based on red-black trees, and the second one on heaps.\nTherefore `priority_queue` has a smaller hidden constant, but also has a drawback:\nit doesn't support the operation of removing an element.\nBecause of this we need to do a \"workaround\", that actually leads to a slightly worse factor $\\log m$ instead of $\\log n$ (although in terms of complexity they are identical).\n\n## Implementation\n\n### set\n\nLet us start with the container `set`.\nSince we need to store vertices ordered by their values $d[]$, it is convenient to store actual pairs: the distance and the index of the vertex.\nAs a result in a `set` pairs are automatically sorted by their distances.\n\n```{.cpp file=dijkstra_sparse_set}\nconst int INF = 1000000000;\nvector<vector<pair<int, int>>> adj;\n\nvoid dijkstra(int s, vector<int> & d, vector<int> & p) {\n    int n = adj.size();\n    d.assign(n, INF);\n    p.assign(n, -1);\n\n    d[s] = 0;\n    set<pair<int, int>> q;\n    q.insert({0, s});\n    while (!q.empty()) {\n        int v = q.begin()->second;\n        q.erase(q.begin());\n\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n            \n            if (d[v] + len < d[to]) {\n                q.erase({d[to], to});\n                d[to] = d[v] + len;\n                p[to] = v;\n                q.insert({d[to], to});\n            }\n        }\n    }\n}\n```\n\nWe don't need the array $u[]$ from the normal Dijkstra's algorithm implementation any more.\nWe will use the `set` to store that information, and also find the vertex with the shortest distance with it.\nIt kinda acts like a queue.\nThe main loops executes until there are no more vertices in the set/queue.\nA vertex with the smallest distance gets extracted, and for each successful relaxation we first remove the old pair, and then after the relaxation add the new pair into the queue.\n\n### priority_queue\n\nThe main difference to the implementation with `set` is that in many languages, including C++, we cannot remove elements from the `priority_queue` (although heaps can support that operation in theory).\nTherefore we have to use a workaround:\nWe simply don't delete the old pair from the queue.\nAs a result a vertex can appear multiple times with different distance in the queue at the same time.\nAmong these pairs we are only interested in the pairs where the first element is equal to the corresponding value in $d[]$, all the other pairs are old.\nTherefore we need to make a small modification:\nat the beginning of each iteration, after extracting the next pair, we check if it is an important pair or if it is already an old and handled pair.\nThis check is important, otherwise the complexity can increase up to $O(n m)$.\n\nBy default a `priority_queue` sorts elements in descending order.\nTo make it sort the elements in ascending order, we can either store the negated distances in it, or pass it a different sorting function.\nWe will do the second option.\n\n```{.cpp file=dijkstra_sparse_pq}\nconst int INF = 1000000000;\nvector<vector<pair<int, int>>> adj;\n\nvoid dijkstra(int s, vector<int> & d, vector<int> & p) {\n    int n = adj.size();\n    d.assign(n, INF);\n    p.assign(n, -1);\n\n    d[s] = 0;\n    using pii = pair<int, int>;\n    priority_queue<pii, vector<pii>, greater<pii>> q;\n    q.push({0, s});\n    while (!q.empty()) {\n        int v = q.top().second;\n        int d_v = q.top().first;\n        q.pop();\n        if (d_v != d[v])\n            continue;\n\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n            \n            if (d[v] + len < d[to]) {\n                d[to] = d[v] + len;\n                p[to] = v;\n                q.push({d[to], to});\n            }\n        }\n    }\n}\n```\n\nIn practice the `priority_queue` version is a little bit faster than the version with `set`.\n\nInterestingly, a [2007 technical report](https://www3.cs.stonybrook.edu/~rezaul/papers/TR-07-54.pdf) concluded the variant of the algorithm not using decrease-key operations ran faster than the decrease-key variant, with a greater performance gap for sparse graphs.\n\n### Getting rid of pairs\n\nYou can improve the performance a little bit more if you don't store pairs in the containers, but only the vertex indices.\nIn this case we must overload the comparison operator:\nit must compare two vertices using the distances stored in $d[]$.\n\nAs a result of the relaxation, the distance of some vertices will change.\nHowever the data structure will not resort itself automatically.\nIn fact changing distances of vertices in the queue, might destroy the data structure.\nAs before, we need to remove the vertex before we relax it, and then insert it again afterwards.\n\nSince we only can remove from `set`, this optimization is only applicable for the `set` method, and doesn't work with `priority_queue` implementation.\nIn practice this significantly increases the performance, especially when larger data types are used to store distances, like `long long` or `double`.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: dijkstra_sparse\n---\n\n# Dijkstra on sparse graphs\n\nFor the statement of the problem, the algorithm with implementation and proof can be found on the article [Dijkstra's algorithm](dijkstra.md).\n\n## Algorithm\n\nWe recall in the derivation of the complexity of Dijkstra's algorithm we used two factors:\nthe time of finding the unmarked vertex with the smallest distance $d[v]$, and the time of the relaxation, i.e. the time of changing the values $d[\\text{to}]$.\n\nIn the simplest implementation these operations require $O(n)$ and $O(1)$ time.\nTherefore, since we perform the first operation $O(n)$ times, and the second one $O(m)$ times, we obtained the complexity $O(n^2 + m)$.\n\nIt is clear, that this complexity is optimal for a dense graph, i.e. when $m \\approx n^2$.\nHowever in sparse graphs, when $m$ is much smaller than the maximal number of edges $n^2$, the complexity gets less optimal because of the first term.\nThus it is necessary to improve the execution time of the first operation (and of course without greatly affecting the second operation by much).\n\nTo accomplish that we can use a variation of multiple auxiliary data structures.\nThe most efficient is the **Fibonacci heap**, which allows the first operation to run in $O(\\log n)$, and the second operation in $O(1)$.\nTherefore we will get the complexity $O(n \\log n + m)$ for Dijkstra's algorithm, which is also the theoretical minimum for the shortest path search problem.\nTherefore this algorithm works optimal, and Fibonacci heaps are the optimal data structure.\nThere doesn't exist any data structure, that can perform both operations in $O(1)$, because this would also allow to sort a list of random numbers in linear time, which is impossible.\nInterestingly there exists an algorithm by Thorup that finds the shortest path in $O(m)$ time, however only works for integer weights, and uses a completely different idea.\nSo this doesn't lead to any contradictions.\nFibonacci heaps provide the optimal complexity for this task.\nHowever they are quite complex to implement, and also have a quite large hidden constant.\n\nAs a compromise you can use data structures, that perform both types of operations (extracting a minimum and updating an item) in $O(\\log n)$.\nThen the complexity of Dijkstra's algorithm is $O(n \\log n + m \\log n) = O(m \\log n)$.\n\nC++ provides two such data structures: `set` and `priority_queue`.\nThe first is based on red-black trees, and the second one on heaps.\nTherefore `priority_queue` has a smaller hidden constant, but also has a drawback:\nit doesn't support the operation of removing an element.\nBecause of this we need to do a \"workaround\", that actually leads to a slightly worse factor $\\log m$ instead of $\\log n$ (although in terms of complexity they are identical).\n\n## Implementation\n\n### set\n\nLet us start with the container `set`.\nSince we need to store vertices ordered by their values $d[]$, it is convenient to store actual pairs: the distance and the index of the vertex.\nAs a result in a `set` pairs are automatically sorted by their distances.\n\n```{.cpp file=dijkstra_sparse_set}\nconst int INF = 1000000000;\nvector<vector<pair<int, int>>> adj;\n\nvoid dijkstra(int s, vector<int> & d, vector<int> & p) {\n    int n = adj.size();\n    d.assign(n, INF);\n    p.assign(n, -1);\n\n    d[s] = 0;\n    set<pair<int, int>> q;\n    q.insert({0, s});\n    while (!q.empty()) {\n        int v = q.begin()->second;\n        q.erase(q.begin());\n\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n            \n            if (d[v] + len < d[to]) {\n                q.erase({d[to], to});\n                d[to] = d[v] + len;\n                p[to] = v;\n                q.insert({d[to], to});\n            }\n        }\n    }\n}\n```\n\nWe don't need the array $u[]$ from the normal Dijkstra's algorithm implementation any more.\nWe will use the `set` to store that information, and also find the vertex with the shortest distance with it.\nIt kinda acts like a queue.\nThe main loops executes until there are no more vertices in the set/queue.\nA vertex with the smallest distance gets extracted, and for each successful relaxation we first remove the old pair, and then after the relaxation add the new pair into the queue.\n\n### priority_queue\n\nThe main difference to the implementation with `set` is that in many languages, including C++, we cannot remove elements from the `priority_queue` (although heaps can support that operation in theory).\nTherefore we have to use a workaround:\nWe simply don't delete the old pair from the queue.\nAs a result a vertex can appear multiple times with different distance in the queue at the same time.\nAmong these pairs we are only interested in the pairs where the first element is equal to the corresponding value in $d[]$, all the other pairs are old.\nTherefore we need to make a small modification:\nat the beginning of each iteration, after extracting the next pair, we check if it is an important pair or if it is already an old and handled pair.\nThis check is important, otherwise the complexity can increase up to $O(n m)$.\n\nBy default a `priority_queue` sorts elements in descending order.\nTo make it sort the elements in ascending order, we can either store the negated distances in it, or pass it a different sorting function.\nWe will do the second option.\n\n```{.cpp file=dijkstra_sparse_pq}\nconst int INF = 1000000000;\nvector<vector<pair<int, int>>> adj;\n\nvoid dijkstra(int s, vector<int> & d, vector<int> & p) {\n    int n = adj.size();\n    d.assign(n, INF);\n    p.assign(n, -1);\n\n    d[s] = 0;\n    using pii = pair<int, int>;\n    priority_queue<pii, vector<pii>, greater<pii>> q;\n    q.push({0, s});\n    while (!q.empty()) {\n        int v = q.top().second;\n        int d_v = q.top().first;\n        q.pop();\n        if (d_v != d[v])\n            continue;\n\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n            \n            if (d[v] + len < d[to]) {\n                d[to] = d[v] + len;\n                p[to] = v;\n                q.push({d[to], to});\n            }\n        }\n    }\n}\n```\n\nIn practice the `priority_queue` version is a little bit faster than the version with `set`.\n\nInterestingly, a [2007 technical report](https://www3.cs.stonybrook.edu/~rezaul/papers/TR-07-54.pdf) concluded the variant of the algorithm not using decrease-key operations ran faster than the decrease-key variant, with a greater performance gap for sparse graphs.\n\n### Getting rid of pairs\n\nYou can improve the performance a little bit more if you don't store pairs in the containers, but only the vertex indices.\nIn this case we must overload the comparison operator:\nit must compare two vertices using the distances stored in $d[]$.\n\nAs a result of the relaxation, the distance of some vertices will change.\nHowever the data structure will not resort itself automatically.\nIn fact changing distances of vertices in the queue, might destroy the data structure.\nAs before, we need to remove the vertex before we relax it, and then insert it again afterwards.\n\nSince we only can remove from `set`, this optimization is only applicable for the `set` method, and doesn't work with `priority_queue` implementation.\nIn practice this significantly increases the performance, especially when larger data types are used to store distances, like `long long` or `double`.\n", "problem_ids": [], "title": "Dijkstra on sparse graphs"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: edmonds_karp\n---\n\n# Maximum flow - Ford-Fulkerson and Edmonds-Karp\n\nThe Edmonds-Karp algorithm is an implementation of the Ford-Fulkerson method for computing a maximal flow in a flow network.\n\n## Flow network\n\nFirst let's define what a **flow network**, a **flow**, and a **maximum flow** is.\n\nA **network** is a directed graph $G$ with vertices $V$ and edges $E$ combined with a function $c$, which assigns each edge $e \\in E$ a non-negative integer value, the **capacity** of $e$.\nSuch a network is called a **flow network**, if we additionally label two vertices, one as **source** and one as **sink**.\n\nA **flow** in a flow network is function $f$, that again assigns each edge $e$ a non-negative integer value, namely the flow.\nThe function has to fulfill the following two conditions:\n\nThe flow of an edge cannot exceed the capacity.\n\n$$f(e) \\le c(e)$$\n\nAnd the sum of the incoming flow of a vertex $u$ has to be equal to the sum of the outgoing flow of $u$ except in the source and sink vertices.\n\n$$\\sum_{(v, u) \\in E} f((v, u)) = \\sum_{(u, v) \\in E} f((u, v))$$\n\nThe source vertex $s$ only has an outgoing flow, and the sink vertex $t$ has only incoming flow.\n\nIt is easy to see that the following equation holds:\n\n$$\\sum_{(s, u) \\in E} f((s, u)) = \\sum_{(u, t) \\in E} f((u, t))$$\n\nA good analogy for a flow network is the following visualization:\nWe represent edges as water pipes, the capacity of an edge is the maximal amount of water that can flow through the pipe per second, and the flow of an edge is the amount of water that currently flows through the pipe per second.\nThis motivates the first flow condition. There cannot flow more water through a pipe than its capacity.\nThe vertices act as junctions, where water comes out of some pipes, and then, these vertices distribute the water in some way to other pipes.\nThis also motivates the second flow condition.\nAll the incoming water has to be distributed to the other pipes in each junction.\nIt cannot magically disappear or appear.\nThe source $s$ is origin of all the water, and the water can only drain in the sink $t$.\n\nThe following image shows a flow network.\nThe first value of each edge represents the flow, which is initially 0, and the second value represents the capacity.\n<center>![Flow network](Flow1.png)</center>\n\nThe value of the flow of a network is the sum of all the flows that get produced in the source $s$, or equivalently to the sum of all the flows that are consumed by the sink $t$.\nA **maximal flow** is a flow with the maximal possible value.\nFinding this maximal flow of a flow network is the problem that we want to solve.\n\nIn the visualization with water pipes, the problem can be formulated in the following way:\nhow much water can we push through the pipes from the source to the sink?\n\nThe following image shows the maximal flow in the flow network.\n<center>![Maximal flow](Flow9.png)</center>\n\n## Ford-Fulkerson method\n\nLet's define one more thing.\nA **residual capacity** of a directed edge is the capacity minus the flow.\nIt should be noted that if there is a flow along some directed edge $(u, v)$, then the reversed edge has capacity 0 and we can define the flow of it as $f((v, u)) = -f((u, v))$.\nThis also defines the residual capacity for all the reversed edges.\nWe can create a **residual network** from all these edges, which is just a network with the same vertices and edges, but we use the residual capacities as capacities.\n\nThe Ford-Fulkerson method works as follows.\nFirst, we set the flow of each edge to zero.\nThen we look for an **augmenting path** from $s$ to $t$.\nAn augmenting path is a simple path in the residual graph, i.e. along the edges whose residual capacity is positive.\nIf such a path is found, then we can increase the flow along these edges.\nWe keep on searching for augmenting paths and increasing the flow.\nOnce an augmenting path doesn't exist anymore, the flow is maximal.\n\nLet us specify in more detail, what increasing the flow along an augmenting path means.\nLet $C$ be the smallest residual capacity of the edges in the path.\nThen we increase the flow in the following way:\nwe update $f((u, v)) ~\\text{+=}~ C$ and $f((v, u)) ~\\text{-=}~ C$ for every edge $(u, v)$ in the path.\n\nHere is an example to demonstrate the method.\nWe use the same flow network as above.\nInitially we start with a flow of 0.\n<center>![Flow network](Flow1.png)</center>\n\nWe can find the path $s - A - B - t$ with the residual capacities 7, 5, and 8.\nTheir minimum is 5, therefore we can increase the flow along this path by 5.\nThis gives a flow of 5 for the network.\n<center>![First path](Flow2.png) ![Network after first path](Flow3.png)</center>\n\nAgain we look for an augmenting path, this time we find $s - D - A - C - t$ with the residual capacities 4, 3, 3, and 5.\nTherefore we can increase the flow by 3 and we get a flow of 8 for the network.\n<center>![Second path](Flow4.png) ![Network after second path](Flow5.png)</center>\n\nThis time we find the path $s - D - C - B - t$ with the residual capacities 1, 2, 3, and 3, and hence, we increase the flow by 1.\n<center>![Third path](Flow6.png) ![Network after third path](Flow7.png)</center>\n\nThis time we find the augmenting path $s - A - D - C - t$ with the residual capacities 2, 3, 1, and 2.\nWe can increase the flow by 1.\nBut this path is very interesting.\nIt includes the reversed edge $(A, D)$.\nIn the original flow network, we are not allowed to send any flow from $A$ to $D$.\nBut because we already have a flow of 3 from $D$ to $A$, this is possible.\nThe intuition of it is the following:\nInstead of sending a flow of 3 from $D$ to $A$, we only send 2 and compensate this by sending an additional flow of 1 from $s$ to $A$, which allows us to send an additional flow of 1 along the path $D - C - t$.\n<center>![Fourth path](Flow8.png) ![Network after fourth path](Flow9.png)</center>\n\nNow, it is impossible to find an augmenting path between $s$ and $t$, therefore this flow of $10$ is the maximal possible.\nWe have found the maximal flow.\n\nIt should be noted, that the Ford-Fulkerson method doesn't specify a method of finding the augmenting path.\nPossible approaches are using [DFS](depth-first-search.md) or [BFS](breadth-first-search.md) which both work in $O(E)$.\nIf all the capacities of the network are integers, then for each augmenting path the flow of the network increases by at least 1 (for more details see [Integral flow theorem](#integral-theorem)).\nTherefore, the complexity of Ford-Fulkerson is $O(E F)$, where $F$ is the maximal flow of the network.\nIn the case of rational capacities, the algorithm will also terminate, but the complexity is not bounded.\nIn the case of irrational capacities, the algorithm might never terminate, and might not even converge to the maximal flow.\n\n## Edmonds-Karp algorithm\n\nEdmonds-Karp algorithm is just an implementation of the Ford-Fulkerson method that uses [BFS](breadth-first-search.md) for finding augmenting paths.\nThe algorithm was first published by Yefim Dinitz in 1970, and later independently published by Jack Edmonds and Richard Karp in 1972.\n\nThe complexity can be given independently of the maximal flow.\nThe algorithm runs in $O(V E^2)$ time, even for irrational capacities.\nThe intuition is, that every time we find an augmenting path one of the edges becomes saturated, and the distance from the edge to $s$ will be longer if it appears later again in an augmenting path.\nThe length of the simple paths is bounded by $V$.\n\n### Implementation\n\nThe matrix `capacity` stores the capacity for every pair of vertices.\n`adj` is the adjacency list of the **undirected graph**, since we have also to use the reversed of directed edges when we are looking for augmenting paths.\n\nThe function `maxflow` will return the value of the maximal flow.\nDuring the algorithm, the matrix `capacity` will actually store the residual capacity of the network.\nThe value of the flow in each edge will actually not be stored, but it is easy to extend the implementation - by using an additional matrix - to also store the flow and return it.\n\n```{.cpp file=edmondskarp}\nint n;\nvector<vector<int>> capacity;\nvector<vector<int>> adj;\n\nint bfs(int s, int t, vector<int>& parent) {\n    fill(parent.begin(), parent.end(), -1);\n    parent[s] = -2;\n    queue<pair<int, int>> q;\n    q.push({s, INF});\n\n    while (!q.empty()) {\n        int cur = q.front().first;\n        int flow = q.front().second;\n        q.pop();\n\n        for (int next : adj[cur]) {\n            if (parent[next] == -1 && capacity[cur][next]) {\n                parent[next] = cur;\n                int new_flow = min(flow, capacity[cur][next]);\n                if (next == t)\n                    return new_flow;\n                q.push({next, new_flow});\n            }\n        }\n    }\n\n    return 0;\n}\n\nint maxflow(int s, int t) {\n    int flow = 0;\n    vector<int> parent(n);\n    int new_flow;\n\n    while (new_flow = bfs(s, t, parent)) {\n        flow += new_flow;\n        int cur = t;\n        while (cur != s) {\n            int prev = parent[cur];\n            capacity[prev][cur] -= new_flow;\n            capacity[cur][prev] += new_flow;\n            cur = prev;\n        }\n    }\n\n    return flow;\n}\n```\n\n## Integral flow theorem ## { #integral-theorem}\n\nThe theorem simply says, that if every capacity in the network is an integer, then the flow in each edge will be an integer in the maximal flow.\n\n## Max-flow min-cut theorem\n\nA **$s$-$t$-cut** is a partition of the vertices of a flow network into two sets, such that a set includes the source $s$ and the other one includes the sink $t$.\nThe capacity of a $s$-$t$-cut is defined as the sum of capacities of the edges from the source side to the sink side.\n\nObviously, we cannot send more flow from $s$ to $t$ than the capacity of any $s$-$t$-cut.\nTherefore, the maximum flow is bounded by the minimum cut capacity.\n\nThe max-flow min-cut theorem goes even further.\nIt says that the capacity of the maximum flow has to be equal to the capacity of the minimum cut.\n\nIn the following image, you can see the minimum cut of the flow network we used earlier.\nIt shows that the capacity of the cut $\\{s, A, D\\}$ and $\\{B, C, t\\}$ is $5 + 3 + 2 = 10$, which is equal to the maximum flow that we found.\nOther cuts will have a bigger capacity, like the capacity between $\\{s, A\\}$ and $\\{B, C, D, t\\}$ is $4 + 3 + 5 = 12$.\n<center>![Minimum cut](Cut.png)</center>\n\nA minimum cut can be found after performing a maximum flow computation using the Ford-Fulkerson method.\nOne possible minimum cut is the following:\nthe set of all the vertices that can be reached from $s$ in the residual graph (using edges with positive residual capacity), and the set of all the other vertices.\nThis partition can be easily found using [DFS](depth-first-search.md) starting at $s$.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: edmonds_karp\n---\n\n# Maximum flow - Ford-Fulkerson and Edmonds-Karp\n\nThe Edmonds-Karp algorithm is an implementation of the Ford-Fulkerson method for computing a maximal flow in a flow network.\n\n## Flow network\n\nFirst let's define what a **flow network**, a **flow**, and a **maximum flow** is.\n\nA **network** is a directed graph $G$ with vertices $V$ and edges $E$ combined with a function $c$, which assigns each edge $e \\in E$ a non-negative integer value, the **capacity** of $e$.\nSuch a network is called a **flow network**, if we additionally label two vertices, one as **source** and one as **sink**.\n\nA **flow** in a flow network is function $f$, that again assigns each edge $e$ a non-negative integer value, namely the flow.\nThe function has to fulfill the following two conditions:\n\nThe flow of an edge cannot exceed the capacity.\n\n$$f(e) \\le c(e)$$\n\nAnd the sum of the incoming flow of a vertex $u$ has to be equal to the sum of the outgoing flow of $u$ except in the source and sink vertices.\n\n$$\\sum_{(v, u) \\in E} f((v, u)) = \\sum_{(u, v) \\in E} f((u, v))$$\n\nThe source vertex $s$ only has an outgoing flow, and the sink vertex $t$ has only incoming flow.\n\nIt is easy to see that the following equation holds:\n\n$$\\sum_{(s, u) \\in E} f((s, u)) = \\sum_{(u, t) \\in E} f((u, t))$$\n\nA good analogy for a flow network is the following visualization:\nWe represent edges as water pipes, the capacity of an edge is the maximal amount of water that can flow through the pipe per second, and the flow of an edge is the amount of water that currently flows through the pipe per second.\nThis motivates the first flow condition. There cannot flow more water through a pipe than its capacity.\nThe vertices act as junctions, where water comes out of some pipes, and then, these vertices distribute the water in some way to other pipes.\nThis also motivates the second flow condition.\nAll the incoming water has to be distributed to the other pipes in each junction.\nIt cannot magically disappear or appear.\nThe source $s$ is origin of all the water, and the water can only drain in the sink $t$.\n\nThe following image shows a flow network.\nThe first value of each edge represents the flow, which is initially 0, and the second value represents the capacity.\n<center>![Flow network](Flow1.png)</center>\n\nThe value of the flow of a network is the sum of all the flows that get produced in the source $s$, or equivalently to the sum of all the flows that are consumed by the sink $t$.\nA **maximal flow** is a flow with the maximal possible value.\nFinding this maximal flow of a flow network is the problem that we want to solve.\n\nIn the visualization with water pipes, the problem can be formulated in the following way:\nhow much water can we push through the pipes from the source to the sink?\n\nThe following image shows the maximal flow in the flow network.\n<center>![Maximal flow](Flow9.png)</center>\n\n## Ford-Fulkerson method\n\nLet's define one more thing.\nA **residual capacity** of a directed edge is the capacity minus the flow.\nIt should be noted that if there is a flow along some directed edge $(u, v)$, then the reversed edge has capacity 0 and we can define the flow of it as $f((v, u)) = -f((u, v))$.\nThis also defines the residual capacity for all the reversed edges.\nWe can create a **residual network** from all these edges, which is just a network with the same vertices and edges, but we use the residual capacities as capacities.\n\nThe Ford-Fulkerson method works as follows.\nFirst, we set the flow of each edge to zero.\nThen we look for an **augmenting path** from $s$ to $t$.\nAn augmenting path is a simple path in the residual graph, i.e. along the edges whose residual capacity is positive.\nIf such a path is found, then we can increase the flow along these edges.\nWe keep on searching for augmenting paths and increasing the flow.\nOnce an augmenting path doesn't exist anymore, the flow is maximal.\n\nLet us specify in more detail, what increasing the flow along an augmenting path means.\nLet $C$ be the smallest residual capacity of the edges in the path.\nThen we increase the flow in the following way:\nwe update $f((u, v)) ~\\text{+=}~ C$ and $f((v, u)) ~\\text{-=}~ C$ for every edge $(u, v)$ in the path.\n\nHere is an example to demonstrate the method.\nWe use the same flow network as above.\nInitially we start with a flow of 0.\n<center>![Flow network](Flow1.png)</center>\n\nWe can find the path $s - A - B - t$ with the residual capacities 7, 5, and 8.\nTheir minimum is 5, therefore we can increase the flow along this path by 5.\nThis gives a flow of 5 for the network.\n<center>![First path](Flow2.png) ![Network after first path](Flow3.png)</center>\n\nAgain we look for an augmenting path, this time we find $s - D - A - C - t$ with the residual capacities 4, 3, 3, and 5.\nTherefore we can increase the flow by 3 and we get a flow of 8 for the network.\n<center>![Second path](Flow4.png) ![Network after second path](Flow5.png)</center>\n\nThis time we find the path $s - D - C - B - t$ with the residual capacities 1, 2, 3, and 3, and hence, we increase the flow by 1.\n<center>![Third path](Flow6.png) ![Network after third path](Flow7.png)</center>\n\nThis time we find the augmenting path $s - A - D - C - t$ with the residual capacities 2, 3, 1, and 2.\nWe can increase the flow by 1.\nBut this path is very interesting.\nIt includes the reversed edge $(A, D)$.\nIn the original flow network, we are not allowed to send any flow from $A$ to $D$.\nBut because we already have a flow of 3 from $D$ to $A$, this is possible.\nThe intuition of it is the following:\nInstead of sending a flow of 3 from $D$ to $A$, we only send 2 and compensate this by sending an additional flow of 1 from $s$ to $A$, which allows us to send an additional flow of 1 along the path $D - C - t$.\n<center>![Fourth path](Flow8.png) ![Network after fourth path](Flow9.png)</center>\n\nNow, it is impossible to find an augmenting path between $s$ and $t$, therefore this flow of $10$ is the maximal possible.\nWe have found the maximal flow.\n\nIt should be noted, that the Ford-Fulkerson method doesn't specify a method of finding the augmenting path.\nPossible approaches are using [DFS](depth-first-search.md) or [BFS](breadth-first-search.md) which both work in $O(E)$.\nIf all the capacities of the network are integers, then for each augmenting path the flow of the network increases by at least 1 (for more details see [Integral flow theorem](#integral-theorem)).\nTherefore, the complexity of Ford-Fulkerson is $O(E F)$, where $F$ is the maximal flow of the network.\nIn the case of rational capacities, the algorithm will also terminate, but the complexity is not bounded.\nIn the case of irrational capacities, the algorithm might never terminate, and might not even converge to the maximal flow.\n\n## Edmonds-Karp algorithm\n\nEdmonds-Karp algorithm is just an implementation of the Ford-Fulkerson method that uses [BFS](breadth-first-search.md) for finding augmenting paths.\nThe algorithm was first published by Yefim Dinitz in 1970, and later independently published by Jack Edmonds and Richard Karp in 1972.\n\nThe complexity can be given independently of the maximal flow.\nThe algorithm runs in $O(V E^2)$ time, even for irrational capacities.\nThe intuition is, that every time we find an augmenting path one of the edges becomes saturated, and the distance from the edge to $s$ will be longer if it appears later again in an augmenting path.\nThe length of the simple paths is bounded by $V$.\n\n### Implementation\n\nThe matrix `capacity` stores the capacity for every pair of vertices.\n`adj` is the adjacency list of the **undirected graph**, since we have also to use the reversed of directed edges when we are looking for augmenting paths.\n\nThe function `maxflow` will return the value of the maximal flow.\nDuring the algorithm, the matrix `capacity` will actually store the residual capacity of the network.\nThe value of the flow in each edge will actually not be stored, but it is easy to extend the implementation - by using an additional matrix - to also store the flow and return it.\n\n```{.cpp file=edmondskarp}\nint n;\nvector<vector<int>> capacity;\nvector<vector<int>> adj;\n\nint bfs(int s, int t, vector<int>& parent) {\n    fill(parent.begin(), parent.end(), -1);\n    parent[s] = -2;\n    queue<pair<int, int>> q;\n    q.push({s, INF});\n\n    while (!q.empty()) {\n        int cur = q.front().first;\n        int flow = q.front().second;\n        q.pop();\n\n        for (int next : adj[cur]) {\n            if (parent[next] == -1 && capacity[cur][next]) {\n                parent[next] = cur;\n                int new_flow = min(flow, capacity[cur][next]);\n                if (next == t)\n                    return new_flow;\n                q.push({next, new_flow});\n            }\n        }\n    }\n\n    return 0;\n}\n\nint maxflow(int s, int t) {\n    int flow = 0;\n    vector<int> parent(n);\n    int new_flow;\n\n    while (new_flow = bfs(s, t, parent)) {\n        flow += new_flow;\n        int cur = t;\n        while (cur != s) {\n            int prev = parent[cur];\n            capacity[prev][cur] -= new_flow;\n            capacity[cur][prev] += new_flow;\n            cur = prev;\n        }\n    }\n\n    return flow;\n}\n```\n\n## Integral flow theorem ## { #integral-theorem}\n\nThe theorem simply says, that if every capacity in the network is an integer, then the flow in each edge will be an integer in the maximal flow.\n\n## Max-flow min-cut theorem\n\nA **$s$-$t$-cut** is a partition of the vertices of a flow network into two sets, such that a set includes the source $s$ and the other one includes the sink $t$.\nThe capacity of a $s$-$t$-cut is defined as the sum of capacities of the edges from the source side to the sink side.\n\nObviously, we cannot send more flow from $s$ to $t$ than the capacity of any $s$-$t$-cut.\nTherefore, the maximum flow is bounded by the minimum cut capacity.\n\nThe max-flow min-cut theorem goes even further.\nIt says that the capacity of the maximum flow has to be equal to the capacity of the minimum cut.\n\nIn the following image, you can see the minimum cut of the flow network we used earlier.\nIt shows that the capacity of the cut $\\{s, A, D\\}$ and $\\{B, C, t\\}$ is $5 + 3 + 2 = 10$, which is equal to the maximum flow that we found.\nOther cuts will have a bigger capacity, like the capacity between $\\{s, A\\}$ and $\\{B, C, D, t\\}$ is $4 + 3 + 5 = 12$.\n<center>![Minimum cut](Cut.png)</center>\n\nA minimum cut can be found after performing a maximum flow computation using the Ford-Fulkerson method.\nOne possible minimum cut is the following:\nthe set of all the vertices that can be reached from $s$ in the residual graph (using edges with positive residual capacity), and the set of all the other vertices.\nThis partition can be easily found using [DFS](depth-first-search.md) starting at $s$.\n\n## Practice Problems\n- [Codeforces - Array and Operations](https://codeforces.com/contest/498/problem/c)\n- [Codeforces - Red-Blue Graph](https://codeforces.com/contest/1288/problem/f)\n- [CSES - Download Speed](https://cses.fi/problemset/task/1694)\n- [CSES - Police Chase](https://cses.fi/problemset/task/1695)\n- [CSES - School Dance](https://cses.fi/problemset/task/1696)\n", "problem_ids": [], "title": "Maximum flow - Ford-Fulkerson and Edmonds-Karp"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: bfs\n---\n\n# Breadth-first search\n\nBreadth first search is one of the basic and essential searching algorithms on graphs.\n\nAs a result of how the algorithm works, the path found by breadth first search to any node is the shortest path to that node, i.e the path that contains the smallest number of edges in unweighted graphs.\n\nThe algorithm works in $O(n + m)$ time, where $n$ is number of vertices and $m$ is the number of edges.\n\n## Description of the algorithm\n\nThe algorithm takes as input an unweighted graph and the id of the source vertex $s$. The input graph can be directed or undirected,\nit does not matter to the algorithm.\n\nThe algorithm can be understood as a fire spreading on the graph: at the zeroth step only the source $s$ is on fire. At each step, the fire burning at each vertex spreads to all of its neighbors. In one iteration of the algorithm, the \"ring of\nfire\" is expanded in width by one unit (hence the name of the algorithm).\n\nMore precisely, the algorithm can be stated as follows: Create a queue $q$ which will contain the vertices to be processed and a\nBoolean array $used[]$ which indicates for each vertex, if it has been lit (or visited) or not.\n\nInitially, push the source $s$ to the queue and set $used[s] = true$, and for all other vertices $v$ set $used[v] = false$.\nThen, loop until the queue is empty and in each iteration, pop a vertex from the front of the queue. Iterate through all the edges going out\nof this vertex and if some of these edges go to vertices that are not already lit, set them on fire and place them in the queue.\n\nAs a result, when the queue is empty, the \"ring of fire\" contains all vertices reachable from the source $s$, with each vertex reached in the shortest possible way.\nYou can also calculate the lengths of the shortest paths (which just requires maintaining an array of path lengths $d[]$) as well as save information to restore all of these shortest paths (for this, it is necessary to maintain an array of \"parents\" $p[]$, which stores for each vertex the vertex from which we reached it).\n\n## Implementation\n\nWe write code for the described algorithm in C++ and Java.\n\n=== \"C++\"\n    ```cpp\n    vector<vector<int>> adj;  // adjacency list representation\n    int n; // number of nodes\n    int s; // source vertex\n\n    queue<int> q;\n    vector<bool> used(n);\n    vector<int> d(n), p(n);\n\n    q.push(s);\n    used[s] = true;\n    p[s] = -1;\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int u : adj[v]) {\n            if (!used[u]) {\n                used[u] = true;\n                q.push(u);\n                d[u] = d[v] + 1;\n                p[u] = v;\n            }\n        }\n    }\n    ```\n=== \"Java\"\n    ```java\n    ArrayList<ArrayList<Integer>> adj = new ArrayList<>(); // adjacency list representation\n        \n    int n; // number of nodes\n    int s; // source vertex\n\n\n    LinkedList<Integer> q = new LinkedList<Integer>();\n    boolean used[] = new boolean[n];\n    int d[] = new int[n];\n    int p[] = new int[n];\n\n    q.push(s);\n    used[s] = true;\n    p[s] = -1;\n    while (!q.isEmpty()) {\n        int v = q.pop();\n        for (int u : adj.get(v)) {\n            if (!used[u]) {\n                used[u] = true;\n                q.push(u);\n                d[u] = d[v] + 1;\n                p[u] = v;\n            }\n        }\n    }\n    ```\n    \nIf we have to restore and display the shortest path from the source to some vertex $u$, it can be done in the following manner:\n    \n=== \"C++\"\n    ```cpp\n    if (!used[u]) {\n        cout << \"No path!\";\n    } else {\n        vector<int> path;\n        for (int v = u; v != -1; v = p[v])\n            path.push_back(v);\n        reverse(path.begin(), path.end());\n        cout << \"Path: \";\n        for (int v : path)\n            cout << v << \" \";\n    }\n    ```\n=== \"Java\"\n    ```java\n    if (!used[u]) {\n        System.out.println(\"No path!\");\n    } else {\n        ArrayList<Integer> path = new ArrayList<Integer>();\n        for (int v = u; v != -1; v = p[v])\n            path.add(v);\n        Collections.reverse(path);\n        for(int v : path)\n            System.out.println(v);\n    }\n    ```\n    \n## Applications of BFS\n\n* Find the shortest path from a source to other vertices in an unweighted graph.\n\n* Find all connected components in an undirected graph in $O(n + m)$ time:\nTo do this, we just run BFS starting from each vertex, except for vertices which have already been visited from previous runs.\nThus, we perform normal BFS from each of the vertices, but do not reset the array $used[]$ each and every time we get a new connected component, and the total running time will still be $O(n + m)$ (performing multiple BFS on the graph without zeroing the array $used []$ is called a series of breadth first searches).\n\n* Finding a solution to a problem or a game with the least number of moves, if each state of the game can be represented by a vertex of the graph, and the transitions from one state to the other are the edges of the graph.\n\n* Finding the shortest path in a graph with weights 0 or 1:\nThis requires just a little modification to normal breadth-first search: Instead of maintaining array $used[]$, we will now check if the distance to vertex is shorter than current found distance, then if the current edge is of zero weight, we add it to the front of the queue else we add it to the back of the queue.This modification is explained in more detail in the article [0-1 BFS](01_bfs.md).\n\n* Finding the shortest cycle in a directed unweighted graph:\nStart a breadth-first search from each vertex.\nAs soon as we try to go from the current vertex back to the source vertex, we have found the shortest cycle containing the source vertex.\nAt this point we can stop the BFS, and start a new BFS from the next vertex.\nFrom all such cycles (at most one from each BFS) choose the shortest.\n\n* Find all the edges that lie on any shortest path between a given pair of vertices $(a, b)$.\nTo do this, run two breadth first searches:\none from $a$ and one from $b$.\nLet $d_a []$ be the array containing shortest distances obtained from the first BFS (from $a$) and $d_b []$ be the array containing shortest distances obtained from the second BFS from $b$.\nNow for every edge $(u, v)$ it is easy to check whether that edge lies on any shortest path between $a$ and $b$:\nthe criterion is the condition $d_a [u] + 1 + d_b [v] = d_a [b]$.\n\n* Find all the vertices on any shortest path between a given pair of vertices $(a, b)$.\nTo accomplish that, run two breadth first searches:\none from $a$ and one from $b$.\nLet $d_a []$ be the array containing shortest distances obtained from the first BFS (from $a$) and $d_b []$ be the array containing shortest distances obtained from the second BFS (from $b$).\nNow for each vertex it is easy to check whether it lies on any shortest path between $a$ and $b$:\nthe criterion is the condition $d_a [v] + d_b [v] = d_a [b]$.\n\n* Find the shortest path of even length from a source vertex $s$ to a target vertex $t$ in an unweighted graph:\nFor this, we must construct an auxiliary graph, whose vertices are the state $(v, c)$, where $v$ - the current node, $c = 0$ or $c = 1$ - the current parity.\nAny edge $(u, v)$ of the original graph in this new column will turn into two edges $((u, 0), (v, 1))$ and $((u, 1), (v, 0))$.\nAfter that we run a BFS to find the shortest path from the starting vertex $(s, 0)$ to the end vertex $(t, 0)$.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: bfs\n---\n\n# Breadth-first search\n\nBreadth first search is one of the basic and essential searching algorithms on graphs.\n\nAs a result of how the algorithm works, the path found by breadth first search to any node is the shortest path to that node, i.e the path that contains the smallest number of edges in unweighted graphs.\n\nThe algorithm works in $O(n + m)$ time, where $n$ is number of vertices and $m$ is the number of edges.\n\n## Description of the algorithm\n\nThe algorithm takes as input an unweighted graph and the id of the source vertex $s$. The input graph can be directed or undirected,\nit does not matter to the algorithm.\n\nThe algorithm can be understood as a fire spreading on the graph: at the zeroth step only the source $s$ is on fire. At each step, the fire burning at each vertex spreads to all of its neighbors. In one iteration of the algorithm, the \"ring of\nfire\" is expanded in width by one unit (hence the name of the algorithm).\n\nMore precisely, the algorithm can be stated as follows: Create a queue $q$ which will contain the vertices to be processed and a\nBoolean array $used[]$ which indicates for each vertex, if it has been lit (or visited) or not.\n\nInitially, push the source $s$ to the queue and set $used[s] = true$, and for all other vertices $v$ set $used[v] = false$.\nThen, loop until the queue is empty and in each iteration, pop a vertex from the front of the queue. Iterate through all the edges going out\nof this vertex and if some of these edges go to vertices that are not already lit, set them on fire and place them in the queue.\n\nAs a result, when the queue is empty, the \"ring of fire\" contains all vertices reachable from the source $s$, with each vertex reached in the shortest possible way.\nYou can also calculate the lengths of the shortest paths (which just requires maintaining an array of path lengths $d[]$) as well as save information to restore all of these shortest paths (for this, it is necessary to maintain an array of \"parents\" $p[]$, which stores for each vertex the vertex from which we reached it).\n\n## Implementation\n\nWe write code for the described algorithm in C++ and Java.\n\n=== \"C++\"\n    ```cpp\n    vector<vector<int>> adj;  // adjacency list representation\n    int n; // number of nodes\n    int s; // source vertex\n\n    queue<int> q;\n    vector<bool> used(n);\n    vector<int> d(n), p(n);\n\n    q.push(s);\n    used[s] = true;\n    p[s] = -1;\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int u : adj[v]) {\n            if (!used[u]) {\n                used[u] = true;\n                q.push(u);\n                d[u] = d[v] + 1;\n                p[u] = v;\n            }\n        }\n    }\n    ```\n=== \"Java\"\n    ```java\n    ArrayList<ArrayList<Integer>> adj = new ArrayList<>(); // adjacency list representation\n        \n    int n; // number of nodes\n    int s; // source vertex\n\n\n    LinkedList<Integer> q = new LinkedList<Integer>();\n    boolean used[] = new boolean[n];\n    int d[] = new int[n];\n    int p[] = new int[n];\n\n    q.push(s);\n    used[s] = true;\n    p[s] = -1;\n    while (!q.isEmpty()) {\n        int v = q.pop();\n        for (int u : adj.get(v)) {\n            if (!used[u]) {\n                used[u] = true;\n                q.push(u);\n                d[u] = d[v] + 1;\n                p[u] = v;\n            }\n        }\n    }\n    ```\n    \nIf we have to restore and display the shortest path from the source to some vertex $u$, it can be done in the following manner:\n    \n=== \"C++\"\n    ```cpp\n    if (!used[u]) {\n        cout << \"No path!\";\n    } else {\n        vector<int> path;\n        for (int v = u; v != -1; v = p[v])\n            path.push_back(v);\n        reverse(path.begin(), path.end());\n        cout << \"Path: \";\n        for (int v : path)\n            cout << v << \" \";\n    }\n    ```\n=== \"Java\"\n    ```java\n    if (!used[u]) {\n        System.out.println(\"No path!\");\n    } else {\n        ArrayList<Integer> path = new ArrayList<Integer>();\n        for (int v = u; v != -1; v = p[v])\n            path.add(v);\n        Collections.reverse(path);\n        for(int v : path)\n            System.out.println(v);\n    }\n    ```\n    \n## Applications of BFS\n\n* Find the shortest path from a source to other vertices in an unweighted graph.\n\n* Find all connected components in an undirected graph in $O(n + m)$ time:\nTo do this, we just run BFS starting from each vertex, except for vertices which have already been visited from previous runs.\nThus, we perform normal BFS from each of the vertices, but do not reset the array $used[]$ each and every time we get a new connected component, and the total running time will still be $O(n + m)$ (performing multiple BFS on the graph without zeroing the array $used []$ is called a series of breadth first searches).\n\n* Finding a solution to a problem or a game with the least number of moves, if each state of the game can be represented by a vertex of the graph, and the transitions from one state to the other are the edges of the graph.\n\n* Finding the shortest path in a graph with weights 0 or 1:\nThis requires just a little modification to normal breadth-first search: Instead of maintaining array $used[]$, we will now check if the distance to vertex is shorter than current found distance, then if the current edge is of zero weight, we add it to the front of the queue else we add it to the back of the queue.This modification is explained in more detail in the article [0-1 BFS](01_bfs.md).\n\n* Finding the shortest cycle in a directed unweighted graph:\nStart a breadth-first search from each vertex.\nAs soon as we try to go from the current vertex back to the source vertex, we have found the shortest cycle containing the source vertex.\nAt this point we can stop the BFS, and start a new BFS from the next vertex.\nFrom all such cycles (at most one from each BFS) choose the shortest.\n\n* Find all the edges that lie on any shortest path between a given pair of vertices $(a, b)$.\nTo do this, run two breadth first searches:\none from $a$ and one from $b$.\nLet $d_a []$ be the array containing shortest distances obtained from the first BFS (from $a$) and $d_b []$ be the array containing shortest distances obtained from the second BFS from $b$.\nNow for every edge $(u, v)$ it is easy to check whether that edge lies on any shortest path between $a$ and $b$:\nthe criterion is the condition $d_a [u] + 1 + d_b [v] = d_a [b]$.\n\n* Find all the vertices on any shortest path between a given pair of vertices $(a, b)$.\nTo accomplish that, run two breadth first searches:\none from $a$ and one from $b$.\nLet $d_a []$ be the array containing shortest distances obtained from the first BFS (from $a$) and $d_b []$ be the array containing shortest distances obtained from the second BFS (from $b$).\nNow for each vertex it is easy to check whether it lies on any shortest path between $a$ and $b$:\nthe criterion is the condition $d_a [v] + d_b [v] = d_a [b]$.\n\n* Find the shortest path of even length from a source vertex $s$ to a target vertex $t$ in an unweighted graph:\nFor this, we must construct an auxiliary graph, whose vertices are the state $(v, c)$, where $v$ - the current node, $c = 0$ or $c = 1$ - the current parity.\nAny edge $(u, v)$ of the original graph in this new column will turn into two edges $((u, 0), (v, 1))$ and $((u, 1), (v, 0))$.\nAfter that we run a BFS to find the shortest path from the starting vertex $(s, 0)$ to the end vertex $(t, 0)$.\n\n## Practice Problems\n\n* [SPOJ: AKBAR](http://spoj.com/problems/AKBAR)\n* [SPOJ: NAKANJ](http://www.spoj.com/problems/NAKANJ/)\n* [SPOJ: WATER](http://www.spoj.com/problems/WATER)\n* [SPOJ: MICE AND MAZE](http://www.spoj.com/problems/MICEMAZE/)\n* [Timus: Caravans](http://acm.timus.ru/problem.aspx?space=1&num=2034)\n* [DevSkill - Holloween Party (archived)](http://web.archive.org/web/20200930162803/http://www.devskill.com/CodingProblems/ViewProblem/60)\n* [DevSkill - Ohani And The Link Cut Tree (archived)](http://web.archive.org/web/20170216192002/http://devskill.com:80/CodingProblems/ViewProblem/150)\n* [SPOJ - Spiky Mazes](http://www.spoj.com/problems/SPIKES/)\n* [SPOJ - Four Chips (hard)](http://www.spoj.com/problems/ADV04F1/)\n* [SPOJ - Inversion Sort](http://www.spoj.com/problems/INVESORT/)\n* [Codeforces - Shortest Path](http://codeforces.com/contest/59/problem/E)\n* [SPOJ - Yet Another Multiple Problem](http://www.spoj.com/problems/MULTII/)\n* [UVA 11392 - Binary 3xType Multiple](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2387)\n* [UVA 10968 - KuPellaKeS](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1909)\n* [Codeforces - Police Stations](http://codeforces.com/contest/796/problem/D)\n* [Codeforces - Okabe and City](http://codeforces.com/contest/821/problem/D)\n* [SPOJ - Find the Treasure](http://www.spoj.com/problems/DIGOKEYS/)\n* [Codeforces - Bear and Forgotten Tree 2](http://codeforces.com/contest/653/problem/E)\n* [Codeforces - Cycle in Maze](http://codeforces.com/contest/769/problem/C)\n* [UVA - 11312 - Flipping Frustration](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2287)\n* [SPOJ - Ada and Cycle](http://www.spoj.com/problems/ADACYCLE/)\n* [CSES - Labyrinth](https://cses.fi/problemset/task/1193)\n* [CSES - Message Route](https://cses.fi/problemset/task/1667/)\n* [CSES - Monsters](https://cses.fi/problemset/task/1194)\n", "problem_ids": ["59_E", "796_D", "821_D", "653_E"], "title": "Breadth-first search"}, {"article": "---\ntitle: Lowest Common Ancestor - O(sqrt(N)) and O(log N) with O(N) preprocessing\ntags:\n  - Translated\ne_maxx_link: lca\n---\n# Lowest Common Ancestor - $O(\\sqrt{N})$ and $O(\\log N)$ with $O(N)$ preprocessing\n\nGiven a tree $G$. Given queries of the form $(v_1, v_2)$, for each query you need to find the lowest common ancestor (or least common ancestor), i.e. a vertex $v$ that lies on the path from the root to $v_1$ and the path from the root to $v_2$, and the vertex should be the lowest. In other words, the desired vertex $v$ is the most bottom ancestor of $v_1$ and $v_2$. It is obvious that their lowest common ancestor lies on a shortest path from $v_1$ and $v_2$. Also, if $v_1$ is the ancestor of $v_2$, $v_1$ is their lowest common ancestor.\n\n### The Idea of the Algorithm\n\nBefore answering the queries, we need to **preprocess** the tree.\nWe make a [DFS](depth-first-search.md) traversal starting at the root and we build a list $\\text{euler}$ which stores the order of the vertices that we visit (a vertex is added to the list when we first visit it, and after the return of the DFS traversals to its children).\nThis is also called an Euler tour of the tree.\nIt is clear that the size of this list will be $O(N)$.\nWe also need to build an array $\\text{first}[0..N-1]$ which stores for each vertex $i$ its first occurrence in $\\text{euler}$.\nThat is, the first position in $\\text{euler}$ such that $\\text{euler}[\\text{first}[i]] = i$.\nAlso by using the DFS we can find the height of each node (distance from root to it) and store it in the array $\\text{height}[0..N-1]$.\n\nSo how can we answer queries using the Euler tour and the additional two arrays?\nSuppose the query is a pair of $v_1$ and $v_2$.\nConsider the vertices that we visit in the Euler tour between the first visit of $v_1$ and the first visit of $v_2$.\nIt is easy to see, that the $\\text{LCA}(v_1, v_2)$ is the vertex with the lowest height on this path.\nWe already noticed, that the LCA has to be part of the shortest path between $v_1$ and $v_2$.\nClearly it also has to be the vertex with the smallest height.\nAnd in the Euler tour we essentially use the shortest path, except that we additionally visit all subtrees that we find on the path.\nBut all vertices in these subtrees are lower in the tree than the LCA and therefore have a larger height.\nSo the $\\text{LCA}(v_1, v_2)$ can be uniquely determined by finding the vertex with the smallest height in the Euler tour between $\\text{first}(v_1)$ and $\\text{first}(v_2)$.\n\nLet's illustrate this idea.\nConsider the following graph and the Euler tour with the corresponding heights:\n<center>![LCA_Euler_Tour](LCA_Euler.png)</center>\n\n$$\\begin{array}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|}\n\\hline\n\\text{Vertices:}   & 1 & 2 & 5 & 2 & 6 & 2 & 1 & 3 & 1 & 4 & 7 & 4 & 1 \\\\ \\hline\n\\text{Heights:} & 1 & 2 & 3 & 2 & 3 & 2 & 1 & 2 & 1 & 2 & 3 & 2 & 1 \\\\ \\hline\n\\end{array}$$\n\nThe tour starting at vertex $6$ and ending at $4$ we visit the vertices $[6, 2, 1, 3, 1, 4]$.\nAmong those vertices the vertex $1$ has the lowest height, therefore $\\text{LCA(6, 4) = 1}$.\n\nTo recap:\nto answer a query we just need **to find the vertex with smallest height** in the array $\\text{euler}$ in the range from $\\text{first}[v_1]$ to $\\text{first}[v_2]$.\nThus, **the LCA problem is reduced to the RMQ problem** (finding the minimum in an range problem).\n\nUsing [Sqrt-Decomposition](../data_structures/sqrt_decomposition.md), it is possible to obtain a solution answering each query in $O(\\sqrt{N})$ with preprocessing in $O(N)$ time.\n\nUsing a [Segment Tree](../data_structures/segment_tree.md) you can answer each query in $O(\\log N)$ with preprocessing in $O(N)$ time.\n\nSince there will almost never be any update to the stored values, a [Sparse Table](../data_structures/sparse-table.md) might be a better choice, allowing $O(1)$ query answering with $O(N\\log N)$ build time.\n\n### Implementation\n\nIn the following implementation of the LCA algorithm a Segment Tree is used.\n\n```{.cpp file=lca}\nstruct LCA {\n    vector<int> height, euler, first, segtree;\n    vector<bool> visited;\n    int n;\n\n    LCA(vector<vector<int>> &adj, int root = 0) {\n        n = adj.size();\n        height.resize(n);\n        first.resize(n);\n        euler.reserve(n * 2);\n        visited.assign(n, false);\n        dfs(adj, root);\n        int m = euler.size();\n        segtree.resize(m * 4);\n        build(1, 0, m - 1);\n    }\n\n    void dfs(vector<vector<int>> &adj, int node, int h = 0) {\n        visited[node] = true;\n        height[node] = h;\n        first[node] = euler.size();\n        euler.push_back(node);\n        for (auto to : adj[node]) {\n            if (!visited[to]) {\n                dfs(adj, to, h + 1);\n                euler.push_back(node);\n            }\n        }\n    }\n\n    void build(int node, int b, int e) {\n        if (b == e) {\n            segtree[node] = euler[b];\n        } else {\n            int mid = (b + e) / 2;\n            build(node << 1, b, mid);\n            build(node << 1 | 1, mid + 1, e);\n            int l = segtree[node << 1], r = segtree[node << 1 | 1];\n            segtree[node] = (height[l] < height[r]) ? l : r;\n        }\n    }\n\n    int query(int node, int b, int e, int L, int R) {\n        if (b > R || e < L)\n            return -1;\n        if (b >= L && e <= R)\n            return segtree[node];\n        int mid = (b + e) >> 1;\n\n        int left = query(node << 1, b, mid, L, R);\n        int right = query(node << 1 | 1, mid + 1, e, L, R);\n        if (left == -1) return right;\n        if (right == -1) return left;\n        return height[left] < height[right] ? left : right;\n    }\n\n    int lca(int u, int v) {\n        int left = first[u], right = first[v];\n        if (left > right)\n            swap(left, right);\n        return query(1, 0, euler.size() - 1, left, right);\n    }\n};\n\n```\n\n", "full_article": "---\ntitle: Lowest Common Ancestor - O(sqrt(N)) and O(log N) with O(N) preprocessing\ntags:\n  - Translated\ne_maxx_link: lca\n---\n# Lowest Common Ancestor - $O(\\sqrt{N})$ and $O(\\log N)$ with $O(N)$ preprocessing\n\nGiven a tree $G$. Given queries of the form $(v_1, v_2)$, for each query you need to find the lowest common ancestor (or least common ancestor), i.e. a vertex $v$ that lies on the path from the root to $v_1$ and the path from the root to $v_2$, and the vertex should be the lowest. In other words, the desired vertex $v$ is the most bottom ancestor of $v_1$ and $v_2$. It is obvious that their lowest common ancestor lies on a shortest path from $v_1$ and $v_2$. Also, if $v_1$ is the ancestor of $v_2$, $v_1$ is their lowest common ancestor.\n\n### The Idea of the Algorithm\n\nBefore answering the queries, we need to **preprocess** the tree.\nWe make a [DFS](depth-first-search.md) traversal starting at the root and we build a list $\\text{euler}$ which stores the order of the vertices that we visit (a vertex is added to the list when we first visit it, and after the return of the DFS traversals to its children).\nThis is also called an Euler tour of the tree.\nIt is clear that the size of this list will be $O(N)$.\nWe also need to build an array $\\text{first}[0..N-1]$ which stores for each vertex $i$ its first occurrence in $\\text{euler}$.\nThat is, the first position in $\\text{euler}$ such that $\\text{euler}[\\text{first}[i]] = i$.\nAlso by using the DFS we can find the height of each node (distance from root to it) and store it in the array $\\text{height}[0..N-1]$.\n\nSo how can we answer queries using the Euler tour and the additional two arrays?\nSuppose the query is a pair of $v_1$ and $v_2$.\nConsider the vertices that we visit in the Euler tour between the first visit of $v_1$ and the first visit of $v_2$.\nIt is easy to see, that the $\\text{LCA}(v_1, v_2)$ is the vertex with the lowest height on this path.\nWe already noticed, that the LCA has to be part of the shortest path between $v_1$ and $v_2$.\nClearly it also has to be the vertex with the smallest height.\nAnd in the Euler tour we essentially use the shortest path, except that we additionally visit all subtrees that we find on the path.\nBut all vertices in these subtrees are lower in the tree than the LCA and therefore have a larger height.\nSo the $\\text{LCA}(v_1, v_2)$ can be uniquely determined by finding the vertex with the smallest height in the Euler tour between $\\text{first}(v_1)$ and $\\text{first}(v_2)$.\n\nLet's illustrate this idea.\nConsider the following graph and the Euler tour with the corresponding heights:\n<center>![LCA_Euler_Tour](LCA_Euler.png)</center>\n\n$$\\begin{array}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|}\n\\hline\n\\text{Vertices:}   & 1 & 2 & 5 & 2 & 6 & 2 & 1 & 3 & 1 & 4 & 7 & 4 & 1 \\\\ \\hline\n\\text{Heights:} & 1 & 2 & 3 & 2 & 3 & 2 & 1 & 2 & 1 & 2 & 3 & 2 & 1 \\\\ \\hline\n\\end{array}$$\n\nThe tour starting at vertex $6$ and ending at $4$ we visit the vertices $[6, 2, 1, 3, 1, 4]$.\nAmong those vertices the vertex $1$ has the lowest height, therefore $\\text{LCA(6, 4) = 1}$.\n\nTo recap:\nto answer a query we just need **to find the vertex with smallest height** in the array $\\text{euler}$ in the range from $\\text{first}[v_1]$ to $\\text{first}[v_2]$.\nThus, **the LCA problem is reduced to the RMQ problem** (finding the minimum in an range problem).\n\nUsing [Sqrt-Decomposition](../data_structures/sqrt_decomposition.md), it is possible to obtain a solution answering each query in $O(\\sqrt{N})$ with preprocessing in $O(N)$ time.\n\nUsing a [Segment Tree](../data_structures/segment_tree.md) you can answer each query in $O(\\log N)$ with preprocessing in $O(N)$ time.\n\nSince there will almost never be any update to the stored values, a [Sparse Table](../data_structures/sparse-table.md) might be a better choice, allowing $O(1)$ query answering with $O(N\\log N)$ build time.\n\n### Implementation\n\nIn the following implementation of the LCA algorithm a Segment Tree is used.\n\n```{.cpp file=lca}\nstruct LCA {\n    vector<int> height, euler, first, segtree;\n    vector<bool> visited;\n    int n;\n\n    LCA(vector<vector<int>> &adj, int root = 0) {\n        n = adj.size();\n        height.resize(n);\n        first.resize(n);\n        euler.reserve(n * 2);\n        visited.assign(n, false);\n        dfs(adj, root);\n        int m = euler.size();\n        segtree.resize(m * 4);\n        build(1, 0, m - 1);\n    }\n\n    void dfs(vector<vector<int>> &adj, int node, int h = 0) {\n        visited[node] = true;\n        height[node] = h;\n        first[node] = euler.size();\n        euler.push_back(node);\n        for (auto to : adj[node]) {\n            if (!visited[to]) {\n                dfs(adj, to, h + 1);\n                euler.push_back(node);\n            }\n        }\n    }\n\n    void build(int node, int b, int e) {\n        if (b == e) {\n            segtree[node] = euler[b];\n        } else {\n            int mid = (b + e) / 2;\n            build(node << 1, b, mid);\n            build(node << 1 | 1, mid + 1, e);\n            int l = segtree[node << 1], r = segtree[node << 1 | 1];\n            segtree[node] = (height[l] < height[r]) ? l : r;\n        }\n    }\n\n    int query(int node, int b, int e, int L, int R) {\n        if (b > R || e < L)\n            return -1;\n        if (b >= L && e <= R)\n            return segtree[node];\n        int mid = (b + e) >> 1;\n\n        int left = query(node << 1, b, mid, L, R);\n        int right = query(node << 1 | 1, mid + 1, e, L, R);\n        if (left == -1) return right;\n        if (right == -1) return left;\n        return height[left] < height[right] ? left : right;\n    }\n\n    int lca(int u, int v) {\n        int left = first[u], right = first[v];\n        if (left > right)\n            swap(left, right);\n        return query(1, 0, euler.size() - 1, left, right);\n    }\n};\n\n```\n\n## Practice Problems\n - [SPOJ: LCA](http://www.spoj.com/problems/LCA/)\n - [SPOJ: DISQUERY](http://www.spoj.com/problems/DISQUERY/)\n - [TIMUS: 1471. Distance in the Tree](http://acm.timus.ru/problem.aspx?space=1&num=1471)\n - [CODEFORCES: Design Tutorial: Inverse the Problem](http://codeforces.com/problemset/problem/472/D)\n - [CODECHEF: Lowest Common Ancestor](https://www.codechef.com/problems/TALCA)\n * [SPOJ - Lowest Common Ancestor](http://www.spoj.com/problems/LCASQ/)\n * [SPOJ - Ada and Orange Tree](http://www.spoj.com/problems/ADAORANG/)\n * [DevSkill - Motoku (archived)](http://web.archive.org/web/20200922005503/https://devskill.com/CodingProblems/ViewProblem/141)\n * [UVA 12655 - Trucks](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=4384)\n * [Codechef - Pishty and Tree](https://www.codechef.com/problems/PSHTTR)\n * [UVA - 12533 - Joining Couples](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=441&page=show_problem&problem=3978)\n * [Codechef - So close yet So Far](https://www.codechef.com/problems/CLOSEFAR)\n * [Codeforces - Drivers Dissatisfaction](http://codeforces.com/contest/733/problem/F)\n * [UVA 11354 - Bond](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2339)\n * [SPOJ - Querry on a tree II](http://www.spoj.com/problems/QTREE2/)\n * [Codeforces - Best Edge Weight](http://codeforces.com/contest/828/problem/F)\n * [Codeforces - Misha, Grisha and Underground](http://codeforces.com/contest/832/problem/D)\n * [SPOJ - Nlogonian Tickets](http://www.spoj.com/problems/NTICKETS/)\n * [Codeforces - Rowena Rawenclaws Diadem](http://codeforces.com/contest/855/problem/D)\n", "problem_ids": ["733_F", "828_F", "832_D"], "title": "Lowest Common Ancestor - $O(\\sqrt{N})$ and $O(\\log N)$ with $O(N)$ preprocessing"}, {"article": "---\ntitle: Finding articulation points in a graph in O(N+M)\ntags:\n  - Translated\ne_maxx_link: cutpoints\n---\n# Finding articulation points in a graph in $O(N+M)$\n\nWe are given an undirected graph. An articulation point (or cut vertex) is defined as a vertex which, when removed along with associated edges, makes the graph disconnected (or more precisely, increases the number of connected components in the graph). The task is to find all articulation points in the given graph.\n\nThe algorithm described here is based on [depth first search](depth-first-search.md) and has $O(N+M)$ complexity, where $N$ is the number of vertices and $M$ is the number of edges in the graph.\n\n## Algorithm\n\nPick an arbitrary vertex of the graph $root$ and run [depth first search](depth-first-search.md) from it. Note the following fact (which is easy to prove):\n\n- Let's say we are in the DFS, looking through the edges starting from vertex $v\\ne root$.\nIf the current edge $(v, to)$ is such that none of the vertices $to$ or its descendants in the DFS traversal tree has a back-edge to any of ancestors of $v$, then $v$ is an articulation point. Otherwise, $v$ is not an articulation point.\n\n- Let's consider the remaining case of $v=root$.\nThis vertex will be the point of articulation if and only if this vertex has more than one child in the DFS tree.\n\nNow we have to learn to check this fact for each vertex efficiently. We'll use \"time of entry into node\" computed by the depth first search.\n\nSo, let $tin[v]$ denote entry time for node $v$. We introduce an array $low[v]$ which will let us check the fact for each vertex $v$. $low[v]$ is the minimum of $tin[v]$, the entry times $tin[p]$ for each node $p$ that is connected to node $v$ via a back-edge $(v, p)$ and the values of $low[to]$ for each vertex $to$ which is a direct descendant of $v$ in the DFS tree:\n\n$$low[v] = \\min \\begin{cases} tin[v] \\\\ tin[p] &\\text{ for all }p\\text{ for which }(v, p)\\text{ is a back edge} \\\\ low[to]& \\text{ for all }to\\text{ for which }(v, to)\\text{ is a tree edge} \\end{cases}$$\n\nNow, there is a back edge from vertex $v$ or one of its descendants to one of its ancestors if and only if vertex $v$ has a child $to$ for which $low[to] < tin[v]$. If $low[to] = tin[v]$, the back edge comes directly to $v$, otherwise it comes to one of the ancestors of $v$.\n\nThus, the vertex $v$ in the DFS tree is an articulation point if and only if $low[to] \\geq tin[v]$.\n\n## Implementation\n\nThe implementation needs to distinguish three cases: when we go down the edge in DFS tree, when we find a back edge to an ancestor of the vertex and when we return to a parent of the vertex. These are the cases:\n\n- $visited[to] = false$ - the edge is part of DFS tree;\n- $visited[to] = true$ && $to \\neq parent$ - the edge is back edge to one of the ancestors;\n- $to = parent$ - the edge leads back to parent in DFS tree.\n\nTo implement this, we need a depth first search function which accepts the parent vertex of the current node.\n\n```cpp\nint n; // number of nodes\nvector<vector<int>> adj; // adjacency list of graph\n\nvector<bool> visited;\nvector<int> tin, low;\nint timer;\n \nvoid dfs(int v, int p = -1) {\n    visited[v] = true;\n    tin[v] = low[v] = timer++;\n    int children=0;\n    for (int to : adj[v]) {\n        if (to == p) continue;\n        if (visited[to]) {\n            low[v] = min(low[v], tin[to]);\n        } else {\n            dfs(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] >= tin[v] && p!=-1)\n                IS_CUTPOINT(v);\n            ++children;\n        }\n    }\n    if(p == -1 && children > 1)\n        IS_CUTPOINT(v);\n}\n \nvoid find_cutpoints() {\n    timer = 0;\n    visited.assign(n, false);\n    tin.assign(n, -1);\n    low.assign(n, -1);\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i])\n            dfs (i);\n    }\n}\n```\n\nMain function is `find_cutpoints`; it performs necessary initialization and starts depth first search in each connected component of the graph.\n\nFunction `IS_CUTPOINT(a)` is some function that will process the fact that vertex $a$ is an articulation point, for example, print it (Caution that this can be called multiple times for a vertex).\n\n", "full_article": "---\ntitle: Finding articulation points in a graph in O(N+M)\ntags:\n  - Translated\ne_maxx_link: cutpoints\n---\n# Finding articulation points in a graph in $O(N+M)$\n\nWe are given an undirected graph. An articulation point (or cut vertex) is defined as a vertex which, when removed along with associated edges, makes the graph disconnected (or more precisely, increases the number of connected components in the graph). The task is to find all articulation points in the given graph.\n\nThe algorithm described here is based on [depth first search](depth-first-search.md) and has $O(N+M)$ complexity, where $N$ is the number of vertices and $M$ is the number of edges in the graph.\n\n## Algorithm\n\nPick an arbitrary vertex of the graph $root$ and run [depth first search](depth-first-search.md) from it. Note the following fact (which is easy to prove):\n\n- Let's say we are in the DFS, looking through the edges starting from vertex $v\\ne root$.\nIf the current edge $(v, to)$ is such that none of the vertices $to$ or its descendants in the DFS traversal tree has a back-edge to any of ancestors of $v$, then $v$ is an articulation point. Otherwise, $v$ is not an articulation point.\n\n- Let's consider the remaining case of $v=root$.\nThis vertex will be the point of articulation if and only if this vertex has more than one child in the DFS tree.\n\nNow we have to learn to check this fact for each vertex efficiently. We'll use \"time of entry into node\" computed by the depth first search.\n\nSo, let $tin[v]$ denote entry time for node $v$. We introduce an array $low[v]$ which will let us check the fact for each vertex $v$. $low[v]$ is the minimum of $tin[v]$, the entry times $tin[p]$ for each node $p$ that is connected to node $v$ via a back-edge $(v, p)$ and the values of $low[to]$ for each vertex $to$ which is a direct descendant of $v$ in the DFS tree:\n\n$$low[v] = \\min \\begin{cases} tin[v] \\\\ tin[p] &\\text{ for all }p\\text{ for which }(v, p)\\text{ is a back edge} \\\\ low[to]& \\text{ for all }to\\text{ for which }(v, to)\\text{ is a tree edge} \\end{cases}$$\n\nNow, there is a back edge from vertex $v$ or one of its descendants to one of its ancestors if and only if vertex $v$ has a child $to$ for which $low[to] < tin[v]$. If $low[to] = tin[v]$, the back edge comes directly to $v$, otherwise it comes to one of the ancestors of $v$.\n\nThus, the vertex $v$ in the DFS tree is an articulation point if and only if $low[to] \\geq tin[v]$.\n\n## Implementation\n\nThe implementation needs to distinguish three cases: when we go down the edge in DFS tree, when we find a back edge to an ancestor of the vertex and when we return to a parent of the vertex. These are the cases:\n\n- $visited[to] = false$ - the edge is part of DFS tree;\n- $visited[to] = true$ && $to \\neq parent$ - the edge is back edge to one of the ancestors;\n- $to = parent$ - the edge leads back to parent in DFS tree.\n\nTo implement this, we need a depth first search function which accepts the parent vertex of the current node.\n\n```cpp\nint n; // number of nodes\nvector<vector<int>> adj; // adjacency list of graph\n\nvector<bool> visited;\nvector<int> tin, low;\nint timer;\n \nvoid dfs(int v, int p = -1) {\n    visited[v] = true;\n    tin[v] = low[v] = timer++;\n    int children=0;\n    for (int to : adj[v]) {\n        if (to == p) continue;\n        if (visited[to]) {\n            low[v] = min(low[v], tin[to]);\n        } else {\n            dfs(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] >= tin[v] && p!=-1)\n                IS_CUTPOINT(v);\n            ++children;\n        }\n    }\n    if(p == -1 && children > 1)\n        IS_CUTPOINT(v);\n}\n \nvoid find_cutpoints() {\n    timer = 0;\n    visited.assign(n, false);\n    tin.assign(n, -1);\n    low.assign(n, -1);\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i])\n            dfs (i);\n    }\n}\n```\n\nMain function is `find_cutpoints`; it performs necessary initialization and starts depth first search in each connected component of the graph.\n\nFunction `IS_CUTPOINT(a)` is some function that will process the fact that vertex $a$ is an articulation point, for example, print it (Caution that this can be called multiple times for a vertex).\n\n## Practice Problems\n\n- [UVA #10199 \"Tourist Guide\"](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=13&page=show_problem&problem=1140) [difficulty: low]\n- [UVA #315 \"Network\"](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=5&page=show_problem&problem=251) [difficulty: low]\n- [SPOJ - Submerging Islands](http://www.spoj.com/problems/SUBMERGE/)\n- [Codeforces - Cutting Figure](https://codeforces.com/problemset/problem/193/A)\n", "problem_ids": ["193_A"], "title": "Finding articulation points in a graph in $O(N+M)$"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: preflow_push_faster\n---\n\n# Maximum flow - Push-relabel method improved\n\nWe will modify the [push-relabel method](push-relabel.md) to achieve a better runtime.\n\n## Description\n\nThe modification is extremely simple:\nIn the previous article we chosen a vertex with excess without any particular rule.\nBut it turns out, that if we always choose the vertices with the **greatest height**, and apply push and relabel operations on them, then the complexity will become better.\nMoreover, to select the vertices with the greatest height we actually don't need any data structures, we simply store the vertices with the greatest height in a list, and recalculate the list once all of them are processed (then vertices with already lower height will be added to the list), or whenever a new vertex with excess and a greater height appears (after relabeling a vertex).\n\nDespite the simplicity, this modification reduces the complexity by a lot.\nTo be precise, the complexity of the resulting algorithm is $O(V E + V^2 \\sqrt{E})$, which in the worst case is $O(V^3)$.\n\nThis modification was proposed by Cheriyan and Maheshwari in 1989.\n\n## Implementation\n\n```{.cpp file=push_relabel_faster}\nconst int inf = 1000000000;\n\nint n;\nvector<vector<int>> capacity, flow;\nvector<int> height, excess;\n\nvoid push(int u, int v)\n{\n    int d = min(excess[u], capacity[u][v] - flow[u][v]);\n    flow[u][v] += d;\n    flow[v][u] -= d;\n    excess[u] -= d;\n    excess[v] += d;\n}\n\nvoid relabel(int u)\n{\n    int d = inf;\n    for (int i = 0; i < n; i++) {\n        if (capacity[u][i] - flow[u][i] > 0)\n            d = min(d, height[i]);\n    }\n    if (d < inf)\n        height[u] = d + 1;\n}\n\nvector<int> find_max_height_vertices(int s, int t) {\n    vector<int> max_height;\n    for (int i = 0; i < n; i++) {\n        if (i != s && i != t && excess[i] > 0) {\n            if (!max_height.empty() && height[i] > height[max_height[0]])\n                max_height.clear();\n            if (max_height.empty() || height[i] == height[max_height[0]])\n                max_height.push_back(i);\n        }\n    }\n    return max_height;\n}\n\nint max_flow(int s, int t)\n{\n    height.assign(n, 0);\n    height[s] = n;\n    flow.assign(n, vector<int>(n, 0));\n    excess.assign(n, 0);\n    excess[s] = inf;\n    for (int i = 0; i < n; i++) {\n        if (i != s)\n            push(s, i);\n    }\n\n    vector<int> current;\n    while (!(current = find_max_height_vertices(s, t)).empty()) {\n        for (int i : current) {\n            bool pushed = false;\n            for (int j = 0; j < n && excess[i]; j++) {\n                if (capacity[i][j] - flow[i][j] > 0 && height[i] == height[j] + 1) {\n                    push(i, j);\n                    pushed = true;\n                }\n            }\n            if (!pushed) {\n                relabel(i);\n                break;\n            }\n        }\n    }\n\n    int max_flow = 0;\n    for (int i = 0; i < n; i++)\n        max_flow += flow[i][t];\n    return max_flow;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: preflow_push_faster\n---\n\n# Maximum flow - Push-relabel method improved\n\nWe will modify the [push-relabel method](push-relabel.md) to achieve a better runtime.\n\n## Description\n\nThe modification is extremely simple:\nIn the previous article we chosen a vertex with excess without any particular rule.\nBut it turns out, that if we always choose the vertices with the **greatest height**, and apply push and relabel operations on them, then the complexity will become better.\nMoreover, to select the vertices with the greatest height we actually don't need any data structures, we simply store the vertices with the greatest height in a list, and recalculate the list once all of them are processed (then vertices with already lower height will be added to the list), or whenever a new vertex with excess and a greater height appears (after relabeling a vertex).\n\nDespite the simplicity, this modification reduces the complexity by a lot.\nTo be precise, the complexity of the resulting algorithm is $O(V E + V^2 \\sqrt{E})$, which in the worst case is $O(V^3)$.\n\nThis modification was proposed by Cheriyan and Maheshwari in 1989.\n\n## Implementation\n\n```{.cpp file=push_relabel_faster}\nconst int inf = 1000000000;\n\nint n;\nvector<vector<int>> capacity, flow;\nvector<int> height, excess;\n\nvoid push(int u, int v)\n{\n    int d = min(excess[u], capacity[u][v] - flow[u][v]);\n    flow[u][v] += d;\n    flow[v][u] -= d;\n    excess[u] -= d;\n    excess[v] += d;\n}\n\nvoid relabel(int u)\n{\n    int d = inf;\n    for (int i = 0; i < n; i++) {\n        if (capacity[u][i] - flow[u][i] > 0)\n            d = min(d, height[i]);\n    }\n    if (d < inf)\n        height[u] = d + 1;\n}\n\nvector<int> find_max_height_vertices(int s, int t) {\n    vector<int> max_height;\n    for (int i = 0; i < n; i++) {\n        if (i != s && i != t && excess[i] > 0) {\n            if (!max_height.empty() && height[i] > height[max_height[0]])\n                max_height.clear();\n            if (max_height.empty() || height[i] == height[max_height[0]])\n                max_height.push_back(i);\n        }\n    }\n    return max_height;\n}\n\nint max_flow(int s, int t)\n{\n    height.assign(n, 0);\n    height[s] = n;\n    flow.assign(n, vector<int>(n, 0));\n    excess.assign(n, 0);\n    excess[s] = inf;\n    for (int i = 0; i < n; i++) {\n        if (i != s)\n            push(s, i);\n    }\n\n    vector<int> current;\n    while (!(current = find_max_height_vertices(s, t)).empty()) {\n        for (int i : current) {\n            bool pushed = false;\n            for (int j = 0; j < n && excess[i]; j++) {\n                if (capacity[i][j] - flow[i][j] > 0 && height[i] == height[j] + 1) {\n                    push(i, j);\n                    pushed = true;\n                }\n            }\n            if (!pushed) {\n                relabel(i);\n                break;\n            }\n        }\n    }\n\n    int max_flow = 0;\n    for (int i = 0; i < n; i++)\n        max_flow += flow[i][t];\n    return max_flow;\n}\n```\n", "problem_ids": [], "title": "Maximum flow - Push-relabel method improved"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: ford_bellman\n---\n\n# Bellman-Ford Algorithm\n\n**Single source shortest path with negative weight edges**\n\nSuppose that we are given a weighted directed graph $G$ with $n$ vertices and $m$ edges, and some specified vertex $v$. You want to find the length of shortest paths from vertex $v$ to every other vertex.\n\nUnlike the Dijkstra algorithm, this algorithm can also be applied to graphs containing negative weight edges . However, if the graph contains a negative cycle, then, clearly, the shortest path to some vertices may not exist (due to the fact that the weight of the shortest path must be equal to minus infinity); however, this algorithm can be modified to signal the presence of a cycle of negative weight, or even deduce this cycle.\n\nThe algorithm bears the name of two American scientists: Richard Bellman and Lester Ford. Ford actually invented this algorithm in 1956 during the study of another mathematical problem, which eventually reduced to a subproblem of finding the shortest paths in the graph, and Ford gave an outline of the algorithm to solve this problem. Bellman in 1958 published an article devoted specifically to the problem of finding the shortest path, and in this article he clearly formulated the algorithm in the form in which it is known to us now.\n\n## Description of the algorithm\n\nLet us assume that the graph contains no negative weight cycle. The case of presence of a negative weight cycle will be discussed below in a separate section.\n\nWe will create an array of distances $d[0 \\ldots n-1]$, which after execution of the algorithm will contain the answer to the problem. In the beginning we fill it as follows: $d[v] = 0$, and all other elements $d[ ]$ equal to infinity $\\infty$.\n\nThe algorithm consists of several phases. Each phase scans through all edges of the graph, and the algorithm tries to produce **relaxation** along each edge $(a,b)$ having weight $c$. Relaxation along the edges is an attempt to improve the value $d[b]$ using value $d[a] + c$. In fact, it means that we are trying to improve the answer for this vertex using edge $(a,b)$ and current response for vertex $a$.\n\nIt is claimed that $n-1$ phases of the algorithm are sufficient to correctly calculate the lengths of all shortest paths in the graph (again, we believe that the cycles of negative weight do not exist). For unreachable vertices the distance $d[ ]$ will remain equal to infinity $\\infty$.\n\n## Implementation\n\nUnlike many other graph algorithms, for Bellman-Ford algorithm, it is more convenient to represent the graph using a single list of all edges (instead of $n$ lists of edges - edges from each vertex). We start the implementation with a structure $\\rm edge$ for representing the edges. The input to the algorithm are numbers $n$, $m$, list $e$ of edges and the starting vertex $v$. All the vertices are numbered $0$ to $n - 1$.\n\n### The simplest implementation\n\nThe constant $\\rm INF$ denotes the number \"infinity\" \u2014 it should be selected in such a way that it is greater than all possible path lengths.\n\n```cpp\nstruct Edge {\n    int a, b, cost;\n};\n\nint n, m, v;\nvector<Edge> edges;\nconst int INF = 1000000000;\n\nvoid solve()\n{\n    vector<int> d(n, INF);\n    d[v] = 0;\n    for (int i = 0; i < n - 1; ++i)\n        for (Edge e : edges)\n            if (d[e.a] < INF)\n                d[e.b] = min(d[e.b], d[e.a] + e.cost);\n    // display d, for example, on the screen\n}\n```\n\nThe check `if (d[e.a] < INF)` is needed only if the graph contains negative weight edges: no such verification would result in relaxation from the vertices to which paths have not yet found, and incorrect distance, of the type $\\infty - 1$, $\\infty - 2$ etc. would appear.\n\n### A better implementation\n\nThis algorithm can be somewhat speeded up: often we already get the answer in a few phases and no useful work is done in remaining phases, just a waste visiting all edges. So, let's keep the flag, to tell whether something changed in the current phase or not, and if any phase, nothing changed, the algorithm can be stopped. (This optimization does not improve the asymptotic behavior, i.e., some graphs will still need all $n-1$ phases, but significantly accelerates the behavior of the algorithm \"on an average\", i.e., on random graphs.)\n\nWith this optimization, it is generally unnecessary to restrict manually the number of phases of the algorithm to $n-1$ \u2014 the algorithm will stop after the desired number of phases.\n\n```cpp\nvoid solve()\n{\n    vector<int> d(n, INF);\n    d[v] = 0;\n    for (;;) {\n        bool any = false;\n\n        for (Edge e : edges)\n            if (d[e.a] < INF)\n                if (d[e.b] > d[e.a] + e.cost) {\n                    d[e.b] = d[e.a] + e.cost;\n                    any = true;\n                }\n\n        if (!any)\n            break;\n    }\n    // display d, for example, on the screen\n}\n```\n\n### Retrieving Path\n\nLet us now consider how to modify the algorithm so that it not only finds the length of shortest paths, but also allows to reconstruct the shortest paths.\n\nFor that, let's create another array $p[0 \\ldots n-1]$, where for each vertex we store its \"predecessor\", i.e. the penultimate vertex in the shortest path leading to it. In fact, the shortest path to any vertex $a$ is a shortest path to some vertex $p[a]$, to which we added $a$ at the end of the path.\n\nNote that the algorithm works on the same logic: it assumes that the shortest distance to one vertex is already calculated, and, tries to improve the shortest distance to other vertices from that vertex. Therefore, at the time of improvement we just need to remember $p[ ]$, i.e,  the vertex from which this improvement has occurred.\n\nFollowing is an implementation of the Bellman-Ford with the retrieval of shortest path to a given node $t$:\n\n```cpp\nvoid solve()\n{\n    vector<int> d(n, INF);\n    d[v] = 0;\n    vector<int> p(n, -1);\n\n    for (;;) {\n        bool any = false;\n        for (Edge e : edges)\n            if (d[e.a] < INF)\n                if (d[e.b] > d[e.a] + e.cost) {\n                    d[e.b] = d[e.a] + e.cost;\n                    p[e.b] = e.a;\n                    any = true;\n                }\n        if (!any)\n            break;\n    }\n\n    if (d[t] == INF)\n        cout << \"No path from \" << v << \" to \" << t << \".\";\n    else {\n        vector<int> path;\n        for (int cur = t; cur != -1; cur = p[cur])\n            path.push_back(cur);\n        reverse(path.begin(), path.end());\n\n        cout << \"Path from \" << v << \" to \" << t << \": \";\n        for (int u : path)\n            cout << u << ' ';\n    }\n}\n```\n\nHere starting from the vertex $t$, we go through the predecessors till we reach starting vertex with no predecessor, and store all the vertices in the path in the list $\\rm path$. This list is a shortest path from $v$ to $t$, but in reverse order, so we call $\\rm reverse()$ function over $\\rm path$ and then output the path.\n\n## The proof of the algorithm\n\nFirst, note that for all unreachable vertices $u$ the algorithm will work correctly, the label $d[u]$ will remain equal to infinity (because the algorithm Bellman-Ford will find some way to all reachable vertices from the start vertex $v$, and relaxation for all other  remaining vertices will never happen).\n\nLet us now prove the following assertion: After the execution of $i_{th}$ phase, the Bellman-Ford algorithm correctly finds all shortest paths whose number of edges does not exceed $i$.\n\nIn other words, for any vertex $a$ let us denote the $k$ number of edges in the shortest path to it (if there are several such paths, you can take any). According to this statement, the algorithm guarantees that after $k_{th}$ phase the shortest path for vertex $a$ will be found.\n\n**Proof**:\nConsider an arbitrary vertex $a$ to which there is a path from the starting vertex $v$, and consider a shortest path to it $(p_0=v, p_1, \\ldots, p_k=a)$. Before the first phase, the shortest path to the vertex $p_0 = v$ was found correctly. During the first phase, the edge $(p_0,p_1)$ has been checked by the algorithm, and therefore, the distance to the vertex $p_1$ was correctly calculated after the first phase. Repeating this statement $k$ times, we see that after $k_{th}$ phase the distance to the vertex $p_k = a$ gets calculated correctly, which we wanted to prove.\n\nThe last thing to notice is that any shortest path cannot have more than $n - 1$ edges. Therefore, the algorithm sufficiently goes up to the $(n-1)_{th}$ phase. After that, it is guaranteed that no relaxation will improve the distance to some vertex.\n\n## The case of a negative cycle\n\nEverywhere above we considered that there is no negative cycle in the graph (precisely, we are interested in a negative cycle that is reachable from the starting vertex $v$, and, for an unreachable cycles nothing in the above algorithm changes). In the presence of a negative cycle(s), there are further complications associated with the fact that distances to all vertices in this cycle, as well as the distances to the vertices reachable from this cycle is not defined \u2014 they should be equal to minus infinity $(- \\infty)$.\n\nIt is easy to see that the Bellman-Ford algorithm can endlessly do the relaxation among all vertices of this cycle and the vertices reachable from it. Therefore, if you do not limit the number of phases to $n - 1$, the algorithm will run indefinitely, constantly improving the distance from these vertices.\n\nHence we obtain the **criterion for presence of a cycle of negative weights reachable for source vertex $v$**: after $(n-1)_{th}$ phase, if we run algorithm for one more phase, and it performs at least one more relaxation, then the graph contains a negative weight cycle that is reachable from $v$; otherwise, such a cycle does not exist.\n\nMoreover, if such a cycle is found, the Bellman-Ford algorithm can be modified so that it retrieves this cycle as a sequence of vertices contained in it. For this, it is sufficient to remember the last vertex $x$ for which there was a relaxation in $n_{th}$ phase. This vertex will either lie in a negative weight cycle, or is reachable from it. To get the vertices that are guaranteed to lie in a negative cycle, starting from the vertex $x$, pass through to the predecessors $n$ times. Hence we will get the vertex $y$, namely the vertex in the cycle earliest reachable from source. We have to go from this vertex, through the predecessors, until we get back to the same vertex $y$ (and it will happen, because relaxation in a negative weight cycle occur in a circular manner).\n\n### Implementation:\n\n```cpp\nvoid solve()\n{\n    vector<int> d(n, INF);\n    d[v] = 0;\n    vector<int> p(n, -1);\n    int x;\n    for (int i = 0; i < n; ++i) {\n        x = -1;\n        for (Edge e : edges)\n            if (d[e.a] < INF)\n                if (d[e.b] > d[e.a] + e.cost) {\n                    d[e.b] = max(-INF, d[e.a] + e.cost);\n                    p[e.b] = e.a;\n                    x = e.b;\n                }\n    }\n\n    if (x == -1)\n        cout << \"No negative cycle from \" << v;\n    else {\n        int y = x;\n        for (int i = 0; i < n; ++i)\n            y = p[y];\n\n        vector<int> path;\n        for (int cur = y;; cur = p[cur]) {\n            path.push_back(cur);\n            if (cur == y && path.size() > 1)\n                break;\n        }\n        reverse(path.begin(), path.end());\n\n        cout << \"Negative cycle: \";\n        for (int u : path)\n            cout << u << ' ';\n    }\n}\n```\n\nDue to the presence of a negative cycle, for $n$ iterations of the algorithm, the distances may go far in the negative range (to negative numbers of the order of $-n m W$, where $W$ is the maximum absolute value of any weight in the graph). Hence in the code, we adopted additional measures against the integer overflow as follows:\n\n```cpp\nd[e.b] = max(-INF, d[e.a] + e.cost);\n```\n\nThe above implementation looks for a negative cycle reachable from some starting vertex $v$; however, the algorithm can be modified to just looking for any negative cycle in the graph. For this we need to put all the distance $d[i]$ to zero and not infinity \u2014 as if we are looking for the shortest path from all vertices simultaneously; the validity of the detection of a negative cycle is not affected.\n\nFor more on this topic \u2014 see separate article, [Finding a negative cycle in the graph](finding-negative-cycle-in-graph.md).\n\n## Shortest Path Faster Algorithm (SPFA)\n\nSPFA is a improvement of the Bellman-Ford algorithm which takes advantage of the fact that not all attempts at relaxation will work.\nThe main idea is to create a queue containing only the vertices that were relaxed but that still could further relax their neighbors.\nAnd whenever you can relax some neighbor, you should put him in the queue. This algorithm can also be used to detect negative cycles as the Bellman-Ford.\n\nThe worst case of this algorithm is equal to the $O(n m)$ of the Bellman-Ford, but in practice it works much faster and some [people claim that it works even in $O(m)$ on average](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm#Average-case_performance). However be careful, because this algorithm is deterministic and it is easy to create counterexamples that make the algorithm run in $O(n m)$.\n\nThere are some care to be taken in the implementation, such as the fact that the algorithm continues forever if there is a negative cycle.\nTo avoid this, it is possible to create a counter that stores how many times a vertex has been relaxed and stop the algorithm as soon as some vertex got relaxed for the $n$-th time.\nNote, also there is no reason to put a vertex in the queue if it is already in.\n\n```{.cpp file=spfa}\nconst int INF = 1000000000;\nvector<vector<pair<int, int>>> adj;\n\nbool spfa(int s, vector<int>& d) {\n    int n = adj.size();\n    d.assign(n, INF);\n    vector<int> cnt(n, 0);\n    vector<bool> inqueue(n, false);\n    queue<int> q;\n\n    d[s] = 0;\n    q.push(s);\n    inqueue[s] = true;\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        inqueue[v] = false;\n\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n\n            if (d[v] + len < d[to]) {\n                d[to] = d[v] + len;\n                if (!inqueue[to]) {\n                    q.push(to);\n                    inqueue[to] = true;\n                    cnt[to]++;\n                    if (cnt[to] > n)\n                        return false;  // negative cycle\n                }\n            }\n        }\n    }\n    return true;\n}\n```\n\n\n## Related problems in online judges\n\nA list of tasks that can be solved using the Bellman-Ford algorithm:\n\n* [E-OLYMP #1453 \"Ford-Bellman\" [difficulty: low]](https://www.e-olymp.com/en/problems/1453)\n* [UVA #423 \"MPI Maelstrom\" [difficulty: low]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=364)\n* [UVA #534 \"Frogger\" [difficulty: medium]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=7&page=show_problem&problem=475)\n* [UVA #10099 \"The Tourist Guide\" [difficulty: medium]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=12&page=show_problem&problem=1040)\n* [UVA #515 \"King\" [difficulty: medium]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=456)\n* [UVA 12519 - The Farnsworth Parabox](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3964)\n\nSee also the problem list in the article [Finding the negative cycle in a graph](finding-negative-cycle-in-graph.md).\n* [CSES - High Score](https://cses.fi/problemset/task/1673)\n* [CSES - Cycle Finding](https://cses.fi/problemset/task/1197)\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: ford_bellman\n---\n\n# Bellman-Ford Algorithm\n\n**Single source shortest path with negative weight edges**\n\nSuppose that we are given a weighted directed graph $G$ with $n$ vertices and $m$ edges, and some specified vertex $v$. You want to find the length of shortest paths from vertex $v$ to every other vertex.\n\nUnlike the Dijkstra algorithm, this algorithm can also be applied to graphs containing negative weight edges . However, if the graph contains a negative cycle, then, clearly, the shortest path to some vertices may not exist (due to the fact that the weight of the shortest path must be equal to minus infinity); however, this algorithm can be modified to signal the presence of a cycle of negative weight, or even deduce this cycle.\n\nThe algorithm bears the name of two American scientists: Richard Bellman and Lester Ford. Ford actually invented this algorithm in 1956 during the study of another mathematical problem, which eventually reduced to a subproblem of finding the shortest paths in the graph, and Ford gave an outline of the algorithm to solve this problem. Bellman in 1958 published an article devoted specifically to the problem of finding the shortest path, and in this article he clearly formulated the algorithm in the form in which it is known to us now.\n\n## Description of the algorithm\n\nLet us assume that the graph contains no negative weight cycle. The case of presence of a negative weight cycle will be discussed below in a separate section.\n\nWe will create an array of distances $d[0 \\ldots n-1]$, which after execution of the algorithm will contain the answer to the problem. In the beginning we fill it as follows: $d[v] = 0$, and all other elements $d[ ]$ equal to infinity $\\infty$.\n\nThe algorithm consists of several phases. Each phase scans through all edges of the graph, and the algorithm tries to produce **relaxation** along each edge $(a,b)$ having weight $c$. Relaxation along the edges is an attempt to improve the value $d[b]$ using value $d[a] + c$. In fact, it means that we are trying to improve the answer for this vertex using edge $(a,b)$ and current response for vertex $a$.\n\nIt is claimed that $n-1$ phases of the algorithm are sufficient to correctly calculate the lengths of all shortest paths in the graph (again, we believe that the cycles of negative weight do not exist). For unreachable vertices the distance $d[ ]$ will remain equal to infinity $\\infty$.\n\n## Implementation\n\nUnlike many other graph algorithms, for Bellman-Ford algorithm, it is more convenient to represent the graph using a single list of all edges (instead of $n$ lists of edges - edges from each vertex). We start the implementation with a structure $\\rm edge$ for representing the edges. The input to the algorithm are numbers $n$, $m$, list $e$ of edges and the starting vertex $v$. All the vertices are numbered $0$ to $n - 1$.\n\n### The simplest implementation\n\nThe constant $\\rm INF$ denotes the number \"infinity\" \u2014 it should be selected in such a way that it is greater than all possible path lengths.\n\n```cpp\nstruct Edge {\n    int a, b, cost;\n};\n\nint n, m, v;\nvector<Edge> edges;\nconst int INF = 1000000000;\n\nvoid solve()\n{\n    vector<int> d(n, INF);\n    d[v] = 0;\n    for (int i = 0; i < n - 1; ++i)\n        for (Edge e : edges)\n            if (d[e.a] < INF)\n                d[e.b] = min(d[e.b], d[e.a] + e.cost);\n    // display d, for example, on the screen\n}\n```\n\nThe check `if (d[e.a] < INF)` is needed only if the graph contains negative weight edges: no such verification would result in relaxation from the vertices to which paths have not yet found, and incorrect distance, of the type $\\infty - 1$, $\\infty - 2$ etc. would appear.\n\n### A better implementation\n\nThis algorithm can be somewhat speeded up: often we already get the answer in a few phases and no useful work is done in remaining phases, just a waste visiting all edges. So, let's keep the flag, to tell whether something changed in the current phase or not, and if any phase, nothing changed, the algorithm can be stopped. (This optimization does not improve the asymptotic behavior, i.e., some graphs will still need all $n-1$ phases, but significantly accelerates the behavior of the algorithm \"on an average\", i.e., on random graphs.)\n\nWith this optimization, it is generally unnecessary to restrict manually the number of phases of the algorithm to $n-1$ \u2014 the algorithm will stop after the desired number of phases.\n\n```cpp\nvoid solve()\n{\n    vector<int> d(n, INF);\n    d[v] = 0;\n    for (;;) {\n        bool any = false;\n\n        for (Edge e : edges)\n            if (d[e.a] < INF)\n                if (d[e.b] > d[e.a] + e.cost) {\n                    d[e.b] = d[e.a] + e.cost;\n                    any = true;\n                }\n\n        if (!any)\n            break;\n    }\n    // display d, for example, on the screen\n}\n```\n\n### Retrieving Path\n\nLet us now consider how to modify the algorithm so that it not only finds the length of shortest paths, but also allows to reconstruct the shortest paths.\n\nFor that, let's create another array $p[0 \\ldots n-1]$, where for each vertex we store its \"predecessor\", i.e. the penultimate vertex in the shortest path leading to it. In fact, the shortest path to any vertex $a$ is a shortest path to some vertex $p[a]$, to which we added $a$ at the end of the path.\n\nNote that the algorithm works on the same logic: it assumes that the shortest distance to one vertex is already calculated, and, tries to improve the shortest distance to other vertices from that vertex. Therefore, at the time of improvement we just need to remember $p[ ]$, i.e,  the vertex from which this improvement has occurred.\n\nFollowing is an implementation of the Bellman-Ford with the retrieval of shortest path to a given node $t$:\n\n```cpp\nvoid solve()\n{\n    vector<int> d(n, INF);\n    d[v] = 0;\n    vector<int> p(n, -1);\n\n    for (;;) {\n        bool any = false;\n        for (Edge e : edges)\n            if (d[e.a] < INF)\n                if (d[e.b] > d[e.a] + e.cost) {\n                    d[e.b] = d[e.a] + e.cost;\n                    p[e.b] = e.a;\n                    any = true;\n                }\n        if (!any)\n            break;\n    }\n\n    if (d[t] == INF)\n        cout << \"No path from \" << v << \" to \" << t << \".\";\n    else {\n        vector<int> path;\n        for (int cur = t; cur != -1; cur = p[cur])\n            path.push_back(cur);\n        reverse(path.begin(), path.end());\n\n        cout << \"Path from \" << v << \" to \" << t << \": \";\n        for (int u : path)\n            cout << u << ' ';\n    }\n}\n```\n\nHere starting from the vertex $t$, we go through the predecessors till we reach starting vertex with no predecessor, and store all the vertices in the path in the list $\\rm path$. This list is a shortest path from $v$ to $t$, but in reverse order, so we call $\\rm reverse()$ function over $\\rm path$ and then output the path.\n\n## The proof of the algorithm\n\nFirst, note that for all unreachable vertices $u$ the algorithm will work correctly, the label $d[u]$ will remain equal to infinity (because the algorithm Bellman-Ford will find some way to all reachable vertices from the start vertex $v$, and relaxation for all other  remaining vertices will never happen).\n\nLet us now prove the following assertion: After the execution of $i_{th}$ phase, the Bellman-Ford algorithm correctly finds all shortest paths whose number of edges does not exceed $i$.\n\nIn other words, for any vertex $a$ let us denote the $k$ number of edges in the shortest path to it (if there are several such paths, you can take any). According to this statement, the algorithm guarantees that after $k_{th}$ phase the shortest path for vertex $a$ will be found.\n\n**Proof**:\nConsider an arbitrary vertex $a$ to which there is a path from the starting vertex $v$, and consider a shortest path to it $(p_0=v, p_1, \\ldots, p_k=a)$. Before the first phase, the shortest path to the vertex $p_0 = v$ was found correctly. During the first phase, the edge $(p_0,p_1)$ has been checked by the algorithm, and therefore, the distance to the vertex $p_1$ was correctly calculated after the first phase. Repeating this statement $k$ times, we see that after $k_{th}$ phase the distance to the vertex $p_k = a$ gets calculated correctly, which we wanted to prove.\n\nThe last thing to notice is that any shortest path cannot have more than $n - 1$ edges. Therefore, the algorithm sufficiently goes up to the $(n-1)_{th}$ phase. After that, it is guaranteed that no relaxation will improve the distance to some vertex.\n\n## The case of a negative cycle\n\nEverywhere above we considered that there is no negative cycle in the graph (precisely, we are interested in a negative cycle that is reachable from the starting vertex $v$, and, for an unreachable cycles nothing in the above algorithm changes). In the presence of a negative cycle(s), there are further complications associated with the fact that distances to all vertices in this cycle, as well as the distances to the vertices reachable from this cycle is not defined \u2014 they should be equal to minus infinity $(- \\infty)$.\n\nIt is easy to see that the Bellman-Ford algorithm can endlessly do the relaxation among all vertices of this cycle and the vertices reachable from it. Therefore, if you do not limit the number of phases to $n - 1$, the algorithm will run indefinitely, constantly improving the distance from these vertices.\n\nHence we obtain the **criterion for presence of a cycle of negative weights reachable for source vertex $v$**: after $(n-1)_{th}$ phase, if we run algorithm for one more phase, and it performs at least one more relaxation, then the graph contains a negative weight cycle that is reachable from $v$; otherwise, such a cycle does not exist.\n\nMoreover, if such a cycle is found, the Bellman-Ford algorithm can be modified so that it retrieves this cycle as a sequence of vertices contained in it. For this, it is sufficient to remember the last vertex $x$ for which there was a relaxation in $n_{th}$ phase. This vertex will either lie in a negative weight cycle, or is reachable from it. To get the vertices that are guaranteed to lie in a negative cycle, starting from the vertex $x$, pass through to the predecessors $n$ times. Hence we will get the vertex $y$, namely the vertex in the cycle earliest reachable from source. We have to go from this vertex, through the predecessors, until we get back to the same vertex $y$ (and it will happen, because relaxation in a negative weight cycle occur in a circular manner).\n\n### Implementation:\n\n```cpp\nvoid solve()\n{\n    vector<int> d(n, INF);\n    d[v] = 0;\n    vector<int> p(n, -1);\n    int x;\n    for (int i = 0; i < n; ++i) {\n        x = -1;\n        for (Edge e : edges)\n            if (d[e.a] < INF)\n                if (d[e.b] > d[e.a] + e.cost) {\n                    d[e.b] = max(-INF, d[e.a] + e.cost);\n                    p[e.b] = e.a;\n                    x = e.b;\n                }\n    }\n\n    if (x == -1)\n        cout << \"No negative cycle from \" << v;\n    else {\n        int y = x;\n        for (int i = 0; i < n; ++i)\n            y = p[y];\n\n        vector<int> path;\n        for (int cur = y;; cur = p[cur]) {\n            path.push_back(cur);\n            if (cur == y && path.size() > 1)\n                break;\n        }\n        reverse(path.begin(), path.end());\n\n        cout << \"Negative cycle: \";\n        for (int u : path)\n            cout << u << ' ';\n    }\n}\n```\n\nDue to the presence of a negative cycle, for $n$ iterations of the algorithm, the distances may go far in the negative range (to negative numbers of the order of $-n m W$, where $W$ is the maximum absolute value of any weight in the graph). Hence in the code, we adopted additional measures against the integer overflow as follows:\n\n```cpp\nd[e.b] = max(-INF, d[e.a] + e.cost);\n```\n\nThe above implementation looks for a negative cycle reachable from some starting vertex $v$; however, the algorithm can be modified to just looking for any negative cycle in the graph. For this we need to put all the distance $d[i]$ to zero and not infinity \u2014 as if we are looking for the shortest path from all vertices simultaneously; the validity of the detection of a negative cycle is not affected.\n\nFor more on this topic \u2014 see separate article, [Finding a negative cycle in the graph](finding-negative-cycle-in-graph.md).\n\n## Shortest Path Faster Algorithm (SPFA)\n\nSPFA is a improvement of the Bellman-Ford algorithm which takes advantage of the fact that not all attempts at relaxation will work.\nThe main idea is to create a queue containing only the vertices that were relaxed but that still could further relax their neighbors.\nAnd whenever you can relax some neighbor, you should put him in the queue. This algorithm can also be used to detect negative cycles as the Bellman-Ford.\n\nThe worst case of this algorithm is equal to the $O(n m)$ of the Bellman-Ford, but in practice it works much faster and some [people claim that it works even in $O(m)$ on average](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm#Average-case_performance). However be careful, because this algorithm is deterministic and it is easy to create counterexamples that make the algorithm run in $O(n m)$.\n\nThere are some care to be taken in the implementation, such as the fact that the algorithm continues forever if there is a negative cycle.\nTo avoid this, it is possible to create a counter that stores how many times a vertex has been relaxed and stop the algorithm as soon as some vertex got relaxed for the $n$-th time.\nNote, also there is no reason to put a vertex in the queue if it is already in.\n\n```{.cpp file=spfa}\nconst int INF = 1000000000;\nvector<vector<pair<int, int>>> adj;\n\nbool spfa(int s, vector<int>& d) {\n    int n = adj.size();\n    d.assign(n, INF);\n    vector<int> cnt(n, 0);\n    vector<bool> inqueue(n, false);\n    queue<int> q;\n\n    d[s] = 0;\n    q.push(s);\n    inqueue[s] = true;\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        inqueue[v] = false;\n\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n\n            if (d[v] + len < d[to]) {\n                d[to] = d[v] + len;\n                if (!inqueue[to]) {\n                    q.push(to);\n                    inqueue[to] = true;\n                    cnt[to]++;\n                    if (cnt[to] > n)\n                        return false;  // negative cycle\n                }\n            }\n        }\n    }\n    return true;\n}\n```\n\n\n## Related problems in online judges\n\nA list of tasks that can be solved using the Bellman-Ford algorithm:\n\n* [E-OLYMP #1453 \"Ford-Bellman\" [difficulty: low]](https://www.e-olymp.com/en/problems/1453)\n* [UVA #423 \"MPI Maelstrom\" [difficulty: low]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=364)\n* [UVA #534 \"Frogger\" [difficulty: medium]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=7&page=show_problem&problem=475)\n* [UVA #10099 \"The Tourist Guide\" [difficulty: medium]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=12&page=show_problem&problem=1040)\n* [UVA #515 \"King\" [difficulty: medium]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=456)\n* [UVA 12519 - The Farnsworth Parabox](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3964)\n\nSee also the problem list in the article [Finding the negative cycle in a graph](finding-negative-cycle-in-graph.md).\n* [CSES - High Score](https://cses.fi/problemset/task/1673)\n* [CSES - Cycle Finding](https://cses.fi/problemset/task/1197)\n", "problem_ids": [], "title": "Bellman-Ford Algorithm"}, {"article": "---\ntags:\n  - Original\n---\n\n# 0-1 BFS\n\nIt is well-known, that you can find the shortest paths between a single source and all other vertices in $O(|E|)$ using [Breadth First Search](breadth-first-search.md) in an **unweighted graph**, i.e. the distance is the minimal number of edges that you need to traverse from the source to another vertex.\nWe can interpret such a graph also as a weighted graph, where every edge has the weight $1$.\nIf not all edges in graph have the same weight, that we need a more general algorithm, like [Dijkstra](dijkstra.md) which runs in $O(|V|^2 + |E|)$ or $O(|E| \\log |V|)$ time.\n\nHowever if the weights are more constrained, we can often do better.\nIn this article we demonstrate how we can use BFS to solve the SSSP (single-source shortest path) problem in $O(|E|)$, if the weight of each edge is either $0$ or $1$.\n\n## Algorithm\n\nWe can develop the algorithm by closely studying Dijkstra's algorithm and thinking about the consequences that our special graph implies.\nThe general form of Dijkstra's algorithm is (here a `set` is used for the priority queue):\n\n```cpp\nd.assign(n, INF);\nd[s] = 0;\nset<pair<int, int>> q;\nq.insert({0, s});\nwhile (!q.empty()) {\n    int v = q.begin()->second;\n    q.erase(q.begin());\n\n    for (auto edge : adj[v]) {\n        int u = edge.first;\n        int w = edge.second;\n\n        if (d[v] + w < d[u]) {\n            q.erase({d[u], u});\n            d[u] = d[v] + w;\n            q.insert({d[u], u});\n        }\n    }\n}\n```\n\nWe can notice that the difference between the distances between the source `s` and two other vertices in the queue differs by at most one.\nEspecially, we know that $d[v] \\le d[u] \\le d[v] + 1$ for each $u \\in Q$.\nThe reason for this is, that we only add vertices with equal distance or with distance plus one to the queue during each iteration.\nAssuming there exists a $u$ in the queue with $d[u] - d[v] > 1$, then $u$ must have been insert in the queue via a different vertex $t$ with $d[t] \\ge d[u] - 1 > d[v]$.\nHowever this is impossible, since Dijkstra's algorithm iterates over the vertices in increasing order.\n\nThis means, that the order of the queue looks like this:\n\n$$Q = \\underbrace{v}_{d[v]}, \\dots, \\underbrace{u}_{d[v]}, \\underbrace{m}_{d[v]+1} \\dots \\underbrace{n}_{d[v]+1}$$\n\nThis structure is so simple, that we don't need an actual priority queue, i.e. using a balanced binary tree would be an overkill.\nWe can simply use a normal queue, and append new vertices at the beginning if the corresponding edge has weight $0$, i.e. if $d[u] = d[v]$, or at the end if the edge has weight $1$, i.e. if $d[u] = d[v] + 1$.\nThis way the queue still remains sorted at all time.\n\n```cpp\nvector<int> d(n, INF);\nd[s] = 0;\ndeque<int> q;\nq.push_front(s);\nwhile (!q.empty()) {\n    int v = q.front();\n    q.pop_front();\n    for (auto edge : adj[v]) {\n        int u = edge.first;\n        int w = edge.second;\n        if (d[v] + w < d[u]) {\n            d[u] = d[v] + w;\n            if (w == 1)\n                q.push_back(u);\n            else\n                q.push_front(u);\n        }\n    }\n}\n```\n\n## Dial's algorithm\n\nWe can extend this even further if we allow the weights of the edges to be even bigger.\nIf every edge in the graph has a weight $\\le k$, then the distances of vertices in the queue will differ by at most $k$ from the distance of $v$ to the source.\nSo we can keep $k + 1$ buckets for the vertices in the queue, and whenever the bucket corresponding to the smallest distance gets empty, we make a cyclic shift to get the bucket with the next higher distance.\nThis extension is called **Dial's algorithm**.\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# 0-1 BFS\n\nIt is well-known, that you can find the shortest paths between a single source and all other vertices in $O(|E|)$ using [Breadth First Search](breadth-first-search.md) in an **unweighted graph**, i.e. the distance is the minimal number of edges that you need to traverse from the source to another vertex.\nWe can interpret such a graph also as a weighted graph, where every edge has the weight $1$.\nIf not all edges in graph have the same weight, that we need a more general algorithm, like [Dijkstra](dijkstra.md) which runs in $O(|V|^2 + |E|)$ or $O(|E| \\log |V|)$ time.\n\nHowever if the weights are more constrained, we can often do better.\nIn this article we demonstrate how we can use BFS to solve the SSSP (single-source shortest path) problem in $O(|E|)$, if the weight of each edge is either $0$ or $1$.\n\n## Algorithm\n\nWe can develop the algorithm by closely studying Dijkstra's algorithm and thinking about the consequences that our special graph implies.\nThe general form of Dijkstra's algorithm is (here a `set` is used for the priority queue):\n\n```cpp\nd.assign(n, INF);\nd[s] = 0;\nset<pair<int, int>> q;\nq.insert({0, s});\nwhile (!q.empty()) {\n    int v = q.begin()->second;\n    q.erase(q.begin());\n\n    for (auto edge : adj[v]) {\n        int u = edge.first;\n        int w = edge.second;\n\n        if (d[v] + w < d[u]) {\n            q.erase({d[u], u});\n            d[u] = d[v] + w;\n            q.insert({d[u], u});\n        }\n    }\n}\n```\n\nWe can notice that the difference between the distances between the source `s` and two other vertices in the queue differs by at most one.\nEspecially, we know that $d[v] \\le d[u] \\le d[v] + 1$ for each $u \\in Q$.\nThe reason for this is, that we only add vertices with equal distance or with distance plus one to the queue during each iteration.\nAssuming there exists a $u$ in the queue with $d[u] - d[v] > 1$, then $u$ must have been insert in the queue via a different vertex $t$ with $d[t] \\ge d[u] - 1 > d[v]$.\nHowever this is impossible, since Dijkstra's algorithm iterates over the vertices in increasing order.\n\nThis means, that the order of the queue looks like this:\n\n$$Q = \\underbrace{v}_{d[v]}, \\dots, \\underbrace{u}_{d[v]}, \\underbrace{m}_{d[v]+1} \\dots \\underbrace{n}_{d[v]+1}$$\n\nThis structure is so simple, that we don't need an actual priority queue, i.e. using a balanced binary tree would be an overkill.\nWe can simply use a normal queue, and append new vertices at the beginning if the corresponding edge has weight $0$, i.e. if $d[u] = d[v]$, or at the end if the edge has weight $1$, i.e. if $d[u] = d[v] + 1$.\nThis way the queue still remains sorted at all time.\n\n```cpp\nvector<int> d(n, INF);\nd[s] = 0;\ndeque<int> q;\nq.push_front(s);\nwhile (!q.empty()) {\n    int v = q.front();\n    q.pop_front();\n    for (auto edge : adj[v]) {\n        int u = edge.first;\n        int w = edge.second;\n        if (d[v] + w < d[u]) {\n            d[u] = d[v] + w;\n            if (w == 1)\n                q.push_back(u);\n            else\n                q.push_front(u);\n        }\n    }\n}\n```\n\n## Dial's algorithm\n\nWe can extend this even further if we allow the weights of the edges to be even bigger.\nIf every edge in the graph has a weight $\\le k$, then the distances of vertices in the queue will differ by at most $k$ from the distance of $v$ to the source.\nSo we can keep $k + 1$ buckets for the vertices in the queue, and whenever the bucket corresponding to the smallest distance gets empty, we make a cyclic shift to get the bucket with the next higher distance.\nThis extension is called **Dial's algorithm**.\n\n## Practice problems\n\n- [CodeChef - Chef and Reversing](https://www.codechef.com/problems/REVERSE)\n- [Labyrinth](https://codeforces.com/contest/1063/problem/B)\n- [KATHTHI](http://www.spoj.com/problems/KATHTHI/)\n- [DoNotTurn](https://community.topcoder.com/stat?c=problem_statement&pm=10337)\n- [Ocean Currents](https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2620)\n- [Olya and Energy Drinks](https://codeforces.com/problemset/problem/877/D)\n- [Three States](https://codeforces.com/problemset/problem/590/C)\n- [Colliding Traffic](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2621)\n- [CHamber of Secrets](https://codeforces.com/problemset/problem/173/B)\n- [Spiral Maximum](https://codeforces.com/problemset/problem/173/C)\n- [Minimum Cost to Make at Least One Valid Path in a Grid](https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid)\n", "problem_ids": [], "title": "0-1 BFS"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: heavy_light\n---\n\n# Heavy-light decomposition\n\n**Heavy-light decomposition** is a fairly general technique that allows us to effectively solve many problems that come down to **queries on a tree** .\n\n\n## Description\n\nLet there be a tree $G$ of $n$ vertices, with an arbitrary root.\n\nThe essence of this tree decomposition is to **split the tree into several paths** so that we can reach the root vertex from any $v$ by traversing at most $\\log n$ paths. In addition, none of these paths should intersect with another.\n\nIt is clear that if we find such a decomposition for any tree, it will allow us to reduce certain single queries of the form *\u201ccalculate something on the path from $a$ to $b$\u201d* to several queries of the type *\u201dcalculate something on the segment $[l, r]$ of the $k^{th}$ path\u201d*.\n\n\n### Construction algorithm\n\nWe calculate for each vertex $v$ the size of its subtree  $s(v)$, i.e. the number of vertices in the subtree of the vertex $v$ including itself.\n\nNext, consider all the edges leading to the children of a vertex $v$. We call an edge  **heavy** if it leads to a vertex $c$ such that:\n\n$$\ns(c) \\ge \\frac{s(v)}{2} \\iff \\text{edge }(v, c)\\text{ is heavy}\n$$\n\nAll other edges are labeled **light**.\n\nIt is obvious that at most one heavy edge can emanate from one vertex downward, because otherwise the vertex $v$ would have at least two children of size $\\ge \\frac{s(v)}{2}$, and therefore the size of subtree of $v$ would be too big, $s(v) \\ge 1 + 2 \\frac{s(v)}{2} > s(v)$, which leads to a contradiction.\n\nNow we will decompose the tree into disjoint paths. Consider all the vertices from which no heavy edges come down. We will go up from each such vertex until we reach the root of the tree or go through a light edge. As a result, we will get several paths which are made up of zero or more heavy edges plus one light edge. The path which has an end at the root is an exception to this and will not have a light edge. Let these be called **heavy paths** - these are the desired paths of heavy-light decomposition.\n\n\n### Proof of correctness\n\nFirst, we note that the heavy paths obtained by the algorithm will be **disjoint** . In fact, if two such paths have a common edge, it would imply that there are two heavy edges coming out of one vertex, which is impossible.\n\nSecondly, we will show that going down from the root of the tree to an arbitrary vertex, we will **change no more than $\\log n$ heavy paths along the way** . Moving down a light edge reduces the size of the current subtree to half or lower:\n\n$$\ns(c) < \\frac{s(v)}{2} \\iff \\text{edge }(v, c)\\text{ is light}\n$$\n\n\nThus, we can go through at most $\\log n$ light edges before subtree size reduces to one.\n\nSince we can move from one heavy path to another only through a light edge (each heavy path, except the one starting at the root, has one light edge), we cannot change heavy paths more than $\\log n$ times along the path from the root to any vertex, as required.\n\n\nThe following image illustrates the decomposition of a sample tree. The heavy edges are thicker than the light edges. The heavy paths are marked by dotted boundaries.\n\n<center>![Image of HLD](hld.png)</center>\n\n\n## Sample problems\n\nWhen solving problems, it is sometimes more convenient to consider the heavy-light decomposition as a set of **vertex disjoint** paths (rather than edge disjoint paths). To do this, it suffices to exclude the last edge from each heavy path if it is a light edge, then no properties are violated, but now each vertex belongs to exactly one heavy path.\n\nBelow we will look at some typical tasks that can be solved with the help of heavy-light decomposition.\n\nSeparately, it is worth paying attention to the problem of the **sum of numbers on the path**, since this is an example of a problem that can be solved by simpler techniques.\n\n\n### Maximum value on the path between two vertices\n\nGiven a tree, each vertex is assigned a value. There are queries of the form $(a, b)$, where $a$ and $b$ are two vertices in the tree, and it is required to find the maximum value on the path between the vertices $a$ and $b$.\n\nWe construct in advance a heavy-light decomposition of the tree. Over each heavy path we will construct a [segment tree](../data_structures/segment_tree.md), which will allow us to search for a vertex with the maximum assigned value in the specified segment of the specified heavy path in $\\mathcal{O}(\\log n)$.  Although the number of heavy paths in heavy-light decomposition can reach $n - 1$, the total size of all paths is bounded by $\\mathcal{O}(n)$, therefore the total size of the segment trees will also be linear.\n\nIn order to answer a query $(a, b)$, we find the [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor) of $a$ and $b$ as $l$, by any preferred method. Now the task has been reduced to two queries $(a, l)$ and $(b, l)$, for each of which we can do the following: find the heavy path that the lower vertex lies in, make a query on this path, move to the top of this path, again determine which heavy path we are on and make a query on it, and so on, until we get to the path containing $l$.\n\nOne should be careful with the case when, for example, $a$ and $l$ are on the same heavy path - then the maximum query on this path should be done not on any prefix, but on the internal section between $a$ and $l$.\n\nResponding to the subqueries $(a, l)$ and $(b, l)$ each requires going through $\\mathcal{O}(\\log n)$ heavy paths and for each path a maximum query is made on some section of the path, which again requires $\\mathcal{O}(\\log n)$ operations in the segment tree.\nHence, one query $(a, b)$ takes $\\mathcal{O}(\\log^2 n)$ time.\n\nIf you additionally calculate and store maximums of all prefixes for each heavy path, then you get a $\\mathcal{O}(\\log n)$ solution because all maximum queries are on prefixes except at most once when we reach the ancestor $l$.\n\n\n###  Sum of the numbers on the path between two vertices\n\nGiven a tree, each vertex is assigned a value. There are queries of the form $(a, b)$, where $a$ and $b$ are two vertices in the tree, and it is required to find the sum of the values on the path between the vertices $a$ and $b$. A variant of this task is possible where additionally there are update operations that change the number assigned to one or more vertices.\n\nThis task can be solved similar to the previous problem of maximums with the help of heavy-light decomposition by building segment trees on heavy paths. Prefix sums can be used instead if there are no updates. However, this problem can be solved by simpler techniques too.\n\nIf there are no updates, then it is possible to find out the sum on the path between two vertices in parallel with the LCA search of two vertices by [binary lifting](lca_binary_lifting.md) \u2014 for this, along with the $2^k$-th ancestors of each vertex it is also necessary to store the sum on the paths up to those ancestors during the preprocessing.\n\nThere is a fundamentally different approach to this problem - to consider the [Euler tour](https://en.wikipedia.org/wiki/Euler_tour_technique) of the tree, and build a segment tree on it. This algorithm is considered in an [article about a similar problem](tree_painting.md). Again, if there are no updates, storing prefix sums is enough and a segment tree is not required.\n\nBoth of these methods provide relatively simple solutions taking $\\mathcal{O}(\\log n)$ for one query.\n\n### Repainting the edges of the path between two vertices\n\nGiven a tree, each edge is initially painted white. There are updates of the form $(a, b, c)$, where $a$ and $b$ are two vertices and $c$ is a color, which instructs that all the edges on the path from $a$ to $b$ must be repainted with color $c$. After all repaintings, it is required to report how many edges of each color were obtained.\n\nSimilar to the above problems, the solution is to simply apply heavy-light decomposition and make a [segment tree](../data_structures/segment_tree.md) over each heavy path.\n\nEach repainting on the path $(a, b)$ will turn into two updates $(a, l)$ and $(b, l)$, where $l$ is the lowest common ancestor of the vertices $a$ and $b$.   \n$\\mathcal{O}(\\log n)$ per path for $\\mathcal{O}(\\log n)$ paths leads to a complexity of $\\mathcal{O}(\\log^2 n)$ per update.\n\n## Implementation\n\nCertain parts of the above discussed approach can be modified to make implementation easier without losing efficiency.\n\n* The definition of **heavy edge** can be changed to **the edge leading to the child with largest subtree**, with ties broken arbitrarily. This may result is some light edges being converted to heavy, which means some heavy paths will combine to form a single path, but all heavy paths will remain disjoint. It is also still guaranteed that going down a light edge reduces subtree size to half or less.\n* Instead of a building segment tree over every heavy path, a single segment tree can be used with disjoint segments allocated to each heavy path.\n* It has been mentioned that answering queries requires calculation of the LCA. While LCA can be calculated separately, it is also possible to integrate LCA calculation in the process of answering queries.\n\nTo perform heavy-light decomposition:\n\n```cpp\nvector<int> parent, depth, heavy, head, pos;\nint cur_pos;\n\nint dfs(int v, vector<vector<int>> const& adj) {\n    int size = 1;\n    int max_c_size = 0;\n    for (int c : adj[v]) {\n        if (c != parent[v]) {\n            parent[c] = v, depth[c] = depth[v] + 1;\n            int c_size = dfs(c, adj);\n            size += c_size;\n            if (c_size > max_c_size)\n                max_c_size = c_size, heavy[v] = c;\n        }\n    }\n    return size;\n}\n\nvoid decompose(int v, int h, vector<vector<int>> const& adj) {\n    head[v] = h, pos[v] = cur_pos++;\n    if (heavy[v] != -1)\n        decompose(heavy[v], h, adj);\n    for (int c : adj[v]) {\n        if (c != parent[v] && c != heavy[v])\n            decompose(c, c, adj);\n    }\n}\n\nvoid init(vector<vector<int>> const& adj) {\n    int n = adj.size();\n    parent = vector<int>(n);\n    depth = vector<int>(n);\n    heavy = vector<int>(n, -1);\n    head = vector<int>(n);\n    pos = vector<int>(n);\n    cur_pos = 0;\n\n    dfs(0, adj);\n    decompose(0, 0, adj);\n}\n```\n\nThe adjacency list of the tree must be passed to the `init` function, and decomposition is performed assuming vertex `0` as root.\n\nThe `dfs` function is used to calculate `heavy[v]`, the child at the other end of the heavy edge from `v`, for every vertex `v`. Additionally `dfs` also stores the parent and depth of each vertex, which will be useful later during queries.\n\nThe `decompose` function assigns for each vertex `v` the values `head[v]` and `pos[v]`, which are respectively the head of the heavy path `v` belongs to and the position of `v` on the single segment tree that covers all vertices.\n\nTo answer queries on paths, for example the maximum query discussed, we can do something like this:\n\n```cpp\nint query(int a, int b) {\n    int res = 0;\n    for (; head[a] != head[b]; b = parent[head[b]]) {\n        if (depth[head[a]] > depth[head[b]])\n            swap(a, b);\n        int cur_heavy_path_max = segment_tree_query(pos[head[b]], pos[b]);\n        res = max(res, cur_heavy_path_max);\n    }\n    if (depth[a] > depth[b])\n        swap(a, b);\n    int last_heavy_path_max = segment_tree_query(pos[a], pos[b]);\n    res = max(res, last_heavy_path_max);\n    return res;\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: heavy_light\n---\n\n# Heavy-light decomposition\n\n**Heavy-light decomposition** is a fairly general technique that allows us to effectively solve many problems that come down to **queries on a tree** .\n\n\n## Description\n\nLet there be a tree $G$ of $n$ vertices, with an arbitrary root.\n\nThe essence of this tree decomposition is to **split the tree into several paths** so that we can reach the root vertex from any $v$ by traversing at most $\\log n$ paths. In addition, none of these paths should intersect with another.\n\nIt is clear that if we find such a decomposition for any tree, it will allow us to reduce certain single queries of the form *\u201ccalculate something on the path from $a$ to $b$\u201d* to several queries of the type *\u201dcalculate something on the segment $[l, r]$ of the $k^{th}$ path\u201d*.\n\n\n### Construction algorithm\n\nWe calculate for each vertex $v$ the size of its subtree  $s(v)$, i.e. the number of vertices in the subtree of the vertex $v$ including itself.\n\nNext, consider all the edges leading to the children of a vertex $v$. We call an edge  **heavy** if it leads to a vertex $c$ such that:\n\n$$\ns(c) \\ge \\frac{s(v)}{2} \\iff \\text{edge }(v, c)\\text{ is heavy}\n$$\n\nAll other edges are labeled **light**.\n\nIt is obvious that at most one heavy edge can emanate from one vertex downward, because otherwise the vertex $v$ would have at least two children of size $\\ge \\frac{s(v)}{2}$, and therefore the size of subtree of $v$ would be too big, $s(v) \\ge 1 + 2 \\frac{s(v)}{2} > s(v)$, which leads to a contradiction.\n\nNow we will decompose the tree into disjoint paths. Consider all the vertices from which no heavy edges come down. We will go up from each such vertex until we reach the root of the tree or go through a light edge. As a result, we will get several paths which are made up of zero or more heavy edges plus one light edge. The path which has an end at the root is an exception to this and will not have a light edge. Let these be called **heavy paths** - these are the desired paths of heavy-light decomposition.\n\n\n### Proof of correctness\n\nFirst, we note that the heavy paths obtained by the algorithm will be **disjoint** . In fact, if two such paths have a common edge, it would imply that there are two heavy edges coming out of one vertex, which is impossible.\n\nSecondly, we will show that going down from the root of the tree to an arbitrary vertex, we will **change no more than $\\log n$ heavy paths along the way** . Moving down a light edge reduces the size of the current subtree to half or lower:\n\n$$\ns(c) < \\frac{s(v)}{2} \\iff \\text{edge }(v, c)\\text{ is light}\n$$\n\n\nThus, we can go through at most $\\log n$ light edges before subtree size reduces to one.\n\nSince we can move from one heavy path to another only through a light edge (each heavy path, except the one starting at the root, has one light edge), we cannot change heavy paths more than $\\log n$ times along the path from the root to any vertex, as required.\n\n\nThe following image illustrates the decomposition of a sample tree. The heavy edges are thicker than the light edges. The heavy paths are marked by dotted boundaries.\n\n<center>![Image of HLD](hld.png)</center>\n\n\n## Sample problems\n\nWhen solving problems, it is sometimes more convenient to consider the heavy-light decomposition as a set of **vertex disjoint** paths (rather than edge disjoint paths). To do this, it suffices to exclude the last edge from each heavy path if it is a light edge, then no properties are violated, but now each vertex belongs to exactly one heavy path.\n\nBelow we will look at some typical tasks that can be solved with the help of heavy-light decomposition.\n\nSeparately, it is worth paying attention to the problem of the **sum of numbers on the path**, since this is an example of a problem that can be solved by simpler techniques.\n\n\n### Maximum value on the path between two vertices\n\nGiven a tree, each vertex is assigned a value. There are queries of the form $(a, b)$, where $a$ and $b$ are two vertices in the tree, and it is required to find the maximum value on the path between the vertices $a$ and $b$.\n\nWe construct in advance a heavy-light decomposition of the tree. Over each heavy path we will construct a [segment tree](../data_structures/segment_tree.md), which will allow us to search for a vertex with the maximum assigned value in the specified segment of the specified heavy path in $\\mathcal{O}(\\log n)$.  Although the number of heavy paths in heavy-light decomposition can reach $n - 1$, the total size of all paths is bounded by $\\mathcal{O}(n)$, therefore the total size of the segment trees will also be linear.\n\nIn order to answer a query $(a, b)$, we find the [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor) of $a$ and $b$ as $l$, by any preferred method. Now the task has been reduced to two queries $(a, l)$ and $(b, l)$, for each of which we can do the following: find the heavy path that the lower vertex lies in, make a query on this path, move to the top of this path, again determine which heavy path we are on and make a query on it, and so on, until we get to the path containing $l$.\n\nOne should be careful with the case when, for example, $a$ and $l$ are on the same heavy path - then the maximum query on this path should be done not on any prefix, but on the internal section between $a$ and $l$.\n\nResponding to the subqueries $(a, l)$ and $(b, l)$ each requires going through $\\mathcal{O}(\\log n)$ heavy paths and for each path a maximum query is made on some section of the path, which again requires $\\mathcal{O}(\\log n)$ operations in the segment tree.\nHence, one query $(a, b)$ takes $\\mathcal{O}(\\log^2 n)$ time.\n\nIf you additionally calculate and store maximums of all prefixes for each heavy path, then you get a $\\mathcal{O}(\\log n)$ solution because all maximum queries are on prefixes except at most once when we reach the ancestor $l$.\n\n\n###  Sum of the numbers on the path between two vertices\n\nGiven a tree, each vertex is assigned a value. There are queries of the form $(a, b)$, where $a$ and $b$ are two vertices in the tree, and it is required to find the sum of the values on the path between the vertices $a$ and $b$. A variant of this task is possible where additionally there are update operations that change the number assigned to one or more vertices.\n\nThis task can be solved similar to the previous problem of maximums with the help of heavy-light decomposition by building segment trees on heavy paths. Prefix sums can be used instead if there are no updates. However, this problem can be solved by simpler techniques too.\n\nIf there are no updates, then it is possible to find out the sum on the path between two vertices in parallel with the LCA search of two vertices by [binary lifting](lca_binary_lifting.md) \u2014 for this, along with the $2^k$-th ancestors of each vertex it is also necessary to store the sum on the paths up to those ancestors during the preprocessing.\n\nThere is a fundamentally different approach to this problem - to consider the [Euler tour](https://en.wikipedia.org/wiki/Euler_tour_technique) of the tree, and build a segment tree on it. This algorithm is considered in an [article about a similar problem](tree_painting.md). Again, if there are no updates, storing prefix sums is enough and a segment tree is not required.\n\nBoth of these methods provide relatively simple solutions taking $\\mathcal{O}(\\log n)$ for one query.\n\n### Repainting the edges of the path between two vertices\n\nGiven a tree, each edge is initially painted white. There are updates of the form $(a, b, c)$, where $a$ and $b$ are two vertices and $c$ is a color, which instructs that all the edges on the path from $a$ to $b$ must be repainted with color $c$. After all repaintings, it is required to report how many edges of each color were obtained.\n\nSimilar to the above problems, the solution is to simply apply heavy-light decomposition and make a [segment tree](../data_structures/segment_tree.md) over each heavy path.\n\nEach repainting on the path $(a, b)$ will turn into two updates $(a, l)$ and $(b, l)$, where $l$ is the lowest common ancestor of the vertices $a$ and $b$.   \n$\\mathcal{O}(\\log n)$ per path for $\\mathcal{O}(\\log n)$ paths leads to a complexity of $\\mathcal{O}(\\log^2 n)$ per update.\n\n## Implementation\n\nCertain parts of the above discussed approach can be modified to make implementation easier without losing efficiency.\n\n* The definition of **heavy edge** can be changed to **the edge leading to the child with largest subtree**, with ties broken arbitrarily. This may result is some light edges being converted to heavy, which means some heavy paths will combine to form a single path, but all heavy paths will remain disjoint. It is also still guaranteed that going down a light edge reduces subtree size to half or less.\n* Instead of a building segment tree over every heavy path, a single segment tree can be used with disjoint segments allocated to each heavy path.\n* It has been mentioned that answering queries requires calculation of the LCA. While LCA can be calculated separately, it is also possible to integrate LCA calculation in the process of answering queries.\n\nTo perform heavy-light decomposition:\n\n```cpp\nvector<int> parent, depth, heavy, head, pos;\nint cur_pos;\n\nint dfs(int v, vector<vector<int>> const& adj) {\n    int size = 1;\n    int max_c_size = 0;\n    for (int c : adj[v]) {\n        if (c != parent[v]) {\n            parent[c] = v, depth[c] = depth[v] + 1;\n            int c_size = dfs(c, adj);\n            size += c_size;\n            if (c_size > max_c_size)\n                max_c_size = c_size, heavy[v] = c;\n        }\n    }\n    return size;\n}\n\nvoid decompose(int v, int h, vector<vector<int>> const& adj) {\n    head[v] = h, pos[v] = cur_pos++;\n    if (heavy[v] != -1)\n        decompose(heavy[v], h, adj);\n    for (int c : adj[v]) {\n        if (c != parent[v] && c != heavy[v])\n            decompose(c, c, adj);\n    }\n}\n\nvoid init(vector<vector<int>> const& adj) {\n    int n = adj.size();\n    parent = vector<int>(n);\n    depth = vector<int>(n);\n    heavy = vector<int>(n, -1);\n    head = vector<int>(n);\n    pos = vector<int>(n);\n    cur_pos = 0;\n\n    dfs(0, adj);\n    decompose(0, 0, adj);\n}\n```\n\nThe adjacency list of the tree must be passed to the `init` function, and decomposition is performed assuming vertex `0` as root.\n\nThe `dfs` function is used to calculate `heavy[v]`, the child at the other end of the heavy edge from `v`, for every vertex `v`. Additionally `dfs` also stores the parent and depth of each vertex, which will be useful later during queries.\n\nThe `decompose` function assigns for each vertex `v` the values `head[v]` and `pos[v]`, which are respectively the head of the heavy path `v` belongs to and the position of `v` on the single segment tree that covers all vertices.\n\nTo answer queries on paths, for example the maximum query discussed, we can do something like this:\n\n```cpp\nint query(int a, int b) {\n    int res = 0;\n    for (; head[a] != head[b]; b = parent[head[b]]) {\n        if (depth[head[a]] > depth[head[b]])\n            swap(a, b);\n        int cur_heavy_path_max = segment_tree_query(pos[head[b]], pos[b]);\n        res = max(res, cur_heavy_path_max);\n    }\n    if (depth[a] > depth[b])\n        swap(a, b);\n    int last_heavy_path_max = segment_tree_query(pos[a], pos[b]);\n    res = max(res, last_heavy_path_max);\n    return res;\n}\n```\n\n## Practice problems\n\n- [SPOJ - QTREE - Query on a tree](https://www.spoj.com/problems/QTREE/)\n", "problem_ids": [], "title": "Heavy-light decomposition"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: lca_simpler\n---\n\n# Lowest Common Ancestor - Binary Lifting\n\nLet $G$ be a tree.\nFor every query of the form `(u, v)` we want to find the lowest common ancestor of the nodes `u` and `v`, i.e. we want to find a node `w` that lies on the path from `u` to the root node, that lies on the path from `v` to the root node, and if there are multiple nodes we pick the one that is farthest away from the root node.\nIn other words the desired node `w` is the lowest ancestor of `u` and `v`.\nIn particular if `u` is an ancestor of `v`, then `u` is their lowest common ancestor.\n\nThe algorithm described in this article will need $O(N \\log N)$ for preprocessing the tree, and then $O(\\log N)$ for each LCA query.\n\n## Algorithm\n\nFor each node we will precompute its ancestor above him, its ancestor two nodes above, its ancestor four above, etc.\nLet's store them in the array `up`, i.e. `up[i][j]` is the `2^j`-th ancestor above the node `i` with `i=1...N`, `j=0...ceil(log(N))`.\nThese information allow us to jump from any node to any ancestor above it in $O(\\log N)$ time.\nWe can compute this array using a [DFS](depth-first-search.md) traversal of the tree.\n\nFor each node we will also remember the time of the first visit of this node (i.e. the time when the DFS discovers the node), and the time when we left it (i.e. after we visited all children and exit the DFS function).\nWe can use this information to determine in constant time if a node is an ancestor of another node.\n\nSuppose now we received a query `(u, v)`.\nWe can immediately check whether one node is the ancestor of the other.\nIn this case this node is already the LCA.\nIf `u` is not the ancestor of `v`, and `v` not the ancestor of `u`, we climb the ancestors of `u` until we find the highest (i.e. closest to the root) node, which is not an ancestor of `v` (i.e. a node `x`, such that `x` is not an ancestor of `v`, but `up[x][0]` is).\nWe can find this node `x` in $O(\\log N)$ time using the array `up`.\n\nWe will describe this process in more detail.\nLet `L = ceil(log(N))`.\nSuppose first that `i = L`.\nIf `up[u][i]` is not an ancestor of `v`, then we can assign `u = up[u][i]` and decrement `i`.\nIf `up[u][i]` is an ancestor, then we just decrement `i`.\nClearly after doing this for all non-negative `i` the node `u` will be the desired node - i.e. `u` is still not an ancestor of `v`, but `up[u][0]` is.\n\nNow, obviously, the answer to LCA will be `up[u][0]` - i.e., the smallest node among the ancestors of the node `u`, which is also an ancestor of `v`.\n\nSo answering a LCA query will iterate `i` from `ceil(log(N))` to `0` and checks in each iteration if one node is the ancestor of the other.\nConsequently each query can be answered in $O(\\log N)$.\n\n## Implementation\n\n```cpp\nint n, l;\nvector<vector<int>> adj;\n\nint timer;\nvector<int> tin, tout;\nvector<vector<int>> up;\n\nvoid dfs(int v, int p)\n{\n    tin[v] = ++timer;\n    up[v][0] = p;\n    for (int i = 1; i <= l; ++i)\n        up[v][i] = up[up[v][i-1]][i-1];\n\n    for (int u : adj[v]) {\n        if (u != p)\n            dfs(u, v);\n    }\n\n    tout[v] = ++timer;\n}\n\nbool is_ancestor(int u, int v)\n{\n    return tin[u] <= tin[v] && tout[u] >= tout[v];\n}\n\nint lca(int u, int v)\n{\n    if (is_ancestor(u, v))\n        return u;\n    if (is_ancestor(v, u))\n        return v;\n    for (int i = l; i >= 0; --i) {\n        if (!is_ancestor(up[u][i], v))\n            u = up[u][i];\n    }\n    return up[u][0];\n}\n\nvoid preprocess(int root) {\n    tin.resize(n);\n    tout.resize(n);\n    timer = 0;\n    l = ceil(log2(n));\n    up.assign(n, vector<int>(l + 1));\n    dfs(root, root);\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: lca_simpler\n---\n\n# Lowest Common Ancestor - Binary Lifting\n\nLet $G$ be a tree.\nFor every query of the form `(u, v)` we want to find the lowest common ancestor of the nodes `u` and `v`, i.e. we want to find a node `w` that lies on the path from `u` to the root node, that lies on the path from `v` to the root node, and if there are multiple nodes we pick the one that is farthest away from the root node.\nIn other words the desired node `w` is the lowest ancestor of `u` and `v`.\nIn particular if `u` is an ancestor of `v`, then `u` is their lowest common ancestor.\n\nThe algorithm described in this article will need $O(N \\log N)$ for preprocessing the tree, and then $O(\\log N)$ for each LCA query.\n\n## Algorithm\n\nFor each node we will precompute its ancestor above him, its ancestor two nodes above, its ancestor four above, etc.\nLet's store them in the array `up`, i.e. `up[i][j]` is the `2^j`-th ancestor above the node `i` with `i=1...N`, `j=0...ceil(log(N))`.\nThese information allow us to jump from any node to any ancestor above it in $O(\\log N)$ time.\nWe can compute this array using a [DFS](depth-first-search.md) traversal of the tree.\n\nFor each node we will also remember the time of the first visit of this node (i.e. the time when the DFS discovers the node), and the time when we left it (i.e. after we visited all children and exit the DFS function).\nWe can use this information to determine in constant time if a node is an ancestor of another node.\n\nSuppose now we received a query `(u, v)`.\nWe can immediately check whether one node is the ancestor of the other.\nIn this case this node is already the LCA.\nIf `u` is not the ancestor of `v`, and `v` not the ancestor of `u`, we climb the ancestors of `u` until we find the highest (i.e. closest to the root) node, which is not an ancestor of `v` (i.e. a node `x`, such that `x` is not an ancestor of `v`, but `up[x][0]` is).\nWe can find this node `x` in $O(\\log N)$ time using the array `up`.\n\nWe will describe this process in more detail.\nLet `L = ceil(log(N))`.\nSuppose first that `i = L`.\nIf `up[u][i]` is not an ancestor of `v`, then we can assign `u = up[u][i]` and decrement `i`.\nIf `up[u][i]` is an ancestor, then we just decrement `i`.\nClearly after doing this for all non-negative `i` the node `u` will be the desired node - i.e. `u` is still not an ancestor of `v`, but `up[u][0]` is.\n\nNow, obviously, the answer to LCA will be `up[u][0]` - i.e., the smallest node among the ancestors of the node `u`, which is also an ancestor of `v`.\n\nSo answering a LCA query will iterate `i` from `ceil(log(N))` to `0` and checks in each iteration if one node is the ancestor of the other.\nConsequently each query can be answered in $O(\\log N)$.\n\n## Implementation\n\n```cpp\nint n, l;\nvector<vector<int>> adj;\n\nint timer;\nvector<int> tin, tout;\nvector<vector<int>> up;\n\nvoid dfs(int v, int p)\n{\n    tin[v] = ++timer;\n    up[v][0] = p;\n    for (int i = 1; i <= l; ++i)\n        up[v][i] = up[up[v][i-1]][i-1];\n\n    for (int u : adj[v]) {\n        if (u != p)\n            dfs(u, v);\n    }\n\n    tout[v] = ++timer;\n}\n\nbool is_ancestor(int u, int v)\n{\n    return tin[u] <= tin[v] && tout[u] >= tout[v];\n}\n\nint lca(int u, int v)\n{\n    if (is_ancestor(u, v))\n        return u;\n    if (is_ancestor(v, u))\n        return v;\n    for (int i = l; i >= 0; --i) {\n        if (!is_ancestor(up[u][i], v))\n            u = up[u][i];\n    }\n    return up[u][0];\n}\n\nvoid preprocess(int root) {\n    tin.resize(n);\n    tout.resize(n);\n    timer = 0;\n    l = ceil(log2(n));\n    up.assign(n, vector<int>(l + 1));\n    dfs(root, root);\n}\n```\n## Practice Problems\n\n* [Codechef - Longest Good Segment](https://www.codechef.com/problems/LGSEG)\n* [HackerEarth - Optimal Connectivity](https://www.hackerearth.com/practice/algorithms/graphs/graph-representation/practice-problems/algorithm/optimal-connectivity-c6ae79ca/)\n", "problem_ids": [], "title": "Lowest Common Ancestor - Binary Lifting"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: min_cost_flow\n---\n\n# Minimum-cost flow - Successive shortest path algorithm\n\nGiven a network $G$ consisting of $n$ vertices and $m$ edges.\nFor each edge (generally speaking, oriented edges, but see below), the capacity (a non-negative integer) and the cost per unit of flow along this edge (some integer) are given.\nAlso the source $s$ and the sink $t$ are marked.\n\nFor a given value $K$, we have to find a flow of this quantity, and among all flows of this quantity we have to choose the flow with the lowest cost.\nThis task is called **minimum-cost flow problem**.\n\nSometimes the task is given a little differently:\nyou want to find the maximum flow, and among all maximal flows we want to find the one with the least cost.\nThis is called the **minimum-cost maximum-flow problem**.\n\nBoth these problems can be solved effectively with the algorithm of successive shortest paths.\n\n## Algorithm\n\nThis algorithm is very similar to the [Edmonds-Karp](edmonds_karp.md) for computing the maximum flow.\n\n### Simplest case\n\nFirst we only consider the simplest case, where the graph is oriented, and there is at most one edge between any pair of vertices (e.g. if $(i, j)$ is an edge in the graph, then $(j, i)$ cannot be part in it as well).\n\nLet $U_{i j}$ be the capacity of an edge $(i, j)$ if this edge exists.\nAnd let $C_{i j}$ be the cost per unit of flow along this edge $(i, j)$.\nAnd finally let $F_{i, j}$ be the flow along the edge $(i, j)$.\nInitially all flow values are zero.\n\nWe **modify** the network as follows:\nfor each edge $(i, j)$ we add the **reverse edge** $(j, i)$ to the network with the capacity $U_{j i} = 0$ and the cost $C_{j i} = -C_{i j}$.\nSince, according to our restrictions, the edge $(j, i)$ was not in the network before, we still have a network that is not a multigraph (graph with multiple edges).\nIn addition we will always keep the condition $F_{j i} = -F_{i j}$ true during the steps of the algorithm.\n\nWe define the **residual network** for some fixed flow $F$ as follow (just like in the Ford-Fulkerson algorithm):\nthe residual network contains only unsaturated edges (i.e. edges in which $F_{i j} < U_{i j}$), and the residual capacity of each such edge is $R_{i j} = U_{i j} - F_{i j}$.\n\nNow we can talk about the **algorithms** to compute the minimum-cost flow.\nAt each iteration of the algorithm we find the shortest path in the residual graph from $s$ to $t$.\nIn contrary to Edmonds-Karp we look for the shortest path in terms of the cost of the path, instead of the number of edges.\nIf there doesn't exists a path anymore, then the algorithm terminates, and the stream $F$ is the desired one.\nIf a path was found, we increase the flow along it as much as possible (i.e. we find the minimal residual capacity $R$ of the path, and increase the flow by it, and reduce the back edges by the same amount).\nIf at some point the flow reaches the value $K$, then we stop the algorithm (note that in the last iteration of the algorithm it is necessary to increase the flow by only such an amount so that the final flow value doesn't surpass $K$).\n\nIt is not difficult to see, that if we set $K$ to infinity, then the algorithm will find the minimum-cost maximum-flow.\nSo both variations of the problem can be solved by the same algorithm.\n\n### Undirected graphs / multigraphs\n\nThe case of an undirected graph or a multigraph doesn't differ conceptually from the algorithm above.\nThe algorithm will also work on these graphs.\nHowever it becomes a little more difficult to implement it.\n\nAn **undirected edge** $(i, j)$ is actually the same as two oriented edges $(i, j)$ and $(j, i)$ with the same capacity and values.\nSince the above-described minimum-cost flow algorithm generates a back edge for each directed edge, so it splits the undirected edge into $4$ directed edges, and we actually get a **multigraph**.\n\nHow do we deal with **multiple edges**?\nFirst the flow for each of the multiple edges must be kept separately.\nSecondly, when searching for the shortest path, it is necessary to take into account that it is important which of the multiple edges is used in the path.\nThus instead of the usual ancestor array we additionally must store the edge number from which we came from along with the ancestor.\nThirdly, as the flow increases along a certain edge, it is necessary to reduce the flow along the back edge.\nSince we have multiple edges, we have to store the edge number for the reversed edge for each edge.\n\nThere are no other obstructions with undirected graphs or multigraphs.\n\n### Complexity\n\nThe algorithm here is generally exponential in the size of the input. To be more specific, in the worst case it may push only as much as $1$ unit of flow on each iteration, taking $O(F)$ iterations to find a minimum-cost flow of size $F$, making a total runtime to be $O(F \\cdot T)$, where $T$ is the time required to find the shortest path from source to sink.\n\nIf [Bellman-Ford](bellman_ford.md) algorithm is used for this, it makes the running time $O(F mn)$. It is also possible to modify [Dijkstra's algorithm](dijkstra.md), so that it needs $O(nm)$ pre-processing as an initial step and then works in $O(m \\log n)$ per iteration, making the overall running time to be $O(mn + F m \\log n)$. [Here](http://web.archive.org/web/20211009144446/https://min-25.hatenablog.com/entry/2018/03/19/235802) is a generator of a graph, on which such algorithm would require $O(2^{n/2} n^2 \\log n)$ time.\n\nThe modified Dijkstra's algorithm uses so-called potentials from [Johnson's algorithm](https://en.wikipedia.org/wiki/Johnson%27s_algorithm). It is possible to combine the ideas of this algorithm and Dinic's algorithm to reduce the number of iterations from $F$ to $\\min(F, nC)$, where $C$ is the maximum cost found among edges. You may read further about potentials and their combination with Dinic algorithm [here](https://codeforces.com/blog/entry/105658).\n\n## Implementation\n\nHere is an implementation using the [SPFA algorithm](bellman_ford.md) for the simplest case.\n\n```{.cpp file=min_cost_flow_successive_shortest_path}\nstruct Edge\n{\n    int from, to, capacity, cost;\n};\n\nvector<vector<int>> adj, cost, capacity;\n\nconst int INF = 1e9;\n\nvoid shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {\n    d.assign(n, INF);\n    d[v0] = 0;\n    vector<bool> inq(n, false);\n    queue<int> q;\n    q.push(v0);\n    p.assign(n, -1);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        inq[u] = false;\n        for (int v : adj[u]) {\n            if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\n                d[v] = d[u] + cost[u][v];\n                p[v] = u;\n                if (!inq[v]) {\n                    inq[v] = true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\n\nint min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {\n    adj.assign(N, vector<int>());\n    cost.assign(N, vector<int>(N, 0));\n    capacity.assign(N, vector<int>(N, 0));\n    for (Edge e : edges) {\n        adj[e.from].push_back(e.to);\n        adj[e.to].push_back(e.from);\n        cost[e.from][e.to] = e.cost;\n        cost[e.to][e.from] = -e.cost;\n        capacity[e.from][e.to] = e.capacity;\n    }\n\n    int flow = 0;\n    int cost = 0;\n    vector<int> d, p;\n    while (flow < K) {\n        shortest_paths(N, s, d, p);\n        if (d[t] == INF)\n            break;\n        \n        // find max flow on that path\n        int f = K - flow;\n        int cur = t;\n        while (cur != s) {\n            f = min(f, capacity[p[cur]][cur]);\n            cur = p[cur];\n        }\n\n        // apply flow\n        flow += f;\n        cost += f * d[t];\n        cur = t;\n        while (cur != s) {\n            capacity[p[cur]][cur] -= f;\n            capacity[cur][p[cur]] += f;\n            cur = p[cur];\n        }\n    }\n\n    if (flow < K)\n        return -1;\n    else\n        return cost;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: min_cost_flow\n---\n\n# Minimum-cost flow - Successive shortest path algorithm\n\nGiven a network $G$ consisting of $n$ vertices and $m$ edges.\nFor each edge (generally speaking, oriented edges, but see below), the capacity (a non-negative integer) and the cost per unit of flow along this edge (some integer) are given.\nAlso the source $s$ and the sink $t$ are marked.\n\nFor a given value $K$, we have to find a flow of this quantity, and among all flows of this quantity we have to choose the flow with the lowest cost.\nThis task is called **minimum-cost flow problem**.\n\nSometimes the task is given a little differently:\nyou want to find the maximum flow, and among all maximal flows we want to find the one with the least cost.\nThis is called the **minimum-cost maximum-flow problem**.\n\nBoth these problems can be solved effectively with the algorithm of successive shortest paths.\n\n## Algorithm\n\nThis algorithm is very similar to the [Edmonds-Karp](edmonds_karp.md) for computing the maximum flow.\n\n### Simplest case\n\nFirst we only consider the simplest case, where the graph is oriented, and there is at most one edge between any pair of vertices (e.g. if $(i, j)$ is an edge in the graph, then $(j, i)$ cannot be part in it as well).\n\nLet $U_{i j}$ be the capacity of an edge $(i, j)$ if this edge exists.\nAnd let $C_{i j}$ be the cost per unit of flow along this edge $(i, j)$.\nAnd finally let $F_{i, j}$ be the flow along the edge $(i, j)$.\nInitially all flow values are zero.\n\nWe **modify** the network as follows:\nfor each edge $(i, j)$ we add the **reverse edge** $(j, i)$ to the network with the capacity $U_{j i} = 0$ and the cost $C_{j i} = -C_{i j}$.\nSince, according to our restrictions, the edge $(j, i)$ was not in the network before, we still have a network that is not a multigraph (graph with multiple edges).\nIn addition we will always keep the condition $F_{j i} = -F_{i j}$ true during the steps of the algorithm.\n\nWe define the **residual network** for some fixed flow $F$ as follow (just like in the Ford-Fulkerson algorithm):\nthe residual network contains only unsaturated edges (i.e. edges in which $F_{i j} < U_{i j}$), and the residual capacity of each such edge is $R_{i j} = U_{i j} - F_{i j}$.\n\nNow we can talk about the **algorithms** to compute the minimum-cost flow.\nAt each iteration of the algorithm we find the shortest path in the residual graph from $s$ to $t$.\nIn contrary to Edmonds-Karp we look for the shortest path in terms of the cost of the path, instead of the number of edges.\nIf there doesn't exists a path anymore, then the algorithm terminates, and the stream $F$ is the desired one.\nIf a path was found, we increase the flow along it as much as possible (i.e. we find the minimal residual capacity $R$ of the path, and increase the flow by it, and reduce the back edges by the same amount).\nIf at some point the flow reaches the value $K$, then we stop the algorithm (note that in the last iteration of the algorithm it is necessary to increase the flow by only such an amount so that the final flow value doesn't surpass $K$).\n\nIt is not difficult to see, that if we set $K$ to infinity, then the algorithm will find the minimum-cost maximum-flow.\nSo both variations of the problem can be solved by the same algorithm.\n\n### Undirected graphs / multigraphs\n\nThe case of an undirected graph or a multigraph doesn't differ conceptually from the algorithm above.\nThe algorithm will also work on these graphs.\nHowever it becomes a little more difficult to implement it.\n\nAn **undirected edge** $(i, j)$ is actually the same as two oriented edges $(i, j)$ and $(j, i)$ with the same capacity and values.\nSince the above-described minimum-cost flow algorithm generates a back edge for each directed edge, so it splits the undirected edge into $4$ directed edges, and we actually get a **multigraph**.\n\nHow do we deal with **multiple edges**?\nFirst the flow for each of the multiple edges must be kept separately.\nSecondly, when searching for the shortest path, it is necessary to take into account that it is important which of the multiple edges is used in the path.\nThus instead of the usual ancestor array we additionally must store the edge number from which we came from along with the ancestor.\nThirdly, as the flow increases along a certain edge, it is necessary to reduce the flow along the back edge.\nSince we have multiple edges, we have to store the edge number for the reversed edge for each edge.\n\nThere are no other obstructions with undirected graphs or multigraphs.\n\n### Complexity\n\nThe algorithm here is generally exponential in the size of the input. To be more specific, in the worst case it may push only as much as $1$ unit of flow on each iteration, taking $O(F)$ iterations to find a minimum-cost flow of size $F$, making a total runtime to be $O(F \\cdot T)$, where $T$ is the time required to find the shortest path from source to sink.\n\nIf [Bellman-Ford](bellman_ford.md) algorithm is used for this, it makes the running time $O(F mn)$. It is also possible to modify [Dijkstra's algorithm](dijkstra.md), so that it needs $O(nm)$ pre-processing as an initial step and then works in $O(m \\log n)$ per iteration, making the overall running time to be $O(mn + F m \\log n)$. [Here](http://web.archive.org/web/20211009144446/https://min-25.hatenablog.com/entry/2018/03/19/235802) is a generator of a graph, on which such algorithm would require $O(2^{n/2} n^2 \\log n)$ time.\n\nThe modified Dijkstra's algorithm uses so-called potentials from [Johnson's algorithm](https://en.wikipedia.org/wiki/Johnson%27s_algorithm). It is possible to combine the ideas of this algorithm and Dinic's algorithm to reduce the number of iterations from $F$ to $\\min(F, nC)$, where $C$ is the maximum cost found among edges. You may read further about potentials and their combination with Dinic algorithm [here](https://codeforces.com/blog/entry/105658).\n\n## Implementation\n\nHere is an implementation using the [SPFA algorithm](bellman_ford.md) for the simplest case.\n\n```{.cpp file=min_cost_flow_successive_shortest_path}\nstruct Edge\n{\n    int from, to, capacity, cost;\n};\n\nvector<vector<int>> adj, cost, capacity;\n\nconst int INF = 1e9;\n\nvoid shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {\n    d.assign(n, INF);\n    d[v0] = 0;\n    vector<bool> inq(n, false);\n    queue<int> q;\n    q.push(v0);\n    p.assign(n, -1);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        inq[u] = false;\n        for (int v : adj[u]) {\n            if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\n                d[v] = d[u] + cost[u][v];\n                p[v] = u;\n                if (!inq[v]) {\n                    inq[v] = true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\n\nint min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {\n    adj.assign(N, vector<int>());\n    cost.assign(N, vector<int>(N, 0));\n    capacity.assign(N, vector<int>(N, 0));\n    for (Edge e : edges) {\n        adj[e.from].push_back(e.to);\n        adj[e.to].push_back(e.from);\n        cost[e.from][e.to] = e.cost;\n        cost[e.to][e.from] = -e.cost;\n        capacity[e.from][e.to] = e.capacity;\n    }\n\n    int flow = 0;\n    int cost = 0;\n    vector<int> d, p;\n    while (flow < K) {\n        shortest_paths(N, s, d, p);\n        if (d[t] == INF)\n            break;\n        \n        // find max flow on that path\n        int f = K - flow;\n        int cur = t;\n        while (cur != s) {\n            f = min(f, capacity[p[cur]][cur]);\n            cur = p[cur];\n        }\n\n        // apply flow\n        flow += f;\n        cost += f * d[t];\n        cur = t;\n        while (cur != s) {\n            capacity[p[cur]][cur] -= f;\n            capacity[cur][p[cur]] += f;\n            cur = p[cur];\n        }\n    }\n\n    if (flow < K)\n        return -1;\n    else\n        return cost;\n}\n```\n", "problem_ids": [], "title": "Minimum-cost flow - Successive shortest path algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: bipartite_checking\n---\n\n# Check whether a graph is bipartite\n\nA bipartite graph is a graph whose vertices can be divided into two disjoint sets so that every edge connects two vertices from different sets (i.e. there are no edges which connect vertices from the same set). These sets are usually called sides.\n\nYou are given an undirected graph. Check whether it is bipartite, and if it is, output its sides.\n\n## Algorithm\n\nThere exists a theorem which claims that a graph is bipartite if and only if all its cycles have even length. However, in practice it's more convenient to use a different formulation of the definition: a graph is bipartite if and only if it is two-colorable.\n\nLet's use a series of [breadth-first searches](breadth-first-search.md), starting from each vertex which hasn't been visited yet. In each search, assign the vertex from which we start to side 1. Each time we visit a yet unvisited neighbor of a vertex assigned to one side, we assign it to the other side. When we try to go to a neighbor of a vertex assigned to one side which has already been visited, we check that it has been assigned to the other side; if it has been assigned to the same side, we conclude that the graph is not bipartite. Once we've visited all vertices and successfully assigned them to sides, we know that the graph is bipartite and we have constructed its partitioning.\n\n## Implementation\n\n```cpp\nint n;\nvector<vector<int>> adj;\n\nvector<int> side(n, -1);\nbool is_bipartite = true;\nqueue<int> q;\nfor (int st = 0; st < n; ++st) {\n    if (side[st] == -1) {\n        q.push(st);\n        side[st] = 0;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int u : adj[v]) {\n                if (side[u] == -1) {\n                    side[u] = side[v] ^ 1;\n                    q.push(u);\n                } else {\n                    is_bipartite &= side[u] != side[v];\n                }\n            }\n        }\n    }\n}\n\ncout << (is_bipartite ? \"YES\" : \"NO\") << endl;\n```\n\n#", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: bipartite_checking\n---\n\n# Check whether a graph is bipartite\n\nA bipartite graph is a graph whose vertices can be divided into two disjoint sets so that every edge connects two vertices from different sets (i.e. there are no edges which connect vertices from the same set). These sets are usually called sides.\n\nYou are given an undirected graph. Check whether it is bipartite, and if it is, output its sides.\n\n## Algorithm\n\nThere exists a theorem which claims that a graph is bipartite if and only if all its cycles have even length. However, in practice it's more convenient to use a different formulation of the definition: a graph is bipartite if and only if it is two-colorable.\n\nLet's use a series of [breadth-first searches](breadth-first-search.md), starting from each vertex which hasn't been visited yet. In each search, assign the vertex from which we start to side 1. Each time we visit a yet unvisited neighbor of a vertex assigned to one side, we assign it to the other side. When we try to go to a neighbor of a vertex assigned to one side which has already been visited, we check that it has been assigned to the other side; if it has been assigned to the same side, we conclude that the graph is not bipartite. Once we've visited all vertices and successfully assigned them to sides, we know that the graph is bipartite and we have constructed its partitioning.\n\n## Implementation\n\n```cpp\nint n;\nvector<vector<int>> adj;\n\nvector<int> side(n, -1);\nbool is_bipartite = true;\nqueue<int> q;\nfor (int st = 0; st < n; ++st) {\n    if (side[st] == -1) {\n        q.push(st);\n        side[st] = 0;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int u : adj[v]) {\n                if (side[u] == -1) {\n                    side[u] = side[v] ^ 1;\n                    q.push(u);\n                } else {\n                    is_bipartite &= side[u] != side[v];\n                }\n            }\n        }\n    }\n}\n\ncout << (is_bipartite ? \"YES\" : \"NO\") << endl;\n```\n\n### Practice problems:\n\n- [SPOJ - BUGLIFE](http://www.spoj.com/problems/BUGLIFE/)\n- [Codeforces - Graph Without Long Directed Paths](https://codeforces.com/contest/1144/problem/F)\n- [Codeforces - String Coloring (easy version)](https://codeforces.com/contest/1296/problem/E1)\n- [CSES : Building Teams](https://cses.fi/problemset/task/1668)\n", "problem_ids": ["1144_F", "1296_E1"], "title": "Check whether a graph is bipartite"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: 2_sat\n---\n\n# 2-SAT \n\nSAT (Boolean satisfiability problem) is the problem of assigning Boolean values to variables to satisfy a given Boolean formula.\nThe Boolean formula will usually be given in CNF (conjunctive normal form), which is a conjunction of multiple clauses, where each clause is a disjunction of literals (variables or negation of variables).\n2-SAT (2-satisfiability) is a restriction of the SAT problem, in 2-SAT every clause has exactly two literals.\nHere is an example of such a 2-SAT problem.\nFind an assignment of $a, b, c$ such that the following formula is true:\n\n$$(a \\lor \\lnot b) \\land (\\lnot a \\lor b) \\land (\\lnot a \\lor \\lnot b) \\land (a \\lor \\lnot c)$$\n\nSAT is NP-complete, there is no known efficient solution known for it.\nHowever 2SAT can be solved efficiently in $O(n + m)$ where $n$ is the number of variables and $m$ is the number of clauses.\n\n## Algorithm:\n\nFirst we need to convert the problem to a different form, the so-called implicative normal form.\nNote that the expression $a \\lor b$ is equivalent to $\\lnot a \\Rightarrow b \\land \\lnot b \\Rightarrow a$ (if one of the two variables is false, then the other one must be true).\n\nWe now construct a directed graph of these implications:\nfor each variable $x$ there will be two vertices $v_x$ and $v_{\\lnot x}$.\nThe edges will correspond to the implications.\n\nLet's look at the example in 2-CNF form:\n\n$$(a \\lor \\lnot b) \\land (\\lnot a \\lor b) \\land (\\lnot a \\lor \\lnot b) \\land (a \\lor \\lnot c)$$\n\nThe oriented graph will contain the following vertices and edges:\n\n$$\\begin{array}{cccc}\n\\lnot a \\Rightarrow \\lnot b & a \\Rightarrow b & a \\Rightarrow \\lnot b & \\lnot a \\Rightarrow \\lnot c\\\\\nb \\Rightarrow a & \\lnot b \\Rightarrow \\lnot a & b \\Rightarrow \\lnot a & c \\Rightarrow a\n\\end{array}$$\n\nYou can see the implication graph in the following image:\n\n<center>![\"Implication Graph of 2-SAT example\"](2SAT.png)</center>\n\nIt is worth paying attention to the property of the implication graph:\nif there is an edge $a \\Rightarrow b$, then there also is an edge $\\lnot b \\Rightarrow \\lnot a$. \n\nAlso note, that if $x$ is reachable from $\\lnot x$, and $\\lnot x$ is reachable from $x$, then the problem has no solution.\nWhatever value we choose for the variable $x$, it will always end in a contradiction - if $x$ will be assigned $\\text{true}$ then the implication tell us that $\\lnot x$ should also be $\\text{true}$ and visa versa.\nIt turns out, that this condition is not only necessary, but also sufficient.\nWe will prove this in a few paragraphs below.\nFirst recall, if a vertex is reachable from a second one, and the second one is reachable from the first one, then these two vertices are in the same strongly connected component.\nTherefore we can formulate the criterion for the existence of a solution as follows:\n\nIn order for this 2-SAT problem to have a solution, it is necessary and sufficient that for any variable $x$ the vertices $x$ and $\\lnot x$ are in different strongly connected components of the strong connection of the implication graph.\n\nThis criterion can be verified in $O(n + m)$ time by finding all strongly connected components.\n\nThe following image shows all strongly connected components for the example.\nAs we can check easily, neither of the four components contain a vertex $x$ and its negation $\\lnot x$, therefore the example has a solution.\nWe will learn in the next paragraphs how to compute a valid assignment, but just for demonstration purposes the solution $a = \\text{false}$, $b = \\text{false}$, $c = \\text{false}$ is given.\n\n<center>![\"Strongly Connected Components of the 2-SAT example\"](2SAT_SCC.png)</center>\n\nNow we construct the algorithm for finding the solution of the 2-SAT problem on the assumption that the solution exists.\n\nNote that, in spite of the fact that the solution exists, it can happen that $\\lnot x$ is reachable from $x$ in the implication graph, or that (but not simultaneously) $x$ is reachable from $\\lnot x$.\nIn that case the choice of either $\\text{true}$ or $\\text{false}$ for $x$ will lead to a contradiction, while the choice of the other one will not.\nLet's learn how to choose a value, such that we don't generate a contradiction.\n\nLet us sort the strongly connected components in topological order (i.e. $\\text{comp}[v] \\le \\text{comp}[u]$ if there is a path from $v$ to $u$) and let $\\text{comp}[v]$ denote the index of strongly connected component to which the vertex $v$ belongs.\nThen, if $\\text{comp}[x] < \\text{comp}[\\lnot x]$ we assign $x$ with $\\text{false}$ and $\\text{true}$ otherwise.\n\nLet us prove that with this assignment of the variables we do not arrive at a contradiction.\nSuppose $x$ is assigned with $\\text{true}$.\nThe other case can be proven in a similar way.\n\nFirst we prove that the vertex $x$ cannot reach the vertex $\\lnot x$.\nBecause we assigned $\\text{true}$ it has to hold that the index of strongly connected component of $x$ is greater than the index of the component of $\\lnot x$.\nThis means that $\\lnot x$ is located on the left of the component containing $x$, and the later vertex cannot reach the first.\n\nSecondly we prove that there doesn't exist a variable $y$, such that the vertices $y$ and $\\lnot y$ are both reachable from $x$ in the implication graph.\nThis would cause a contradiction, because $x = \\text{true}$ implies that $y = \\text{true}$ and $\\lnot y = \\text{true}$.\nLet us prove this by contradiction.\nSuppose that $y$ and $\\lnot y$ are both reachable from $x$, then by the property of the implication graph $\\lnot x$ is reachable from both $y$ and $\\lnot y$.\nBy transitivity this results that $\\lnot x$ is reachable by $x$, which contradicts the assumption.\n\nSo we have constructed an algorithm that finds the required values of variables under the assumption that for any variable $x$ the vertices $x$ and $\\lnot x$ are in different strongly connected components.\nAbove showed the correctness of this algorithm.\nConsequently we simultaneously proved the above criterion for the existence of a solution.\n\n## Implementation:\n\nNow we can implement the entire algorithm.\nFirst we construct the graph of implications and find all strongly connected components.\nThis can be accomplished with Kosaraju's algorithm in $O(n + m)$ time.\nIn the second traversal of the graph Kosaraju's algorithm visits the strongly connected components in topological order, therefore it is easy to compute $\\text{comp}[v]$ for each vertex $v$.\n\nAfterwards we can choose the assignment of $x$ by comparing $\\text{comp}[x]$ and $\\text{comp}[\\lnot x]$. \nIf $\\text{comp}[x] = \\text{comp}[\\lnot x]$ we return $\\text{false}$ to indicate that there doesn't exist a valid assignment that satisfies the 2-SAT problem.\n\nBelow is the implementation of the solution of the 2-SAT problem for the already constructed graph of implication $adj$ and the transpose graph $adj^{\\intercal}$ (in which the direction of each edge is reversed).\nIn the graph the vertices with indices $2k$ and $2k+1$ are the two vertices corresponding to variable $k$ with $2k+1$ corresponding to the negated variable.\n\n```{.cpp file=2sat}\nint n;\nvector<vector<int>> adj, adj_t;\nvector<bool> used;\nvector<int> order, comp;\nvector<bool> assignment;\n\nvoid dfs1(int v) {\n    used[v] = true;\n    for (int u : adj[v]) {\n        if (!used[u])\n            dfs1(u);\n    }\n    order.push_back(v);\n}\n\nvoid dfs2(int v, int cl) {\n    comp[v] = cl;\n    for (int u : adj_t[v]) {\n        if (comp[u] == -1)\n            dfs2(u, cl);\n    }\n}\n\nbool solve_2SAT() {\n    order.clear();\n    used.assign(n, false);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i])\n            dfs1(i);\n    }\n\n    comp.assign(n, -1);\n    for (int i = 0, j = 0; i < n; ++i) {\n        int v = order[n - i - 1];\n        if (comp[v] == -1)\n            dfs2(v, j++);\n    }\n\n    assignment.assign(n / 2, false);\n    for (int i = 0; i < n; i += 2) {\n        if (comp[i] == comp[i + 1])\n            return false;\n        assignment[i / 2] = comp[i] > comp[i + 1];\n    }\n    return true;\n}\n\nvoid add_disjunction(int a, bool na, int b, bool nb) {\n    // na and nb signify whether a and b are to be negated \n    a = 2*a ^ na;\n    b = 2*b ^ nb;\n    int neg_a = a ^ 1;\n    int neg_b = b ^ 1;\n    adj[neg_a].push_back(b);\n    adj[neg_b].push_back(a);\n    adj_t[b].push_back(neg_a);\n    adj_t[a].push_back(neg_b);\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: 2_sat\n---\n\n# 2-SAT \n\nSAT (Boolean satisfiability problem) is the problem of assigning Boolean values to variables to satisfy a given Boolean formula.\nThe Boolean formula will usually be given in CNF (conjunctive normal form), which is a conjunction of multiple clauses, where each clause is a disjunction of literals (variables or negation of variables).\n2-SAT (2-satisfiability) is a restriction of the SAT problem, in 2-SAT every clause has exactly two literals.\nHere is an example of such a 2-SAT problem.\nFind an assignment of $a, b, c$ such that the following formula is true:\n\n$$(a \\lor \\lnot b) \\land (\\lnot a \\lor b) \\land (\\lnot a \\lor \\lnot b) \\land (a \\lor \\lnot c)$$\n\nSAT is NP-complete, there is no known efficient solution known for it.\nHowever 2SAT can be solved efficiently in $O(n + m)$ where $n$ is the number of variables and $m$ is the number of clauses.\n\n## Algorithm:\n\nFirst we need to convert the problem to a different form, the so-called implicative normal form.\nNote that the expression $a \\lor b$ is equivalent to $\\lnot a \\Rightarrow b \\land \\lnot b \\Rightarrow a$ (if one of the two variables is false, then the other one must be true).\n\nWe now construct a directed graph of these implications:\nfor each variable $x$ there will be two vertices $v_x$ and $v_{\\lnot x}$.\nThe edges will correspond to the implications.\n\nLet's look at the example in 2-CNF form:\n\n$$(a \\lor \\lnot b) \\land (\\lnot a \\lor b) \\land (\\lnot a \\lor \\lnot b) \\land (a \\lor \\lnot c)$$\n\nThe oriented graph will contain the following vertices and edges:\n\n$$\\begin{array}{cccc}\n\\lnot a \\Rightarrow \\lnot b & a \\Rightarrow b & a \\Rightarrow \\lnot b & \\lnot a \\Rightarrow \\lnot c\\\\\nb \\Rightarrow a & \\lnot b \\Rightarrow \\lnot a & b \\Rightarrow \\lnot a & c \\Rightarrow a\n\\end{array}$$\n\nYou can see the implication graph in the following image:\n\n<center>![\"Implication Graph of 2-SAT example\"](2SAT.png)</center>\n\nIt is worth paying attention to the property of the implication graph:\nif there is an edge $a \\Rightarrow b$, then there also is an edge $\\lnot b \\Rightarrow \\lnot a$. \n\nAlso note, that if $x$ is reachable from $\\lnot x$, and $\\lnot x$ is reachable from $x$, then the problem has no solution.\nWhatever value we choose for the variable $x$, it will always end in a contradiction - if $x$ will be assigned $\\text{true}$ then the implication tell us that $\\lnot x$ should also be $\\text{true}$ and visa versa.\nIt turns out, that this condition is not only necessary, but also sufficient.\nWe will prove this in a few paragraphs below.\nFirst recall, if a vertex is reachable from a second one, and the second one is reachable from the first one, then these two vertices are in the same strongly connected component.\nTherefore we can formulate the criterion for the existence of a solution as follows:\n\nIn order for this 2-SAT problem to have a solution, it is necessary and sufficient that for any variable $x$ the vertices $x$ and $\\lnot x$ are in different strongly connected components of the strong connection of the implication graph.\n\nThis criterion can be verified in $O(n + m)$ time by finding all strongly connected components.\n\nThe following image shows all strongly connected components for the example.\nAs we can check easily, neither of the four components contain a vertex $x$ and its negation $\\lnot x$, therefore the example has a solution.\nWe will learn in the next paragraphs how to compute a valid assignment, but just for demonstration purposes the solution $a = \\text{false}$, $b = \\text{false}$, $c = \\text{false}$ is given.\n\n<center>![\"Strongly Connected Components of the 2-SAT example\"](2SAT_SCC.png)</center>\n\nNow we construct the algorithm for finding the solution of the 2-SAT problem on the assumption that the solution exists.\n\nNote that, in spite of the fact that the solution exists, it can happen that $\\lnot x$ is reachable from $x$ in the implication graph, or that (but not simultaneously) $x$ is reachable from $\\lnot x$.\nIn that case the choice of either $\\text{true}$ or $\\text{false}$ for $x$ will lead to a contradiction, while the choice of the other one will not.\nLet's learn how to choose a value, such that we don't generate a contradiction.\n\nLet us sort the strongly connected components in topological order (i.e. $\\text{comp}[v] \\le \\text{comp}[u]$ if there is a path from $v$ to $u$) and let $\\text{comp}[v]$ denote the index of strongly connected component to which the vertex $v$ belongs.\nThen, if $\\text{comp}[x] < \\text{comp}[\\lnot x]$ we assign $x$ with $\\text{false}$ and $\\text{true}$ otherwise.\n\nLet us prove that with this assignment of the variables we do not arrive at a contradiction.\nSuppose $x$ is assigned with $\\text{true}$.\nThe other case can be proven in a similar way.\n\nFirst we prove that the vertex $x$ cannot reach the vertex $\\lnot x$.\nBecause we assigned $\\text{true}$ it has to hold that the index of strongly connected component of $x$ is greater than the index of the component of $\\lnot x$.\nThis means that $\\lnot x$ is located on the left of the component containing $x$, and the later vertex cannot reach the first.\n\nSecondly we prove that there doesn't exist a variable $y$, such that the vertices $y$ and $\\lnot y$ are both reachable from $x$ in the implication graph.\nThis would cause a contradiction, because $x = \\text{true}$ implies that $y = \\text{true}$ and $\\lnot y = \\text{true}$.\nLet us prove this by contradiction.\nSuppose that $y$ and $\\lnot y$ are both reachable from $x$, then by the property of the implication graph $\\lnot x$ is reachable from both $y$ and $\\lnot y$.\nBy transitivity this results that $\\lnot x$ is reachable by $x$, which contradicts the assumption.\n\nSo we have constructed an algorithm that finds the required values of variables under the assumption that for any variable $x$ the vertices $x$ and $\\lnot x$ are in different strongly connected components.\nAbove showed the correctness of this algorithm.\nConsequently we simultaneously proved the above criterion for the existence of a solution.\n\n## Implementation:\n\nNow we can implement the entire algorithm.\nFirst we construct the graph of implications and find all strongly connected components.\nThis can be accomplished with Kosaraju's algorithm in $O(n + m)$ time.\nIn the second traversal of the graph Kosaraju's algorithm visits the strongly connected components in topological order, therefore it is easy to compute $\\text{comp}[v]$ for each vertex $v$.\n\nAfterwards we can choose the assignment of $x$ by comparing $\\text{comp}[x]$ and $\\text{comp}[\\lnot x]$. \nIf $\\text{comp}[x] = \\text{comp}[\\lnot x]$ we return $\\text{false}$ to indicate that there doesn't exist a valid assignment that satisfies the 2-SAT problem.\n\nBelow is the implementation of the solution of the 2-SAT problem for the already constructed graph of implication $adj$ and the transpose graph $adj^{\\intercal}$ (in which the direction of each edge is reversed).\nIn the graph the vertices with indices $2k$ and $2k+1$ are the two vertices corresponding to variable $k$ with $2k+1$ corresponding to the negated variable.\n\n```{.cpp file=2sat}\nint n;\nvector<vector<int>> adj, adj_t;\nvector<bool> used;\nvector<int> order, comp;\nvector<bool> assignment;\n\nvoid dfs1(int v) {\n    used[v] = true;\n    for (int u : adj[v]) {\n        if (!used[u])\n            dfs1(u);\n    }\n    order.push_back(v);\n}\n\nvoid dfs2(int v, int cl) {\n    comp[v] = cl;\n    for (int u : adj_t[v]) {\n        if (comp[u] == -1)\n            dfs2(u, cl);\n    }\n}\n\nbool solve_2SAT() {\n    order.clear();\n    used.assign(n, false);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i])\n            dfs1(i);\n    }\n\n    comp.assign(n, -1);\n    for (int i = 0, j = 0; i < n; ++i) {\n        int v = order[n - i - 1];\n        if (comp[v] == -1)\n            dfs2(v, j++);\n    }\n\n    assignment.assign(n / 2, false);\n    for (int i = 0; i < n; i += 2) {\n        if (comp[i] == comp[i + 1])\n            return false;\n        assignment[i / 2] = comp[i] > comp[i + 1];\n    }\n    return true;\n}\n\nvoid add_disjunction(int a, bool na, int b, bool nb) {\n    // na and nb signify whether a and b are to be negated \n    a = 2*a ^ na;\n    b = 2*b ^ nb;\n    int neg_a = a ^ 1;\n    int neg_b = b ^ 1;\n    adj[neg_a].push_back(b);\n    adj[neg_b].push_back(a);\n    adj_t[b].push_back(neg_a);\n    adj_t[a].push_back(neg_b);\n}\n```\n\n## Practice Problems\n * [Codeforces: The Door Problem](http://codeforces.com/contest/776/problem/D)\n * [Kattis: Illumination](https://open.kattis.com/problems/illumination)\n * [UVA: Rectangles](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3081)\n * [Codeforces : Radio Stations](https://codeforces.com/problemset/problem/1215/F)\n * [CSES : Giant Pizza](https://cses.fi/problemset/task/1684)\n", "problem_ids": [], "title": "2-SAT"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: kirchhoff_theorem\n---\n\n# Kirchhoff's theorem. Finding the number of spanning trees\n\nProblem: You are given a connected undirected graph (with possible multiple edges) represented using an adjacency matrix. Find the number of different spanning trees of this graph.\n\nThe following formula was proven by Kirchhoff in 1847.\n\n## Kirchhoff's matrix tree theorem\n\nLet $A$ be the adjacency matrix of the graph: $A_{u,v}$ is the number of edges between $u$ and $v$.\nLet $D$ be the degree matrix of the graph: a diagonal matrix with $D_{u,u}$ being the degree of vertex $u$ (including multiple edges and loops - edges which connect vertex $u$ with itself).\n\nThe Laplacian matrix of the graph is defined as $L = D - A$.\nAccording to Kirchhoff's theorem, all cofactors of this matrix are equal to each other, and they are equal to the number of spanning trees of the graph.\nThe $(i,j)$ cofactor of a matrix is the product of $(-1)^{i + j}$ with the determinant of the matrix that you get after removing the $i$-th row and $j$-th column.\nSo you can, for example, delete the last row and last column of the matrix $L$, and the absolute value of the determinant of the resulting matrix will give you the number of spanning trees.\n\nThe determinant of the matrix can be found in $O(N^3)$ by using the [Gaussian method](../linear_algebra/determinant-gauss.md).\n\nThe proof of this theorem is quite difficult and is not presented here; for an outline of the proof and variations of the theorem for graphs without multiple edges and for directed graphs refer to [Wikipedia](https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem).\n\n## Relation to Kirchhoff's circuit laws\n\nKirchhoff's matrix tree theorem and Kirchhoff's laws for electrical circuit are related in a beautiful way. It is possible to show (using Ohm's law and Kirchhoff's first law) that resistance $R_{ij}$ between two points of the circuit $i$ and $j$ is\n\n$$R_{ij} = \\frac{ \\left| L^{(i,j)} \\right| }{ | L^j | }.$$\n\nHere the matrix $L$ is obtained from the matrix of inverse resistances $A$ ($A_{i,j}$ is inverse of the resistance of the conductor between points $i$ and $j$) using the procedure described in Kirchhoff's matrix tree theorem.\n$T^j$ is the matrix with row and column $j$ removed, $T^{(i,j)}$ is the matrix with two rows and two columns $i$ and $j$ removed.\n\nKirchhoff's theorem gives this formula geometric meaning.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: kirchhoff_theorem\n---\n\n# Kirchhoff's theorem. Finding the number of spanning trees\n\nProblem: You are given a connected undirected graph (with possible multiple edges) represented using an adjacency matrix. Find the number of different spanning trees of this graph.\n\nThe following formula was proven by Kirchhoff in 1847.\n\n## Kirchhoff's matrix tree theorem\n\nLet $A$ be the adjacency matrix of the graph: $A_{u,v}$ is the number of edges between $u$ and $v$.\nLet $D$ be the degree matrix of the graph: a diagonal matrix with $D_{u,u}$ being the degree of vertex $u$ (including multiple edges and loops - edges which connect vertex $u$ with itself).\n\nThe Laplacian matrix of the graph is defined as $L = D - A$.\nAccording to Kirchhoff's theorem, all cofactors of this matrix are equal to each other, and they are equal to the number of spanning trees of the graph.\nThe $(i,j)$ cofactor of a matrix is the product of $(-1)^{i + j}$ with the determinant of the matrix that you get after removing the $i$-th row and $j$-th column.\nSo you can, for example, delete the last row and last column of the matrix $L$, and the absolute value of the determinant of the resulting matrix will give you the number of spanning trees.\n\nThe determinant of the matrix can be found in $O(N^3)$ by using the [Gaussian method](../linear_algebra/determinant-gauss.md).\n\nThe proof of this theorem is quite difficult and is not presented here; for an outline of the proof and variations of the theorem for graphs without multiple edges and for directed graphs refer to [Wikipedia](https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem).\n\n## Relation to Kirchhoff's circuit laws\n\nKirchhoff's matrix tree theorem and Kirchhoff's laws for electrical circuit are related in a beautiful way. It is possible to show (using Ohm's law and Kirchhoff's first law) that resistance $R_{ij}$ between two points of the circuit $i$ and $j$ is\n\n$$R_{ij} = \\frac{ \\left| L^{(i,j)} \\right| }{ | L^j | }.$$\n\nHere the matrix $L$ is obtained from the matrix of inverse resistances $A$ ($A_{i,j}$ is inverse of the resistance of the conductor between points $i$ and $j$) using the procedure described in Kirchhoff's matrix tree theorem.\n$T^j$ is the matrix with row and column $j$ removed, $T^{(i,j)}$ is the matrix with two rows and two columns $i$ and $j$ removed.\n\nKirchhoff's theorem gives this formula geometric meaning.\n\n## Practice Problems\n - [CODECHEF: Roads in Stars](https://www.codechef.com/problems/STARROAD)\n - [SPOJ: Maze](http://www.spoj.com/problems/KPMAZE/)\n - [CODECHEF: Complement Spanning Trees](https://www.codechef.com/problems/CSTREE)\n", "problem_ids": [], "title": "Kirchhoff's theorem. Finding the number of spanning trees"}, {"article": "---\ntags:\n  - Original\n---\n\n# Strong Orientation\n\nA **strong orientation** of an undirected graph is an assignment of a direction to each edge that makes it a [strongly connected graph](strongly-connected-components.md).\nThat is, after the *orientation* we should be able to visit any vertex from any vertex by following the directed edges.\n\n## Solution\n\nOf course, this cannot be done to *every* graph.\nConsider a [bridge](bridge-searching.md) in a graph.\nWe have to assign a direction to it and by doing so we make this bridge \"crossable\" in only one direction. That means we can't go from one of the bridge's ends to the other, so we can't make the graph strongly connected.\n\nNow consider a [DFS](depth-first-search.md) through a bridgeless connected graph.\nClearly, we will visit each vertex.\nAnd since there are no bridges, we can remove any DFS tree edge and still be able to go\nfrom below the edge to above the edge by using a path that contains at least one back edge.\nFrom this follows that from any vertex we can go to the root of the DFS tree.\nAlso, from the root of the DFS tree we can visit any vertex we choose.\nWe found a strong orientation!\n\nIn other words, to strongly orient a bridgeless connected graph,\nrun a DFS on it and let the DFS tree edges point away from the DFS root and\nall other edges from the descendant to the ancestor in the DFS tree.\n\nThe result that bridgeless connected graphs are exactly the graphs that have strong orientations is called **Robbins' theorem**.\n\n## Problem extension\n\nLet's consider the problem of finding a graph orientation so that the number of SCCs is minimal.\n\nOf course, each graph component can be considered separately.\nNow, since only bridgeless graphs are strongly orientable, let's remove all bridges temporarily.\nWe end up with some number of bridgeless components\n(exactly *how many components there were at the beginning* + *how many bridges there were*)\n and we know that we can strongly orient each of them.\n\nWe were only allowed to orient edges, not remove them, but it turns out we can orient the bridges arbitrarily.\nOf course, the easiest way to orient them is to run the algorithm described above without modifications on each original connected component.\n\n### Implementation\n\nHere, the input is *n* \u2014 the number of vertices, *m* \u2014 the number of edges, then *m* lines describing the edges.\n\nThe output is the minimal number of SCCs on the first line and on the second line\na string of *m* characters,\neither `>` \u2014 telling us that the corresponding edge from the input\nis oriented from the left to the right vertex (as in the input),\nor `<` \u2014 the opposite.\n\nThis is a bridge search algorithm modified to also orient the edges,\nyou can as well orient the edges as a first step and count the SCCs on the oriented graph as a second.\n\n```cpp\nvector<vector<pair<int, int>>> adj; // adjacency list - vertex and edge pairs\nvector<pair<int, int>> edges;\n\nvector<int> tin, low;\nint bridge_cnt;\nstring orient;\nvector<bool> edge_used;\nvoid find_bridges(int v) {\n\tstatic int time = 0;\n\tlow[v] = tin[v] = time++;\n\tfor (auto p : adj[v]) {\n\t\tif (edge_used[p.second]) continue;\n\t\tedge_used[p.second] = true;\n\t\torient[p.second] = v == edges[p.second].first ? '>' : '<';\n\t\tint nv = p.first;\n\t\tif (tin[nv] == -1) { // if nv is not visited yet\n\t\t\tfind_bridges(nv);\n\t\t\tlow[v] = min(low[v], low[nv]);\n\t\t\tif (low[nv] > tin[v]) {\n\t\t\t\t// a bridge between v and nv\n\t\t\t\tbridge_cnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tlow[v] = min(low[v], low[nv]);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tadj.resize(n);\n\ttin.resize(n, -1);\n\tlow.resize(n, -1);\n\torient.resize(m);\n\tedges.resize(m);\n\tedge_used.resize(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\ta--; b--;\n\t\tadj[a].push_back({b, i});\n\t\tadj[b].push_back({a, i});\n\t\tedges[i] = {a, b};\n\t}\n\tint comp_cnt = 0;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (tin[v] == -1) {\n\t\t\tcomp_cnt++;\n\t\t\tfind_bridges(v);\n\t\t}\n\t}\n\tprintf(\"%d\\n%s\\n\", comp_cnt + bridge_cnt, orient.c_str());\n}\n```\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Strong Orientation\n\nA **strong orientation** of an undirected graph is an assignment of a direction to each edge that makes it a [strongly connected graph](strongly-connected-components.md).\nThat is, after the *orientation* we should be able to visit any vertex from any vertex by following the directed edges.\n\n## Solution\n\nOf course, this cannot be done to *every* graph.\nConsider a [bridge](bridge-searching.md) in a graph.\nWe have to assign a direction to it and by doing so we make this bridge \"crossable\" in only one direction. That means we can't go from one of the bridge's ends to the other, so we can't make the graph strongly connected.\n\nNow consider a [DFS](depth-first-search.md) through a bridgeless connected graph.\nClearly, we will visit each vertex.\nAnd since there are no bridges, we can remove any DFS tree edge and still be able to go\nfrom below the edge to above the edge by using a path that contains at least one back edge.\nFrom this follows that from any vertex we can go to the root of the DFS tree.\nAlso, from the root of the DFS tree we can visit any vertex we choose.\nWe found a strong orientation!\n\nIn other words, to strongly orient a bridgeless connected graph,\nrun a DFS on it and let the DFS tree edges point away from the DFS root and\nall other edges from the descendant to the ancestor in the DFS tree.\n\nThe result that bridgeless connected graphs are exactly the graphs that have strong orientations is called **Robbins' theorem**.\n\n## Problem extension\n\nLet's consider the problem of finding a graph orientation so that the number of SCCs is minimal.\n\nOf course, each graph component can be considered separately.\nNow, since only bridgeless graphs are strongly orientable, let's remove all bridges temporarily.\nWe end up with some number of bridgeless components\n(exactly *how many components there were at the beginning* + *how many bridges there were*)\n and we know that we can strongly orient each of them.\n\nWe were only allowed to orient edges, not remove them, but it turns out we can orient the bridges arbitrarily.\nOf course, the easiest way to orient them is to run the algorithm described above without modifications on each original connected component.\n\n### Implementation\n\nHere, the input is *n* \u2014 the number of vertices, *m* \u2014 the number of edges, then *m* lines describing the edges.\n\nThe output is the minimal number of SCCs on the first line and on the second line\na string of *m* characters,\neither `>` \u2014 telling us that the corresponding edge from the input\nis oriented from the left to the right vertex (as in the input),\nor `<` \u2014 the opposite.\n\nThis is a bridge search algorithm modified to also orient the edges,\nyou can as well orient the edges as a first step and count the SCCs on the oriented graph as a second.\n\n```cpp\nvector<vector<pair<int, int>>> adj; // adjacency list - vertex and edge pairs\nvector<pair<int, int>> edges;\n\nvector<int> tin, low;\nint bridge_cnt;\nstring orient;\nvector<bool> edge_used;\nvoid find_bridges(int v) {\n\tstatic int time = 0;\n\tlow[v] = tin[v] = time++;\n\tfor (auto p : adj[v]) {\n\t\tif (edge_used[p.second]) continue;\n\t\tedge_used[p.second] = true;\n\t\torient[p.second] = v == edges[p.second].first ? '>' : '<';\n\t\tint nv = p.first;\n\t\tif (tin[nv] == -1) { // if nv is not visited yet\n\t\t\tfind_bridges(nv);\n\t\t\tlow[v] = min(low[v], low[nv]);\n\t\t\tif (low[nv] > tin[v]) {\n\t\t\t\t// a bridge between v and nv\n\t\t\t\tbridge_cnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tlow[v] = min(low[v], low[nv]);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tadj.resize(n);\n\ttin.resize(n, -1);\n\tlow.resize(n, -1);\n\torient.resize(m);\n\tedges.resize(m);\n\tedge_used.resize(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\ta--; b--;\n\t\tadj[a].push_back({b, i});\n\t\tadj[b].push_back({a, i});\n\t\tedges[i] = {a, b};\n\t}\n\tint comp_cnt = 0;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (tin[v] == -1) {\n\t\t\tcomp_cnt++;\n\t\t\tfind_bridges(v);\n\t\t}\n\t}\n\tprintf(\"%d\\n%s\\n\", comp_cnt + bridge_cnt, orient.c_str());\n}\n```\n\n## Practice Problems\n\n* [26th Polish OI - Osiedla](https://szkopul.edu.pl/problemset/problem/nldsb4EW1YuZykBlf4lcZL1Y/site/)\n", "problem_ids": [], "title": "Strong Orientation"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: mst_kruskal\n---\n\n# Minimum spanning tree - Kruskal's algorithm\n\nGiven a weighted undirected graph.\nWe want to find a subtree of this graph which connects all vertices (i.e. it is a spanning tree) and has the least weight (i.e. the sum of weights of all the edges is minimum) of all possible spanning trees.\nThis spanning tree is called a minimum spanning tree.\n\nIn the left image you can see a weighted undirected graph, and in the right image you can see the corresponding minimum spanning tree.\n\n![Random graph](MST_before.png) ![MST of this graph](MST_after.png)\n\nThis article will discuss few important facts associated with minimum spanning trees, and then will give the simplest implementation of Kruskal's algorithm for finding minimum spanning tree.\n\n## Properties of the minimum spanning tree\n\n* A minimum spanning tree of a graph is unique, if the weight of all the edges are distinct. Otherwise, there may be multiple minimum spanning trees.\n  (Specific algorithms typically output one of the possible minimum spanning trees).\n* Minimum spanning tree is also the tree with minimum product of weights of edges.\n  (It can be easily proved by replacing the weights of all edges with their logarithms)\n* In a minimum spanning tree of a graph, the maximum weight of an edge is the minimum possible from all possible spanning trees of that graph.\n  (This follows from the validity of Kruskal's algorithm).\n* The maximum spanning tree (spanning tree with the sum of weights of edges being maximum) of a graph can be obtained similarly to that of the minimum spanning tree, by changing the signs of the weights of all the edges to their opposite and then applying any of the minimum spanning tree algorithm.\n\n## Kruskal's algorithm\n\nThis algorithm was described by Joseph Bernard Kruskal, Jr. in 1956.\n\nKruskal's algorithm initially places all the nodes of the original graph isolated from each other, to form a forest of single node trees, and then gradually merges these trees, combining at each iteration any two of all the trees with some edge of the original graph. Before the execution of the algorithm, all edges are sorted by weight (in non-decreasing order). Then begins the process of unification: pick all edges from the first to the last (in sorted order), and if the ends of the currently picked edge belong to different subtrees, these subtrees are combined, and the edge is added to the answer. After iterating through all the edges, all the vertices will belong to the same sub-tree, and we will get the answer.\n\n## The simplest implementation\n\nThe following code directly implements the algorithm described above, and is having $O(M \\log M + N^2)$ time complexity.\nSorting edges requires $O(M \\log N)$ (which is the same as $O(M \\log M)$) operations.\nInformation regarding the subtree to which a vertex belongs is maintained with the help of an array `tree_id[]` - for each vertex `v`, `tree_id[v]` stores the number of the tree , to which `v` belongs.\nFor each edge, whether it belongs to the ends of different trees, can be determined in $O(1)$.\nFinally, the union of the two trees is carried out in $O(N)$ by a simple pass through `tree_id[]` array.\nGiven that the total number of merge operations is $N-1$, we obtain the asymptotic behavior of $O(M \\log N + N^2)$.\n\n```cpp\nstruct Edge {\n    int u, v, weight;\n    bool operator<(Edge const& other) {\n        return weight < other.weight;\n    }\n};\n\nint n;\nvector<Edge> edges;\n\nint cost = 0;\nvector<int> tree_id(n);\nvector<Edge> result;\nfor (int i = 0; i < n; i++)\n    tree_id[i] = i;\n\nsort(edges.begin(), edges.end());\n   \nfor (Edge e : edges) {\n    if (tree_id[e.u] != tree_id[e.v]) {\n        cost += e.weight;\n        result.push_back(e);\n\n        int old_id = tree_id[e.u], new_id = tree_id[e.v];\n        for (int i = 0; i < n; i++) {\n            if (tree_id[i] == old_id)\n                tree_id[i] = new_id;\n        }\n    }\n}\n```\n\n## Proof of correctness\n\nWhy does Kruskal's algorithm give us the correct result?\n\nIf the original graph was connected, then also the resulting graph will be connected.\nBecause otherwise there would be two components that could be connected with at least one edge. Though this is impossible, because Kruskal would have chosen one of these edges, since the ids of the components are different.\nAlso the resulting graph doesn't contain any cycles, since we forbid this explicitly in the algorithm.\nTherefore the algorithm generates a spanning tree.\n\nSo why does this algorithm give us a minimum spanning tree?\n\nWe can show the proposal \"if $F$ is a set of edges chosen by the algorithm at any stage in the algorithm, then there exists a MST that contains all edges of $F$\" using induction.\n\nThe proposal is obviously true at the beginning, the empty set is a subset of any MST.\n\nNow let's assume $F$ is some edge set at any stage of the algorithm, $T$ is a MST containing $F$ and $e$ is the new edge we want to add using Kruskal.\n\nIf $e$ generates a cycle, then we don't add it, and so the proposal is still true after this step.\n\nIn case that $T$ already contains $e$, the proposal is also true after this step.\n\nIn case $T$ doesn't contain the edge $e$, then $T + e$ will contain a cycle $C$.\nThis cycle will contain at least one edge $f$, that is not in $F$.\nThe set of edges $T - f + e$ will also be a spanning tree. \nNotice that the weight of $f$ cannot be smaller than the weight of $e$, because otherwise Kruskal would have chosen $f$ earlier.\nIt also cannot have a bigger weight, since that would make the total weight of $T - f + e$ smaller than the total weight of $T$, which is impossible since $T$ is already a MST.\nThis means that the weight of $e$ has to be the same as the weight of $f$.\nTherefore $T - f + e$ is also a MST, and it contains all edges from $F + e$.\nSo also here the proposal is still fulfilled after the step.\n\nThis proves the proposal.\nWhich means that after iterating over all edges the resulting edge set will be connected, and will be contained in a MST, which means that it has to be a MST already.\n\n## Improved implementation\n\nWe can use the [**Disjoint Set Union** (DSU)](../data_structures/disjoint_set_union.md) data structure to write a faster implementation of the Kruskal's algorithm with the time complexity of about $O(M \\log N)$. [This article](mst_kruskal_with_dsu.md) details such an approach.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: mst_kruskal\n---\n\n# Minimum spanning tree - Kruskal's algorithm\n\nGiven a weighted undirected graph.\nWe want to find a subtree of this graph which connects all vertices (i.e. it is a spanning tree) and has the least weight (i.e. the sum of weights of all the edges is minimum) of all possible spanning trees.\nThis spanning tree is called a minimum spanning tree.\n\nIn the left image you can see a weighted undirected graph, and in the right image you can see the corresponding minimum spanning tree.\n\n![Random graph](MST_before.png) ![MST of this graph](MST_after.png)\n\nThis article will discuss few important facts associated with minimum spanning trees, and then will give the simplest implementation of Kruskal's algorithm for finding minimum spanning tree.\n\n## Properties of the minimum spanning tree\n\n* A minimum spanning tree of a graph is unique, if the weight of all the edges are distinct. Otherwise, there may be multiple minimum spanning trees.\n  (Specific algorithms typically output one of the possible minimum spanning trees).\n* Minimum spanning tree is also the tree with minimum product of weights of edges.\n  (It can be easily proved by replacing the weights of all edges with their logarithms)\n* In a minimum spanning tree of a graph, the maximum weight of an edge is the minimum possible from all possible spanning trees of that graph.\n  (This follows from the validity of Kruskal's algorithm).\n* The maximum spanning tree (spanning tree with the sum of weights of edges being maximum) of a graph can be obtained similarly to that of the minimum spanning tree, by changing the signs of the weights of all the edges to their opposite and then applying any of the minimum spanning tree algorithm.\n\n## Kruskal's algorithm\n\nThis algorithm was described by Joseph Bernard Kruskal, Jr. in 1956.\n\nKruskal's algorithm initially places all the nodes of the original graph isolated from each other, to form a forest of single node trees, and then gradually merges these trees, combining at each iteration any two of all the trees with some edge of the original graph. Before the execution of the algorithm, all edges are sorted by weight (in non-decreasing order). Then begins the process of unification: pick all edges from the first to the last (in sorted order), and if the ends of the currently picked edge belong to different subtrees, these subtrees are combined, and the edge is added to the answer. After iterating through all the edges, all the vertices will belong to the same sub-tree, and we will get the answer.\n\n## The simplest implementation\n\nThe following code directly implements the algorithm described above, and is having $O(M \\log M + N^2)$ time complexity.\nSorting edges requires $O(M \\log N)$ (which is the same as $O(M \\log M)$) operations.\nInformation regarding the subtree to which a vertex belongs is maintained with the help of an array `tree_id[]` - for each vertex `v`, `tree_id[v]` stores the number of the tree , to which `v` belongs.\nFor each edge, whether it belongs to the ends of different trees, can be determined in $O(1)$.\nFinally, the union of the two trees is carried out in $O(N)$ by a simple pass through `tree_id[]` array.\nGiven that the total number of merge operations is $N-1$, we obtain the asymptotic behavior of $O(M \\log N + N^2)$.\n\n```cpp\nstruct Edge {\n    int u, v, weight;\n    bool operator<(Edge const& other) {\n        return weight < other.weight;\n    }\n};\n\nint n;\nvector<Edge> edges;\n\nint cost = 0;\nvector<int> tree_id(n);\nvector<Edge> result;\nfor (int i = 0; i < n; i++)\n    tree_id[i] = i;\n\nsort(edges.begin(), edges.end());\n   \nfor (Edge e : edges) {\n    if (tree_id[e.u] != tree_id[e.v]) {\n        cost += e.weight;\n        result.push_back(e);\n\n        int old_id = tree_id[e.u], new_id = tree_id[e.v];\n        for (int i = 0; i < n; i++) {\n            if (tree_id[i] == old_id)\n                tree_id[i] = new_id;\n        }\n    }\n}\n```\n\n## Proof of correctness\n\nWhy does Kruskal's algorithm give us the correct result?\n\nIf the original graph was connected, then also the resulting graph will be connected.\nBecause otherwise there would be two components that could be connected with at least one edge. Though this is impossible, because Kruskal would have chosen one of these edges, since the ids of the components are different.\nAlso the resulting graph doesn't contain any cycles, since we forbid this explicitly in the algorithm.\nTherefore the algorithm generates a spanning tree.\n\nSo why does this algorithm give us a minimum spanning tree?\n\nWe can show the proposal \"if $F$ is a set of edges chosen by the algorithm at any stage in the algorithm, then there exists a MST that contains all edges of $F$\" using induction.\n\nThe proposal is obviously true at the beginning, the empty set is a subset of any MST.\n\nNow let's assume $F$ is some edge set at any stage of the algorithm, $T$ is a MST containing $F$ and $e$ is the new edge we want to add using Kruskal.\n\nIf $e$ generates a cycle, then we don't add it, and so the proposal is still true after this step.\n\nIn case that $T$ already contains $e$, the proposal is also true after this step.\n\nIn case $T$ doesn't contain the edge $e$, then $T + e$ will contain a cycle $C$.\nThis cycle will contain at least one edge $f$, that is not in $F$.\nThe set of edges $T - f + e$ will also be a spanning tree. \nNotice that the weight of $f$ cannot be smaller than the weight of $e$, because otherwise Kruskal would have chosen $f$ earlier.\nIt also cannot have a bigger weight, since that would make the total weight of $T - f + e$ smaller than the total weight of $T$, which is impossible since $T$ is already a MST.\nThis means that the weight of $e$ has to be the same as the weight of $f$.\nTherefore $T - f + e$ is also a MST, and it contains all edges from $F + e$.\nSo also here the proposal is still fulfilled after the step.\n\nThis proves the proposal.\nWhich means that after iterating over all edges the resulting edge set will be connected, and will be contained in a MST, which means that it has to be a MST already.\n\n## Improved implementation\n\nWe can use the [**Disjoint Set Union** (DSU)](../data_structures/disjoint_set_union.md) data structure to write a faster implementation of the Kruskal's algorithm with the time complexity of about $O(M \\log N)$. [This article](mst_kruskal_with_dsu.md) details such an approach.\n\n## Practice Problems\n\n* [SPOJ - Koicost](http://www.spoj.com/problems/KOICOST/)\n* [SPOJ - MaryBMW](http://www.spoj.com/problems/MARYBMW/)\n* [Codechef - Fullmetal Alchemist](https://www.codechef.com/ICL2016/problems/ICL16A)\n* [Codeforces - Edges in MST](http://codeforces.com/contest/160/problem/D)\n* [UVA 12176 - Bring Your Own Horse](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3328)\n* [UVA 10600 - ACM Contest and Blackout](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1541)\n* [UVA 10724 - Road Construction](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1665)\n* [Hackerrank - Roads in HackerLand](https://www.hackerrank.com/contests/june-world-codesprint/challenges/johnland/problem)\n* [UVA 11710 - Expensive subway](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2757)\n* [Codechef - Chefland and Electricity](https://www.codechef.com/problems/CHEFELEC)\n* [UVA 10307 - Killing Aliens in Borg Maze](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1248)\n* [Codeforces - Flea](http://codeforces.com/problemset/problem/32/C)\n* [Codeforces - Igon in Museum](http://codeforces.com/problemset/problem/598/D)\n* [Codeforces - Hongcow Builds a Nation](http://codeforces.com/problemset/problem/744/A)\n* [UVA - 908 - Re-connecting Computer Sites](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=849)\n* [UVA 1208 - Oreon](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3649)\n* [UVA 1235 - Anti Brute Force Lock](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3676)\n* [UVA 10034 - Freckles](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=975)\n* [UVA 11228 - Transportation system](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2169)\n* [UVA 11631 - Dark roads](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2678)\n* [UVA 11733 - Airports](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2833)\n* [UVA 11747 - Heavy Cycle Edges](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2847)\n* [SPOJ - Blinet](http://www.spoj.com/problems/BLINNET/)\n* [SPOJ - Help the Old King](http://www.spoj.com/problems/IITKWPCG/)\n* [Codeforces - Hierarchy](http://codeforces.com/contest/17/problem/B)\n* [SPOJ - Modems](https://www.spoj.com/problems/EC_MODE/)\n* [CSES - Road Reparation](https://cses.fi/problemset/task/1675)\n* [CSES - Road Construction](https://cses.fi/problemset/task/1676)\n", "problem_ids": ["160_D", "32_C", "17_B"], "title": "Minimum spanning tree - Kruskal's algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: preflow_push\n---\n\n# Maximum flow - Push-relabel algorithm\n\nThe push-relabel algorithm (or also known as preflow-push algorithm) is an algorithm for computing the maximum flow of a flow network.\nThe exact definition of the problem that we want to solve can be found in the article [Maximum flow - Ford-Fulkerson and Edmonds-Karp](edmonds_karp.md).\n\nIn this article we will consider solving the problem by pushing a preflow through the network, which will run in $O(V^4)$, or more precisely in $O(V^2 E)$, time.\nThe algorithm was designed by Andrew Goldberg and Robert Tarjan in 1985.\n\n## Definitions\n\nDuring the algorithm we will have to handle a **preflow** - i.e. a function $f$ that is similar to the flow function, but does not necessarily satisfies the flow conservation constraint.\nFor it only the constraints\n\n$$0 \\le f(e) \\le c(e)$$\n\nand\n\n$$\\sum_{(v, u) \\in E} f((v, u)) \\ge \\sum_{(u, v) \\in E} f((u, v))$$\n\nhave to hold.\n\nSo it is possible for some vertex to receive more flow than it distributes.\nWe say that this vertex has some excess flow, and define the amount of it with the **excess** function $x(u) =\\sum_{(v, u) \\in E} f((v, u)) - \\sum_{(u, v) \\in E} f((u, v))$.\n\nIn the same way as with the flow function, we can define the residual capacities and the residual graph with the preflow function.\n\nThe algorithm will start off with an initial preflow (some vertices having excess), and during the execution the preflow will be handled and modified.\nGiving away some details already, the algorithm will pick a vertex with excess, and push the excess to neighboring vertices.\nIt will repeat this until all vertices, except the source and the sink, are free from excess.\nIt is easy to see, that a preflow without excess is a valid flow.\nThis makes the algorithm terminate with an actual flow.\n\nThere are still two problem, we have to deal with.\nFirst, how do we guarantee that this actually terminates?\nAnd secondly, how do we guarantee that this will actually give us a maximum flow, and not just any random flow?\n\nTo solve these problems we need the help of another function, namely the **labeling** functions $h$, often also called **height** function, which assigns each vertex an integer.\nWe call a labeling is valid, if $h(s) = |V|$, $h(t) = 0$, and $h(u) \\le h(v) + 1$ if there is an edge $(u, v)$ in the residual graph - i.e. the edge $(u, v)$ has a positive capacity in the residual graph.\nIn other words, if it is possible to increase the flow from $u$ to $v$, then the height of $v$ can be at most one smaller than the height of $u$, but it can be equal or even higher.\n\nIt is important to note, that if there exists a valid labeling function, then there doesn't exist an augmenting path from $s$ to $t$ in the residual graph.\nBecause such a path will have a length of at most $|V| - 1$ edges, and each edge can decrease the height only by at most by one, which is impossible if the first height is $h(s) = |V|$ and the last height is $h(t) = 0$.\n\nUsing this labeling function we can state the strategy of the push-relabel algorithm:\nWe start with a valid preflow and a valid labeling function.\nIn each step we push some excess between vertices, and update the labels of vertices.\nWe have to make sure, that after each step the preflow and the labeling are still valid.\nIf then the algorithm determines, the preflow is a valid flow.\nAnd because we also have a valid labeling, there doesn't exists a path between $s$ and $t$ in the residual graph, which means that the flow is actually a maximum flow.\n\nIf we compare the Ford-Fulkerson algorithm with the push-relabel algorithm it seems like the algorithms are the duals of each other.\nThe Ford-Fulkerson algorithm keeps a valid flow at all time and improves it until there doesn't exists an augmenting path any more, while in the push-relabel algorithm there doesn't exists an augmenting path at any time, and we will improve the preflow until it is a valid flow.\n\n## Algorithm\n\nFirst we have to initialize the graph with a valid preflow and labeling function.\n\nUsing the empty preflow - like it is done in the Ford-Fulkerson algorithm - is not possible, because then there will be an augmenting path and this implies that there doesn't exists a valid labeling.\nTherefore we will initialize each edges outgoing from $s$ with its maximal capacity: $f((s, u)) = c((s, u))$.\nAnd all other edges with zero.\nIn this case there exists a valid labeling, namely $h(s) = |V|$ for the source vertex and $h(u) = 0$ for all other.\n\nNow let's describe the two operations in more detail.\n\nWith the `push` operation we try to push as much excess flow from one vertex $u$ to a neighboring vertex $v$.\nWe have one rule: we are only allowed to push flow from $u$ to $v$ if $h(u) = h(v) + 1$.\nIn layman's terms, the excess flow has to flow downwards, but not too steeply.\nOf course we only can push $\\min(x(u), c((u, v)) - f((u, v)))$ flow.\n\nIf a vertex has excess, but it is not possible to push the excess to any adjacent vertex, then we need to increase the height of this vertex.\nWe call this operation `relabel`.\nWe will increase it by as much as it is possible, while still maintaining validity of the labeling.\n\nTo recap, the algorithm in a nutshell is:\nWe initialize a valid preflow and a valid labeling.\nWhile we can perform push or relabel operations, we perform them.\nAfterwards the preflow is actually a flow and we return it.\n\n## Complexity\n\nIt is easy to show, that the maximal label of a vertex is $2|V| - 1$.\nAt this point all remaining excess can and will be pushed back to the source.\nThis gives at most $O(V^2)$ relabel operations.\n\nIt can also be showed, that there will be at most $O(V E)$ saturating pushes (a push where the total capacity of the edge is used) and at most $O(V^2 E)$ non-saturating pushes (a push where the capacity of an edge is not fully used) performed.\nIf we pick a data structure that allows us to find the next vertex with excess in $O(1)$ time, then the total complexity of the algorithm is $O(V^2 E)$.\n\n## Implementation\n\n```{.cpp file=push_relabel}\nconst int inf = 1000000000;\n\nint n;\nvector<vector<int>> capacity, flow;\nvector<int> height, excess, seen;\nqueue<int> excess_vertices;\n\nvoid push(int u, int v)\n{\n    int d = min(excess[u], capacity[u][v] - flow[u][v]);\n    flow[u][v] += d;\n    flow[v][u] -= d;\n    excess[u] -= d;\n    excess[v] += d;\n    if (d && excess[v] == d)\n        excess_vertices.push(v);\n}\n\nvoid relabel(int u)\n{\n    int d = inf;\n    for (int i = 0; i < n; i++) {\n        if (capacity[u][i] - flow[u][i] > 0)\n            d = min(d, height[i]);\n    }\n    if (d < inf)\n        height[u] = d + 1;\n}\n\nvoid discharge(int u)\n{\n    while (excess[u] > 0) {\n        if (seen[u] < n) {\n            int v = seen[u];\n            if (capacity[u][v] - flow[u][v] > 0 && height[u] > height[v])\n                push(u, v);\n            else \n                seen[u]++;\n        } else {\n            relabel(u);\n            seen[u] = 0;\n        }\n    }\n}\n\nint max_flow(int s, int t)\n{\n    height.assign(n, 0);\n    height[s] = n;\n    flow.assign(n, vector<int>(n, 0));\n    excess.assign(n, 0);\n    excess[s] = inf;\n    for (int i = 0; i < n; i++) {\n    \tif (i != s)\n\t        push(s, i);\n    }\n    seen.assign(n, 0);\n\n    while (!excess_vertices.empty()) {\n        int u = excess_vertices.front();\n        excess_vertices.pop();\n        if (u != s && u != t)\n            discharge(u);\n    }\n\n    int max_flow = 0;\n    for (int i = 0; i < n; i++)\n        max_flow += flow[i][t];\n    return max_flow;\n}\n```\n\nHere we use the queue `excess_vertices` to store all vertices that currently have excess.\nIn that way we can pick the next vertex for a push or a relabel operation in constant time.\n\nAnd to make sure that we don't spend too much time finding the adjacent vertex to whom we can push, we use a data structure called **current-arc**.\nBasically we will iterate over the edges in a circular order and always store the last edge that we used.\nThis way, for a certain labeling value, we will switch the current edge only $O(n)$ time.\nAnd since the relabeling already takes $O(n)$ time, we don't make the complexity worse.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: preflow_push\n---\n\n# Maximum flow - Push-relabel algorithm\n\nThe push-relabel algorithm (or also known as preflow-push algorithm) is an algorithm for computing the maximum flow of a flow network.\nThe exact definition of the problem that we want to solve can be found in the article [Maximum flow - Ford-Fulkerson and Edmonds-Karp](edmonds_karp.md).\n\nIn this article we will consider solving the problem by pushing a preflow through the network, which will run in $O(V^4)$, or more precisely in $O(V^2 E)$, time.\nThe algorithm was designed by Andrew Goldberg and Robert Tarjan in 1985.\n\n## Definitions\n\nDuring the algorithm we will have to handle a **preflow** - i.e. a function $f$ that is similar to the flow function, but does not necessarily satisfies the flow conservation constraint.\nFor it only the constraints\n\n$$0 \\le f(e) \\le c(e)$$\n\nand\n\n$$\\sum_{(v, u) \\in E} f((v, u)) \\ge \\sum_{(u, v) \\in E} f((u, v))$$\n\nhave to hold.\n\nSo it is possible for some vertex to receive more flow than it distributes.\nWe say that this vertex has some excess flow, and define the amount of it with the **excess** function $x(u) =\\sum_{(v, u) \\in E} f((v, u)) - \\sum_{(u, v) \\in E} f((u, v))$.\n\nIn the same way as with the flow function, we can define the residual capacities and the residual graph with the preflow function.\n\nThe algorithm will start off with an initial preflow (some vertices having excess), and during the execution the preflow will be handled and modified.\nGiving away some details already, the algorithm will pick a vertex with excess, and push the excess to neighboring vertices.\nIt will repeat this until all vertices, except the source and the sink, are free from excess.\nIt is easy to see, that a preflow without excess is a valid flow.\nThis makes the algorithm terminate with an actual flow.\n\nThere are still two problem, we have to deal with.\nFirst, how do we guarantee that this actually terminates?\nAnd secondly, how do we guarantee that this will actually give us a maximum flow, and not just any random flow?\n\nTo solve these problems we need the help of another function, namely the **labeling** functions $h$, often also called **height** function, which assigns each vertex an integer.\nWe call a labeling is valid, if $h(s) = |V|$, $h(t) = 0$, and $h(u) \\le h(v) + 1$ if there is an edge $(u, v)$ in the residual graph - i.e. the edge $(u, v)$ has a positive capacity in the residual graph.\nIn other words, if it is possible to increase the flow from $u$ to $v$, then the height of $v$ can be at most one smaller than the height of $u$, but it can be equal or even higher.\n\nIt is important to note, that if there exists a valid labeling function, then there doesn't exist an augmenting path from $s$ to $t$ in the residual graph.\nBecause such a path will have a length of at most $|V| - 1$ edges, and each edge can decrease the height only by at most by one, which is impossible if the first height is $h(s) = |V|$ and the last height is $h(t) = 0$.\n\nUsing this labeling function we can state the strategy of the push-relabel algorithm:\nWe start with a valid preflow and a valid labeling function.\nIn each step we push some excess between vertices, and update the labels of vertices.\nWe have to make sure, that after each step the preflow and the labeling are still valid.\nIf then the algorithm determines, the preflow is a valid flow.\nAnd because we also have a valid labeling, there doesn't exists a path between $s$ and $t$ in the residual graph, which means that the flow is actually a maximum flow.\n\nIf we compare the Ford-Fulkerson algorithm with the push-relabel algorithm it seems like the algorithms are the duals of each other.\nThe Ford-Fulkerson algorithm keeps a valid flow at all time and improves it until there doesn't exists an augmenting path any more, while in the push-relabel algorithm there doesn't exists an augmenting path at any time, and we will improve the preflow until it is a valid flow.\n\n## Algorithm\n\nFirst we have to initialize the graph with a valid preflow and labeling function.\n\nUsing the empty preflow - like it is done in the Ford-Fulkerson algorithm - is not possible, because then there will be an augmenting path and this implies that there doesn't exists a valid labeling.\nTherefore we will initialize each edges outgoing from $s$ with its maximal capacity: $f((s, u)) = c((s, u))$.\nAnd all other edges with zero.\nIn this case there exists a valid labeling, namely $h(s) = |V|$ for the source vertex and $h(u) = 0$ for all other.\n\nNow let's describe the two operations in more detail.\n\nWith the `push` operation we try to push as much excess flow from one vertex $u$ to a neighboring vertex $v$.\nWe have one rule: we are only allowed to push flow from $u$ to $v$ if $h(u) = h(v) + 1$.\nIn layman's terms, the excess flow has to flow downwards, but not too steeply.\nOf course we only can push $\\min(x(u), c((u, v)) - f((u, v)))$ flow.\n\nIf a vertex has excess, but it is not possible to push the excess to any adjacent vertex, then we need to increase the height of this vertex.\nWe call this operation `relabel`.\nWe will increase it by as much as it is possible, while still maintaining validity of the labeling.\n\nTo recap, the algorithm in a nutshell is:\nWe initialize a valid preflow and a valid labeling.\nWhile we can perform push or relabel operations, we perform them.\nAfterwards the preflow is actually a flow and we return it.\n\n## Complexity\n\nIt is easy to show, that the maximal label of a vertex is $2|V| - 1$.\nAt this point all remaining excess can and will be pushed back to the source.\nThis gives at most $O(V^2)$ relabel operations.\n\nIt can also be showed, that there will be at most $O(V E)$ saturating pushes (a push where the total capacity of the edge is used) and at most $O(V^2 E)$ non-saturating pushes (a push where the capacity of an edge is not fully used) performed.\nIf we pick a data structure that allows us to find the next vertex with excess in $O(1)$ time, then the total complexity of the algorithm is $O(V^2 E)$.\n\n## Implementation\n\n```{.cpp file=push_relabel}\nconst int inf = 1000000000;\n\nint n;\nvector<vector<int>> capacity, flow;\nvector<int> height, excess, seen;\nqueue<int> excess_vertices;\n\nvoid push(int u, int v)\n{\n    int d = min(excess[u], capacity[u][v] - flow[u][v]);\n    flow[u][v] += d;\n    flow[v][u] -= d;\n    excess[u] -= d;\n    excess[v] += d;\n    if (d && excess[v] == d)\n        excess_vertices.push(v);\n}\n\nvoid relabel(int u)\n{\n    int d = inf;\n    for (int i = 0; i < n; i++) {\n        if (capacity[u][i] - flow[u][i] > 0)\n            d = min(d, height[i]);\n    }\n    if (d < inf)\n        height[u] = d + 1;\n}\n\nvoid discharge(int u)\n{\n    while (excess[u] > 0) {\n        if (seen[u] < n) {\n            int v = seen[u];\n            if (capacity[u][v] - flow[u][v] > 0 && height[u] > height[v])\n                push(u, v);\n            else \n                seen[u]++;\n        } else {\n            relabel(u);\n            seen[u] = 0;\n        }\n    }\n}\n\nint max_flow(int s, int t)\n{\n    height.assign(n, 0);\n    height[s] = n;\n    flow.assign(n, vector<int>(n, 0));\n    excess.assign(n, 0);\n    excess[s] = inf;\n    for (int i = 0; i < n; i++) {\n    \tif (i != s)\n\t        push(s, i);\n    }\n    seen.assign(n, 0);\n\n    while (!excess_vertices.empty()) {\n        int u = excess_vertices.front();\n        excess_vertices.pop();\n        if (u != s && u != t)\n            discharge(u);\n    }\n\n    int max_flow = 0;\n    for (int i = 0; i < n; i++)\n        max_flow += flow[i][t];\n    return max_flow;\n}\n```\n\nHere we use the queue `excess_vertices` to store all vertices that currently have excess.\nIn that way we can pick the next vertex for a push or a relabel operation in constant time.\n\nAnd to make sure that we don't spend too much time finding the adjacent vertex to whom we can push, we use a data structure called **current-arc**.\nBasically we will iterate over the edges in a circular order and always store the last edge that we used.\nThis way, for a certain labeling value, we will switch the current edge only $O(n)$ time.\nAnd since the relabeling already takes $O(n)$ time, we don't make the complexity worse.\n", "problem_ids": [], "title": "Maximum flow - Push-relabel algorithm"}, {"article": "---\ntitle: Checking a graph for acyclicity and finding a cycle in O(M)\ntags:\n  - Translated\ne_maxx_link: finding_cycle\n---\n# Checking a graph for acyclicity and finding a cycle in $O(M)$\n\nConsider a directed or undirected graph without loops and multiple edges. We have to check whether it is acyclic, and if it is not, then find any cycle.\n\nWe can solve this problem by using [Depth First Search](depth-first-search.md) in $O(M)$ where $M$ is number of edges.\n\n## Algorithm\n\nWe will run a series of DFS in the graph. Initially all vertices are colored white (0). From each unvisited (white) vertex, start the DFS, mark it gray (1) while entering and mark it black (2) on exit. If DFS moves to a gray vertex, then we have found a cycle (if the graph is undirected, the edge to parent is not considered).\nThe cycle itself can be reconstructed using parent array.\n\n## Implementation\n\nHere is an implementation for directed graph.\n\n```cpp\nint n;\nvector<vector<int>> adj;\nvector<char> color;\nvector<int> parent;\nint cycle_start, cycle_end;\n\nbool dfs(int v) {\n    color[v] = 1;\n    for (int u : adj[v]) {\n        if (color[u] == 0) {\n            parent[u] = v;\n            if (dfs(u))\n                return true;\n        } else if (color[u] == 1) {\n            cycle_end = v;\n            cycle_start = u;\n            return true;\n        }\n    }\n    color[v] = 2;\n    return false;\n}\n\nvoid find_cycle() {\n    color.assign(n, 0);\n    parent.assign(n, -1);\n    cycle_start = -1;\n\n    for (int v = 0; v < n; v++) {\n        if (color[v] == 0 && dfs(v))\n            break;\n    }\n\n    if (cycle_start == -1) {\n        cout << \"Acyclic\" << endl;\n    } else {\n        vector<int> cycle;\n        cycle.push_back(cycle_start);\n        for (int v = cycle_end; v != cycle_start; v = parent[v])\n            cycle.push_back(v);\n        cycle.push_back(cycle_start);\n        reverse(cycle.begin(), cycle.end());\n\n        cout << \"Cycle found: \";\n        for (int v : cycle)\n            cout << v << \" \";\n        cout << endl;\n    }\n}\n```\n\nHere is an implementation for undirected graph.\nNote that in the undirected version, if a vertex `v` gets colored black, it will never be visited again by the DFS.\nThis is because we already explored all connected edges of `v` when we first visited it.\nThe connected component containing `v` (after removing the edge between `v` and its parent) must be a tree, if the DFS has completed processing `v` without finding a cycle.\nSo we don't even need to distinguish between gray and black states.\nThus we can turn the char vector `color` into a boolean vector `visited`.\n\n```cpp\nint n;\nvector<vector<int>> adj;\nvector<bool> visited;\nvector<int> parent;\nint cycle_start, cycle_end;\n\nbool dfs(int v, int par) { // passing vertex and its parent vertex\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if(u == par) continue; // skipping edge to parent vertex\n        if (visited[u]) {\n            cycle_end = v;\n            cycle_start = u;\n            return true;\n        }\n        parent[u] = v;\n        if (dfs(u, parent[u]))\n            return true;\n    }\n    return false;\n}\n\nvoid find_cycle() {\n    visited.assign(n, false);\n    parent.assign(n, -1);\n    cycle_start = -1;\n\n    for (int v = 0; v < n; v++) {\n        if (!visited[v] && dfs(v, parent[v]))\n            break;\n    }\n\n    if (cycle_start == -1) {\n        cout << \"Acyclic\" << endl;\n    } else {\n        vector<int> cycle;\n        cycle.push_back(cycle_start);\n        for (int v = cycle_end; v != cycle_start; v = parent[v])\n            cycle.push_back(v);\n        cycle.push_back(cycle_start);\n\n        cout << \"Cycle found: \";\n        for (int v : cycle)\n            cout << v << \" \";\n        cout << endl;\n    }\n}\n```\n#", "full_article": "---\ntitle: Checking a graph for acyclicity and finding a cycle in O(M)\ntags:\n  - Translated\ne_maxx_link: finding_cycle\n---\n# Checking a graph for acyclicity and finding a cycle in $O(M)$\n\nConsider a directed or undirected graph without loops and multiple edges. We have to check whether it is acyclic, and if it is not, then find any cycle.\n\nWe can solve this problem by using [Depth First Search](depth-first-search.md) in $O(M)$ where $M$ is number of edges.\n\n## Algorithm\n\nWe will run a series of DFS in the graph. Initially all vertices are colored white (0). From each unvisited (white) vertex, start the DFS, mark it gray (1) while entering and mark it black (2) on exit. If DFS moves to a gray vertex, then we have found a cycle (if the graph is undirected, the edge to parent is not considered).\nThe cycle itself can be reconstructed using parent array.\n\n## Implementation\n\nHere is an implementation for directed graph.\n\n```cpp\nint n;\nvector<vector<int>> adj;\nvector<char> color;\nvector<int> parent;\nint cycle_start, cycle_end;\n\nbool dfs(int v) {\n    color[v] = 1;\n    for (int u : adj[v]) {\n        if (color[u] == 0) {\n            parent[u] = v;\n            if (dfs(u))\n                return true;\n        } else if (color[u] == 1) {\n            cycle_end = v;\n            cycle_start = u;\n            return true;\n        }\n    }\n    color[v] = 2;\n    return false;\n}\n\nvoid find_cycle() {\n    color.assign(n, 0);\n    parent.assign(n, -1);\n    cycle_start = -1;\n\n    for (int v = 0; v < n; v++) {\n        if (color[v] == 0 && dfs(v))\n            break;\n    }\n\n    if (cycle_start == -1) {\n        cout << \"Acyclic\" << endl;\n    } else {\n        vector<int> cycle;\n        cycle.push_back(cycle_start);\n        for (int v = cycle_end; v != cycle_start; v = parent[v])\n            cycle.push_back(v);\n        cycle.push_back(cycle_start);\n        reverse(cycle.begin(), cycle.end());\n\n        cout << \"Cycle found: \";\n        for (int v : cycle)\n            cout << v << \" \";\n        cout << endl;\n    }\n}\n```\n\nHere is an implementation for undirected graph.\nNote that in the undirected version, if a vertex `v` gets colored black, it will never be visited again by the DFS.\nThis is because we already explored all connected edges of `v` when we first visited it.\nThe connected component containing `v` (after removing the edge between `v` and its parent) must be a tree, if the DFS has completed processing `v` without finding a cycle.\nSo we don't even need to distinguish between gray and black states.\nThus we can turn the char vector `color` into a boolean vector `visited`.\n\n```cpp\nint n;\nvector<vector<int>> adj;\nvector<bool> visited;\nvector<int> parent;\nint cycle_start, cycle_end;\n\nbool dfs(int v, int par) { // passing vertex and its parent vertex\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if(u == par) continue; // skipping edge to parent vertex\n        if (visited[u]) {\n            cycle_end = v;\n            cycle_start = u;\n            return true;\n        }\n        parent[u] = v;\n        if (dfs(u, parent[u]))\n            return true;\n    }\n    return false;\n}\n\nvoid find_cycle() {\n    visited.assign(n, false);\n    parent.assign(n, -1);\n    cycle_start = -1;\n\n    for (int v = 0; v < n; v++) {\n        if (!visited[v] && dfs(v, parent[v]))\n            break;\n    }\n\n    if (cycle_start == -1) {\n        cout << \"Acyclic\" << endl;\n    } else {\n        vector<int> cycle;\n        cycle.push_back(cycle_start);\n        for (int v = cycle_end; v != cycle_start; v = parent[v])\n            cycle.push_back(v);\n        cycle.push_back(cycle_start);\n\n        cout << \"Cycle found: \";\n        for (int v : cycle)\n            cout << v << \" \";\n        cout << endl;\n    }\n}\n```\n### Practice problems:\n\n- [CSES : Round Trip](https://cses.fi/problemset/task/1669)\n- [CSES : Round Trip II](https://cses.fi/problemset/task/1678/)\n", "problem_ids": [], "title": "Checking a graph for acyclicity and finding a cycle in $O(M)$"}, {"article": "---\ntitle: Finding bridges in a graph in O(N+M)\ntags:\n  - Translated\ne_maxx_link: bridge_searching\n---\n# Finding bridges in a graph in $O(N+M)$\n\nWe are given an undirected graph. A bridge is defined as an edge which, when removed, makes the graph disconnected (or more precisely, increases the number of connected components in the graph). The task is to find all bridges in the given graph.\n\nInformally, the problem is formulated as follows: given a map of cities connected with roads, find all \"important\" roads, i.e. roads which, when removed, cause disappearance of a path between some pair of cities.\n\nThe algorithm described here is based on [depth first search](depth-first-search.md) and has $O(N+M)$ complexity, where $N$ is the number of vertices and $M$ is the number of edges in the graph.\n\nNote that there is also the article [Finding Bridges Online](bridge-searching-online.md) - unlike the offline algorithm described here, the online algorithm is able to maintain the list of all bridges in a changing graph (assuming that the only type of change is addition of new edges).\n\n## Algorithm\n\nPick an arbitrary vertex of the graph $root$ and run [depth first search](depth-first-search.md) from it. Note the following fact (which is easy to prove):\n\n- Let's say we are in the DFS, looking through the edges starting from vertex $v$. The current edge $(v, to)$ is a bridge if and only if none of the vertices $to$ and its descendants in the DFS traversal tree has a back-edge to vertex $v$ or any of its ancestors. Indeed, this condition means that there is no other way from $v$ to $to$ except for edge $(v, to)$.\n\nNow we have to learn to check this fact for each vertex efficiently. We'll use \"time of entry into node\" computed by the depth first search.\n\nSo, let $tin[v]$ denote entry time for node $v$. We introduce an array $low$ which will let us check the fact for each vertex $v$. $low[v]$ is the minimum of $tin[v]$, the entry times $tin[p]$ for each node $p$ that is connected to node $v$ via a back-edge $(v, p)$ and the values of $low[to]$ for each vertex $to$ which is a direct descendant of $v$ in the DFS tree:\n\n$$low[v] = \\min \\begin{cases} tin[v] \\\\ tin[p]& \\text{ for all }p\\text{ for which }(v, p)\\text{ is a back edge} \\\\ low[to]& \\text{ for all }to\\text{ for which }(v, to)\\text{ is a tree edge} \\end{cases}$$\n\nNow, there is a back edge from vertex $v$ or one of its descendants to one of its ancestors if and only if vertex $v$ has a child $to$ for which $low[to] \\leq tin[v]$. If $low[to] = tin[v]$, the back edge comes directly to $v$, otherwise it comes to one of the ancestors of $v$.\n\nThus, the current edge $(v, to)$ in the DFS tree is a bridge if and only if $low[to] > tin[v]$.\n\n## Implementation\n\nThe implementation needs to distinguish three cases: when we go down the edge in DFS tree, when we find a back edge to an ancestor of the vertex and when we return to a parent of the vertex. These are the cases:\n\n- $visited[to] = false$ - the edge is part of DFS tree;\n- $visited[to] = true$ && $to \\neq parent$ - the edge is back edge to one of the ancestors;\n- $to = parent$ - the edge leads back to parent in DFS tree.\n\nTo implement this, we need a depth first search function which accepts the parent vertex of the current node.\n\n```cpp\nint n; // number of nodes\nvector<vector<int>> adj; // adjacency list of graph\n\nvector<bool> visited;\nvector<int> tin, low;\nint timer;\n \nvoid dfs(int v, int p = -1) {\n    visited[v] = true;\n    tin[v] = low[v] = timer++;\n    for (int to : adj[v]) {\n        if (to == p) continue;\n        if (visited[to]) {\n            low[v] = min(low[v], tin[to]);\n        } else {\n            dfs(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] > tin[v])\n                IS_BRIDGE(v, to);\n        }\n    }\n}\n \nvoid find_bridges() {\n    timer = 0;\n    visited.assign(n, false);\n    tin.assign(n, -1);\n    low.assign(n, -1);\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i])\n            dfs(i);\n    }\n}\n```\n\nMain function is `find_bridges`; it performs necessary initialization and starts depth first search in each connected component of the graph.\n\nFunction `IS_BRIDGE(a, b)` is some function that will process the fact that edge $(a, b)$ is a bridge, for example, print it.\n\nNote that this implementation malfunctions if the graph has multiple edges, since it ignores them. Of course, multiple edges will never be a part of the answer, so `IS_BRIDGE` can check additionally that the reported bridge is not a multiple edge. Alternatively it's possible to pass to `dfs` the index of the edge used to enter the vertex instead of the parent vertex (and store the indices of all vertices).\n\n", "full_article": "---\ntitle: Finding bridges in a graph in O(N+M)\ntags:\n  - Translated\ne_maxx_link: bridge_searching\n---\n# Finding bridges in a graph in $O(N+M)$\n\nWe are given an undirected graph. A bridge is defined as an edge which, when removed, makes the graph disconnected (or more precisely, increases the number of connected components in the graph). The task is to find all bridges in the given graph.\n\nInformally, the problem is formulated as follows: given a map of cities connected with roads, find all \"important\" roads, i.e. roads which, when removed, cause disappearance of a path between some pair of cities.\n\nThe algorithm described here is based on [depth first search](depth-first-search.md) and has $O(N+M)$ complexity, where $N$ is the number of vertices and $M$ is the number of edges in the graph.\n\nNote that there is also the article [Finding Bridges Online](bridge-searching-online.md) - unlike the offline algorithm described here, the online algorithm is able to maintain the list of all bridges in a changing graph (assuming that the only type of change is addition of new edges).\n\n## Algorithm\n\nPick an arbitrary vertex of the graph $root$ and run [depth first search](depth-first-search.md) from it. Note the following fact (which is easy to prove):\n\n- Let's say we are in the DFS, looking through the edges starting from vertex $v$. The current edge $(v, to)$ is a bridge if and only if none of the vertices $to$ and its descendants in the DFS traversal tree has a back-edge to vertex $v$ or any of its ancestors. Indeed, this condition means that there is no other way from $v$ to $to$ except for edge $(v, to)$.\n\nNow we have to learn to check this fact for each vertex efficiently. We'll use \"time of entry into node\" computed by the depth first search.\n\nSo, let $tin[v]$ denote entry time for node $v$. We introduce an array $low$ which will let us check the fact for each vertex $v$. $low[v]$ is the minimum of $tin[v]$, the entry times $tin[p]$ for each node $p$ that is connected to node $v$ via a back-edge $(v, p)$ and the values of $low[to]$ for each vertex $to$ which is a direct descendant of $v$ in the DFS tree:\n\n$$low[v] = \\min \\begin{cases} tin[v] \\\\ tin[p]& \\text{ for all }p\\text{ for which }(v, p)\\text{ is a back edge} \\\\ low[to]& \\text{ for all }to\\text{ for which }(v, to)\\text{ is a tree edge} \\end{cases}$$\n\nNow, there is a back edge from vertex $v$ or one of its descendants to one of its ancestors if and only if vertex $v$ has a child $to$ for which $low[to] \\leq tin[v]$. If $low[to] = tin[v]$, the back edge comes directly to $v$, otherwise it comes to one of the ancestors of $v$.\n\nThus, the current edge $(v, to)$ in the DFS tree is a bridge if and only if $low[to] > tin[v]$.\n\n## Implementation\n\nThe implementation needs to distinguish three cases: when we go down the edge in DFS tree, when we find a back edge to an ancestor of the vertex and when we return to a parent of the vertex. These are the cases:\n\n- $visited[to] = false$ - the edge is part of DFS tree;\n- $visited[to] = true$ && $to \\neq parent$ - the edge is back edge to one of the ancestors;\n- $to = parent$ - the edge leads back to parent in DFS tree.\n\nTo implement this, we need a depth first search function which accepts the parent vertex of the current node.\n\n```cpp\nint n; // number of nodes\nvector<vector<int>> adj; // adjacency list of graph\n\nvector<bool> visited;\nvector<int> tin, low;\nint timer;\n \nvoid dfs(int v, int p = -1) {\n    visited[v] = true;\n    tin[v] = low[v] = timer++;\n    for (int to : adj[v]) {\n        if (to == p) continue;\n        if (visited[to]) {\n            low[v] = min(low[v], tin[to]);\n        } else {\n            dfs(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] > tin[v])\n                IS_BRIDGE(v, to);\n        }\n    }\n}\n \nvoid find_bridges() {\n    timer = 0;\n    visited.assign(n, false);\n    tin.assign(n, -1);\n    low.assign(n, -1);\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i])\n            dfs(i);\n    }\n}\n```\n\nMain function is `find_bridges`; it performs necessary initialization and starts depth first search in each connected component of the graph.\n\nFunction `IS_BRIDGE(a, b)` is some function that will process the fact that edge $(a, b)$ is a bridge, for example, print it.\n\nNote that this implementation malfunctions if the graph has multiple edges, since it ignores them. Of course, multiple edges will never be a part of the answer, so `IS_BRIDGE` can check additionally that the reported bridge is not a multiple edge. Alternatively it's possible to pass to `dfs` the index of the edge used to enter the vertex instead of the parent vertex (and store the indices of all vertices).\n\n## Practice Problems\n\n- [UVA #796 \"Critical Links\"](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=737) [difficulty: low]\n- [UVA #610 \"Street Directions\"](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=551) [difficulty: medium]\n- [Case of the Computer Network (Codeforces Round #310 Div. 1 E)](http://codeforces.com/problemset/problem/555/E) [difficulty: hard]\n* [UVA 12363 - Hedge Mazes](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3785)\n* [UVA 315 - Network](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=251)\n* [GYM - Computer Network (J)](http://codeforces.com/gym/100114)\n* [SPOJ - King Graffs Defense](http://www.spoj.com/problems/GRAFFDEF/)\n* [SPOJ - Critical Edges](http://www.spoj.com/problems/EC_P/)\n* [Codeforces - Break Up](http://codeforces.com/contest/700/problem/C)\n* [Codeforces - Tourist Reform](http://codeforces.com/contest/732/problem/F)\n", "problem_ids": ["700_C", "732_F"], "title": "Finding bridges in a graph in $O(N+M)$"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: mst_kruskal_with_dsu\n---\n\n# Minimum spanning tree - Kruskal with Disjoint Set Union\n\nFor an explanation of the MST problem and the Kruskal algorithm, first see the [main article on Kruskal's algorithm](mst_kruskal.md).\n\nIn this article we will consider the data structure [\"Disjoint Set Union\"](../data_structures/disjoint_set_union.md) for implementing Kruskal's algorithm, which will allow the algorithm to achieve the time complexity of $O(M \\log N)$.\n\n## Description\n\nJust as in the simple version of the Kruskal algorithm, we sort all the edges of the graph in non-decreasing order of weights.\nThen put each vertex in its own tree (i.e. its set) via calls to the `make_set` function - it will take a total of $O(N)$.\nWe iterate through all the edges (in sorted order) and for each edge determine whether the ends belong to different trees (with two `find_set` calls in $O(1)$ each).\nFinally, we need to perform the union of the two trees (sets), for which the DSU `union_sets` function will be called - also in $O(1)$.\nSo we get the total time complexity of $O(M \\log N + N + M)$ = $O(M \\log N)$.\n\n## Implementation\n\nHere is an implementation of Kruskal's algorithm with Union by Rank.\n\n```cpp\nvector<int> parent, rank;\n\nvoid make_set(int v) {\n    parent[v] = v;\n    rank[v] = 0;\n}\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n\nstruct Edge {\n    int u, v, weight;\n    bool operator<(Edge const& other) {\n        return weight < other.weight;\n    }\n};\n\nint n;\nvector<Edge> edges;\n\nint cost = 0;\nvector<Edge> result;\nparent.resize(n);\nrank.resize(n);\nfor (int i = 0; i < n; i++)\n    make_set(i);\n\nsort(edges.begin(), edges.end());\n\nfor (Edge e : edges) {\n    if (find_set(e.u) != find_set(e.v)) {\n        cost += e.weight;\n        result.push_back(e);\n        union_sets(e.u, e.v);\n    }\n}\n```\n\nNotice: since the MST will contain exactly $N-1$ edges, we can stop the for loop once we found that many.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: mst_kruskal_with_dsu\n---\n\n# Minimum spanning tree - Kruskal with Disjoint Set Union\n\nFor an explanation of the MST problem and the Kruskal algorithm, first see the [main article on Kruskal's algorithm](mst_kruskal.md).\n\nIn this article we will consider the data structure [\"Disjoint Set Union\"](../data_structures/disjoint_set_union.md) for implementing Kruskal's algorithm, which will allow the algorithm to achieve the time complexity of $O(M \\log N)$.\n\n## Description\n\nJust as in the simple version of the Kruskal algorithm, we sort all the edges of the graph in non-decreasing order of weights.\nThen put each vertex in its own tree (i.e. its set) via calls to the `make_set` function - it will take a total of $O(N)$.\nWe iterate through all the edges (in sorted order) and for each edge determine whether the ends belong to different trees (with two `find_set` calls in $O(1)$ each).\nFinally, we need to perform the union of the two trees (sets), for which the DSU `union_sets` function will be called - also in $O(1)$.\nSo we get the total time complexity of $O(M \\log N + N + M)$ = $O(M \\log N)$.\n\n## Implementation\n\nHere is an implementation of Kruskal's algorithm with Union by Rank.\n\n```cpp\nvector<int> parent, rank;\n\nvoid make_set(int v) {\n    parent[v] = v;\n    rank[v] = 0;\n}\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n\nstruct Edge {\n    int u, v, weight;\n    bool operator<(Edge const& other) {\n        return weight < other.weight;\n    }\n};\n\nint n;\nvector<Edge> edges;\n\nint cost = 0;\nvector<Edge> result;\nparent.resize(n);\nrank.resize(n);\nfor (int i = 0; i < n; i++)\n    make_set(i);\n\nsort(edges.begin(), edges.end());\n\nfor (Edge e : edges) {\n    if (find_set(e.u) != find_set(e.v)) {\n        cost += e.weight;\n        result.push_back(e);\n        union_sets(e.u, e.v);\n    }\n}\n```\n\nNotice: since the MST will contain exactly $N-1$ edges, we can stop the for loop once we found that many.\n\n## Practice Problems\n\nSee [main article on Kruskal's algorithm](mst_kruskal.md) for the list of practice problems on this topic.\n", "problem_ids": [], "title": "Minimum spanning tree - Kruskal with Disjoint Set Union"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: lca_linear\n---\n\n# Lowest Common Ancestor - Farach-Colton and Bender Algorithm\n\nLet $G$ be a tree.\nFor every query of the form $(u, v)$ we want to find the lowest common ancestor of the nodes $u$ and $v$, i.e. we want to find a node $w$ that lies on the path from $u$ to the root node, that lies on the path from $v$ to the root node, and if there are multiple nodes we pick the one that is farthest away from the root node.\nIn other words the desired node $w$ is the lowest ancestor of $u$ and $v$.\nIn particular if $u$ is an ancestor of $v$, then $u$ is their lowest common ancestor.\n\nThe algorithm which will be described in this article was developed by Farach-Colton and Bender.\nIt is asymptotically optimal.\n\n## Algorithm\n\nWe use the classical reduction of the LCA problem to the RMQ problem.\nWe traverse all nodes of the tree with [DFS](depth-first-search.md) and keep an array with all visited nodes and the heights of these nodes. \nThe LCA of two nodes $u$ and $v$ is the node between the occurrences of $u$ and $v$ in the tour, that has the smallest height.\n\nIn the following picture you can see a possible Euler-Tour of a graph and in the list below you can see the visited nodes and their heights.\n\n<center>![LCA_Euler_Tour](LCA_Euler.png)</center>\n\n$$\\begin{array}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|}\n\\hline\n\\text{Nodes:}   & 1 & 2 & 5 & 2 & 6 & 2 & 1 & 3 & 1 & 4 & 7 & 4 & 1 \\\\ \\hline\n\\text{Heights:} & 1 & 2 & 3 & 2 & 3 & 2 & 1 & 2 & 1 & 2 & 3 & 2 & 1 \\\\ \\hline\n\\end{array}$$\n\nYou can read more about this reduction in the article [Lowest Common Ancestor](lca.md).\nIn that article the minimum of a range was either found by sqrt-decomposition in $O(\\sqrt{N})$ or in $O(\\log N)$ using a Segment tree.\nIn this article we look at how we can solve the given range minimum queries in $O(1)$ time, while still only taking $O(N)$ time for preprocessing.\n\nNote that the reduced RMQ problem is very specific:\nany two adjacent elements in the array differ exactly by one (since the elements of the array are nothing more than the heights of the nodes visited in order of traversal, and we either go to a descendant, in which case the next element is one bigger, or go back to the ancestor, in which case the next element is one lower).\nThe Farach-Colton and Bender algorithm describes a solution for exactly this specialized RMQ problem.\n\nLet's denote with $A$ the array on which we want to perform the range minimum queries.\nAnd $N$ will be the size of $A$.\n\nThere is an easy data structure that we can use for solving the RMQ problem with $O(N \\log N)$ preprocessing and $O(1)$ for each query: the [Sparse Table](../data_structures/sparse-table.md).\nWe create a table $T$ where each element $T[i][j]$ is equal to the minimum of $A$ in the interval $[i, i + 2^j - 1]$.\nObviously $0 \\leq j \\leq \\lceil \\log N \\rceil$, and therefore the size of the Sparse Table will be $O(N \\log N)$.\nYou can build the table easily in $O(N \\log N)$ by noting that $T[i][j] = \\min(T[i][j-1], T[i+2^{j-1}][j-1])$.\n\nHow can we answer a query RMQ in $O(1)$ using this data structure?\nLet the received query be $[l, r]$, then the answer is $\\min(T[l][\\text{sz}], T[r-2^{\\text{sz}}+1][\\text{sz}])$, where $\\text{sz}$ is the biggest exponent such that $2^{\\text{sz}}$ is not bigger than the range length $r-l+1$. \nIndeed we can take the range $[l, r]$ and cover it two segments of length $2^{\\text{sz}}$ - one starting in $l$ and the other ending in $r$.\nThese segments overlap, but this doesn't interfere with our computation.\nTo really achieve the time complexity of $O(1)$ per query, we need to know the values of $\\text{sz}$ for all possible lengths from $1$ to $N$.\nBut this can be easily precomputed.\n\nNow we want to improve the complexity of the preprocessing down to $O(N)$.\n\nWe divide the array $A$ into blocks of size $K = 0.5 \\log N$ with $\\log$ being the logarithm to base 2.\nFor each block we calculate the minimum element and store them in an array $B$.\n$B$ has the size $\\frac{N}{K}$.\nWe construct a sparse table from the array $B$.\nThe size and the time complexity of it will be:\n\n$$\\frac{N}{K}\\log\\left(\\frac{N}{K}\\right) = \\frac{2N}{\\log(N)} \\log\\left(\\frac{2N}{\\log(N)}\\right) =$$\n\n$$= \\frac{2N}{\\log(N)} \\left(1 + \\log\\left(\\frac{N}{\\log(N)}\\right)\\right) \\leq \\frac{2N}{\\log(N)} + 2N = O(N)$$\n\nNow we only have to learn how to quickly answer range minimum queries within each block.\nIn fact if the received range minimum query is $[l, r]$ and $l$ and $r$ are in different blocks then the answer is the minimum of the following three values:\nthe minimum of the suffix of block of $l$ starting at $l$, the minimum of the prefix of block of $r$ ending at $r$, and the minimum of the blocks between those.\nThe minimum of the blocks in between can be answered in $O(1)$ using the Sparse Table.\nSo this leaves us only the range minimum queries inside blocks.\n\nHere we will exploit the property of the array.\nRemember that the values in the array - which are just height values in the tree - will always differ by one.\nIf we remove the first element of a block, and subtract it from every other item in the block, every block can be identified by a sequence of length $K - 1$ consisting of the number $+1$ and $-1$.\nBecause these blocks are so small, there are only a few different sequences that can occur.\nThe number of possible sequences is:\n\n$$2^{K-1} = 2^{0.5 \\log(N) - 1} = 0.5 \\left(2^{\\log(N)}\\right)^{0.5} = 0.5 \\sqrt{N}$$\n\nThus the number of different blocks is $O(\\sqrt{N})$, and therefore we can precompute the results of range minimum queries inside all different blocks in $O(\\sqrt{N} K^2) = O(\\sqrt{N} \\log^2(N)) = O(N)$ time.\nFor the implementation we can characterize a block by a bitmask of length $K-1$ (which will fit in a standard int) and store the index of the minimum in an array $\\text{block}[\\text{mask}][l][r]$ of size $O(\\sqrt{N} \\log^2(N))$.\n\nSo we learned how to precompute range minimum queries within each block, as well as range minimum queries over a range of blocks, all in $O(N)$.\nWith these precomputations we can answer each query in $O(1)$, by using at most four precomputed values: the minimum of the block containing `l`, the minimum of the block containing `r`, and the two minima of the overlapping segments of the blocks between them.\n\n## Implementation\n\n```cpp\nint n;\nvector<vector<int>> adj;\n\nint block_size, block_cnt;\nvector<int> first_visit;\nvector<int> euler_tour;\nvector<int> height;\nvector<int> log_2;\nvector<vector<int>> st;\nvector<vector<vector<int>>> blocks;\nvector<int> block_mask;\n\nvoid dfs(int v, int p, int h) {\n    first_visit[v] = euler_tour.size();\n    euler_tour.push_back(v);\n    height[v] = h;\n    \n    for (int u : adj[v]) {\n        if (u == p)\n            continue;\n        dfs(u, v, h + 1);\n        euler_tour.push_back(v);\n    }\n}\n\nint min_by_h(int i, int j) {\n    return height[euler_tour[i]] < height[euler_tour[j]] ? i : j;\n}\n\nvoid precompute_lca(int root) {\n    // get euler tour & indices of first occurrences\n    first_visit.assign(n, -1);\n    height.assign(n, 0);\n    euler_tour.reserve(2 * n);\n    dfs(root, -1, 0);\n\n    // precompute all log values\n    int m = euler_tour.size();\n    log_2.reserve(m + 1);\n    log_2.push_back(-1);\n    for (int i = 1; i <= m; i++)\n        log_2.push_back(log_2[i / 2] + 1);\n\n    block_size = max(1, log_2[m] / 2);\n    block_cnt = (m + block_size - 1) / block_size;\n\n    // precompute minimum of each block and build sparse table\n    st.assign(block_cnt, vector<int>(log_2[block_cnt] + 1));\n    for (int i = 0, j = 0, b = 0; i < m; i++, j++) {\n        if (j == block_size)\n            j = 0, b++;\n        if (j == 0 || min_by_h(i, st[b][0]) == i)\n            st[b][0] = i;\n    }\n    for (int l = 1; l <= log_2[block_cnt]; l++) {\n        for (int i = 0; i < block_cnt; i++) {\n            int ni = i + (1 << (l - 1));\n            if (ni >= block_cnt)\n                st[i][l] = st[i][l-1];\n            else\n                st[i][l] = min_by_h(st[i][l-1], st[ni][l-1]);\n        }\n    }\n\n    // precompute mask for each block\n    block_mask.assign(block_cnt, 0);\n    for (int i = 0, j = 0, b = 0; i < m; i++, j++) {\n        if (j == block_size)\n            j = 0, b++;\n        if (j > 0 && (i >= m || min_by_h(i - 1, i) == i - 1))\n            block_mask[b] += 1 << (j - 1);\n    }\n\n    // precompute RMQ for each unique block\n    int possibilities = 1 << (block_size - 1);\n    blocks.resize(possibilities);\n    for (int b = 0; b < block_cnt; b++) {\n        int mask = block_mask[b];\n        if (!blocks[mask].empty())\n            continue;\n        blocks[mask].assign(block_size, vector<int>(block_size));\n        for (int l = 0; l < block_size; l++) {\n            blocks[mask][l][l] = l;\n            for (int r = l + 1; r < block_size; r++) {\n                blocks[mask][l][r] = blocks[mask][l][r - 1];\n                if (b * block_size + r < m)\n                    blocks[mask][l][r] = min_by_h(b * block_size + blocks[mask][l][r], \n                            b * block_size + r) - b * block_size;\n            }\n        }\n    }\n}\n\nint lca_in_block(int b, int l, int r) {\n    return blocks[block_mask[b]][l][r] + b * block_size;\n}\n\nint lca(int v, int u) {\n    int l = first_visit[v];\n    int r = first_visit[u];\n    if (l > r)\n        swap(l, r);\n    int bl = l / block_size;\n    int br = r / block_size;\n    if (bl == br)\n        return euler_tour[lca_in_block(bl, l % block_size, r % block_size)];\n    int ans1 = lca_in_block(bl, l % block_size, block_size - 1);\n    int ans2 = lca_in_block(br, 0, r % block_size);\n    int ans = min_by_h(ans1, ans2);\n    if (bl + 1 < br) {\n        int l = log_2[br - bl - 1];\n        int ans3 = st[bl+1][l];\n        int ans4 = st[br - (1 << l)][l];\n        ans = min_by_h(ans, min_by_h(ans3, ans4));\n    }\n    return euler_tour[ans];\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: lca_linear\n---\n\n# Lowest Common Ancestor - Farach-Colton and Bender Algorithm\n\nLet $G$ be a tree.\nFor every query of the form $(u, v)$ we want to find the lowest common ancestor of the nodes $u$ and $v$, i.e. we want to find a node $w$ that lies on the path from $u$ to the root node, that lies on the path from $v$ to the root node, and if there are multiple nodes we pick the one that is farthest away from the root node.\nIn other words the desired node $w$ is the lowest ancestor of $u$ and $v$.\nIn particular if $u$ is an ancestor of $v$, then $u$ is their lowest common ancestor.\n\nThe algorithm which will be described in this article was developed by Farach-Colton and Bender.\nIt is asymptotically optimal.\n\n## Algorithm\n\nWe use the classical reduction of the LCA problem to the RMQ problem.\nWe traverse all nodes of the tree with [DFS](depth-first-search.md) and keep an array with all visited nodes and the heights of these nodes. \nThe LCA of two nodes $u$ and $v$ is the node between the occurrences of $u$ and $v$ in the tour, that has the smallest height.\n\nIn the following picture you can see a possible Euler-Tour of a graph and in the list below you can see the visited nodes and their heights.\n\n<center>![LCA_Euler_Tour](LCA_Euler.png)</center>\n\n$$\\begin{array}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|}\n\\hline\n\\text{Nodes:}   & 1 & 2 & 5 & 2 & 6 & 2 & 1 & 3 & 1 & 4 & 7 & 4 & 1 \\\\ \\hline\n\\text{Heights:} & 1 & 2 & 3 & 2 & 3 & 2 & 1 & 2 & 1 & 2 & 3 & 2 & 1 \\\\ \\hline\n\\end{array}$$\n\nYou can read more about this reduction in the article [Lowest Common Ancestor](lca.md).\nIn that article the minimum of a range was either found by sqrt-decomposition in $O(\\sqrt{N})$ or in $O(\\log N)$ using a Segment tree.\nIn this article we look at how we can solve the given range minimum queries in $O(1)$ time, while still only taking $O(N)$ time for preprocessing.\n\nNote that the reduced RMQ problem is very specific:\nany two adjacent elements in the array differ exactly by one (since the elements of the array are nothing more than the heights of the nodes visited in order of traversal, and we either go to a descendant, in which case the next element is one bigger, or go back to the ancestor, in which case the next element is one lower).\nThe Farach-Colton and Bender algorithm describes a solution for exactly this specialized RMQ problem.\n\nLet's denote with $A$ the array on which we want to perform the range minimum queries.\nAnd $N$ will be the size of $A$.\n\nThere is an easy data structure that we can use for solving the RMQ problem with $O(N \\log N)$ preprocessing and $O(1)$ for each query: the [Sparse Table](../data_structures/sparse-table.md).\nWe create a table $T$ where each element $T[i][j]$ is equal to the minimum of $A$ in the interval $[i, i + 2^j - 1]$.\nObviously $0 \\leq j \\leq \\lceil \\log N \\rceil$, and therefore the size of the Sparse Table will be $O(N \\log N)$.\nYou can build the table easily in $O(N \\log N)$ by noting that $T[i][j] = \\min(T[i][j-1], T[i+2^{j-1}][j-1])$.\n\nHow can we answer a query RMQ in $O(1)$ using this data structure?\nLet the received query be $[l, r]$, then the answer is $\\min(T[l][\\text{sz}], T[r-2^{\\text{sz}}+1][\\text{sz}])$, where $\\text{sz}$ is the biggest exponent such that $2^{\\text{sz}}$ is not bigger than the range length $r-l+1$. \nIndeed we can take the range $[l, r]$ and cover it two segments of length $2^{\\text{sz}}$ - one starting in $l$ and the other ending in $r$.\nThese segments overlap, but this doesn't interfere with our computation.\nTo really achieve the time complexity of $O(1)$ per query, we need to know the values of $\\text{sz}$ for all possible lengths from $1$ to $N$.\nBut this can be easily precomputed.\n\nNow we want to improve the complexity of the preprocessing down to $O(N)$.\n\nWe divide the array $A$ into blocks of size $K = 0.5 \\log N$ with $\\log$ being the logarithm to base 2.\nFor each block we calculate the minimum element and store them in an array $B$.\n$B$ has the size $\\frac{N}{K}$.\nWe construct a sparse table from the array $B$.\nThe size and the time complexity of it will be:\n\n$$\\frac{N}{K}\\log\\left(\\frac{N}{K}\\right) = \\frac{2N}{\\log(N)} \\log\\left(\\frac{2N}{\\log(N)}\\right) =$$\n\n$$= \\frac{2N}{\\log(N)} \\left(1 + \\log\\left(\\frac{N}{\\log(N)}\\right)\\right) \\leq \\frac{2N}{\\log(N)} + 2N = O(N)$$\n\nNow we only have to learn how to quickly answer range minimum queries within each block.\nIn fact if the received range minimum query is $[l, r]$ and $l$ and $r$ are in different blocks then the answer is the minimum of the following three values:\nthe minimum of the suffix of block of $l$ starting at $l$, the minimum of the prefix of block of $r$ ending at $r$, and the minimum of the blocks between those.\nThe minimum of the blocks in between can be answered in $O(1)$ using the Sparse Table.\nSo this leaves us only the range minimum queries inside blocks.\n\nHere we will exploit the property of the array.\nRemember that the values in the array - which are just height values in the tree - will always differ by one.\nIf we remove the first element of a block, and subtract it from every other item in the block, every block can be identified by a sequence of length $K - 1$ consisting of the number $+1$ and $-1$.\nBecause these blocks are so small, there are only a few different sequences that can occur.\nThe number of possible sequences is:\n\n$$2^{K-1} = 2^{0.5 \\log(N) - 1} = 0.5 \\left(2^{\\log(N)}\\right)^{0.5} = 0.5 \\sqrt{N}$$\n\nThus the number of different blocks is $O(\\sqrt{N})$, and therefore we can precompute the results of range minimum queries inside all different blocks in $O(\\sqrt{N} K^2) = O(\\sqrt{N} \\log^2(N)) = O(N)$ time.\nFor the implementation we can characterize a block by a bitmask of length $K-1$ (which will fit in a standard int) and store the index of the minimum in an array $\\text{block}[\\text{mask}][l][r]$ of size $O(\\sqrt{N} \\log^2(N))$.\n\nSo we learned how to precompute range minimum queries within each block, as well as range minimum queries over a range of blocks, all in $O(N)$.\nWith these precomputations we can answer each query in $O(1)$, by using at most four precomputed values: the minimum of the block containing `l`, the minimum of the block containing `r`, and the two minima of the overlapping segments of the blocks between them.\n\n## Implementation\n\n```cpp\nint n;\nvector<vector<int>> adj;\n\nint block_size, block_cnt;\nvector<int> first_visit;\nvector<int> euler_tour;\nvector<int> height;\nvector<int> log_2;\nvector<vector<int>> st;\nvector<vector<vector<int>>> blocks;\nvector<int> block_mask;\n\nvoid dfs(int v, int p, int h) {\n    first_visit[v] = euler_tour.size();\n    euler_tour.push_back(v);\n    height[v] = h;\n    \n    for (int u : adj[v]) {\n        if (u == p)\n            continue;\n        dfs(u, v, h + 1);\n        euler_tour.push_back(v);\n    }\n}\n\nint min_by_h(int i, int j) {\n    return height[euler_tour[i]] < height[euler_tour[j]] ? i : j;\n}\n\nvoid precompute_lca(int root) {\n    // get euler tour & indices of first occurrences\n    first_visit.assign(n, -1);\n    height.assign(n, 0);\n    euler_tour.reserve(2 * n);\n    dfs(root, -1, 0);\n\n    // precompute all log values\n    int m = euler_tour.size();\n    log_2.reserve(m + 1);\n    log_2.push_back(-1);\n    for (int i = 1; i <= m; i++)\n        log_2.push_back(log_2[i / 2] + 1);\n\n    block_size = max(1, log_2[m] / 2);\n    block_cnt = (m + block_size - 1) / block_size;\n\n    // precompute minimum of each block and build sparse table\n    st.assign(block_cnt, vector<int>(log_2[block_cnt] + 1));\n    for (int i = 0, j = 0, b = 0; i < m; i++, j++) {\n        if (j == block_size)\n            j = 0, b++;\n        if (j == 0 || min_by_h(i, st[b][0]) == i)\n            st[b][0] = i;\n    }\n    for (int l = 1; l <= log_2[block_cnt]; l++) {\n        for (int i = 0; i < block_cnt; i++) {\n            int ni = i + (1 << (l - 1));\n            if (ni >= block_cnt)\n                st[i][l] = st[i][l-1];\n            else\n                st[i][l] = min_by_h(st[i][l-1], st[ni][l-1]);\n        }\n    }\n\n    // precompute mask for each block\n    block_mask.assign(block_cnt, 0);\n    for (int i = 0, j = 0, b = 0; i < m; i++, j++) {\n        if (j == block_size)\n            j = 0, b++;\n        if (j > 0 && (i >= m || min_by_h(i - 1, i) == i - 1))\n            block_mask[b] += 1 << (j - 1);\n    }\n\n    // precompute RMQ for each unique block\n    int possibilities = 1 << (block_size - 1);\n    blocks.resize(possibilities);\n    for (int b = 0; b < block_cnt; b++) {\n        int mask = block_mask[b];\n        if (!blocks[mask].empty())\n            continue;\n        blocks[mask].assign(block_size, vector<int>(block_size));\n        for (int l = 0; l < block_size; l++) {\n            blocks[mask][l][l] = l;\n            for (int r = l + 1; r < block_size; r++) {\n                blocks[mask][l][r] = blocks[mask][l][r - 1];\n                if (b * block_size + r < m)\n                    blocks[mask][l][r] = min_by_h(b * block_size + blocks[mask][l][r], \n                            b * block_size + r) - b * block_size;\n            }\n        }\n    }\n}\n\nint lca_in_block(int b, int l, int r) {\n    return blocks[block_mask[b]][l][r] + b * block_size;\n}\n\nint lca(int v, int u) {\n    int l = first_visit[v];\n    int r = first_visit[u];\n    if (l > r)\n        swap(l, r);\n    int bl = l / block_size;\n    int br = r / block_size;\n    if (bl == br)\n        return euler_tour[lca_in_block(bl, l % block_size, r % block_size)];\n    int ans1 = lca_in_block(bl, l % block_size, block_size - 1);\n    int ans2 = lca_in_block(br, 0, r % block_size);\n    int ans = min_by_h(ans1, ans2);\n    if (bl + 1 < br) {\n        int l = log_2[br - bl - 1];\n        int ans3 = st[bl+1][l];\n        int ans4 = st[br - (1 << l)][l];\n        ans = min_by_h(ans, min_by_h(ans3, ans4));\n    }\n    return euler_tour[ans];\n}\n```\n", "problem_ids": [], "title": "Lowest Common Ancestor - Farach-Colton and Bender Algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: floyd_warshall_algorithm\n---\n\n# Floyd-Warshall Algorithm\n\nGiven a directed or an undirected weighted graph $G$ with $n$ vertices.\nThe task is to find the length of the shortest path $d_{ij}$ between each pair of vertices $i$ and $j$.\n\nThe graph may have negative weight edges, but no negative weight cycles.\n\nIf there is such a negative cycle, you can just traverse this cycle over and over, in each iteration making the cost of the path smaller.\nSo you can make certain paths arbitrarily small, or in other words that shortest path is undefined.\nThat automatically means that an undirected graph cannot have any negative weight edges, as such an edge forms already a negative cycle as you can move back and forth along that edge as long as you like.\n\nThis algorithm can also be used to detect the presence of negative cycles.\nThe graph has a negative cycle if at the end of the algorithm, the distance from a vertex $v$ to itself is negative.\n\nThis algorithm has been simultaneously published in articles by Robert Floyd and Stephen Warshall in 1962.\nHowever, in 1959, Bernard Roy published essentially the same algorithm, but its publication went unnoticed.\n\n## Description of the algorithm\n\nThe key idea of the algorithm is to partition the process of finding the shortest path between any two vertices to several incremental phases.\n\nLet us number the vertices starting from 1 to $n$.\nThe matrix of distances is $d[ ][ ]$.\n\nBefore $k$-th phase ($k = 1 \\dots n$), $d[i][j]$ for any vertices $i$ and $j$ stores the length of the shortest path between the vertex $i$ and vertex $j$, which contains only the vertices $\\{1, 2, ..., k-1\\}$ as internal vertices in the path.\n\nIn other words, before $k$-th phase the value of $d[i][j]$ is equal to the length of the shortest path from vertex $i$ to the vertex $j$, if this path is allowed to enter only the vertex with numbers smaller than $k$ (the beginning and end of the path are not restricted by this property).\n\nIt is easy to make sure that this property holds for the first phase. For $k = 0$, we can fill matrix with $d[i][j] = w_{i j}$ if there exists an edge between $i$ and $j$ with weight $w_{i j}$ and $d[i][j] = \\infty$ if there doesn't exist an edge.\nIn practice $\\infty$ will be some high value.\nAs we shall see later, this is a requirement for the algorithm.\n\nSuppose now that we are in the $k$-th phase, and we want to compute the matrix $d[ ][ ]$ so that it meets the requirements for the $(k + 1)$-th phase.\nWe have to fix the distances for some vertices pairs $(i, j)$.\nThere are two fundamentally different cases:\n\n*   The shortest way from the vertex $i$ to the vertex $j$ with internal vertices from the set $\\{1, 2, \\dots, k\\}$ coincides with the shortest path with internal vertices from the set $\\{1, 2, \\dots, k-1\\}$.\n\n    In this case, $d[i][j]$ will not change during the transition.\n\n*   The shortest path with internal vertices from $\\{1, 2, \\dots, k\\}$ is shorter.\n\n    This means that the new, shorter path passes through the vertex $k$.\n    This means that we can split the shortest path between $i$ and $j$ into two paths:\n    the path between $i$ and $k$, and the path between $k$ and $j$.\n    It is clear that both this paths only use internal vertices of $\\{1, 2, \\dots, k-1\\}$ and are the shortest such paths in that respect.\n    Therefore we already have computed the lengths of those paths before, and we can compute the length of the shortest path between $i$ and $j$ as $d[i][k] + d[k][j]$.\n\nCombining these two cases we find that we can recalculate the length of all pairs $(i, j)$ in the $k$-th phase in the following way:\n\n$$d_{\\text{new}}[i][j] = min(d[i][j], d[i][k] + d[k][j])$$\n\nThus, all the work that is required in the $k$-th phase is to iterate over all pairs of vertices and recalculate the length of the shortest path between them.\nAs a result, after the $n$-th phase, the value $d[i][j]$ in the distance matrix is the length of the shortest path between $i$ and $j$, or is $\\infty$ if the path between the vertices $i$ and $j$ does not exist.\n\nA last remark - we don't need to create a separate distance matrix $d_{\\text{new}}[ ][ ]$ for temporarily storing the shortest paths of the $k$-th phase, i.e. all changes can be made directly in the matrix $d[ ][ ]$ at any phase.\nIn fact at any $k$-th phase we are at most improving the distance of any path in the distance matrix, hence we cannot worsen the length of the shortest path for any pair of the vertices that are to be processed in the $(k+1)$-th phase or later.\n\nThe time complexity of this algorithm is obviously $O(n^3)$.\n\n## Implementation\n\nLet $d[][]$ is a 2D array of size $n \\times n$, which is filled according to the $0$-th phase as explained earlier.\nAlso we will set $d[i][i] = 0$ for any $i$ at the $0$-th phase.\n\nThen the algorithm is implemented as follows:\n\n```cpp\nfor (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]); \n        }\n    }\n}\n```\n\nIt is assumed that if there is no edge between any two vertices $i$ and $j$, then the matrix at $d[i][j]$ contains a large number (large enough so that it is greater than the length of any path in this graph).\nThen this edge will always be unprofitable to take, and the algorithm will work correctly.\n\nHowever if there are negative weight edges in the graph, special measures have to be taken.\nOtherwise the resulting values in matrix may be of the form $\\infty - 1$,  $\\infty - 2$, etc., which, of course, still indicates that between the respective vertices doesn't exist a path.\nTherefore, if the graph has negative weight edges, it is better to write the Floyd-Warshall algorithm in the following way, so that it does not perform transitions using paths that don't exist.\n\n```cpp\nfor (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (d[i][k] < INF && d[k][j] < INF)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]); \n        }\n    }\n}\n```\n\n## Retrieving the sequence of vertices in the shortest path\n\nIt is easy to maintain additional information with which it will be possible to retrieve the shortest path between any two given vertices in the form of a sequence of vertices.\n\nFor this, in addition to the distance matrix $d[ ][ ]$, a matrix of ancestors $p[ ][ ]$ must be maintained, which will contain the number of the phase where the shortest distance between two vertices was last modified.\nIt is clear that the number of the phase is nothing more than a vertex in the middle of the desired shortest path.\nNow we just need to find the shortest path between vertices $i$ and $p[i][j]$, and between $p[i][j]$ and $j$.\nThis leads to a simple recursive reconstruction algorithm of the shortest path.\n\n## The case of real weights\n\nIf the weights of the edges are not integer but real, it is necessary to take the errors, which occur when working with float types, into account.\n\nThe Floyd-Warshall algorithm has the unpleasant effect, that the errors accumulate very quickly.\nIn fact if there is an error in the first phase of $\\delta$, this error may propagate to the second iteration as $2 \\delta$, to the third iteration as $4 \\delta$, and so on.\n\nTo avoid this the algorithm can be modified to take the error (EPS = $\\delta$) into account by using following comparison:\n\n```cpp\nif (d[i][k] + d[k][j] < d[i][j] - EPS)\n    d[i][j] = d[i][k] + d[k][j]; \n```\n\n## The case of negative cycles\n\nFormally the Floyd-Warshall algorithm does not apply to graphs containing negative weight cycle(s).\nBut for all pairs of vertices $i$ and $j$ for which there doesn't exist a path starting at $i$, visiting a negative cycle, and end at $j$,  the algorithm will still work correctly.\n\nFor the pair of vertices for which the answer does not exist (due to the presence of a negative cycle in the path between them), the Floyd algorithm will store any number (perhaps highly negative, but not necessarily) in the distance matrix.\nHowever it is possible to improve the Floyd-Warshall algorithm, so that it carefully treats such pairs of vertices, and outputs them, for example as $-\\text{INF}$.\n\nThis can be done in the following way:\nlet us run the usual Floyd-Warshall algorithm for a given graph.\nThen a shortest path between vertices $i$ and $j$ does not exist, if and only if, there is a vertex $t$ that is reachable from $i$ and also from $j$, for which $d[t][t] < 0$.\n\nIn addition, when using the Floyd-Warshall algorithm for graphs with negative cycles, we should keep in mind that situations may arise in which distances can get exponentially fast into the negative.\nTherefore integer overflow must be handled by limiting the minimal distance by some value (e.g. $-\\text{INF}$).\n\nTo learn more about finding negative cycles in a graph, see the separate article [Finding a negative cycle in the graph](finding-negative-cycle-in-graph.md).\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: floyd_warshall_algorithm\n---\n\n# Floyd-Warshall Algorithm\n\nGiven a directed or an undirected weighted graph $G$ with $n$ vertices.\nThe task is to find the length of the shortest path $d_{ij}$ between each pair of vertices $i$ and $j$.\n\nThe graph may have negative weight edges, but no negative weight cycles.\n\nIf there is such a negative cycle, you can just traverse this cycle over and over, in each iteration making the cost of the path smaller.\nSo you can make certain paths arbitrarily small, or in other words that shortest path is undefined.\nThat automatically means that an undirected graph cannot have any negative weight edges, as such an edge forms already a negative cycle as you can move back and forth along that edge as long as you like.\n\nThis algorithm can also be used to detect the presence of negative cycles.\nThe graph has a negative cycle if at the end of the algorithm, the distance from a vertex $v$ to itself is negative.\n\nThis algorithm has been simultaneously published in articles by Robert Floyd and Stephen Warshall in 1962.\nHowever, in 1959, Bernard Roy published essentially the same algorithm, but its publication went unnoticed.\n\n## Description of the algorithm\n\nThe key idea of the algorithm is to partition the process of finding the shortest path between any two vertices to several incremental phases.\n\nLet us number the vertices starting from 1 to $n$.\nThe matrix of distances is $d[ ][ ]$.\n\nBefore $k$-th phase ($k = 1 \\dots n$), $d[i][j]$ for any vertices $i$ and $j$ stores the length of the shortest path between the vertex $i$ and vertex $j$, which contains only the vertices $\\{1, 2, ..., k-1\\}$ as internal vertices in the path.\n\nIn other words, before $k$-th phase the value of $d[i][j]$ is equal to the length of the shortest path from vertex $i$ to the vertex $j$, if this path is allowed to enter only the vertex with numbers smaller than $k$ (the beginning and end of the path are not restricted by this property).\n\nIt is easy to make sure that this property holds for the first phase. For $k = 0$, we can fill matrix with $d[i][j] = w_{i j}$ if there exists an edge between $i$ and $j$ with weight $w_{i j}$ and $d[i][j] = \\infty$ if there doesn't exist an edge.\nIn practice $\\infty$ will be some high value.\nAs we shall see later, this is a requirement for the algorithm.\n\nSuppose now that we are in the $k$-th phase, and we want to compute the matrix $d[ ][ ]$ so that it meets the requirements for the $(k + 1)$-th phase.\nWe have to fix the distances for some vertices pairs $(i, j)$.\nThere are two fundamentally different cases:\n\n*   The shortest way from the vertex $i$ to the vertex $j$ with internal vertices from the set $\\{1, 2, \\dots, k\\}$ coincides with the shortest path with internal vertices from the set $\\{1, 2, \\dots, k-1\\}$.\n\n    In this case, $d[i][j]$ will not change during the transition.\n\n*   The shortest path with internal vertices from $\\{1, 2, \\dots, k\\}$ is shorter.\n\n    This means that the new, shorter path passes through the vertex $k$.\n    This means that we can split the shortest path between $i$ and $j$ into two paths:\n    the path between $i$ and $k$, and the path between $k$ and $j$.\n    It is clear that both this paths only use internal vertices of $\\{1, 2, \\dots, k-1\\}$ and are the shortest such paths in that respect.\n    Therefore we already have computed the lengths of those paths before, and we can compute the length of the shortest path between $i$ and $j$ as $d[i][k] + d[k][j]$.\n\nCombining these two cases we find that we can recalculate the length of all pairs $(i, j)$ in the $k$-th phase in the following way:\n\n$$d_{\\text{new}}[i][j] = min(d[i][j], d[i][k] + d[k][j])$$\n\nThus, all the work that is required in the $k$-th phase is to iterate over all pairs of vertices and recalculate the length of the shortest path between them.\nAs a result, after the $n$-th phase, the value $d[i][j]$ in the distance matrix is the length of the shortest path between $i$ and $j$, or is $\\infty$ if the path between the vertices $i$ and $j$ does not exist.\n\nA last remark - we don't need to create a separate distance matrix $d_{\\text{new}}[ ][ ]$ for temporarily storing the shortest paths of the $k$-th phase, i.e. all changes can be made directly in the matrix $d[ ][ ]$ at any phase.\nIn fact at any $k$-th phase we are at most improving the distance of any path in the distance matrix, hence we cannot worsen the length of the shortest path for any pair of the vertices that are to be processed in the $(k+1)$-th phase or later.\n\nThe time complexity of this algorithm is obviously $O(n^3)$.\n\n## Implementation\n\nLet $d[][]$ is a 2D array of size $n \\times n$, which is filled according to the $0$-th phase as explained earlier.\nAlso we will set $d[i][i] = 0$ for any $i$ at the $0$-th phase.\n\nThen the algorithm is implemented as follows:\n\n```cpp\nfor (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]); \n        }\n    }\n}\n```\n\nIt is assumed that if there is no edge between any two vertices $i$ and $j$, then the matrix at $d[i][j]$ contains a large number (large enough so that it is greater than the length of any path in this graph).\nThen this edge will always be unprofitable to take, and the algorithm will work correctly.\n\nHowever if there are negative weight edges in the graph, special measures have to be taken.\nOtherwise the resulting values in matrix may be of the form $\\infty - 1$,  $\\infty - 2$, etc., which, of course, still indicates that between the respective vertices doesn't exist a path.\nTherefore, if the graph has negative weight edges, it is better to write the Floyd-Warshall algorithm in the following way, so that it does not perform transitions using paths that don't exist.\n\n```cpp\nfor (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (d[i][k] < INF && d[k][j] < INF)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]); \n        }\n    }\n}\n```\n\n## Retrieving the sequence of vertices in the shortest path\n\nIt is easy to maintain additional information with which it will be possible to retrieve the shortest path between any two given vertices in the form of a sequence of vertices.\n\nFor this, in addition to the distance matrix $d[ ][ ]$, a matrix of ancestors $p[ ][ ]$ must be maintained, which will contain the number of the phase where the shortest distance between two vertices was last modified.\nIt is clear that the number of the phase is nothing more than a vertex in the middle of the desired shortest path.\nNow we just need to find the shortest path between vertices $i$ and $p[i][j]$, and between $p[i][j]$ and $j$.\nThis leads to a simple recursive reconstruction algorithm of the shortest path.\n\n## The case of real weights\n\nIf the weights of the edges are not integer but real, it is necessary to take the errors, which occur when working with float types, into account.\n\nThe Floyd-Warshall algorithm has the unpleasant effect, that the errors accumulate very quickly.\nIn fact if there is an error in the first phase of $\\delta$, this error may propagate to the second iteration as $2 \\delta$, to the third iteration as $4 \\delta$, and so on.\n\nTo avoid this the algorithm can be modified to take the error (EPS = $\\delta$) into account by using following comparison:\n\n```cpp\nif (d[i][k] + d[k][j] < d[i][j] - EPS)\n    d[i][j] = d[i][k] + d[k][j]; \n```\n\n## The case of negative cycles\n\nFormally the Floyd-Warshall algorithm does not apply to graphs containing negative weight cycle(s).\nBut for all pairs of vertices $i$ and $j$ for which there doesn't exist a path starting at $i$, visiting a negative cycle, and end at $j$,  the algorithm will still work correctly.\n\nFor the pair of vertices for which the answer does not exist (due to the presence of a negative cycle in the path between them), the Floyd algorithm will store any number (perhaps highly negative, but not necessarily) in the distance matrix.\nHowever it is possible to improve the Floyd-Warshall algorithm, so that it carefully treats such pairs of vertices, and outputs them, for example as $-\\text{INF}$.\n\nThis can be done in the following way:\nlet us run the usual Floyd-Warshall algorithm for a given graph.\nThen a shortest path between vertices $i$ and $j$ does not exist, if and only if, there is a vertex $t$ that is reachable from $i$ and also from $j$, for which $d[t][t] < 0$.\n\nIn addition, when using the Floyd-Warshall algorithm for graphs with negative cycles, we should keep in mind that situations may arise in which distances can get exponentially fast into the negative.\nTherefore integer overflow must be handled by limiting the minimal distance by some value (e.g. $-\\text{INF}$).\n\nTo learn more about finding negative cycles in a graph, see the separate article [Finding a negative cycle in the graph](finding-negative-cycle-in-graph.md).\n\n## Practice Problems\n - [UVA: Page Hopping](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=762)\n - [SPOJ: Possible Friends](http://www.spoj.com/problems/SOCIALNE/)\n - [CODEFORCES: Greg and Graph](http://codeforces.com/problemset/problem/295/B)\n - [SPOJ: CHICAGO - 106 miles to Chicago](http://www.spoj.com/problems/CHICAGO/)\n * [UVA 10724 - Road Construction](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1665)\n * [UVA  117 - The Postal Worker Rings Once](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=53)\n * [Codeforces - Traveling Graph](http://codeforces.com/problemset/problem/21/D)\n * [UVA - 1198 - The Geodetic Set Problem](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3639)\n * [UVA - 10048 - Audiophobia](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=989)\n * [UVA - 125 - Numbering Paths](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=61)\n * [LOJ - Travel Company](http://lightoj.com/volume_showproblem.php?problem=1221)\n * [UVA 423 - MPI Maelstrom](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=364)\n * [UVA 1416 - Warfare And Logistics](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4162)\n * [UVA 1233 - USHER](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3674)\n * [UVA 10793 - The Orc Attack](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1734)\n * [UVA 10099 The Tourist Guide](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1040)\n * [UVA 869 - Airline Comparison](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=810)\n * [UVA 13211 - Geonosis](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=5134)\n * [SPOJ - Defend the Rohan](http://www.spoj.com/problems/ROHAAN/)\n * [Codeforces - Roads in Berland](http://codeforces.com/contest/25/problem/C)\n * [Codeforces - String Problem](http://codeforces.com/contest/33/problem/B)\n * [GYM - Manic Moving (C)](http://codeforces.com/gym/101223)\n * [SPOJ - Arbitrage](http://www.spoj.com/problems/ARBITRAG/)\n * [UVA - 12179 - Randomly-priced Tickets](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3331)\n * [LOJ - 1086 - Jogging Trails](http://lightoj.com/volume_showproblem.php?problem=1086)\n * [SPOJ - Ingredients](http://www.spoj.com/problems/INGRED/)\n * [CSES - Shortest Routes II](https://cses.fi/problemset/task/1672)\n", "problem_ids": ["21_D", "25_C", "33_B"], "title": "Floyd-Warshall Algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: assignment_mincostflow\n---\n\n# Solving assignment problem using min-cost-flow\n\nThe **assignment problem** has two equivalent statements:\n\n   - Given a square matrix $A[1..N, 1..N]$, you need to select $N$ elements in it so that exactly one element is selected in each row and column, and the sum of the values of these elements is the smallest.\n   - There are $N$ orders and $N$ machines. The cost of manufacturing on each machine is known for each order.  Only one order can be performed on each machine. It is required to assign all orders to the machines so that the total cost is minimized.\n\nHere we will consider the solution of the problem based on the algorithm for finding the [minimum cost flow (min-cost-flow)](min_cost_flow.md), solving the assignment problem in $\\mathcal{O}(N^3)$.\n\n## Description\n\nLet's build a bipartite network: there is a source $S$, a drain $T$, in the first part there are $N$ vertices (corresponding to rows of the matrix, or orders), in the second there are also $N$ vertices (corresponding to the columns of the matrix, or machines). Between each vertex $i$ of the first set and each vertex $j$ of the second set, we draw an edge with bandwidth 1 and cost $A_{ij}$. From the source $S$ we draw edges to all vertices $i$ of the first set with bandwidth 1 and cost 0. We draw an edge with bandwidth 1 and cost 0 from each vertex of the second set $j$ to the drain $T$.\n\nWe find in the resulting network the maximum flow of the minimum cost. Obviously, the value of the flow will be $N$. Further, for each vertex $i$ of the first segment there is exactly one vertex $j$ of the second segment, such that the flow $F_{ij}$ = 1. Finally, this is a one-to-one correspondence between the vertices of the first segment and the vertices of the second part, which is the solution to the problem (since the found flow has a minimal cost, then the sum of the costs of the selected edges will be the lowest possible, which is the optimality criterion).\n\nThe complexity of this solution of the assignment problem depends on the algorithm by which the search for the maximum flow of the minimum cost is performed. The complexity will be $\\mathcal{O}(N^3)$ using [Dijkstra](dijkstra.md) or $\\mathcal{O}(N^4)$ using [Bellman-Ford](bellman_ford.md). This is due to the fact that the flow is of size $O(N)$ and each iteration of Dijkstra algorithm can be performed in $O(N^2)$, while it is $O(N^3)$ for Bellman-Ford.\n\n## Implementation\n\nThe implementation given here is long, it can probably be significantly reduced.\nIt uses the [SPFA algorithm](bellman_ford.md) for finding shortest paths.\n\n```cpp\nconst int INF = 1000 * 1000 * 1000;\n\nvector<int> assignment(vector<vector<int>> a) {\n    int n = a.size();\n    int m = n * 2 + 2;\n    vector<vector<int>> f(m, vector<int>(m));\n    int s = m - 2, t = m - 1;\n    int cost = 0;\n    while (true) {\n        vector<int> dist(m, INF);\n        vector<int> p(m);\n        vector<bool> inq(m, false);\n        queue<int> q;\n        dist[s] = 0;\n        p[s] = -1;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            inq[v] = false;\n            if (v == s) {\n                for (int i = 0; i < n; ++i) {\n                    if (f[s][i] == 0) {\n                        dist[i] = 0;\n                        p[i] = s;\n                        inq[i] = true;\n                        q.push(i);\n                    }\n                }\n            } else {\n                if (v < n) {\n                    for (int j = n; j < n + n; ++j) {\n                        if (f[v][j] < 1 && dist[j] > dist[v] + a[v][j - n]) {\n                            dist[j] = dist[v] + a[v][j - n];\n                            p[j] = v;\n                            if (!inq[j]) {\n                                q.push(j);\n                                inq[j] = true;\n                            }\n                        }\n                    }\n                } else {\n                    for (int j = 0; j < n; ++j) {\n                        if (f[v][j] < 0 && dist[j] > dist[v] - a[j][v - n]) {\n                            dist[j] = dist[v] - a[j][v - n];\n                            p[j] = v;\n                            if (!inq[j]) {\n                                q.push(j);\n                                inq[j] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int curcost = INF;\n        for (int i = n; i < n + n; ++i) {\n            if (f[i][t] == 0 && dist[i] < curcost) {\n                curcost = dist[i];\n                p[t] = i;\n            }\n        }\n        if (curcost == INF)\n            break;\n        cost += curcost;\n        for (int cur = t; cur != -1; cur = p[cur]) {\n            int prev = p[cur];\n            if (prev != -1)\n                f[cur][prev] = -(f[prev][cur] = 1);\n        }\n    }\n\n    vector<int> answer(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (f[i][j + n] == 1)\n                answer[i] = j;\n        }\n    }\n    return answer;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: assignment_mincostflow\n---\n\n# Solving assignment problem using min-cost-flow\n\nThe **assignment problem** has two equivalent statements:\n\n   - Given a square matrix $A[1..N, 1..N]$, you need to select $N$ elements in it so that exactly one element is selected in each row and column, and the sum of the values of these elements is the smallest.\n   - There are $N$ orders and $N$ machines. The cost of manufacturing on each machine is known for each order.  Only one order can be performed on each machine. It is required to assign all orders to the machines so that the total cost is minimized.\n\nHere we will consider the solution of the problem based on the algorithm for finding the [minimum cost flow (min-cost-flow)](min_cost_flow.md), solving the assignment problem in $\\mathcal{O}(N^3)$.\n\n## Description\n\nLet's build a bipartite network: there is a source $S$, a drain $T$, in the first part there are $N$ vertices (corresponding to rows of the matrix, or orders), in the second there are also $N$ vertices (corresponding to the columns of the matrix, or machines). Between each vertex $i$ of the first set and each vertex $j$ of the second set, we draw an edge with bandwidth 1 and cost $A_{ij}$. From the source $S$ we draw edges to all vertices $i$ of the first set with bandwidth 1 and cost 0. We draw an edge with bandwidth 1 and cost 0 from each vertex of the second set $j$ to the drain $T$.\n\nWe find in the resulting network the maximum flow of the minimum cost. Obviously, the value of the flow will be $N$. Further, for each vertex $i$ of the first segment there is exactly one vertex $j$ of the second segment, such that the flow $F_{ij}$ = 1. Finally, this is a one-to-one correspondence between the vertices of the first segment and the vertices of the second part, which is the solution to the problem (since the found flow has a minimal cost, then the sum of the costs of the selected edges will be the lowest possible, which is the optimality criterion).\n\nThe complexity of this solution of the assignment problem depends on the algorithm by which the search for the maximum flow of the minimum cost is performed. The complexity will be $\\mathcal{O}(N^3)$ using [Dijkstra](dijkstra.md) or $\\mathcal{O}(N^4)$ using [Bellman-Ford](bellman_ford.md). This is due to the fact that the flow is of size $O(N)$ and each iteration of Dijkstra algorithm can be performed in $O(N^2)$, while it is $O(N^3)$ for Bellman-Ford.\n\n## Implementation\n\nThe implementation given here is long, it can probably be significantly reduced.\nIt uses the [SPFA algorithm](bellman_ford.md) for finding shortest paths.\n\n```cpp\nconst int INF = 1000 * 1000 * 1000;\n\nvector<int> assignment(vector<vector<int>> a) {\n    int n = a.size();\n    int m = n * 2 + 2;\n    vector<vector<int>> f(m, vector<int>(m));\n    int s = m - 2, t = m - 1;\n    int cost = 0;\n    while (true) {\n        vector<int> dist(m, INF);\n        vector<int> p(m);\n        vector<bool> inq(m, false);\n        queue<int> q;\n        dist[s] = 0;\n        p[s] = -1;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            inq[v] = false;\n            if (v == s) {\n                for (int i = 0; i < n; ++i) {\n                    if (f[s][i] == 0) {\n                        dist[i] = 0;\n                        p[i] = s;\n                        inq[i] = true;\n                        q.push(i);\n                    }\n                }\n            } else {\n                if (v < n) {\n                    for (int j = n; j < n + n; ++j) {\n                        if (f[v][j] < 1 && dist[j] > dist[v] + a[v][j - n]) {\n                            dist[j] = dist[v] + a[v][j - n];\n                            p[j] = v;\n                            if (!inq[j]) {\n                                q.push(j);\n                                inq[j] = true;\n                            }\n                        }\n                    }\n                } else {\n                    for (int j = 0; j < n; ++j) {\n                        if (f[v][j] < 0 && dist[j] > dist[v] - a[j][v - n]) {\n                            dist[j] = dist[v] - a[j][v - n];\n                            p[j] = v;\n                            if (!inq[j]) {\n                                q.push(j);\n                                inq[j] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int curcost = INF;\n        for (int i = n; i < n + n; ++i) {\n            if (f[i][t] == 0 && dist[i] < curcost) {\n                curcost = dist[i];\n                p[t] = i;\n            }\n        }\n        if (curcost == INF)\n            break;\n        cost += curcost;\n        for (int cur = t; cur != -1; cur = p[cur]) {\n            int prev = p[cur];\n            if (prev != -1)\n                f[cur][prev] = -(f[prev][cur] = 1);\n        }\n    }\n\n    vector<int> answer(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (f[i][j + n] == 1)\n                answer[i] = j;\n        }\n    }\n    return answer;\n}\n```\n", "problem_ids": [], "title": "Solving assignment problem using min-cost-flow"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: bfs\n---\n\n# Breadth-first search\n\nBreadth first search is one of the basic and essential searching algorithms on graphs.\n\nAs a result of how the algorithm works, the path found by breadth first search to any node is the shortest path to that node, i.e the path that contains the smallest number of edges in unweighted graphs.\n\nThe algorithm works in $O(n + m)$ time, where $n$ is number of vertices and $m$ is the number of edges.\n\n## Description of the algorithm\n\nThe algorithm takes as input an unweighted graph and the id of the source vertex $s$. The input graph can be directed or undirected,\nit does not matter to the algorithm.\n\nThe algorithm can be understood as a fire spreading on the graph: at the zeroth step only the source $s$ is on fire. At each step, the fire burning at each vertex spreads to all of its neighbors. In one iteration of the algorithm, the \"ring of\nfire\" is expanded in width by one unit (hence the name of the algorithm).\n\nMore precisely, the algorithm can be stated as follows: Create a queue $q$ which will contain the vertices to be processed and a\nBoolean array $used[]$ which indicates for each vertex, if it has been lit (or visited) or not.\n\nInitially, push the source $s$ to the queue and set $used[s] = true$, and for all other vertices $v$ set $used[v] = false$.\nThen, loop until the queue is empty and in each iteration, pop a vertex from the front of the queue. Iterate through all the edges going out\nof this vertex and if some of these edges go to vertices that are not already lit, set them on fire and place them in the queue.\n\nAs a result, when the queue is empty, the \"ring of fire\" contains all vertices reachable from the source $s$, with each vertex reached in the shortest possible way.\nYou can also calculate the lengths of the shortest paths (which just requires maintaining an array of path lengths $d[]$) as well as save information to restore all of these shortest paths (for this, it is necessary to maintain an array of \"parents\" $p[]$, which stores for each vertex the vertex from which we reached it).\n\n## Implementation\n\nWe write code for the described algorithm in C++ and Java.\n\n=== \"C++\"\n    ```cpp\n    vector<vector<int>> adj;  // adjacency list representation\n    int n; // number of nodes\n    int s; // source vertex\n\n    queue<int> q;\n    vector<bool> used(n);\n    vector<int> d(n), p(n);\n\n    q.push(s);\n    used[s] = true;\n    p[s] = -1;\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int u : adj[v]) {\n            if (!used[u]) {\n                used[u] = true;\n                q.push(u);\n                d[u] = d[v] + 1;\n                p[u] = v;\n            }\n        }\n    }\n    ```\n=== \"Java\"\n    ```java\n    ArrayList<ArrayList<Integer>> adj = new ArrayList<>(); // adjacency list representation\n        \n    int n; // number of nodes\n    int s; // source vertex\n\n\n    LinkedList<Integer> q = new LinkedList<Integer>();\n    boolean used[] = new boolean[n];\n    int d[] = new int[n];\n    int p[] = new int[n];\n\n    q.push(s);\n    used[s] = true;\n    p[s] = -1;\n    while (!q.isEmpty()) {\n        int v = q.pop();\n        for (int u : adj.get(v)) {\n            if (!used[u]) {\n                used[u] = true;\n                q.push(u);\n                d[u] = d[v] + 1;\n                p[u] = v;\n            }\n        }\n    }\n    ```\n    \nIf we have to restore and display the shortest path from the source to some vertex $u$, it can be done in the following manner:\n    \n=== \"C++\"\n    ```cpp\n    if (!used[u]) {\n        cout << \"No path!\";\n    } else {\n        vector<int> path;\n        for (int v = u; v != -1; v = p[v])\n            path.push_back(v);\n        reverse(path.begin(), path.end());\n        cout << \"Path: \";\n        for (int v : path)\n            cout << v << \" \";\n    }\n    ```\n=== \"Java\"\n    ```java\n    if (!used[u]) {\n        System.out.println(\"No path!\");\n    } else {\n        ArrayList<Integer> path = new ArrayList<Integer>();\n        for (int v = u; v != -1; v = p[v])\n            path.add(v);\n        Collections.reverse(path);\n        for(int v : path)\n            System.out.println(v);\n    }\n    ```\n    \n## Applications of BFS\n\n* Find the shortest path from a source to other vertices in an unweighted graph.\n\n* Find all connected components in an undirected graph in $O(n + m)$ time:\nTo do this, we just run BFS starting from each vertex, except for vertices which have already been visited from previous runs.\nThus, we perform normal BFS from each of the vertices, but do not reset the array $used[]$ each and every time we get a new connected component, and the total running time will still be $O(n + m)$ (performing multiple BFS on the graph without zeroing the array $used []$ is called a series of breadth first searches).\n\n* Finding a solution to a problem or a game with the least number of moves, if each state of the game can be represented by a vertex of the graph, and the transitions from one state to the other are the edges of the graph.\n\n* Finding the shortest path in a graph with weights 0 or 1:\nThis requires just a little modification to normal breadth-first search: Instead of maintaining array $used[]$, we will now check if the distance to vertex is shorter than current found distance, then if the current edge is of zero weight, we add it to the front of the queue else we add it to the back of the queue.This modification is explained in more detail in the article [0-1 BFS](01_bfs.md).\n\n* Finding the shortest cycle in a directed unweighted graph:\nStart a breadth-first search from each vertex.\nAs soon as we try to go from the current vertex back to the source vertex, we have found the shortest cycle containing the source vertex.\nAt this point we can stop the BFS, and start a new BFS from the next vertex.\nFrom all such cycles (at most one from each BFS) choose the shortest.\n\n* Find all the edges that lie on any shortest path between a given pair of vertices $(a, b)$.\nTo do this, run two breadth first searches:\none from $a$ and one from $b$.\nLet $d_a []$ be the array containing shortest distances obtained from the first BFS (from $a$) and $d_b []$ be the array containing shortest distances obtained from the second BFS from $b$.\nNow for every edge $(u, v)$ it is easy to check whether that edge lies on any shortest path between $a$ and $b$:\nthe criterion is the condition $d_a [u] + 1 + d_b [v] = d_a [b]$.\n\n* Find all the vertices on any shortest path between a given pair of vertices $(a, b)$.\nTo accomplish that, run two breadth first searches:\none from $a$ and one from $b$.\nLet $d_a []$ be the array containing shortest distances obtained from the first BFS (from $a$) and $d_b []$ be the array containing shortest distances obtained from the second BFS (from $b$).\nNow for each vertex it is easy to check whether it lies on any shortest path between $a$ and $b$:\nthe criterion is the condition $d_a [v] + d_b [v] = d_a [b]$.\n\n* Find the shortest path of even length from a source vertex $s$ to a target vertex $t$ in an unweighted graph:\nFor this, we must construct an auxiliary graph, whose vertices are the state $(v, c)$, where $v$ - the current node, $c = 0$ or $c = 1$ - the current parity.\nAny edge $(u, v)$ of the original graph in this new column will turn into two edges $((u, 0), (v, 1))$ and $((u, 1), (v, 0))$.\nAfter that we run a BFS to find the shortest path from the starting vertex $(s, 0)$ to the end vertex $(t, 0)$.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: bfs\n---\n\n# Breadth-first search\n\nBreadth first search is one of the basic and essential searching algorithms on graphs.\n\nAs a result of how the algorithm works, the path found by breadth first search to any node is the shortest path to that node, i.e the path that contains the smallest number of edges in unweighted graphs.\n\nThe algorithm works in $O(n + m)$ time, where $n$ is number of vertices and $m$ is the number of edges.\n\n## Description of the algorithm\n\nThe algorithm takes as input an unweighted graph and the id of the source vertex $s$. The input graph can be directed or undirected,\nit does not matter to the algorithm.\n\nThe algorithm can be understood as a fire spreading on the graph: at the zeroth step only the source $s$ is on fire. At each step, the fire burning at each vertex spreads to all of its neighbors. In one iteration of the algorithm, the \"ring of\nfire\" is expanded in width by one unit (hence the name of the algorithm).\n\nMore precisely, the algorithm can be stated as follows: Create a queue $q$ which will contain the vertices to be processed and a\nBoolean array $used[]$ which indicates for each vertex, if it has been lit (or visited) or not.\n\nInitially, push the source $s$ to the queue and set $used[s] = true$, and for all other vertices $v$ set $used[v] = false$.\nThen, loop until the queue is empty and in each iteration, pop a vertex from the front of the queue. Iterate through all the edges going out\nof this vertex and if some of these edges go to vertices that are not already lit, set them on fire and place them in the queue.\n\nAs a result, when the queue is empty, the \"ring of fire\" contains all vertices reachable from the source $s$, with each vertex reached in the shortest possible way.\nYou can also calculate the lengths of the shortest paths (which just requires maintaining an array of path lengths $d[]$) as well as save information to restore all of these shortest paths (for this, it is necessary to maintain an array of \"parents\" $p[]$, which stores for each vertex the vertex from which we reached it).\n\n## Implementation\n\nWe write code for the described algorithm in C++ and Java.\n\n=== \"C++\"\n    ```cpp\n    vector<vector<int>> adj;  // adjacency list representation\n    int n; // number of nodes\n    int s; // source vertex\n\n    queue<int> q;\n    vector<bool> used(n);\n    vector<int> d(n), p(n);\n\n    q.push(s);\n    used[s] = true;\n    p[s] = -1;\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int u : adj[v]) {\n            if (!used[u]) {\n                used[u] = true;\n                q.push(u);\n                d[u] = d[v] + 1;\n                p[u] = v;\n            }\n        }\n    }\n    ```\n=== \"Java\"\n    ```java\n    ArrayList<ArrayList<Integer>> adj = new ArrayList<>(); // adjacency list representation\n        \n    int n; // number of nodes\n    int s; // source vertex\n\n\n    LinkedList<Integer> q = new LinkedList<Integer>();\n    boolean used[] = new boolean[n];\n    int d[] = new int[n];\n    int p[] = new int[n];\n\n    q.push(s);\n    used[s] = true;\n    p[s] = -1;\n    while (!q.isEmpty()) {\n        int v = q.pop();\n        for (int u : adj.get(v)) {\n            if (!used[u]) {\n                used[u] = true;\n                q.push(u);\n                d[u] = d[v] + 1;\n                p[u] = v;\n            }\n        }\n    }\n    ```\n    \nIf we have to restore and display the shortest path from the source to some vertex $u$, it can be done in the following manner:\n    \n=== \"C++\"\n    ```cpp\n    if (!used[u]) {\n        cout << \"No path!\";\n    } else {\n        vector<int> path;\n        for (int v = u; v != -1; v = p[v])\n            path.push_back(v);\n        reverse(path.begin(), path.end());\n        cout << \"Path: \";\n        for (int v : path)\n            cout << v << \" \";\n    }\n    ```\n=== \"Java\"\n    ```java\n    if (!used[u]) {\n        System.out.println(\"No path!\");\n    } else {\n        ArrayList<Integer> path = new ArrayList<Integer>();\n        for (int v = u; v != -1; v = p[v])\n            path.add(v);\n        Collections.reverse(path);\n        for(int v : path)\n            System.out.println(v);\n    }\n    ```\n    \n## Applications of BFS\n\n* Find the shortest path from a source to other vertices in an unweighted graph.\n\n* Find all connected components in an undirected graph in $O(n + m)$ time:\nTo do this, we just run BFS starting from each vertex, except for vertices which have already been visited from previous runs.\nThus, we perform normal BFS from each of the vertices, but do not reset the array $used[]$ each and every time we get a new connected component, and the total running time will still be $O(n + m)$ (performing multiple BFS on the graph without zeroing the array $used []$ is called a series of breadth first searches).\n\n* Finding a solution to a problem or a game with the least number of moves, if each state of the game can be represented by a vertex of the graph, and the transitions from one state to the other are the edges of the graph.\n\n* Finding the shortest path in a graph with weights 0 or 1:\nThis requires just a little modification to normal breadth-first search: Instead of maintaining array $used[]$, we will now check if the distance to vertex is shorter than current found distance, then if the current edge is of zero weight, we add it to the front of the queue else we add it to the back of the queue.This modification is explained in more detail in the article [0-1 BFS](01_bfs.md).\n\n* Finding the shortest cycle in a directed unweighted graph:\nStart a breadth-first search from each vertex.\nAs soon as we try to go from the current vertex back to the source vertex, we have found the shortest cycle containing the source vertex.\nAt this point we can stop the BFS, and start a new BFS from the next vertex.\nFrom all such cycles (at most one from each BFS) choose the shortest.\n\n* Find all the edges that lie on any shortest path between a given pair of vertices $(a, b)$.\nTo do this, run two breadth first searches:\none from $a$ and one from $b$.\nLet $d_a []$ be the array containing shortest distances obtained from the first BFS (from $a$) and $d_b []$ be the array containing shortest distances obtained from the second BFS from $b$.\nNow for every edge $(u, v)$ it is easy to check whether that edge lies on any shortest path between $a$ and $b$:\nthe criterion is the condition $d_a [u] + 1 + d_b [v] = d_a [b]$.\n\n* Find all the vertices on any shortest path between a given pair of vertices $(a, b)$.\nTo accomplish that, run two breadth first searches:\none from $a$ and one from $b$.\nLet $d_a []$ be the array containing shortest distances obtained from the first BFS (from $a$) and $d_b []$ be the array containing shortest distances obtained from the second BFS (from $b$).\nNow for each vertex it is easy to check whether it lies on any shortest path between $a$ and $b$:\nthe criterion is the condition $d_a [v] + d_b [v] = d_a [b]$.\n\n* Find the shortest path of even length from a source vertex $s$ to a target vertex $t$ in an unweighted graph:\nFor this, we must construct an auxiliary graph, whose vertices are the state $(v, c)$, where $v$ - the current node, $c = 0$ or $c = 1$ - the current parity.\nAny edge $(u, v)$ of the original graph in this new column will turn into two edges $((u, 0), (v, 1))$ and $((u, 1), (v, 0))$.\nAfter that we run a BFS to find the shortest path from the starting vertex $(s, 0)$ to the end vertex $(t, 0)$.\n\n## Practice Problems\n\n* [SPOJ: AKBAR](http://spoj.com/problems/AKBAR)\n* [SPOJ: NAKANJ](http://www.spoj.com/problems/NAKANJ/)\n* [SPOJ: WATER](http://www.spoj.com/problems/WATER)\n* [SPOJ: MICE AND MAZE](http://www.spoj.com/problems/MICEMAZE/)\n* [Timus: Caravans](http://acm.timus.ru/problem.aspx?space=1&num=2034)\n* [DevSkill - Holloween Party (archived)](http://web.archive.org/web/20200930162803/http://www.devskill.com/CodingProblems/ViewProblem/60)\n* [DevSkill - Ohani And The Link Cut Tree (archived)](http://web.archive.org/web/20170216192002/http://devskill.com:80/CodingProblems/ViewProblem/150)\n* [SPOJ - Spiky Mazes](http://www.spoj.com/problems/SPIKES/)\n* [SPOJ - Four Chips (hard)](http://www.spoj.com/problems/ADV04F1/)\n* [SPOJ - Inversion Sort](http://www.spoj.com/problems/INVESORT/)\n* [Codeforces - Shortest Path](http://codeforces.com/contest/59/problem/E)\n* [SPOJ - Yet Another Multiple Problem](http://www.spoj.com/problems/MULTII/)\n* [UVA 11392 - Binary 3xType Multiple](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2387)\n* [UVA 10968 - KuPellaKeS](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1909)\n* [Codeforces - Police Stations](http://codeforces.com/contest/796/problem/D)\n* [Codeforces - Okabe and City](http://codeforces.com/contest/821/problem/D)\n* [SPOJ - Find the Treasure](http://www.spoj.com/problems/DIGOKEYS/)\n* [Codeforces - Bear and Forgotten Tree 2](http://codeforces.com/contest/653/problem/E)\n* [Codeforces - Cycle in Maze](http://codeforces.com/contest/769/problem/C)\n* [UVA - 11312 - Flipping Frustration](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2287)\n* [SPOJ - Ada and Cycle](http://www.spoj.com/problems/ADACYCLE/)\n* [CSES - Labyrinth](https://cses.fi/problemset/task/1193)\n* [CSES - Message Route](https://cses.fi/problemset/task/1667/)\n* [CSES - Monsters](https://cses.fi/problemset/task/1194)\n", "problem_ids": ["59_E", "796_D", "821_D", "653_E"], "title": "Breadth-first search"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: johnson_problem_2\n---\n\n# Scheduling jobs on two machines\n\nThis task is about finding an optimal schedule for $n$ jobs on two machines.\nEvery item must first be processed on the first machine, and afterwards on the second one.\nThe $i$-th job takes $a_i$ time on the first machine, and $b_i$ time on the second machine.\nEach machine can only process one job at a time.\n\nWe want to find the optimal order of the jobs, so that the final processing time is the minimum possible.\n\nThis solution that is discussed here is called Johnson's rule (named after S. M. Johnson).\n\nIt is worth noting, that the task becomes NP-complete, if we have more than two machines.\n\n## Construction of the algorithm\n\nNote first, that we can assume that the order of jobs for the first and the second machine have to coincide.\nIn fact, since the jobs for the second machine become available after processing them at the first, and if there are several jobs available for the second machine, than the processing time will be equal to the sum of their $b_i$, regardless of their order.\nTherefore it is only advantageous to send the jobs to the second machine in the same order as we sent them to the first machine.\n\nConsider the order of the jobs, which coincides with their input order $1, 2, \\dots, n$.\n\nWe denote by $x_i$ the **idle time** of the second machine immediately before processing $i$.\nOur goal is to **minimize the total idle time**:\n\n$$F(x) = \\sum x_i ~ \\rightarrow \\min$$\n\nFor the first job we have $x_1 = a_1$.\nFor the second job, since it gets sent to the machine at the time $a_1 + a_2$, and the second machine gets free at $x_1 + b_1$, we have $x_2 = \\max\\left((a_1 + a_2) - (x_1 + b_1), 0\\right)$.\nIn general we get the equation:\n\n$$x_k = \\max\\left(\\sum_{i=1}^k a_i - \\sum_{i=1}^{k-1} b_i - \\sum_{i=1}^{k-1} x_i, 0 \\right)$$\n\nWe can now calculate the **total idle time** $F(x)$.\nIt is claimed that it has the form\n\n$$F(x) = \\max_{k=1 \\dots n} K_i,$$\n\nwhere\n\n$$K_i = \\sum_{i=1}^k a_i - \\sum_{i=1}^{k-1} b_i.$$\n\nThis can be easily verified using induction.\n\nWe now use the **permutation method**:\nwe will exchange two neighboring jobs $j$ and $j+1$ and see how this will change the total idle time.\n\nBy the form of the expression of $K_i$, it is clear that only $K_j$ and $K_{j+1}$ change, we denote their new values with $K_j'$ and $K_{j+1}'$.\n\nIf this change from of the jobs $j$ and $j+1$ increased the total idle time, it has to be the case that:\n\n$$\\max(K_j, K_{j+1}) \\le \\max(K_j', K_{j+1}')$$\n\n(Switching two jobs might also have no impact at all.\nThe above condition is only a sufficient one, but not a necessary one.)\n\nAfter removing $\\sum_{i=1}^{j+1} a_i - \\sum_{i=1}^{j-1} b_i$ from both sides of the inequality, we get:\n\n$$\\max(-a_{j+1}, -b_j) \\le \\max(-b_{j+1}, -a_j)$$\n\nAnd after getting rid of the negative signs:\n\n$$\\min(a_j, b_{j+1}) \\le \\min(b_j, a_{j+1})$$\n\nThus we obtained a **comparator**:\nby sorting the jobs on it, we obtain an optimal order of the jobs, in which no two jobs can be switched with an improvement of the final time.\n\nHowever you can further **simplify** the sorting, if you look at the comparator from a different angle.\nThe comparator can be interpreted in the following way:\nIf we have the four times $(a_j, a_{j+1}, b_j, b_{j+1})$, and the minimum of them is a time corresponding to the first machine, then the corresponding job should be done first.\nIf the minimum time is a time from the second machine, then it should go later.\nThus we can sort the jobs by $\\min(a_i, b_i)$, and if the processing time of the current job on the first machine is less then the processing time on the second machine, then this job must be done before all the remaining jobs, and otherwise after all remaining tasks.\n\nOne way or another, it turns out that by Johnson's rule we can solve the problem by sorting the jobs, and thus receive a time complexity of $O(n \\log n)$.\n\n## Implementation\n\nHere we implement the second variation of the described algorithm.\n\n```{.cpp file=johnsons_rule}\nstruct Job {\n    int a, b, idx;\n\n    bool operator<(Job o) const {\n        return min(a, b) < min(o.a, o.b);\n    }\n};\n\nvector<Job> johnsons_rule(vector<Job> jobs) {\n    sort(jobs.begin(), jobs.end());\n    vector<Job> a, b;\n    for (Job j : jobs) {\n        if (j.a < j.b)\n            a.push_back(j);\n        else\n            b.push_back(j);\n    }\n    a.insert(a.end(), b.rbegin(), b.rend());\n    return a;\n}\n\npair<int, int> finish_times(vector<Job> const& jobs) {\n    int t1 = 0, t2 = 0;\n    for (Job j : jobs) {\n        t1 += j.a;\n        t2 = max(t2, t1) + j.b;\n    }\n    return make_pair(t1, t2);\n}\n```\n\nAll the information about each job is store in struct.\nThe first function sorts all jobs and computes the optimal schedule.\nThe second function computes the finish times of both machines given a schedule.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: johnson_problem_2\n---\n\n# Scheduling jobs on two machines\n\nThis task is about finding an optimal schedule for $n$ jobs on two machines.\nEvery item must first be processed on the first machine, and afterwards on the second one.\nThe $i$-th job takes $a_i$ time on the first machine, and $b_i$ time on the second machine.\nEach machine can only process one job at a time.\n\nWe want to find the optimal order of the jobs, so that the final processing time is the minimum possible.\n\nThis solution that is discussed here is called Johnson's rule (named after S. M. Johnson).\n\nIt is worth noting, that the task becomes NP-complete, if we have more than two machines.\n\n## Construction of the algorithm\n\nNote first, that we can assume that the order of jobs for the first and the second machine have to coincide.\nIn fact, since the jobs for the second machine become available after processing them at the first, and if there are several jobs available for the second machine, than the processing time will be equal to the sum of their $b_i$, regardless of their order.\nTherefore it is only advantageous to send the jobs to the second machine in the same order as we sent them to the first machine.\n\nConsider the order of the jobs, which coincides with their input order $1, 2, \\dots, n$.\n\nWe denote by $x_i$ the **idle time** of the second machine immediately before processing $i$.\nOur goal is to **minimize the total idle time**:\n\n$$F(x) = \\sum x_i ~ \\rightarrow \\min$$\n\nFor the first job we have $x_1 = a_1$.\nFor the second job, since it gets sent to the machine at the time $a_1 + a_2$, and the second machine gets free at $x_1 + b_1$, we have $x_2 = \\max\\left((a_1 + a_2) - (x_1 + b_1), 0\\right)$.\nIn general we get the equation:\n\n$$x_k = \\max\\left(\\sum_{i=1}^k a_i - \\sum_{i=1}^{k-1} b_i - \\sum_{i=1}^{k-1} x_i, 0 \\right)$$\n\nWe can now calculate the **total idle time** $F(x)$.\nIt is claimed that it has the form\n\n$$F(x) = \\max_{k=1 \\dots n} K_i,$$\n\nwhere\n\n$$K_i = \\sum_{i=1}^k a_i - \\sum_{i=1}^{k-1} b_i.$$\n\nThis can be easily verified using induction.\n\nWe now use the **permutation method**:\nwe will exchange two neighboring jobs $j$ and $j+1$ and see how this will change the total idle time.\n\nBy the form of the expression of $K_i$, it is clear that only $K_j$ and $K_{j+1}$ change, we denote their new values with $K_j'$ and $K_{j+1}'$.\n\nIf this change from of the jobs $j$ and $j+1$ increased the total idle time, it has to be the case that:\n\n$$\\max(K_j, K_{j+1}) \\le \\max(K_j', K_{j+1}')$$\n\n(Switching two jobs might also have no impact at all.\nThe above condition is only a sufficient one, but not a necessary one.)\n\nAfter removing $\\sum_{i=1}^{j+1} a_i - \\sum_{i=1}^{j-1} b_i$ from both sides of the inequality, we get:\n\n$$\\max(-a_{j+1}, -b_j) \\le \\max(-b_{j+1}, -a_j)$$\n\nAnd after getting rid of the negative signs:\n\n$$\\min(a_j, b_{j+1}) \\le \\min(b_j, a_{j+1})$$\n\nThus we obtained a **comparator**:\nby sorting the jobs on it, we obtain an optimal order of the jobs, in which no two jobs can be switched with an improvement of the final time.\n\nHowever you can further **simplify** the sorting, if you look at the comparator from a different angle.\nThe comparator can be interpreted in the following way:\nIf we have the four times $(a_j, a_{j+1}, b_j, b_{j+1})$, and the minimum of them is a time corresponding to the first machine, then the corresponding job should be done first.\nIf the minimum time is a time from the second machine, then it should go later.\nThus we can sort the jobs by $\\min(a_i, b_i)$, and if the processing time of the current job on the first machine is less then the processing time on the second machine, then this job must be done before all the remaining jobs, and otherwise after all remaining tasks.\n\nOne way or another, it turns out that by Johnson's rule we can solve the problem by sorting the jobs, and thus receive a time complexity of $O(n \\log n)$.\n\n## Implementation\n\nHere we implement the second variation of the described algorithm.\n\n```{.cpp file=johnsons_rule}\nstruct Job {\n    int a, b, idx;\n\n    bool operator<(Job o) const {\n        return min(a, b) < min(o.a, o.b);\n    }\n};\n\nvector<Job> johnsons_rule(vector<Job> jobs) {\n    sort(jobs.begin(), jobs.end());\n    vector<Job> a, b;\n    for (Job j : jobs) {\n        if (j.a < j.b)\n            a.push_back(j);\n        else\n            b.push_back(j);\n    }\n    a.insert(a.end(), b.rbegin(), b.rend());\n    return a;\n}\n\npair<int, int> finish_times(vector<Job> const& jobs) {\n    int t1 = 0, t2 = 0;\n    for (Job j : jobs) {\n        t1 += j.a;\n        t2 = max(t2, t1) + j.b;\n    }\n    return make_pair(t1, t2);\n}\n```\n\nAll the information about each job is store in struct.\nThe first function sorts all jobs and computes the optimal schedule.\nThe second function computes the finish times of both machines given a schedule.\n", "problem_ids": [], "title": "Scheduling jobs on two machines"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: schedule_with_completion_duration\n---\n\n# Optimal schedule of jobs given their deadlines and durations\n\nSuppose, we have a set of jobs, and we are aware of every job\u2019s deadline and its duration. The execution of a job cannot be interrupted prior to its ending. It is required to create such a schedule to accomplish the biggest number of jobs.\n\n## Solving\n\nThe algorithm of the solving is **greedy**. Let\u2019s sort all the jobs by their deadlines and look at them in descending order. Also, let\u2019s create a queue $q$, in which we\u2019ll gradually put the jobs and extract one with the least run-time (for instance, we can use set or priority_queue). Initially, $q$ is empty.\n\nSuppose, we\u2019re looking at the $i$-th job. First of all, let\u2019s put it into $q$. Let\u2019s consider the period of time between the deadline of $i$-th job and the deadline of $i-1$-th job. That is the segment of some length $T$. We will extract jobs from $q$ (in their left duration ascending order) and execute them until the whole segment $T$ is filled. Important: if at any moment of time the extracted job can only be partly executed until segment $T$ is filled, then we execute this job partly just as far as possible, i.e., during the $T$-time, and we put the remaining part of a job back into $q$.\n\nOn the algorithm\u2019s completion we\u2019ll choose the optimal solution (or, at least, one of several solutions). The running time of algorithm is $O(n \\log n)$.\n\n## Implementation\n\nThe following function takes a vector of jobs (consisting of a deadline, a duration, and the job's index) and computes a vector containing all indices of the used jobs in the optimal schedule.\nNotice that you still need to sort these jobs by their deadline, if you want to write down the plan explicitly.\n\n```{.cpp file=schedule_deadline_duration}\nstruct Job {\n    int deadline, duration, idx;\n\n    bool operator<(Job o) const {\n        return deadline < o.deadline;\n    }\n};\n\nvector<int> compute_schedule(vector<Job> jobs) {\n    sort(jobs.begin(), jobs.end());\n\n    set<pair<int,int>> s;\n    vector<int> schedule;\n    for (int i = jobs.size()-1; i >= 0; i--) {\n        int t = jobs[i].deadline - (i ? jobs[i-1].deadline : 0);\n        s.insert(make_pair(jobs[i].duration, jobs[i].idx));\n        while (t && !s.empty()) {\n            auto it = s.begin();\n            if (it->first <= t) {\n                t -= it->first;\n                schedule.push_back(it->second);\n            } else {\n                s.insert(make_pair(it->first - t, it->second));\n                t = 0;\n            }\n            s.erase(it);\n        }\n    }\n    return schedule;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: schedule_with_completion_duration\n---\n\n# Optimal schedule of jobs given their deadlines and durations\n\nSuppose, we have a set of jobs, and we are aware of every job\u2019s deadline and its duration. The execution of a job cannot be interrupted prior to its ending. It is required to create such a schedule to accomplish the biggest number of jobs.\n\n## Solving\n\nThe algorithm of the solving is **greedy**. Let\u2019s sort all the jobs by their deadlines and look at them in descending order. Also, let\u2019s create a queue $q$, in which we\u2019ll gradually put the jobs and extract one with the least run-time (for instance, we can use set or priority_queue). Initially, $q$ is empty.\n\nSuppose, we\u2019re looking at the $i$-th job. First of all, let\u2019s put it into $q$. Let\u2019s consider the period of time between the deadline of $i$-th job and the deadline of $i-1$-th job. That is the segment of some length $T$. We will extract jobs from $q$ (in their left duration ascending order) and execute them until the whole segment $T$ is filled. Important: if at any moment of time the extracted job can only be partly executed until segment $T$ is filled, then we execute this job partly just as far as possible, i.e., during the $T$-time, and we put the remaining part of a job back into $q$.\n\nOn the algorithm\u2019s completion we\u2019ll choose the optimal solution (or, at least, one of several solutions). The running time of algorithm is $O(n \\log n)$.\n\n## Implementation\n\nThe following function takes a vector of jobs (consisting of a deadline, a duration, and the job's index) and computes a vector containing all indices of the used jobs in the optimal schedule.\nNotice that you still need to sort these jobs by their deadline, if you want to write down the plan explicitly.\n\n```{.cpp file=schedule_deadline_duration}\nstruct Job {\n    int deadline, duration, idx;\n\n    bool operator<(Job o) const {\n        return deadline < o.deadline;\n    }\n};\n\nvector<int> compute_schedule(vector<Job> jobs) {\n    sort(jobs.begin(), jobs.end());\n\n    set<pair<int,int>> s;\n    vector<int> schedule;\n    for (int i = jobs.size()-1; i >= 0; i--) {\n        int t = jobs[i].deadline - (i ? jobs[i-1].deadline : 0);\n        s.insert(make_pair(jobs[i].duration, jobs[i].idx));\n        while (t && !s.empty()) {\n            auto it = s.begin();\n            if (it->first <= t) {\n                t -= it->first;\n                schedule.push_back(it->second);\n            } else {\n                s.insert(make_pair(it->first - t, it->second));\n                t = 0;\n            }\n            s.erase(it);\n        }\n    }\n    return schedule;\n}\n```\n", "problem_ids": [], "title": "Optimal schedule of jobs given their deadlines and durations"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: johnson_problem_1\n---\n\n# Scheduling jobs on one machine\n\nThis task is about finding an optimal schedule for $n$ jobs on a single machine, if the job $i$ can be processed in $t_i$ time, but for the $t$ seconds waiting before processing the job a penalty of $f_i(t)$ has to be paid.\n\nThus the task asks to find such an permutation of the jobs, so that the total penalty is minimal.\nIf we denote by $\\pi$ the permutation of the jobs ($\\pi_1$ is the first processed item, $\\pi_2$ the second, etc.), then the total penalty is equal to:\n\n$$F(\\pi) = f_{\\pi_1}(0) + f_{\\pi_2}(t_{\\pi_1}) + f_{\\pi_3}(t_{\\pi_1} + t_{\\pi_2}) + \\dots + f_{\\pi_n}\\left(\\sum_{i=1}^{n-1} t_{\\pi_i}\\right)$$\n\n## Solutions for special cases\n\n### Linear penalty functions\n\nFirst we will solve the problem in the case that all penalty functions $f_i(t)$ are linear, i.e. they have the form $f_i(t) = c_i \\cdot t$, where $c_i$ is a non-negative number.\nNote that these functions don't have a constant term.\nOtherwise we can sum up all constant term, and resolve the problem without them.\n\nLet us fixate some permutation $\\pi$, and take an index $i = 1 \\dots n-1$.\nLet the permutation $\\pi'$ be equal to the permutation $\\pi$ with the elements $i$ and $i+1$ switched.\nLet's see how much the penalty changed.\n\n$$F(\\pi') - F(\\pi) =$$\n\nIt is easy to see that the changes only occur in the $i$-th and $(i+1)$-th summands:\n\n$$\\begin{align}\n&= c_{\\pi_i'} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k'} + c_{\\pi_{i+1}'} \\cdot \\sum_{k = 1}^i t_{\\pi_k'} - c_{\\pi_i} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k} - c_{\\pi_{i+1}} \\cdot \\sum_{k = 1}^i t_{\\pi_k} \\\\\n&= c_{\\pi_{i+1}} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k'} + c_{\\pi_i} \\cdot \\sum_{k = 1}^i t_{\\pi_k'} - c_{\\pi_i} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k} - c_{\\pi_{i+1}} \\cdot \\sum_{k = 1}^i t_{\\pi_k} \\\\\n&= c_{\\pi_i} \\cdot t_{\\pi_{i+1}} - c_{\\pi_{i+1}} \\cdot t_{\\pi_i}\n\\end{align}$$\n\nIt is easy to see, that if the schedule $\\pi$ is optimal, than any change in it leads to an increased penalty (or to the identical penalty), therefore for the optimal schedule we can write down the following condition:\n\n$$c_{\\pi_{i}} \\cdot t_{\\pi_{i+1}} - c_{\\pi_{i+1}} \\cdot t_{\\pi_i} \\ge 0 \\quad \\forall i = 1 \\dots n-1$$\n\nAnd after rearranging we get:\n\n$$\\frac{c_{\\pi_i}}{t_{\\pi_i}} \\ge \\frac{c_{\\pi_{i+1}}}{t_{\\pi_{i+1}}} \\quad \\forall i = 1 \\dots n-1$$\n\nThus we obtain the **optimal schedule** by simply **sorting** the jobs by the fraction $\\frac{c_i}{t_i}$ in non-ascending order.\n\nIt should be noted, that we constructed this algorithm by the so-called **permutation method**:\nwe tried to swap two adjacent elements, calculated how much the penalty changed, and then derived the algorithm for finding the optimal method.\n\n### Exponential penalty function\n\nLet the penalty function look like this:\n\n$$f_i(t) = c_i \\cdot e^{\\alpha \\cdot t},$$\n\nwhere all numbers $c_i$ are non-negative and the constant $\\alpha$ is positive.\n\nBy applying the permutation method, it is easy to determine that the jobs must be sorted in non-ascending order of the value:\n\n$$v_i = \\frac{1 - e^{\\alpha \\cdot t_i}}{c_i}$$\n\n### Identical monotone penalty function\n\nIn this case we consider the case that all $f_i(t)$ are equal, and this function is monotone increasing.\n\nIt is obvious that in this case the optimal permutation is to arrange the jobs by non-descending processing time $t_i$.\n\n## The Livshits-Kladov theorem\n\nThe Livshits-Kladov theorem establishes that the permutation method is only applicable for the above mentioned three cases, i.e.:\n\n- Linear case: $f_i(t) = c_i(t) + d_i$, where $c_i$ are non-negative constants,\n- Exponential case: $f_i(t) = c_i \\cdot e_{\\alpha \\cdot t} + d_i$, where $c_i$ and $\\alpha$ are positive constants,\n- Identical case: $f_i(t) = \\phi(t)$, where $\\phi$ is a monotone increasing function.\n\nIn all other cases the method cannot be applied.\n\nThe theorem is proven under the assumption that the penalty functions are sufficiently smooth (the third derivatives exists).\n\nIn all three case we apply the permutation method, through which the desired optimal schedule can be found by sorting, hence in $O(n \\log n)$ time.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: johnson_problem_1\n---\n\n# Scheduling jobs on one machine\n\nThis task is about finding an optimal schedule for $n$ jobs on a single machine, if the job $i$ can be processed in $t_i$ time, but for the $t$ seconds waiting before processing the job a penalty of $f_i(t)$ has to be paid.\n\nThus the task asks to find such an permutation of the jobs, so that the total penalty is minimal.\nIf we denote by $\\pi$ the permutation of the jobs ($\\pi_1$ is the first processed item, $\\pi_2$ the second, etc.), then the total penalty is equal to:\n\n$$F(\\pi) = f_{\\pi_1}(0) + f_{\\pi_2}(t_{\\pi_1}) + f_{\\pi_3}(t_{\\pi_1} + t_{\\pi_2}) + \\dots + f_{\\pi_n}\\left(\\sum_{i=1}^{n-1} t_{\\pi_i}\\right)$$\n\n## Solutions for special cases\n\n### Linear penalty functions\n\nFirst we will solve the problem in the case that all penalty functions $f_i(t)$ are linear, i.e. they have the form $f_i(t) = c_i \\cdot t$, where $c_i$ is a non-negative number.\nNote that these functions don't have a constant term.\nOtherwise we can sum up all constant term, and resolve the problem without them.\n\nLet us fixate some permutation $\\pi$, and take an index $i = 1 \\dots n-1$.\nLet the permutation $\\pi'$ be equal to the permutation $\\pi$ with the elements $i$ and $i+1$ switched.\nLet's see how much the penalty changed.\n\n$$F(\\pi') - F(\\pi) =$$\n\nIt is easy to see that the changes only occur in the $i$-th and $(i+1)$-th summands:\n\n$$\\begin{align}\n&= c_{\\pi_i'} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k'} + c_{\\pi_{i+1}'} \\cdot \\sum_{k = 1}^i t_{\\pi_k'} - c_{\\pi_i} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k} - c_{\\pi_{i+1}} \\cdot \\sum_{k = 1}^i t_{\\pi_k} \\\\\n&= c_{\\pi_{i+1}} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k'} + c_{\\pi_i} \\cdot \\sum_{k = 1}^i t_{\\pi_k'} - c_{\\pi_i} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k} - c_{\\pi_{i+1}} \\cdot \\sum_{k = 1}^i t_{\\pi_k} \\\\\n&= c_{\\pi_i} \\cdot t_{\\pi_{i+1}} - c_{\\pi_{i+1}} \\cdot t_{\\pi_i}\n\\end{align}$$\n\nIt is easy to see, that if the schedule $\\pi$ is optimal, than any change in it leads to an increased penalty (or to the identical penalty), therefore for the optimal schedule we can write down the following condition:\n\n$$c_{\\pi_{i}} \\cdot t_{\\pi_{i+1}} - c_{\\pi_{i+1}} \\cdot t_{\\pi_i} \\ge 0 \\quad \\forall i = 1 \\dots n-1$$\n\nAnd after rearranging we get:\n\n$$\\frac{c_{\\pi_i}}{t_{\\pi_i}} \\ge \\frac{c_{\\pi_{i+1}}}{t_{\\pi_{i+1}}} \\quad \\forall i = 1 \\dots n-1$$\n\nThus we obtain the **optimal schedule** by simply **sorting** the jobs by the fraction $\\frac{c_i}{t_i}$ in non-ascending order.\n\nIt should be noted, that we constructed this algorithm by the so-called **permutation method**:\nwe tried to swap two adjacent elements, calculated how much the penalty changed, and then derived the algorithm for finding the optimal method.\n\n### Exponential penalty function\n\nLet the penalty function look like this:\n\n$$f_i(t) = c_i \\cdot e^{\\alpha \\cdot t},$$\n\nwhere all numbers $c_i$ are non-negative and the constant $\\alpha$ is positive.\n\nBy applying the permutation method, it is easy to determine that the jobs must be sorted in non-ascending order of the value:\n\n$$v_i = \\frac{1 - e^{\\alpha \\cdot t_i}}{c_i}$$\n\n### Identical monotone penalty function\n\nIn this case we consider the case that all $f_i(t)$ are equal, and this function is monotone increasing.\n\nIt is obvious that in this case the optimal permutation is to arrange the jobs by non-descending processing time $t_i$.\n\n## The Livshits-Kladov theorem\n\nThe Livshits-Kladov theorem establishes that the permutation method is only applicable for the above mentioned three cases, i.e.:\n\n- Linear case: $f_i(t) = c_i(t) + d_i$, where $c_i$ are non-negative constants,\n- Exponential case: $f_i(t) = c_i \\cdot e_{\\alpha \\cdot t} + d_i$, where $c_i$ and $\\alpha$ are positive constants,\n- Identical case: $f_i(t) = \\phi(t)$, where $\\phi$ is a monotone increasing function.\n\nIn all other cases the method cannot be applied.\n\nThe theorem is proven under the assumption that the penalty functions are sufficiently smooth (the third derivatives exists).\n\nIn all three case we apply the permutation method, through which the desired optimal schedule can be found by sorting, hence in $O(n \\log n)$ time.\n", "problem_ids": [], "title": "Scheduling jobs on one machine"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: binomial_coeff\n---\n\n# Binomial Coefficients\n\nBinomial coefficients $\\binom n k$ are the number of ways to select a set of $k$ elements from $n$ different elements without taking into account the order of arrangement of these elements (i.e., the number of unordered sets).\n\nBinomial coefficients are also the coefficients in the expansion of $(a + b) ^ n$ (so-called binomial theorem):\n\n$$ (a+b)^n = \\binom n 0 a^n + \\binom n 1 a^{n-1} b + \\binom n 2 a^{n-2} b^2 + \\cdots + \\binom n k a^{n-k} b^k + \\cdots + \\binom n n b^n $$\n\nIt is believed that this formula, as well as the triangle which allows efficient calculation of the coefficients, was discovered by Blaise Pascal in the 17th century. Nevertheless, it was known to the Chinese mathematician Yang Hui, who lived in the 13th century. Perhaps it was discovered by a Persian scholar Omar Khayyam. Moreover, Indian mathematician Pingala, who lived  earlier in the 3rd. BC, got similar results. The merit of the Newton is that he generalized this formula for exponents that are not natural.\n\n## Calculation\n\n**Analytic formula** for the calculation:\n\n$$ \\binom n k = \\frac {n!} {k!(n-k)!} $$\n\nThis formula can be easily deduced from the problem of ordered arrangement (number of ways to select $k$ different elements from $n$ different elements). First, let's count the number of ordered selections of $k$ elements. There are $n$ ways to select the first element, $n-1$ ways to select the second element, $n-2$ ways to select the third element, and so on. As a result, we get the formula of the number of ordered arrangements: $n (n-1) (n-2) \\cdots (n - k + 1) = \\frac {n!} {(n-k)!}$. We can easily move to unordered arrangements, noting that each unordered arrangement corresponds to exactly $k!$ ordered arrangements ($k!$ is the number of possible permutations of $k$ elements). We get the final formula by dividing $\\frac {n!} {(n-k)!}$ by $k!$.\n\n**Recurrence formula** (which is associated with the famous \"Pascal's Triangle\"):\n\n$$ \\binom n k = \\binom {n-1} {k-1} + \\binom {n-1} k $$\n\nIt is easy to deduce this using the analytic formula.\n\nNote that for $n \\lt k$ the value of $\\binom n k$ is assumed to be zero.\n\n## Properties\n\nBinomial coefficients have many different properties. Here are the simplest of them:\n\n*   Symmetry rule:\n\n    \\[ \\binom n k = \\binom n {n-k} \\]\n\n*   Factoring in:\n\n    \\[ \\binom n k = \\frac n k \\binom {n-1} {k-1} \\]\n\n*   Sum over $k$:\n\n    \\[ \\sum_{k = 0}^n \\binom n k = 2 ^ n \\]\n\n*   Sum over $n$:\n\n    \\[ \\sum_{m = 0}^n \\binom m k = \\binom {n + 1} {k + 1} \\]\n\n*   Sum over $n$ and $k$:\n\n    \\[ \\sum_{k = 0}^m  \\binom {n + k} k = \\binom {n + m + 1} m \\]\n\n*   Sum of the squares:\n\n    \\[ {\\binom n 0}^2 + {\\binom n 1}^2 + \\cdots + {\\binom n n}^2 = \\binom {2n} n \\]\n\n*   Weighted sum:\n\n    \\[ 1 \\binom n 1 + 2 \\binom n 2 + \\cdots + n \\binom n n = n 2^{n-1} \\]\n\n*   Connection with the [Fibonacci numbers](../algebra/fibonacci-numbers.md):\n\n    \\[ \\binom n 0 + \\binom {n-1} 1 + \\cdots + \\binom {n-k} k + \\cdots + \\binom 0 n = F_{n+1} \\]\n\n## Calculation\n\n### Straightforward calculation using analytical formula\n\nThe first, straightforward formula is very easy to code, but this method is likely to overflow even for relatively small values of $n$ and $k$ (even if the answer completely fit into some datatype, the calculation of the intermediate factorials can lead to overflow). Therefore, this method often can only be used with [long arithmetic](../algebra/big-integer.md):\n\n```cpp\nint C(int n, int k) {\n    int res = 1;\n    for (int i = n - k + 1; i <= n; ++i)\n        res *= i;\n    for (int i = 2; i <= k; ++i)\n        res /= i;\n    return res;\n}\n```\n\n### Improved implementation\n\nNote that in the above implementation numerator and denominator have the same number of factors ($k$), each of which is greater than or equal to 1. Therefore, we can replace our fraction with a product $k$ fractions, each of which is real-valued. However, on each step after multiplying current answer by each of the next fractions the answer will still be integer (this follows from the property of factoring in). \n\nC++ implementation:\n\n```cpp\nint C(int n, int k) {\n    double res = 1;\n    for (int i = 1; i <= k; ++i)\n        res = res * (n - k + i) / i;\n    return (int)(res + 0.01);\n}\n```\n\nHere we carefully cast the floating point number to an integer, taking into account that due to the accumulated errors, it may be slightly less than the true value (for example, $2.99999$ instead of $3$).\n\n### Pascal's Triangle\n\nBy using the recurrence relation we can construct a table of binomial coefficients (Pascal's triangle) and take the result from it. The advantage of this method is that intermediate results never exceed the answer and calculating each new table element requires only one addition. The flaw is slow execution for large $n$ and $k$ if you just need a single value and not the whole table (because in order to calculate $\\binom n k$ you will need to build a table of all $\\binom i j, 1 \\le i \\le n, 1 \\le j \\le n$, or at least to $1 \\le j \\le \\min (i, 2k)$). The time complexity can be considered to be $\\mathcal{O}(n^2)$.\n\nC++ implementation:\n\n```cpp\nconst int maxn = ...;\nint C[maxn + 1][maxn + 1];\nC[0][0] = 1;\nfor (int n = 1; n <= maxn; ++n) {\n    C[n][0] = C[n][n] = 1;\n    for (int k = 1; k < n; ++k)\n        C[n][k] = C[n - 1][k - 1] + C[n - 1][k];\n}\n```\n\nIf the entire table of values is not necessary, storing only two last rows of it is sufficient (current $n$-th row and the previous $n-1$-th).\n\n### Calculation in $O(1)$ {data-toc-label=\"Calculation in O(1)\"}\n\nFinally, in some situations it is beneficial to precompute all the factorials in order to produce any necessary binomial coefficient with only two divisions later. This can be advantageous when using [long arithmetic](../algebra/big-integer.md), when the memory does not allow precomputation of the whole Pascal's triangle.\n\n\n## Computing binomial coefficients modulo $m$ {data-toc-label=\"Computing binomial coefficients modulo m\"}\n\nQuite often you come across the problem of computing binomial coefficients modulo some $m$.\n\n### Binomial coefficient for small $n$ {data-toc-label=\"Binomial coefficient for small n\"}\n\nThe previously discussed approach of Pascal's triangle can be used to calculate all values of $\\binom{n}{k} \\bmod m$ for reasonably small $n$, since it requires time complexity $\\mathcal{O}(n^2)$. This approach can handle any modulo, since only addition operations are used.\n\n\n### Binomial coefficient modulo large prime\n\nThe formula for the binomial coefficients is\n\n$$\\binom n k = \\frac {n!} {k!(n-k)!},$$\n\nso if we want to compute it modulo some prime $m > n$ we get\n\n$$\\binom n k \\equiv n! \\cdot (k!)^{-1} \\cdot ((n-k)!)^{-1} \\mod m.$$\n\nFirst we precompute all factorials modulo $m$ up to $\\text{MAXN}!$ in $O(\\text{MAXN})$ time.\n\n```cpp\nfactorial[0] = 1;\nfor (int i = 1; i <= MAXN; i++) {\n    factorial[i] = factorial[i - 1] * i % m;\n}\n```\n\nAnd afterwards we can compute the binomial coefficient in $O(\\log m)$ time.\n\n```cpp\nlong long binomial_coefficient(int n, int k) {\n    return factorial[n] * inverse(factorial[k] * factorial[n - k] % m) % m;\n}\n```\n\nWe even can compute the binomial coefficient in $O(1)$ time if we precompute the inverses of all factorials in $O(\\text{MAXN} \\log m)$ using the regular method for computing the inverse, or even in $O(\\text{MAXN})$ time using the congruence $(x!)^{-1} \\equiv ((x-1)!)^{-1} \\cdot x^{-1}$ and the method for [computing all inverses](../algebra/module-inverse.md#mod-inv-all-num) in $O(n)$.\n\n```cpp\nlong long binomial_coefficient(int n, int k) {\n    return factorial[n] * inverse_factorial[k] % m * inverse_factorial[n - k] % m;\n}\n```\n\n### Binomial coefficient modulo prime power  { #mod-prime-pow}\n\nHere we want to compute the binomial coefficient modulo some prime power, i.e. $m = p^b$ for some prime $p$.\nIf $p > \\max(k, n-k)$, then we can use the same method as described in the previous section.\nBut if $p \\le \\max(k, n-k)$, then at least one of $k!$ and $(n-k)!$ are not coprime with $m$, and therefore we cannot compute the inverses - they don't exist.\nNevertheless we can compute the binomial coefficient.\n\nThe idea is the following:\nWe compute for each $x!$ the biggest exponent $c$ such that $p^c$ divides $x!$, i.e. $p^c ~|~ x!$.\nLet $c(x)$ be that number.\nAnd let $g(x) := \\frac{x!}{p^{c(x)}}$.\nThen we can write the binomial coefficient as:\n\n$$\\binom n k = \\frac {g(n) p^{c(n)}} {g(k) p^{c(k)} g(n-k) p^{c(n-k)}} = \\frac {g(n)} {g(k) g(n-k)}p^{c(n) - c(k) - c(n-k)}$$\n\nThe interesting thing is, that $g(x)$ is now free from the prime divisor $p$.\nTherefore $g(x)$ is coprime to m, and we can compute the modular inverses of $g(k)$ and $g(n-k)$.\n\nAfter precomputing all values for $g$ and $c$, which can be done efficiently using dynamic programming in $\\mathcal{O}(n)$, we can compute the binomial coefficient in $O(\\log m)$ time.\nOr precompute all inverses and all powers of $p$, and then compute the binomial coefficient in $O(1)$.\n\nNotice, if $c(n) - c(k) - c(n-k) \\ge b$, than $p^b ~|~ p^{c(n) - c(k) - c(n-k)}$, and the binomial coefficient is $0$.\n\n### Binomial coefficient modulo an arbitrary number\n\nNow we compute the binomial coefficient modulo some arbitrary modulus $m$.\n\nLet the prime factorization of $m$ be $m = p_1^{e_1} p_2^{e_2} \\cdots p_h^{e_h}$.\nWe can compute the binomial coefficient modulo $p_i^{e_i}$ for every $i$.\nThis gives us $h$ different congruences.\nSince all moduli $p_i^{e_i}$ are coprime, we can apply the [Chinese Remainder Theorem](../algebra/chinese-remainder-theorem.md) to compute the binomial coefficient modulo the product of the moduli, which is the desired binomial coefficient modulo $m$.\n\n### Binomial coefficient for large $n$ and small modulo {data-toc-label=\"Binomial coefficient for large n and small modulo\"}\n\nWhen $n$ is too large, the $\\mathcal{O}(n)$ algorithms discussed above become impractical. However, if the modulo $m$ is small there are still ways to calculate $\\binom{n}{k} \\bmod m$.\n\nWhen the modulo $m$ is prime, there are 2 options:\n\n* [Lucas's theorem](https://en.wikipedia.org/wiki/Lucas's_theorem) can be applied which breaks the problem of computing $\\binom{n}{k} \\bmod m$ into $\\log_m n$ problems of the form $\\binom{x_i}{y_i} \\bmod m$ where $x_i, y_i < m$.  If each reduced coefficient is calculated using precomputed factorials and inverse factorials, the complexity is $\\mathcal{O}(m + \\log_m n)$.\n* The method of computing [factorial modulo P](../algebra/factorial-modulo.md) can be used to get the required $g$ and $c$ values and use them as described in the section of [modulo prime power](#mod-prime-pow). This takes $\\mathcal{O}(m \\log_m n)$.\n\nWhen $m$ is not prime but square-free, the prime factors of $m$ can be obtained and the coefficient modulo each prime factor can be calculated using either of the above methods, and the overall answer can be obtained by the Chinese Remainder Theorem.\n\nWhen $m$ is not square-free, a [generalization of Lucas's theorem for prime powers](https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf) can be applied instead of Lucas's theorem.\n\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: binomial_coeff\n---\n\n# Binomial Coefficients\n\nBinomial coefficients $\\binom n k$ are the number of ways to select a set of $k$ elements from $n$ different elements without taking into account the order of arrangement of these elements (i.e., the number of unordered sets).\n\nBinomial coefficients are also the coefficients in the expansion of $(a + b) ^ n$ (so-called binomial theorem):\n\n$$ (a+b)^n = \\binom n 0 a^n + \\binom n 1 a^{n-1} b + \\binom n 2 a^{n-2} b^2 + \\cdots + \\binom n k a^{n-k} b^k + \\cdots + \\binom n n b^n $$\n\nIt is believed that this formula, as well as the triangle which allows efficient calculation of the coefficients, was discovered by Blaise Pascal in the 17th century. Nevertheless, it was known to the Chinese mathematician Yang Hui, who lived in the 13th century. Perhaps it was discovered by a Persian scholar Omar Khayyam. Moreover, Indian mathematician Pingala, who lived  earlier in the 3rd. BC, got similar results. The merit of the Newton is that he generalized this formula for exponents that are not natural.\n\n## Calculation\n\n**Analytic formula** for the calculation:\n\n$$ \\binom n k = \\frac {n!} {k!(n-k)!} $$\n\nThis formula can be easily deduced from the problem of ordered arrangement (number of ways to select $k$ different elements from $n$ different elements). First, let's count the number of ordered selections of $k$ elements. There are $n$ ways to select the first element, $n-1$ ways to select the second element, $n-2$ ways to select the third element, and so on. As a result, we get the formula of the number of ordered arrangements: $n (n-1) (n-2) \\cdots (n - k + 1) = \\frac {n!} {(n-k)!}$. We can easily move to unordered arrangements, noting that each unordered arrangement corresponds to exactly $k!$ ordered arrangements ($k!$ is the number of possible permutations of $k$ elements). We get the final formula by dividing $\\frac {n!} {(n-k)!}$ by $k!$.\n\n**Recurrence formula** (which is associated with the famous \"Pascal's Triangle\"):\n\n$$ \\binom n k = \\binom {n-1} {k-1} + \\binom {n-1} k $$\n\nIt is easy to deduce this using the analytic formula.\n\nNote that for $n \\lt k$ the value of $\\binom n k$ is assumed to be zero.\n\n## Properties\n\nBinomial coefficients have many different properties. Here are the simplest of them:\n\n*   Symmetry rule:\n\n    \\[ \\binom n k = \\binom n {n-k} \\]\n\n*   Factoring in:\n\n    \\[ \\binom n k = \\frac n k \\binom {n-1} {k-1} \\]\n\n*   Sum over $k$:\n\n    \\[ \\sum_{k = 0}^n \\binom n k = 2 ^ n \\]\n\n*   Sum over $n$:\n\n    \\[ \\sum_{m = 0}^n \\binom m k = \\binom {n + 1} {k + 1} \\]\n\n*   Sum over $n$ and $k$:\n\n    \\[ \\sum_{k = 0}^m  \\binom {n + k} k = \\binom {n + m + 1} m \\]\n\n*   Sum of the squares:\n\n    \\[ {\\binom n 0}^2 + {\\binom n 1}^2 + \\cdots + {\\binom n n}^2 = \\binom {2n} n \\]\n\n*   Weighted sum:\n\n    \\[ 1 \\binom n 1 + 2 \\binom n 2 + \\cdots + n \\binom n n = n 2^{n-1} \\]\n\n*   Connection with the [Fibonacci numbers](../algebra/fibonacci-numbers.md):\n\n    \\[ \\binom n 0 + \\binom {n-1} 1 + \\cdots + \\binom {n-k} k + \\cdots + \\binom 0 n = F_{n+1} \\]\n\n## Calculation\n\n### Straightforward calculation using analytical formula\n\nThe first, straightforward formula is very easy to code, but this method is likely to overflow even for relatively small values of $n$ and $k$ (even if the answer completely fit into some datatype, the calculation of the intermediate factorials can lead to overflow). Therefore, this method often can only be used with [long arithmetic](../algebra/big-integer.md):\n\n```cpp\nint C(int n, int k) {\n    int res = 1;\n    for (int i = n - k + 1; i <= n; ++i)\n        res *= i;\n    for (int i = 2; i <= k; ++i)\n        res /= i;\n    return res;\n}\n```\n\n### Improved implementation\n\nNote that in the above implementation numerator and denominator have the same number of factors ($k$), each of which is greater than or equal to 1. Therefore, we can replace our fraction with a product $k$ fractions, each of which is real-valued. However, on each step after multiplying current answer by each of the next fractions the answer will still be integer (this follows from the property of factoring in). \n\nC++ implementation:\n\n```cpp\nint C(int n, int k) {\n    double res = 1;\n    for (int i = 1; i <= k; ++i)\n        res = res * (n - k + i) / i;\n    return (int)(res + 0.01);\n}\n```\n\nHere we carefully cast the floating point number to an integer, taking into account that due to the accumulated errors, it may be slightly less than the true value (for example, $2.99999$ instead of $3$).\n\n### Pascal's Triangle\n\nBy using the recurrence relation we can construct a table of binomial coefficients (Pascal's triangle) and take the result from it. The advantage of this method is that intermediate results never exceed the answer and calculating each new table element requires only one addition. The flaw is slow execution for large $n$ and $k$ if you just need a single value and not the whole table (because in order to calculate $\\binom n k$ you will need to build a table of all $\\binom i j, 1 \\le i \\le n, 1 \\le j \\le n$, or at least to $1 \\le j \\le \\min (i, 2k)$). The time complexity can be considered to be $\\mathcal{O}(n^2)$.\n\nC++ implementation:\n\n```cpp\nconst int maxn = ...;\nint C[maxn + 1][maxn + 1];\nC[0][0] = 1;\nfor (int n = 1; n <= maxn; ++n) {\n    C[n][0] = C[n][n] = 1;\n    for (int k = 1; k < n; ++k)\n        C[n][k] = C[n - 1][k - 1] + C[n - 1][k];\n}\n```\n\nIf the entire table of values is not necessary, storing only two last rows of it is sufficient (current $n$-th row and the previous $n-1$-th).\n\n### Calculation in $O(1)$ {data-toc-label=\"Calculation in O(1)\"}\n\nFinally, in some situations it is beneficial to precompute all the factorials in order to produce any necessary binomial coefficient with only two divisions later. This can be advantageous when using [long arithmetic](../algebra/big-integer.md), when the memory does not allow precomputation of the whole Pascal's triangle.\n\n\n## Computing binomial coefficients modulo $m$ {data-toc-label=\"Computing binomial coefficients modulo m\"}\n\nQuite often you come across the problem of computing binomial coefficients modulo some $m$.\n\n### Binomial coefficient for small $n$ {data-toc-label=\"Binomial coefficient for small n\"}\n\nThe previously discussed approach of Pascal's triangle can be used to calculate all values of $\\binom{n}{k} \\bmod m$ for reasonably small $n$, since it requires time complexity $\\mathcal{O}(n^2)$. This approach can handle any modulo, since only addition operations are used.\n\n\n### Binomial coefficient modulo large prime\n\nThe formula for the binomial coefficients is\n\n$$\\binom n k = \\frac {n!} {k!(n-k)!},$$\n\nso if we want to compute it modulo some prime $m > n$ we get\n\n$$\\binom n k \\equiv n! \\cdot (k!)^{-1} \\cdot ((n-k)!)^{-1} \\mod m.$$\n\nFirst we precompute all factorials modulo $m$ up to $\\text{MAXN}!$ in $O(\\text{MAXN})$ time.\n\n```cpp\nfactorial[0] = 1;\nfor (int i = 1; i <= MAXN; i++) {\n    factorial[i] = factorial[i - 1] * i % m;\n}\n```\n\nAnd afterwards we can compute the binomial coefficient in $O(\\log m)$ time.\n\n```cpp\nlong long binomial_coefficient(int n, int k) {\n    return factorial[n] * inverse(factorial[k] * factorial[n - k] % m) % m;\n}\n```\n\nWe even can compute the binomial coefficient in $O(1)$ time if we precompute the inverses of all factorials in $O(\\text{MAXN} \\log m)$ using the regular method for computing the inverse, or even in $O(\\text{MAXN})$ time using the congruence $(x!)^{-1} \\equiv ((x-1)!)^{-1} \\cdot x^{-1}$ and the method for [computing all inverses](../algebra/module-inverse.md#mod-inv-all-num) in $O(n)$.\n\n```cpp\nlong long binomial_coefficient(int n, int k) {\n    return factorial[n] * inverse_factorial[k] % m * inverse_factorial[n - k] % m;\n}\n```\n\n### Binomial coefficient modulo prime power  { #mod-prime-pow}\n\nHere we want to compute the binomial coefficient modulo some prime power, i.e. $m = p^b$ for some prime $p$.\nIf $p > \\max(k, n-k)$, then we can use the same method as described in the previous section.\nBut if $p \\le \\max(k, n-k)$, then at least one of $k!$ and $(n-k)!$ are not coprime with $m$, and therefore we cannot compute the inverses - they don't exist.\nNevertheless we can compute the binomial coefficient.\n\nThe idea is the following:\nWe compute for each $x!$ the biggest exponent $c$ such that $p^c$ divides $x!$, i.e. $p^c ~|~ x!$.\nLet $c(x)$ be that number.\nAnd let $g(x) := \\frac{x!}{p^{c(x)}}$.\nThen we can write the binomial coefficient as:\n\n$$\\binom n k = \\frac {g(n) p^{c(n)}} {g(k) p^{c(k)} g(n-k) p^{c(n-k)}} = \\frac {g(n)} {g(k) g(n-k)}p^{c(n) - c(k) - c(n-k)}$$\n\nThe interesting thing is, that $g(x)$ is now free from the prime divisor $p$.\nTherefore $g(x)$ is coprime to m, and we can compute the modular inverses of $g(k)$ and $g(n-k)$.\n\nAfter precomputing all values for $g$ and $c$, which can be done efficiently using dynamic programming in $\\mathcal{O}(n)$, we can compute the binomial coefficient in $O(\\log m)$ time.\nOr precompute all inverses and all powers of $p$, and then compute the binomial coefficient in $O(1)$.\n\nNotice, if $c(n) - c(k) - c(n-k) \\ge b$, than $p^b ~|~ p^{c(n) - c(k) - c(n-k)}$, and the binomial coefficient is $0$.\n\n### Binomial coefficient modulo an arbitrary number\n\nNow we compute the binomial coefficient modulo some arbitrary modulus $m$.\n\nLet the prime factorization of $m$ be $m = p_1^{e_1} p_2^{e_2} \\cdots p_h^{e_h}$.\nWe can compute the binomial coefficient modulo $p_i^{e_i}$ for every $i$.\nThis gives us $h$ different congruences.\nSince all moduli $p_i^{e_i}$ are coprime, we can apply the [Chinese Remainder Theorem](../algebra/chinese-remainder-theorem.md) to compute the binomial coefficient modulo the product of the moduli, which is the desired binomial coefficient modulo $m$.\n\n### Binomial coefficient for large $n$ and small modulo {data-toc-label=\"Binomial coefficient for large n and small modulo\"}\n\nWhen $n$ is too large, the $\\mathcal{O}(n)$ algorithms discussed above become impractical. However, if the modulo $m$ is small there are still ways to calculate $\\binom{n}{k} \\bmod m$.\n\nWhen the modulo $m$ is prime, there are 2 options:\n\n* [Lucas's theorem](https://en.wikipedia.org/wiki/Lucas's_theorem) can be applied which breaks the problem of computing $\\binom{n}{k} \\bmod m$ into $\\log_m n$ problems of the form $\\binom{x_i}{y_i} \\bmod m$ where $x_i, y_i < m$.  If each reduced coefficient is calculated using precomputed factorials and inverse factorials, the complexity is $\\mathcal{O}(m + \\log_m n)$.\n* The method of computing [factorial modulo P](../algebra/factorial-modulo.md) can be used to get the required $g$ and $c$ values and use them as described in the section of [modulo prime power](#mod-prime-pow). This takes $\\mathcal{O}(m \\log_m n)$.\n\nWhen $m$ is not prime but square-free, the prime factors of $m$ can be obtained and the coefficient modulo each prime factor can be calculated using either of the above methods, and the overall answer can be obtained by the Chinese Remainder Theorem.\n\nWhen $m$ is not square-free, a [generalization of Lucas's theorem for prime powers](https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf) can be applied instead of Lucas's theorem.\n\n\n## Practice Problems\n* [Codechef - Number of ways](https://www.codechef.com/LTIME24/problems/NWAYS/)\n* [Codeforces - Curious Array](http://codeforces.com/problemset/problem/407/C)\n* [LightOj - Necklaces](http://www.lightoj.com/volume_showproblem.php?problem=1419)\n* [HACKEREARTH: Binomial Coefficient](https://www.hackerearth.com/problem/algorithm/binomial-coefficient-1/description/)\n* [SPOJ - Ada and Teams](http://www.spoj.com/problems/ADATEAMS/)\n* [DevSkill - Drive In Grid](https://devskill.com/CodingProblems/ViewProblem/61)\n* [SPOJ - Greedy Walking](http://www.spoj.com/problems/UCV2013E/)\n* [UVa 13214 - The Robot's Grid](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=5137)\n* [SPOJ - Good Predictions](http://www.spoj.com/problems/GOODB/)\n* [SPOJ - Card Game](http://www.spoj.com/problems/HC12/)\n* [SPOJ - Topper Rama Rao](http://www.spoj.com/problems/HLP_RAMS/)\n* [UVa 13184 - Counting Edges and Graphs](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=5095)\n* [Codeforces - Anton and School 2](http://codeforces.com/contest/785/problem/D)\n* [DevSkill - Parandthesis](https://devskill.com/CodingProblems/ViewProblem/255)\n* [Codeforces - Bacterial Melee](http://codeforces.com/contest/760/problem/F)\n* [Codeforces - Points, Lines and Ready-made Titles](http://codeforces.com/contest/872/problem/E)\n* [SPOJ - The Ultimate Riddle](https://www.spoj.com/problems/DCEPC13D/)\n* [CodeChef - Long Sandwich](https://www.codechef.com/MAY17/problems/SANDWICH/)\n* [Codeforces - Placing Jinas](https://codeforces.com/problemset/problem/1696/E)\n\n## References\n* [Blog fishi.devtail.io](https://fishi.devtail.io/weblog/2015/06/25/computing-large-binomial-coefficients-modulo-prime-non-prime/)\n* [Question on Mathematics StackExchange](https://math.stackexchange.com/questions/95491/n-choose-k-bmod-m-using-chinese-remainder-theorem)\n* [Question on CodeChef Discuss](https://discuss.codechef.com/questions/98129/your-approach-to-solve-sandwich)\n", "problem_ids": ["407_C", "760_F"], "title": "Binomial Coefficients"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: inclusion_exclusion_principle\n---\n\n# The Inclusion-Exclusion Principle\n\nThe inclusion-exclusion principle is an important combinatorial way to compute the size of a set or the probability of complex events. It relates the sizes of individual sets with their union.\n\n## Statement\n\n### The verbal formula\n\nThe inclusion-exclusion principle can be expressed as follows:\n\nTo compute the size of a union of multiple sets, it is necessary to sum the sizes of these sets **separately**, and then subtract the sizes of all **pairwise** intersections of the sets, then add back the size of the intersections of **triples** of the sets, subtract the size of **quadruples** of the sets, and so on, up to the intersection of **all** sets.\n\n### The formulation in terms of sets\n\nThe above definition can be expressed mathematically as follows:\n\n$$\\left| \\bigcup_{i=1}^n A_i \\right| = \\sum_{i=1}^n|A_i| - \\sum_{1\\leq i<j\\leq n} |A_i \\cap A_j| + \\sum _{1\\leq i<j<k\\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} | A_1 \\cap \\cdots \\cap A_n |$$\n\nAnd in a more compact way:\n\n$$\\left|\\bigcup_{i=1}^n A_i \\right| = \\sum_{\\emptyset \\neq J\\subseteq \\{1,2,\\ldots ,n\\}} (-1)^{|J|-1}{\\Biggl |}\\bigcap_{j\\in J}A_{j}{\\Biggr |}$$\n\n### The formulation using Venn diagrams\n\nLet the diagram show three sets $A$, $B$ and $C$:\n\n![Venn diagram](venn-inclusion-exclusion.png \"Venn diagram\")\n\nThen the area of their union $A \\cup B \\cup C$ is equal to the sum of the areas $A$, $B$ and $C$ less double-covered areas $A \\cap B$, $A \\cap C$, $B \\cap C$, but with the addition of the area covered by three sets $A \\cap B \\cap C$:\n\n$$S(A \\cup B \\cup C) = S(A) + S(B) + S(C) - S(A \\cap B) - S(A \\cap C) - S(B \\cap C) + S(A \\cap B \\cap C)$$\n\nIt can also be generalized for an association of $n$ sets.\n\n### The formulation in terms of probability theory\n\nIf $A_i$ $(i = 1,2...n)$ are events and ${\\cal P}(A_i)$ the probability of an event from $A_i$ to occur, then the probability of their union (i.e. the probability that at least one of the events occur) is equal to:\n\n$$\\begin{eqnarray}\n{\\cal P} \\left( \\bigcup_{i=1}^n A_i \\right) &=& \\sum_{i=1}^n{\\cal P}(A_i)\\ - \\sum_{1\\leq i<j\\leq n} {\\cal P}(A_i \\cap A_j)\\  + \\\\\n&+& \\sum _{1\\leq i<j<k\\leq n}{\\cal P}(A_i \\cap A_j \\cap A_k) - \\cdots + (-1)^{n-1} {\\cal P}( A_1 \\cap \\cdots \\cap A_n )\n\\end{eqnarray}$$\n\nAnd in a more compact way:\n\n$${\\cal P} \\left(\\bigcup_{i=1}^n A_i \\right) = \\sum_{\\emptyset \\neq J\\subseteq \\{1,2,\\ldots ,n\\}} (-1)^{|J|-1}\\ {\\cal P}{\\Biggl (}\\bigcap_{j\\in J}A_{j}{\\Biggr )}$$\n\n## Proof\n\nFor the proof it is convenient to use the mathematical formulation in terms of set theory:\n\n$$\\left|\\bigcup_{i=1}^n A_i \\right| = \\sum_{\\emptyset \\neq J\\subseteq \\{1,2,\\ldots ,n\\}} (-1)^{|J|-1}{\\Biggl |}\\bigcap_{j\\in J}A_{j}{\\Biggr |}$$\n\nWe want to prove that any element contained in at least one of the sets $A_i$ will occur in the formula only once (note that elements which are not present in any of the sets $A_i$ will never be considered on the right part of the formula).\n\nConsider an element $x$ occurring in $k \\geq 1$ sets $A_i$. We will show it is counted only once in the formula. Note that:\n\n* in terms which $|J| = 1$, the item $x$ will be counted **$+\\ k$** times;\n* in terms which $|J| = 2$, the item $x$ will be counted **$-\\ \\binom{k}{2}$** times - because it will be counted in those terms that include two of the $k$ sets containing $x$;\n* in terms which $|J| = 3$, the item $x$ will be counted **$+\\ \\binom{k}{3}$** times;\n* $\\cdots$\n* in terms which $|J| = k$, the item $x$ will be counted **$(-1)^{k-1}\\cdot \\binom{k}{k}$** times;\n* in terms which $|J| \\gt k$, the item $x$ will be counted **zero** times;\n\nThis leads us to the following sum of [binomial coefficients](binomial-coefficients.md):\n\n$$ T = \\binom{k}{1} - \\binom{k}{2} + \\binom{k}{3} - \\cdots + (-1)^{i-1}\\cdot \\binom{k}{i} + \\cdots + (-1)^{k-1}\\cdot \\binom{k}{k}$$\n\nThis expression is very similar to the binomial expansion of $(1 - x)^k$:\n\n$$ (1 - x)^k = \\binom{k}{0} - \\binom{k}{1} \\cdot x + \\binom{k}{2} \\cdot x^2 - \\binom{k}{3} \\cdot x^3 + \\cdots + (-1)^k\\cdot \\binom{k}{k} \\cdot x^k $$\n\nWhen $x = 1$, $(1 - x)^k$ looks a lot like $T$. However, the expression has an additional $\\binom{k}{0} = 1$, and it is multiplied by $-1$. That leads us to $(1 - 1)^k = 1 - T$. Therefore $T = 1 - (1 - 1)^k = 1$, what was required to prove. The element is counted only once.\n\n## Generalization for calculating number of elements in exactly $r$ sets {data-toc-label=\"Generalization for calculating number of elements in exactly r sets\"}\n\nInclusion-exclusion principle can be rewritten to calculate number of elements which are present in zero sets:\n\n$$\\left|\\bigcap_{i=1}^n \\overline{A_i}\\right|=\\sum_{m=0}^n (-1)^m \\sum_{|X|=m} \\left|\\bigcap_{i\\in X} A_{i}\\right|$$\n\nConsider its generalization to calculate number of elements which are present in exactly $r$ sets:\n\n$$\\left|\\bigcup_{|B|=r}\\left[\\bigcap_{i \\in B} A_i \\cap \\bigcap_{j \\not\\in B} \\overline{A_j}\\right]\\right|=\\sum_{m=r}^n (-1)^{m-r}\\dbinom{m}{r} \\sum_{|X|=m} \\left|\\bigcap_{i \\in X} A_{i}\\right|$$\n\nTo prove this formula, consider some particular $B$. Due to basic inclusion-exclusion principle we can say about it that:\n\n$$\\left|\\bigcap_{i \\in B} A_i \\cap \\bigcap_{j \\not \\in B} \\overline{A_j}\\right|=\\sum_{m=r}^{n} (-1)^{m-r} \\sum_{\\substack{|X|=m \\newline B \\subset X}}\\left|\\bigcap_{i\\in X} A_{i}\\right|$$\n\nThe sets on the left side do not intersect for different $B$, thus we can sum them up directly. Also one should note that any set $X$ will always have coefficient $(-1)^{m-r}$ if it occurs and it will occur for exactly $\\dbinom{m}{r}$ sets $B$. \n\n## Usage when solving problems\n\nThe inclusion-exclusion principle is hard to understand without studying its applications.\n\nFirst, we will look at three simplest tasks \"at paper\", illustrating applications of the principle, and then consider more practical problems which are difficult to solve without inclusion-exclusion principle.\n\nTasks asking to \"find the **number** of ways\" are worth of note, as they sometimes lead to polynomial solutions, not necessarily exponential.\n\n### A simple task on permutations\n\nTask: count how many permutations of numbers from $0$ to $9$ exist such that the first element is greater than $1$ and the last one is less than $8$.\n\nLet's count the number of \"bad\" permutations, that is, permutations in which the first element is $\\leq 1$ and/or the last is $\\geq 8$.\n\nWe will denote by $X$ the set of permutations in which the first element is $\\leq 1$ and $Y$ the set of permutations in which the last element is $\\geq 8$. Then the number of \"bad\" permutations, as on the inclusion-exclusion formula, will be:\n\n$$ |X \\cup Y| = |X| + |Y| - |X \\cap Y| $$\n\nAfter a simple combinatorial calculation, we will get to:\n\n$$ 2 \\cdot 9! + 2 \\cdot 9! - 2 \\cdot 2 \\cdot 8! $$\n\nThe only thing left is to subtract this number from the total of $10!$ to get the number of \"good\" permutations.\n\n### A simple task on (0, 1, 2) sequences\n\nTask: count how many sequences of length $n$ exist consisting only of numbers $0,1,2$ such that each number occurs **at least once**.\n\nAgain let us turn to the inverse problem, i.e. we calculate the number of sequences which do **not** contain **at least one** of the numbers.\n\nLet's denote by $A_i (i = 0,1,2)$ the set of sequences in which the digit $i$ does **not** occur.\nThe formula of inclusion-exclusion on the number of \"bad\" sequences will be:\n\n$$ |A_0 \\cup A_1 \\cup A_2| = |A_0| + |A_1| + |A_2| - |A_0 \\cap A_1| - |A_0 \\cap A_2| - |A_1 \\cap A_2| + |A_0 \\cap A_1 \\cap A_2| $$\n\n* The size of each $A_i$ is $2^n$, as each sequence can only contain two of the digits.\n* The size of each pairwise intersection $A_i \\cap A_j$  is equal to $1$, as there will be only one digit to build the sequence.\n* The size of the intersection of all three sets is equal to $0$, as there will be no digits to build the sequence.\n\nAs we solved the inverse problem, we subtract it from the total of $3^n$ sequences:\n\n$$3^n - (3 \\cdot 2^n - 3 \\cdot 1 + 0)$$\n\n<div id=\"the-number-of-integer-solutions-to-the-equation\"></div>\n### Number of upper-bound integer sums {: #number-of-upper-bound-integer-sums }\n\nConsider the following equation:\n\n$$x_1 + x_2 + x_3 + x_4 + x_5 + x_6 = 20$$\n\nwhere $0 \\le x_i \\le 8 ~ (i = 1,2,\\ldots 6)$.\n\nTask: count the number of solutions to the equation.\n\nForget the restriction on $x_i$ for a moment and just count the number of nonnegative solutions to this equation. This is easily done using [Stars and Bars](stars_and_bars.md):\nwe want to break a sequence of $20$ units into $6$ groups, which is the same as arranging $5$ _bars_ and $20$ _stars_:\n\n$$N_0 = \\binom{25}{5}$$\n\nWe will now calculate the number of \"bad\" solutions with the inclusion-exclusion principle. The \"bad\" solutions will be those in which one or more $x_i$ are greater than $9$.\n\nDenote by $A_k ~ (k = 1,2\\ldots 6)$ the set of solutions where $x_k \\ge 9$, and all other $x_i \\ge 0 ~ (i \\ne k)$ (they may be $\\ge 9$ or not). To calculate the size of $A_k$, note that we have essentially the same combinatorial problem that was solved in the two paragraphs above, but now $9$ of the units are excluded from the slots and definitely belong to the first group. Thus:\n\n$$ | A_k | = \\binom{16}{5} $$\n\nSimilarly, the size of the intersection between two sets $A_k$ and $A_p$ (for $k \\ne p$) is equal to:\n\n$$ \\left| A_k \\cap A_p \\right| = \\binom{7}{5}$$\n\nThe size of each intersection of three sets is zero, since $20$ units will not be enough for three or more variables greater than or equal to $9$.\n\nCombining all this into the formula of inclusions-exceptions and given that we solved the inverse problem, we finally get the answer:\n\n$$\\binom{25}{5} - \\left(\\binom{6}{1} \\cdot \\binom{16}{5} - \\binom{6}{2} \\cdot \\binom{7}{5}\\right) $$\n\n### The number of relative primes in a given interval\n\nTask: given two numbers $n$ and $r$, count the number of integers in the interval $[1;r]$ that are relatively prime to n (their greatest common divisor is $1$).\n\nLet's solve the inverse problem - compute the number of not mutually primes with $n$.\n\nWe will denote the prime factors of $n$ as $p_i (i = 1\\cdots k)$.\n\nHow many numbers in the interval $[1;r]$ are divisible by $p_i$? The answer to this question is:\n\n$$ \\left\\lfloor \\frac{ r }{ p_i } \\right\\rfloor $$\n\nHowever, if we simply sum these numbers, some numbers will be summarized several times (those that share multiple $p_i$ as their factors). Therefore, it is necessary to use the inclusion-exclusion principle.\n\nWe will iterate over all $2^k$ subsets of $p_i$s, calculate their product and add or subtract the number of multiples of their product.\n\nHere is a C++ implementation:\n\n```cpp\nint solve (int n, int r) {\n\tvector<int> p;\n\tfor (int i=2; i*i<=n; ++i)\n\t\tif (n % i == 0) {\n\t\t\tp.push_back (i);\n\t\t\twhile (n % i == 0)\n\t\t\t\tn /= i;\n\t\t}\n\tif (n > 1)\n\t\tp.push_back (n);\n\n\tint sum = 0;\n\tfor (int msk=1; msk<(1<<p.size()); ++msk) {\n\t\tint mult = 1,\n\t\t\tbits = 0;\n\t\tfor (int i=0; i<(int)p.size(); ++i)\n\t\t\tif (msk & (1<<i)) {\n\t\t\t\t++bits;\n\t\t\t\tmult *= p[i];\n\t\t\t}\n\n\t\tint cur = r / mult;\n\t\tif (bits % 2 == 1)\n\t\t\tsum += cur;\n\t\telse\n\t\t\tsum -= cur;\n\t}\n\n\treturn r - sum;\n}\n```\n\nAsymptotics of the solution is $O (\\sqrt{n})$.\n\n### The number of integers in a given interval which are multiple of at least one of the given numbers\n\nGiven $n$ numbers $a_i$ and number $r$. You want to count the number of integers in the interval $[1; r]$ that are multiple of at least one of the $a_i$.\n\nThe solution algorithm is almost identical to the one for previous task \u2014 construct the formula of inclusion-exclusion on the numbers $a_i$, i.e. each term in this formula is the number of numbers divisible by a given subset of numbers $a_i$ (in other words, divisible by their [least common multiple](../algebra/euclid-algorithm.md)).\n\nSo we will now iterate over all $2^n$ subsets of integers $a_i$ with $O(n \\log r)$ operations to find their least common multiple, adding or subtracting the number of multiples of it in the interval. Asymptotics is $O (2^n\\cdot n\\cdot \\log r)$.\n\n### The number of strings that satisfy a given pattern\n\nConsider $n$ patterns of strings of the same length, consisting only of letters ($a...z$) or question marks. You're also given a number $k$. A string matches a pattern if it has the same length as the pattern, and at each position, either the corresponding characters are equal or the character in the pattern is a question mark. The task is to count the number of strings that match exactly $k$ of the patterns (first problem) and at least $k$ of the patterns (second problem).\n\nNotice first that we can easily count the number of strings that satisfy at once all of the specified patterns. To do this, simply \"cross\" patterns: iterate though the positions (\"slots\") and look at a position over all patterns. If all patterns have a question mark in this position, the character can be any letter from $a$ to $z$. Otherwise, the character of this position is uniquely defined by the patterns that do not contain a question mark.\n\nLearn now to solve the first version of the problem: when the string must satisfy exactly $k$ of the patterns.\n\nTo solve it, iterate and fix a specific subset $X$ from the set of patterns consisting of $k$ patterns. Then we have to count the number of strings that satisfy this set of patterns, and only matches it, that is, they don't match any other pattern. We will use the inclusion-exclusion principle in a slightly different manner: we sum on all supersets $Y$ (subsets from the original set of strings that contain $X$), and either add to the current answer or subtract it from the number of strings:\n\n$$ ans(X) = \\sum_{Y \\supseteq X} (-1)^{|Y|-k} \\cdot f(Y) $$\n\nWhere $f(Y)$ is the number of strings that match $Y$ (at least $Y$).\n\n(If you have a hard time figuring out this, you can try drawing Venn Diagrams.)\n\nIf we sum up on all $ans(X)$, we will get the final answer:\n\n$$ ans = \\sum_{X ~ : ~ |X| = k} ans(X) $$\n\nHowever, asymptotics of this solution is $O(3^k \\cdot k)$. To improve it, notice that different $ans(X)$ computations very often share $Y$ sets.\n\nWe will reverse the formula of inclusion-exclusion and sum in terms of $Y$ sets. Now it becomes clear that the same set $Y$ would be taken into account in the computation of $ans(X)$ of $\\binom{|Y|}{k}$ sets with the same sign $(-1)^{|Y| - k}$.\n\n$$ ans = \\sum_{Y ~ : ~ |Y| \\ge k} (-1)^{|Y|-k} \\cdot \\binom{|Y|}{k} \\cdot f(Y) $$\n\nNow our solution has asymptotics $O(2^k \\cdot k)$.\n\nWe will now solve the second version of the problem: find the number of strings that match **at least** $k$ of the patterns.\n\nOf course, we can just use the solution to the first version of the problem and add the answers for sets with size greater than $k$. However, you may notice that in this problem, a set |Y| is considered in the formula for all sets with size $\\ge k$ which are contained in $Y$. That said, we can write the part of the expression that is being multiplied by $f(Y)$ as:\n\n\n$$ (-1)^{|Y|-k} \\cdot \\binom{|Y|}{k} + (-1)^{|Y|-k-1} \\cdot \\binom{|Y|}{k+1} + (-1)^{|Y|-k-2} \\cdot \\binom{|Y|}{k+2} + \\cdots + (-1)^{|Y|-|Y|} \\cdot \\binom{|Y|}{|Y|} $$\n\nLooking at Graham's (Graham, Knuth, Patashnik. \"Concrete mathematics\" [1998] ), we see a well-known formula for [binomial coefficients](binomial-coefficients.md):\n\n$$ \\sum_{k=0}^m (-1)^k \\cdot \\binom{n}{k} = (-1)^m \\cdot \\binom{n-1}{m} $$\n\nApplying it here, we find that the entire sum of binomial coefficients is minimized:\n\n$$ (-1)^{|Y|-k} \\cdot \\binom{|Y|-1}{|Y|-k} $$\n\nThus, for this task, we also obtained a solution with the asymptotics $O(2^k \\cdot k)$:\n\n$$ ans = \\sum_{Y ~ : ~ |Y| \\ge k} (-1)^{|Y|-k} \\cdot \\binom{|Y|-1}{|Y|-k} \\cdot f(Y) $$\n\n### The number of ways of going from a cell to another\n\nThere is a field $n \\times m$, and $k$ of its cells are impassable walls. A robot is initially at the cell $(1,1)$ (bottom left). The robot can only move right or up, and eventually it needs to get into the cell $(n,m)$, avoiding all obstacles. You need to count the number of ways he can do it.\n\nAssume that the sizes $n$ and $m$ are very large (say, $10^9$), and the number $k$ is small (around $100$).\n\nFor now, sort the obstacles by their coordinate $x$, and in case of equality \u2014 coordinate $y$.\n\nAlso just learn how to solve a problem without obstacles: i.e. learn how to count the number of ways to get from one cell to another. In one axis, we need to go through $x$ cells, and on the other, $y$ cells. From simple combinatorics, we get a formula using [binomial coefficients](binomial-coefficients.md):\n\n$$\\binom{x+y}{x}$$\n\nNow to count the number of ways to get from one cell to another, avoiding all obstacles, you can use inclusion-exclusion to solve the inverse problem: count the number of ways to walk through the board stepping at a subset of obstacles (and subtract it from the total number of ways).\n\nWhen iterating over a subset of the obstacles that we'll step, to count the number of ways to do this simply multiply the number of all paths from starting cell to the first of the selected obstacles, a first obstacle to the second, and so on, and then add or subtract this number from the answer, in accordance with the standard formula of inclusion-exclusion.\n\nHowever, this will again be non-polynomial in complexity $O(2^k \\cdot k)$.\n\nHere goes a polynomial solution:\n\nWe will use dynamic programming. For convenience, push (1,1) to the beginning and (n,m) at the end of the obstacles array. Let's compute the numbers $d[i]$ \u2014 the number of ways to get from the starting point ($0-th$) to $i-th$, without stepping on any other obstacle (except for $i$, of course). We will compute this number for all the obstacle cells, and also for the ending one.\n\nLet's forget for a second the obstacles and just count the number of paths from cell $0$ to $i$. We need to consider some \"bad\" paths, the ones that pass through the obstacles, and subtract them from the total number of ways of going from $0$ to $i$.\n\nWhen considering an obstacle $t$ between $0$ and $i$ ($0 < t < i$), on which we can step, we see that the number of paths from $0$ to $i$ that pass through $t$ which have $t$ as the **first obstacle between start and $i$**. We can compute that as: $d[t]$ multiplied by the number of arbitrary paths from $t$ to $i$. We can count the number of \"bad\" ways summing this for all $t$ between $0$ and $i$.\n\nWe can compute $d[i]$ in $O(k)$ for $O(k)$ obstacles, so this solution has complexity $O(k^2)$.\n\n### The number of coprime quadruples\n\nYou're given $n$ numbers: $a_1, a_2, \\ldots, a_n$. You are required to count the number of ways to choose four numbers so that their combined greatest common divisor is equal to one.\n\nWe will solve the inverse problem \u2014 compute the number of \"bad\" quadruples, i.e. quadruples in which all numbers are divisible by a number $d > 1$.\n\nWe will use the inclusion-exclusion principle while summing over all possible groups of four numbers divisible by a divisor $d$.\n\n$$ans = \\sum_{d \\ge 2} (-1)^{deg(d)-1} \\cdot f(d)$$\n\nwhere $deg(d)$ is the number of primes in the factorization of the number $d$ and $f(d)$ the number of quadruples divisible by $d$.\n\nTo calculate the function $f(d)$, you just have to count the number of multiples of $d$ (as mentioned on a previous task) and use [binomial coefficients](binomial-coefficients.md) to count the number of ways to choose four of them.\n\nThus, using the formula of inclusions-exclusions we sum the number of groups of four divisible by a prime number, then subtract the number of quadruples which are divisible by the product of two primes, add quadruples divisible by three primes, etc.\n\n\n### The number of harmonic triplets\n\nYou are given a number $n \\le 10^6$. You are required to count the number of triples $2 \\le a < b < c \\le n$ that satisfy one of the following conditions:\n\n* or ${\\rm gcd}(a,b) = {\\rm gcd}(a,c) = {\\rm gcd}(b,c) = 1$,\n* or ${\\rm gcd}(a,b) > 1, {\\rm gcd}(a,c) > 1, {\\rm gcd}(b,c) > 1$.\n\nFirst, go straight to the inverse problem \u2014 i.e. count the number of non-harmonic triples.\n\nSecond, note that any non-harmonic triplet is made of a pair of coprimes and a third number that is not coprime with at least one from the pair.\n\nThus, the number of non-harmonic triples that contain $i$ is equal the number of integers from $2$ to $n$ that are coprimes with $i$ multiplied by the number of integers that are not coprime with $i$.\n\nEither $gcd(a,b) = 1 \\wedge gcd(a,c) > 1 \\wedge gcd(b,c) > 1$\n\nor $gcd(a,b) = 1 \\wedge gcd(a,c) = 1 \\wedge gcd(b,c) > 1$\n\nIn both of these cases, it will be counted twice. The first case will be counted when $i = a$ and when $i = b$. The second case will be counted when $i = b$ and when $i = c$. Therefore, to compute the number of non-harmonic triples, we sum this calculation through all $i$ from $2$ to $n$ and divide it by $2$.\n\nNow all we have left to solve is to learn to count the number of coprimes to $i$ in the interval $[2;n]$. Although this problem has already been mentioned, the above solution is not suitable here \u2014 it would require the factorization of each of the integers from $2$ to $n$, and then iterating through all subsets of these primes.\n\nA faster solution is possible with such modification of the sieve of Eratosthenes:\n\n1. First, we find all numbers in the interval $[2;n]$ such that its simple factorization does not include a prime factor twice. We will also need to know, for these numbers, how many factors it includes.\n    * To do this we will maintain an array $deg[i]$ to store the number of primes in the factorization of $i$, and an array $good[i]$, to mark either if $i$ contains each factor at most once ($good[i] = 1$) or not ($good[i] = 0$). When iterating from $2$ to $n$, if we reach a number that has $deg$ equal to $0$, then it is a prime and its $deg$ is $1$.\n    * During the sieve of Eratosthenes, we will iterate $i$ from $2$ to $n$. When processing a prime number we go through all of its multiples and increase their $deg[]$. If one of these multiples is multiple of the square of $i$, then we can put $good$ as false.\n\n2. Second, we need to calculate the answer for all $i$ from $2$ to $n$, i.e., the array $cnt[]$ \u2014 the number of integers not coprime with $i$.\n    * To do this, remember how the formula of inclusion-exclusion works \u2014 actually here we implement the same concept, but with inverted logic: we iterate over a component (a product of primes from the factorization) and add or subtract its term on the formula of inclusion-exclusion of each of its multiples.\n    * So, let's say we are processing a number $i$ such that $good[i] = true$, i.e., it is involved in the formula of inclusion-exclusion. Iterate through all numbers that are multiples of $i$, and either add or subtract $\\lfloor N/i \\rfloor$ from their $cnt[]$ (the signal depends on $deg[i]$: if $deg[i]$ is odd, then we must add, otherwise subtract).\n\nHere's a C++ implementation:\n\n```cpp\nint n;\nbool good[MAXN];\nint deg[MAXN], cnt[MAXN];\n\nlong long solve() {\n\tmemset (good, 1, sizeof good);\n\tmemset (deg, 0, sizeof deg);\n\tmemset (cnt, 0, sizeof cnt);\n\n\tlong long ans_bad = 0;\n\tfor (int i=2; i<=n; ++i) {\n\t\tif (good[i]) {\n\t\t\tif (deg[i] == 0)  deg[i] = 1;\n\t\t\tfor (int j=1; i*j<=n; ++j) {\n\t\t\t\tif (j > 1 && deg[i] == 1)\n\t\t\t\t\tif (j % i == 0)\n\t\t\t\t\t\tgood[i*j] = false;\n\t\t\t\t\telse\n\t\t\t\t\t\t++deg[i*j];\n\t\t\t\tcnt[i*j] += (n / i) * (deg[i]%2==1 ? +1 : -1);\n\t\t\t}\n\t\t}\n\t\tans_bad += (cnt[i] - 1) * 1ll * (n-1 - cnt[i]);\n\t}\n\n\treturn (n-1) * 1ll * (n-2) * (n-3) / 6 - ans_bad / 2;\n}\n```\n\nThe asymptotics of our solution is $O(n \\log n)$, as for almost every number up to $n$ we make $n/i$ iterations on the nested loop.\n\n### The number of permutations without fixed points (derangements)\n\nProve that the number of permutations of length $n$ without fixed points (i.e. no number $i$ is in position $i$ - also called a derangement) is equal to the following number:\n\n$$n! - \\binom{n}{1} \\cdot (n-1)! + \\binom{n}{2} \\cdot (n-2)! - \\binom{n}{3} \\cdot (n-3)! + \\cdots \\pm \\binom{n}{n} \\cdot (n-n)! $$\n\nand approximately equal to:\n\n$$ \\frac{ n! }{ e } $$\n\n(if you round this expression to the nearest whole number \u2014 you get exactly the number of permutations without fixed points)\n\nDenote by $A_k$ the set of permutations of length $n$ with a fixed point at position $k$ ($1 \\le k \\le n$) (i.e. element $k$ is at position $k$).\n\nWe now use the formula of inclusion-exclusion to count the number of permutations with at least one fixed point. For this we need to learn to count sizes of an intersection of sets $A_i$, as follows:\n\n$$\\begin{eqnarray}\n\\left| A_p \\right| &=& (n-1)!\\ , \\\\\n\\left| A_p \\cap A_q \\right| &=& (n-2)!\\ , \\\\\n\\left| A_p \\cap A_q \\cap A_r \\right| &=& (n-3)!\\ , \\\\\n\\cdots ,\n\\end{eqnarray}$$\n\nbecause if we know that the number of fixed points is equal $x$, then we know the position of $x$ elements of the permutation, and all other $(n-x)$ elements can be placed anywhere.\n\nSubstituting this into the formula of inclusion-exclusion, and given that the number of ways to choose a subset of size $x$ from the set of $n$ elements is equal to $\\binom{n}{x}$, we obtain a formula for the number of permutations with at least one fixed point:\n\n$$\\binom{n}{1} \\cdot (n-1)! - \\binom{n}{2} \\cdot (n-2)! + \\binom{n}{3} \\cdot (n-3)! - \\cdots \\pm \\binom{n}{n} \\cdot (n-n)! $$\n\nThen the number of permutations without fixed points is equal to:\n\n$$n! - \\binom{n}{1} \\cdot (n-1)! + \\binom{n}{2} \\cdot (n-2)! - \\binom{n}{3} \\cdot (n-3)! + \\cdots \\pm \\binom{n}{n} \\cdot (n-n)! $$\n\nSimplifying this expression, we obtain **exact and approximate expressions for the number of permutations without fixed points**:\n\n$$ n! \\left( 1 - \\frac{1}{1!} + \\frac{1}{2!} - \\frac{1}{3!} + \\cdots \\pm \\frac{1}{n!} \\right ) \\approx \\frac{n!}{e} $$\n\n(because the sum in brackets are the first $n+1$ terms of the expansion in Taylor series $e^{-1}$)\n\nIt is worth noting that a similar problem can be solved this way: when you need the fixed points were not among the $m$ first elements of permutations (and not among all, as we just solved). The formula obtained is as the given above accurate formula, but it will go up to the sum of $k$, instead of $n$.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: inclusion_exclusion_principle\n---\n\n# The Inclusion-Exclusion Principle\n\nThe inclusion-exclusion principle is an important combinatorial way to compute the size of a set or the probability of complex events. It relates the sizes of individual sets with their union.\n\n## Statement\n\n### The verbal formula\n\nThe inclusion-exclusion principle can be expressed as follows:\n\nTo compute the size of a union of multiple sets, it is necessary to sum the sizes of these sets **separately**, and then subtract the sizes of all **pairwise** intersections of the sets, then add back the size of the intersections of **triples** of the sets, subtract the size of **quadruples** of the sets, and so on, up to the intersection of **all** sets.\n\n### The formulation in terms of sets\n\nThe above definition can be expressed mathematically as follows:\n\n$$\\left| \\bigcup_{i=1}^n A_i \\right| = \\sum_{i=1}^n|A_i| - \\sum_{1\\leq i<j\\leq n} |A_i \\cap A_j| + \\sum _{1\\leq i<j<k\\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} | A_1 \\cap \\cdots \\cap A_n |$$\n\nAnd in a more compact way:\n\n$$\\left|\\bigcup_{i=1}^n A_i \\right| = \\sum_{\\emptyset \\neq J\\subseteq \\{1,2,\\ldots ,n\\}} (-1)^{|J|-1}{\\Biggl |}\\bigcap_{j\\in J}A_{j}{\\Biggr |}$$\n\n### The formulation using Venn diagrams\n\nLet the diagram show three sets $A$, $B$ and $C$:\n\n![Venn diagram](venn-inclusion-exclusion.png \"Venn diagram\")\n\nThen the area of their union $A \\cup B \\cup C$ is equal to the sum of the areas $A$, $B$ and $C$ less double-covered areas $A \\cap B$, $A \\cap C$, $B \\cap C$, but with the addition of the area covered by three sets $A \\cap B \\cap C$:\n\n$$S(A \\cup B \\cup C) = S(A) + S(B) + S(C) - S(A \\cap B) - S(A \\cap C) - S(B \\cap C) + S(A \\cap B \\cap C)$$\n\nIt can also be generalized for an association of $n$ sets.\n\n### The formulation in terms of probability theory\n\nIf $A_i$ $(i = 1,2...n)$ are events and ${\\cal P}(A_i)$ the probability of an event from $A_i$ to occur, then the probability of their union (i.e. the probability that at least one of the events occur) is equal to:\n\n$$\\begin{eqnarray}\n{\\cal P} \\left( \\bigcup_{i=1}^n A_i \\right) &=& \\sum_{i=1}^n{\\cal P}(A_i)\\ - \\sum_{1\\leq i<j\\leq n} {\\cal P}(A_i \\cap A_j)\\  + \\\\\n&+& \\sum _{1\\leq i<j<k\\leq n}{\\cal P}(A_i \\cap A_j \\cap A_k) - \\cdots + (-1)^{n-1} {\\cal P}( A_1 \\cap \\cdots \\cap A_n )\n\\end{eqnarray}$$\n\nAnd in a more compact way:\n\n$${\\cal P} \\left(\\bigcup_{i=1}^n A_i \\right) = \\sum_{\\emptyset \\neq J\\subseteq \\{1,2,\\ldots ,n\\}} (-1)^{|J|-1}\\ {\\cal P}{\\Biggl (}\\bigcap_{j\\in J}A_{j}{\\Biggr )}$$\n\n## Proof\n\nFor the proof it is convenient to use the mathematical formulation in terms of set theory:\n\n$$\\left|\\bigcup_{i=1}^n A_i \\right| = \\sum_{\\emptyset \\neq J\\subseteq \\{1,2,\\ldots ,n\\}} (-1)^{|J|-1}{\\Biggl |}\\bigcap_{j\\in J}A_{j}{\\Biggr |}$$\n\nWe want to prove that any element contained in at least one of the sets $A_i$ will occur in the formula only once (note that elements which are not present in any of the sets $A_i$ will never be considered on the right part of the formula).\n\nConsider an element $x$ occurring in $k \\geq 1$ sets $A_i$. We will show it is counted only once in the formula. Note that:\n\n* in terms which $|J| = 1$, the item $x$ will be counted **$+\\ k$** times;\n* in terms which $|J| = 2$, the item $x$ will be counted **$-\\ \\binom{k}{2}$** times - because it will be counted in those terms that include two of the $k$ sets containing $x$;\n* in terms which $|J| = 3$, the item $x$ will be counted **$+\\ \\binom{k}{3}$** times;\n* $\\cdots$\n* in terms which $|J| = k$, the item $x$ will be counted **$(-1)^{k-1}\\cdot \\binom{k}{k}$** times;\n* in terms which $|J| \\gt k$, the item $x$ will be counted **zero** times;\n\nThis leads us to the following sum of [binomial coefficients](binomial-coefficients.md):\n\n$$ T = \\binom{k}{1} - \\binom{k}{2} + \\binom{k}{3} - \\cdots + (-1)^{i-1}\\cdot \\binom{k}{i} + \\cdots + (-1)^{k-1}\\cdot \\binom{k}{k}$$\n\nThis expression is very similar to the binomial expansion of $(1 - x)^k$:\n\n$$ (1 - x)^k = \\binom{k}{0} - \\binom{k}{1} \\cdot x + \\binom{k}{2} \\cdot x^2 - \\binom{k}{3} \\cdot x^3 + \\cdots + (-1)^k\\cdot \\binom{k}{k} \\cdot x^k $$\n\nWhen $x = 1$, $(1 - x)^k$ looks a lot like $T$. However, the expression has an additional $\\binom{k}{0} = 1$, and it is multiplied by $-1$. That leads us to $(1 - 1)^k = 1 - T$. Therefore $T = 1 - (1 - 1)^k = 1$, what was required to prove. The element is counted only once.\n\n## Generalization for calculating number of elements in exactly $r$ sets {data-toc-label=\"Generalization for calculating number of elements in exactly r sets\"}\n\nInclusion-exclusion principle can be rewritten to calculate number of elements which are present in zero sets:\n\n$$\\left|\\bigcap_{i=1}^n \\overline{A_i}\\right|=\\sum_{m=0}^n (-1)^m \\sum_{|X|=m} \\left|\\bigcap_{i\\in X} A_{i}\\right|$$\n\nConsider its generalization to calculate number of elements which are present in exactly $r$ sets:\n\n$$\\left|\\bigcup_{|B|=r}\\left[\\bigcap_{i \\in B} A_i \\cap \\bigcap_{j \\not\\in B} \\overline{A_j}\\right]\\right|=\\sum_{m=r}^n (-1)^{m-r}\\dbinom{m}{r} \\sum_{|X|=m} \\left|\\bigcap_{i \\in X} A_{i}\\right|$$\n\nTo prove this formula, consider some particular $B$. Due to basic inclusion-exclusion principle we can say about it that:\n\n$$\\left|\\bigcap_{i \\in B} A_i \\cap \\bigcap_{j \\not \\in B} \\overline{A_j}\\right|=\\sum_{m=r}^{n} (-1)^{m-r} \\sum_{\\substack{|X|=m \\newline B \\subset X}}\\left|\\bigcap_{i\\in X} A_{i}\\right|$$\n\nThe sets on the left side do not intersect for different $B$, thus we can sum them up directly. Also one should note that any set $X$ will always have coefficient $(-1)^{m-r}$ if it occurs and it will occur for exactly $\\dbinom{m}{r}$ sets $B$. \n\n## Usage when solving problems\n\nThe inclusion-exclusion principle is hard to understand without studying its applications.\n\nFirst, we will look at three simplest tasks \"at paper\", illustrating applications of the principle, and then consider more practical problems which are difficult to solve without inclusion-exclusion principle.\n\nTasks asking to \"find the **number** of ways\" are worth of note, as they sometimes lead to polynomial solutions, not necessarily exponential.\n\n### A simple task on permutations\n\nTask: count how many permutations of numbers from $0$ to $9$ exist such that the first element is greater than $1$ and the last one is less than $8$.\n\nLet's count the number of \"bad\" permutations, that is, permutations in which the first element is $\\leq 1$ and/or the last is $\\geq 8$.\n\nWe will denote by $X$ the set of permutations in which the first element is $\\leq 1$ and $Y$ the set of permutations in which the last element is $\\geq 8$. Then the number of \"bad\" permutations, as on the inclusion-exclusion formula, will be:\n\n$$ |X \\cup Y| = |X| + |Y| - |X \\cap Y| $$\n\nAfter a simple combinatorial calculation, we will get to:\n\n$$ 2 \\cdot 9! + 2 \\cdot 9! - 2 \\cdot 2 \\cdot 8! $$\n\nThe only thing left is to subtract this number from the total of $10!$ to get the number of \"good\" permutations.\n\n### A simple task on (0, 1, 2) sequences\n\nTask: count how many sequences of length $n$ exist consisting only of numbers $0,1,2$ such that each number occurs **at least once**.\n\nAgain let us turn to the inverse problem, i.e. we calculate the number of sequences which do **not** contain **at least one** of the numbers.\n\nLet's denote by $A_i (i = 0,1,2)$ the set of sequences in which the digit $i$ does **not** occur.\nThe formula of inclusion-exclusion on the number of \"bad\" sequences will be:\n\n$$ |A_0 \\cup A_1 \\cup A_2| = |A_0| + |A_1| + |A_2| - |A_0 \\cap A_1| - |A_0 \\cap A_2| - |A_1 \\cap A_2| + |A_0 \\cap A_1 \\cap A_2| $$\n\n* The size of each $A_i$ is $2^n$, as each sequence can only contain two of the digits.\n* The size of each pairwise intersection $A_i \\cap A_j$  is equal to $1$, as there will be only one digit to build the sequence.\n* The size of the intersection of all three sets is equal to $0$, as there will be no digits to build the sequence.\n\nAs we solved the inverse problem, we subtract it from the total of $3^n$ sequences:\n\n$$3^n - (3 \\cdot 2^n - 3 \\cdot 1 + 0)$$\n\n<div id=\"the-number-of-integer-solutions-to-the-equation\"></div>\n### Number of upper-bound integer sums {: #number-of-upper-bound-integer-sums }\n\nConsider the following equation:\n\n$$x_1 + x_2 + x_3 + x_4 + x_5 + x_6 = 20$$\n\nwhere $0 \\le x_i \\le 8 ~ (i = 1,2,\\ldots 6)$.\n\nTask: count the number of solutions to the equation.\n\nForget the restriction on $x_i$ for a moment and just count the number of nonnegative solutions to this equation. This is easily done using [Stars and Bars](stars_and_bars.md):\nwe want to break a sequence of $20$ units into $6$ groups, which is the same as arranging $5$ _bars_ and $20$ _stars_:\n\n$$N_0 = \\binom{25}{5}$$\n\nWe will now calculate the number of \"bad\" solutions with the inclusion-exclusion principle. The \"bad\" solutions will be those in which one or more $x_i$ are greater than $9$.\n\nDenote by $A_k ~ (k = 1,2\\ldots 6)$ the set of solutions where $x_k \\ge 9$, and all other $x_i \\ge 0 ~ (i \\ne k)$ (they may be $\\ge 9$ or not). To calculate the size of $A_k$, note that we have essentially the same combinatorial problem that was solved in the two paragraphs above, but now $9$ of the units are excluded from the slots and definitely belong to the first group. Thus:\n\n$$ | A_k | = \\binom{16}{5} $$\n\nSimilarly, the size of the intersection between two sets $A_k$ and $A_p$ (for $k \\ne p$) is equal to:\n\n$$ \\left| A_k \\cap A_p \\right| = \\binom{7}{5}$$\n\nThe size of each intersection of three sets is zero, since $20$ units will not be enough for three or more variables greater than or equal to $9$.\n\nCombining all this into the formula of inclusions-exceptions and given that we solved the inverse problem, we finally get the answer:\n\n$$\\binom{25}{5} - \\left(\\binom{6}{1} \\cdot \\binom{16}{5} - \\binom{6}{2} \\cdot \\binom{7}{5}\\right) $$\n\n### The number of relative primes in a given interval\n\nTask: given two numbers $n$ and $r$, count the number of integers in the interval $[1;r]$ that are relatively prime to n (their greatest common divisor is $1$).\n\nLet's solve the inverse problem - compute the number of not mutually primes with $n$.\n\nWe will denote the prime factors of $n$ as $p_i (i = 1\\cdots k)$.\n\nHow many numbers in the interval $[1;r]$ are divisible by $p_i$? The answer to this question is:\n\n$$ \\left\\lfloor \\frac{ r }{ p_i } \\right\\rfloor $$\n\nHowever, if we simply sum these numbers, some numbers will be summarized several times (those that share multiple $p_i$ as their factors). Therefore, it is necessary to use the inclusion-exclusion principle.\n\nWe will iterate over all $2^k$ subsets of $p_i$s, calculate their product and add or subtract the number of multiples of their product.\n\nHere is a C++ implementation:\n\n```cpp\nint solve (int n, int r) {\n\tvector<int> p;\n\tfor (int i=2; i*i<=n; ++i)\n\t\tif (n % i == 0) {\n\t\t\tp.push_back (i);\n\t\t\twhile (n % i == 0)\n\t\t\t\tn /= i;\n\t\t}\n\tif (n > 1)\n\t\tp.push_back (n);\n\n\tint sum = 0;\n\tfor (int msk=1; msk<(1<<p.size()); ++msk) {\n\t\tint mult = 1,\n\t\t\tbits = 0;\n\t\tfor (int i=0; i<(int)p.size(); ++i)\n\t\t\tif (msk & (1<<i)) {\n\t\t\t\t++bits;\n\t\t\t\tmult *= p[i];\n\t\t\t}\n\n\t\tint cur = r / mult;\n\t\tif (bits % 2 == 1)\n\t\t\tsum += cur;\n\t\telse\n\t\t\tsum -= cur;\n\t}\n\n\treturn r - sum;\n}\n```\n\nAsymptotics of the solution is $O (\\sqrt{n})$.\n\n### The number of integers in a given interval which are multiple of at least one of the given numbers\n\nGiven $n$ numbers $a_i$ and number $r$. You want to count the number of integers in the interval $[1; r]$ that are multiple of at least one of the $a_i$.\n\nThe solution algorithm is almost identical to the one for previous task \u2014 construct the formula of inclusion-exclusion on the numbers $a_i$, i.e. each term in this formula is the number of numbers divisible by a given subset of numbers $a_i$ (in other words, divisible by their [least common multiple](../algebra/euclid-algorithm.md)).\n\nSo we will now iterate over all $2^n$ subsets of integers $a_i$ with $O(n \\log r)$ operations to find their least common multiple, adding or subtracting the number of multiples of it in the interval. Asymptotics is $O (2^n\\cdot n\\cdot \\log r)$.\n\n### The number of strings that satisfy a given pattern\n\nConsider $n$ patterns of strings of the same length, consisting only of letters ($a...z$) or question marks. You're also given a number $k$. A string matches a pattern if it has the same length as the pattern, and at each position, either the corresponding characters are equal or the character in the pattern is a question mark. The task is to count the number of strings that match exactly $k$ of the patterns (first problem) and at least $k$ of the patterns (second problem).\n\nNotice first that we can easily count the number of strings that satisfy at once all of the specified patterns. To do this, simply \"cross\" patterns: iterate though the positions (\"slots\") and look at a position over all patterns. If all patterns have a question mark in this position, the character can be any letter from $a$ to $z$. Otherwise, the character of this position is uniquely defined by the patterns that do not contain a question mark.\n\nLearn now to solve the first version of the problem: when the string must satisfy exactly $k$ of the patterns.\n\nTo solve it, iterate and fix a specific subset $X$ from the set of patterns consisting of $k$ patterns. Then we have to count the number of strings that satisfy this set of patterns, and only matches it, that is, they don't match any other pattern. We will use the inclusion-exclusion principle in a slightly different manner: we sum on all supersets $Y$ (subsets from the original set of strings that contain $X$), and either add to the current answer or subtract it from the number of strings:\n\n$$ ans(X) = \\sum_{Y \\supseteq X} (-1)^{|Y|-k} \\cdot f(Y) $$\n\nWhere $f(Y)$ is the number of strings that match $Y$ (at least $Y$).\n\n(If you have a hard time figuring out this, you can try drawing Venn Diagrams.)\n\nIf we sum up on all $ans(X)$, we will get the final answer:\n\n$$ ans = \\sum_{X ~ : ~ |X| = k} ans(X) $$\n\nHowever, asymptotics of this solution is $O(3^k \\cdot k)$. To improve it, notice that different $ans(X)$ computations very often share $Y$ sets.\n\nWe will reverse the formula of inclusion-exclusion and sum in terms of $Y$ sets. Now it becomes clear that the same set $Y$ would be taken into account in the computation of $ans(X)$ of $\\binom{|Y|}{k}$ sets with the same sign $(-1)^{|Y| - k}$.\n\n$$ ans = \\sum_{Y ~ : ~ |Y| \\ge k} (-1)^{|Y|-k} \\cdot \\binom{|Y|}{k} \\cdot f(Y) $$\n\nNow our solution has asymptotics $O(2^k \\cdot k)$.\n\nWe will now solve the second version of the problem: find the number of strings that match **at least** $k$ of the patterns.\n\nOf course, we can just use the solution to the first version of the problem and add the answers for sets with size greater than $k$. However, you may notice that in this problem, a set |Y| is considered in the formula for all sets with size $\\ge k$ which are contained in $Y$. That said, we can write the part of the expression that is being multiplied by $f(Y)$ as:\n\n\n$$ (-1)^{|Y|-k} \\cdot \\binom{|Y|}{k} + (-1)^{|Y|-k-1} \\cdot \\binom{|Y|}{k+1} + (-1)^{|Y|-k-2} \\cdot \\binom{|Y|}{k+2} + \\cdots + (-1)^{|Y|-|Y|} \\cdot \\binom{|Y|}{|Y|} $$\n\nLooking at Graham's (Graham, Knuth, Patashnik. \"Concrete mathematics\" [1998] ), we see a well-known formula for [binomial coefficients](binomial-coefficients.md):\n\n$$ \\sum_{k=0}^m (-1)^k \\cdot \\binom{n}{k} = (-1)^m \\cdot \\binom{n-1}{m} $$\n\nApplying it here, we find that the entire sum of binomial coefficients is minimized:\n\n$$ (-1)^{|Y|-k} \\cdot \\binom{|Y|-1}{|Y|-k} $$\n\nThus, for this task, we also obtained a solution with the asymptotics $O(2^k \\cdot k)$:\n\n$$ ans = \\sum_{Y ~ : ~ |Y| \\ge k} (-1)^{|Y|-k} \\cdot \\binom{|Y|-1}{|Y|-k} \\cdot f(Y) $$\n\n### The number of ways of going from a cell to another\n\nThere is a field $n \\times m$, and $k$ of its cells are impassable walls. A robot is initially at the cell $(1,1)$ (bottom left). The robot can only move right or up, and eventually it needs to get into the cell $(n,m)$, avoiding all obstacles. You need to count the number of ways he can do it.\n\nAssume that the sizes $n$ and $m$ are very large (say, $10^9$), and the number $k$ is small (around $100$).\n\nFor now, sort the obstacles by their coordinate $x$, and in case of equality \u2014 coordinate $y$.\n\nAlso just learn how to solve a problem without obstacles: i.e. learn how to count the number of ways to get from one cell to another. In one axis, we need to go through $x$ cells, and on the other, $y$ cells. From simple combinatorics, we get a formula using [binomial coefficients](binomial-coefficients.md):\n\n$$\\binom{x+y}{x}$$\n\nNow to count the number of ways to get from one cell to another, avoiding all obstacles, you can use inclusion-exclusion to solve the inverse problem: count the number of ways to walk through the board stepping at a subset of obstacles (and subtract it from the total number of ways).\n\nWhen iterating over a subset of the obstacles that we'll step, to count the number of ways to do this simply multiply the number of all paths from starting cell to the first of the selected obstacles, a first obstacle to the second, and so on, and then add or subtract this number from the answer, in accordance with the standard formula of inclusion-exclusion.\n\nHowever, this will again be non-polynomial in complexity $O(2^k \\cdot k)$.\n\nHere goes a polynomial solution:\n\nWe will use dynamic programming. For convenience, push (1,1) to the beginning and (n,m) at the end of the obstacles array. Let's compute the numbers $d[i]$ \u2014 the number of ways to get from the starting point ($0-th$) to $i-th$, without stepping on any other obstacle (except for $i$, of course). We will compute this number for all the obstacle cells, and also for the ending one.\n\nLet's forget for a second the obstacles and just count the number of paths from cell $0$ to $i$. We need to consider some \"bad\" paths, the ones that pass through the obstacles, and subtract them from the total number of ways of going from $0$ to $i$.\n\nWhen considering an obstacle $t$ between $0$ and $i$ ($0 < t < i$), on which we can step, we see that the number of paths from $0$ to $i$ that pass through $t$ which have $t$ as the **first obstacle between start and $i$**. We can compute that as: $d[t]$ multiplied by the number of arbitrary paths from $t$ to $i$. We can count the number of \"bad\" ways summing this for all $t$ between $0$ and $i$.\n\nWe can compute $d[i]$ in $O(k)$ for $O(k)$ obstacles, so this solution has complexity $O(k^2)$.\n\n### The number of coprime quadruples\n\nYou're given $n$ numbers: $a_1, a_2, \\ldots, a_n$. You are required to count the number of ways to choose four numbers so that their combined greatest common divisor is equal to one.\n\nWe will solve the inverse problem \u2014 compute the number of \"bad\" quadruples, i.e. quadruples in which all numbers are divisible by a number $d > 1$.\n\nWe will use the inclusion-exclusion principle while summing over all possible groups of four numbers divisible by a divisor $d$.\n\n$$ans = \\sum_{d \\ge 2} (-1)^{deg(d)-1} \\cdot f(d)$$\n\nwhere $deg(d)$ is the number of primes in the factorization of the number $d$ and $f(d)$ the number of quadruples divisible by $d$.\n\nTo calculate the function $f(d)$, you just have to count the number of multiples of $d$ (as mentioned on a previous task) and use [binomial coefficients](binomial-coefficients.md) to count the number of ways to choose four of them.\n\nThus, using the formula of inclusions-exclusions we sum the number of groups of four divisible by a prime number, then subtract the number of quadruples which are divisible by the product of two primes, add quadruples divisible by three primes, etc.\n\n\n### The number of harmonic triplets\n\nYou are given a number $n \\le 10^6$. You are required to count the number of triples $2 \\le a < b < c \\le n$ that satisfy one of the following conditions:\n\n* or ${\\rm gcd}(a,b) = {\\rm gcd}(a,c) = {\\rm gcd}(b,c) = 1$,\n* or ${\\rm gcd}(a,b) > 1, {\\rm gcd}(a,c) > 1, {\\rm gcd}(b,c) > 1$.\n\nFirst, go straight to the inverse problem \u2014 i.e. count the number of non-harmonic triples.\n\nSecond, note that any non-harmonic triplet is made of a pair of coprimes and a third number that is not coprime with at least one from the pair.\n\nThus, the number of non-harmonic triples that contain $i$ is equal the number of integers from $2$ to $n$ that are coprimes with $i$ multiplied by the number of integers that are not coprime with $i$.\n\nEither $gcd(a,b) = 1 \\wedge gcd(a,c) > 1 \\wedge gcd(b,c) > 1$\n\nor $gcd(a,b) = 1 \\wedge gcd(a,c) = 1 \\wedge gcd(b,c) > 1$\n\nIn both of these cases, it will be counted twice. The first case will be counted when $i = a$ and when $i = b$. The second case will be counted when $i = b$ and when $i = c$. Therefore, to compute the number of non-harmonic triples, we sum this calculation through all $i$ from $2$ to $n$ and divide it by $2$.\n\nNow all we have left to solve is to learn to count the number of coprimes to $i$ in the interval $[2;n]$. Although this problem has already been mentioned, the above solution is not suitable here \u2014 it would require the factorization of each of the integers from $2$ to $n$, and then iterating through all subsets of these primes.\n\nA faster solution is possible with such modification of the sieve of Eratosthenes:\n\n1. First, we find all numbers in the interval $[2;n]$ such that its simple factorization does not include a prime factor twice. We will also need to know, for these numbers, how many factors it includes.\n    * To do this we will maintain an array $deg[i]$ to store the number of primes in the factorization of $i$, and an array $good[i]$, to mark either if $i$ contains each factor at most once ($good[i] = 1$) or not ($good[i] = 0$). When iterating from $2$ to $n$, if we reach a number that has $deg$ equal to $0$, then it is a prime and its $deg$ is $1$.\n    * During the sieve of Eratosthenes, we will iterate $i$ from $2$ to $n$. When processing a prime number we go through all of its multiples and increase their $deg[]$. If one of these multiples is multiple of the square of $i$, then we can put $good$ as false.\n\n2. Second, we need to calculate the answer for all $i$ from $2$ to $n$, i.e., the array $cnt[]$ \u2014 the number of integers not coprime with $i$.\n    * To do this, remember how the formula of inclusion-exclusion works \u2014 actually here we implement the same concept, but with inverted logic: we iterate over a component (a product of primes from the factorization) and add or subtract its term on the formula of inclusion-exclusion of each of its multiples.\n    * So, let's say we are processing a number $i$ such that $good[i] = true$, i.e., it is involved in the formula of inclusion-exclusion. Iterate through all numbers that are multiples of $i$, and either add or subtract $\\lfloor N/i \\rfloor$ from their $cnt[]$ (the signal depends on $deg[i]$: if $deg[i]$ is odd, then we must add, otherwise subtract).\n\nHere's a C++ implementation:\n\n```cpp\nint n;\nbool good[MAXN];\nint deg[MAXN], cnt[MAXN];\n\nlong long solve() {\n\tmemset (good, 1, sizeof good);\n\tmemset (deg, 0, sizeof deg);\n\tmemset (cnt, 0, sizeof cnt);\n\n\tlong long ans_bad = 0;\n\tfor (int i=2; i<=n; ++i) {\n\t\tif (good[i]) {\n\t\t\tif (deg[i] == 0)  deg[i] = 1;\n\t\t\tfor (int j=1; i*j<=n; ++j) {\n\t\t\t\tif (j > 1 && deg[i] == 1)\n\t\t\t\t\tif (j % i == 0)\n\t\t\t\t\t\tgood[i*j] = false;\n\t\t\t\t\telse\n\t\t\t\t\t\t++deg[i*j];\n\t\t\t\tcnt[i*j] += (n / i) * (deg[i]%2==1 ? +1 : -1);\n\t\t\t}\n\t\t}\n\t\tans_bad += (cnt[i] - 1) * 1ll * (n-1 - cnt[i]);\n\t}\n\n\treturn (n-1) * 1ll * (n-2) * (n-3) / 6 - ans_bad / 2;\n}\n```\n\nThe asymptotics of our solution is $O(n \\log n)$, as for almost every number up to $n$ we make $n/i$ iterations on the nested loop.\n\n### The number of permutations without fixed points (derangements)\n\nProve that the number of permutations of length $n$ without fixed points (i.e. no number $i$ is in position $i$ - also called a derangement) is equal to the following number:\n\n$$n! - \\binom{n}{1} \\cdot (n-1)! + \\binom{n}{2} \\cdot (n-2)! - \\binom{n}{3} \\cdot (n-3)! + \\cdots \\pm \\binom{n}{n} \\cdot (n-n)! $$\n\nand approximately equal to:\n\n$$ \\frac{ n! }{ e } $$\n\n(if you round this expression to the nearest whole number \u2014 you get exactly the number of permutations without fixed points)\n\nDenote by $A_k$ the set of permutations of length $n$ with a fixed point at position $k$ ($1 \\le k \\le n$) (i.e. element $k$ is at position $k$).\n\nWe now use the formula of inclusion-exclusion to count the number of permutations with at least one fixed point. For this we need to learn to count sizes of an intersection of sets $A_i$, as follows:\n\n$$\\begin{eqnarray}\n\\left| A_p \\right| &=& (n-1)!\\ , \\\\\n\\left| A_p \\cap A_q \\right| &=& (n-2)!\\ , \\\\\n\\left| A_p \\cap A_q \\cap A_r \\right| &=& (n-3)!\\ , \\\\\n\\cdots ,\n\\end{eqnarray}$$\n\nbecause if we know that the number of fixed points is equal $x$, then we know the position of $x$ elements of the permutation, and all other $(n-x)$ elements can be placed anywhere.\n\nSubstituting this into the formula of inclusion-exclusion, and given that the number of ways to choose a subset of size $x$ from the set of $n$ elements is equal to $\\binom{n}{x}$, we obtain a formula for the number of permutations with at least one fixed point:\n\n$$\\binom{n}{1} \\cdot (n-1)! - \\binom{n}{2} \\cdot (n-2)! + \\binom{n}{3} \\cdot (n-3)! - \\cdots \\pm \\binom{n}{n} \\cdot (n-n)! $$\n\nThen the number of permutations without fixed points is equal to:\n\n$$n! - \\binom{n}{1} \\cdot (n-1)! + \\binom{n}{2} \\cdot (n-2)! - \\binom{n}{3} \\cdot (n-3)! + \\cdots \\pm \\binom{n}{n} \\cdot (n-n)! $$\n\nSimplifying this expression, we obtain **exact and approximate expressions for the number of permutations without fixed points**:\n\n$$ n! \\left( 1 - \\frac{1}{1!} + \\frac{1}{2!} - \\frac{1}{3!} + \\cdots \\pm \\frac{1}{n!} \\right ) \\approx \\frac{n!}{e} $$\n\n(because the sum in brackets are the first $n+1$ terms of the expansion in Taylor series $e^{-1}$)\n\nIt is worth noting that a similar problem can be solved this way: when you need the fixed points were not among the $m$ first elements of permutations (and not among all, as we just solved). The formula obtained is as the given above accurate formula, but it will go up to the sum of $k$, instead of $n$.\n\n## Practice Problems\n\nA list of tasks that can be solved using the principle of inclusions-exclusions:\n\n* [UVA #10325 \"The Lottery\" [difficulty: low]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1266)\n* [UVA #11806 \"Cheerleaders\" [difficulty: low]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n* [TopCoder SRM 477 \"CarelessSecretary\" [difficulty: low]](http://www.topcoder.com/stat?c=problem_statement&pm=10875)\n* [TopCoder TCHS 16 \"Divisibility\" [difficulty: low]](http://community.topcoder.com/stat?c=problem_statement&pm=6658&rd=10068)\n* [SPOJ #6285 NGM2 , \"Another Game With Numbers\" [difficulty: low]](http://www.spoj.com/problems/NGM2/)\n* [TopCoder SRM 382 \"CharmingTicketsEasy\" [difficulty: medium]](http://community.topcoder.com/stat?c=problem_statement&pm=8470)\n* [TopCoder SRM 390 \"SetOfPatterns\" [difficulty: medium]](http://www.topcoder.com/stat?c=problem_statement&pm=8307)\n* [TopCoder SRM 176 \"Deranged\" [difficulty: medium]](http://community.topcoder.com/stat?c=problem_statement&pm=2013)\n* [TopCoder SRM 457 \"TheHexagonsDivOne\" [difficulty: medium]](http://community.topcoder.com/stat?c=problem_statement&pm=10702&rd=14144&rm=303184&cr=22697599)\n* [Test>>>thebest \"HarmonicTriples\" (in Russian) [difficulty: medium]](http://esci.ru/ttb/statement-62.htm)\n* [SPOJ #4191 MSKYCODE \"Sky Code\" [difficulty: medium]](http://www.spoj.com/problems/MSKYCODE/)\n* [SPOJ #4168 SQFREE \"Square-free integers\" [difficulty: medium]](http://www.spoj.com/problems/SQFREE/)\n* [CodeChef \"Count Relations\" [difficulty: medium]](http://www.codechef.com/JAN11/problems/COUNTREL/)\n* [SPOJ - Almost Prime Numbers Again](http://www.spoj.com/problems/KPRIMESB/)\n* [SPOJ - Find number of Pair of Friends](http://www.spoj.com/problems/IITKWPCH/)\n* [SPOJ - Balanced Cow Subsets](http://www.spoj.com/problems/SUBSET/)\n* [SPOJ - EASY MATH [difficulty: medium]](http://www.spoj.com/problems/EASYMATH/)\n* [SPOJ - MOMOS - FEASTOFPIGS [difficulty: easy]](https://www.spoj.com/problems/MOMOS/)\n* [Atcoder - Grid 2 [difficulty: easy]](https://atcoder.jp/contests/dp/tasks/dp_y/)\n* [Codeforces - Count GCD](https://codeforces.com/contest/1750/problem/D)\n", "problem_ids": [], "title": "The Inclusion-Exclusion Principle"}, {"article": "---\ntitle: Generating all K-combinations\ntags:\n  - Translated\ne_maxx_link: generating_combinations\n---\n# Generating all $K$-combinations\n\nIn this article we will discuss the problem of generating all $K$-combinations.\nGiven the natural numbers $N$ and $K$, and considering a set of numbers from $1$ to $N$.\nThe task is to derive all **subsets of size $K$**.\n\n## Generate next lexicographical $K$-combination {data-toc-label=\"Generate next lexicographical K-combination\"}\n\nFirst we will generate them in lexicographical order.\nThe algorithm for this is simple. The first combination will be ${1, 2, ..., K}$. Now let's see how\nto find the combination that immediately follows this, lexicographically. To do so, we consider our\ncurrent combination, and find the rightmost element that has not yet reached its highest possible value. Once\nfinding this element, we increment it by $1$, and assign the lowest valid value to all subsequent\nelements.\n\n```{.cpp file=next_combination}\nbool next_combination(vector<int>& a, int n) {\n    int k = (int)a.size();\n    for (int i = k - 1; i >= 0; i--) {\n        if (a[i] < n - k + i + 1) {\n            a[i]++;\n            for (int j = i + 1; j < k; j++)\n                a[j] = a[j - 1] + 1;\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## Generate all $K$-combinations such that adjacent combinations differ by one element {data-toc-label=\"Generate all K-combinations such that adjacent combinations differ by one element\"}\n\nThis time we want to generate all $K$-combinations in such\nan order, that adjacent combinations differ exactly by one element.\n\nThis can be solved using the [Gray Code](../algebra/gray-code.md):\nIf we assign a bitmask to each subset, then by generating and iterating over these bitmasks with Gray codes, we can obtain our answer.\n\nThe task of generating $K$-combinations can also be solved using Gray Codes in a different way:\nGenerate Gray Codes for the numbers from $0$ to $2^N - 1$ and leave only those codes containing $K$ $1$s.\nThe surprising fact is that in the resulting sequence of $K$ set bits, any two neighboring masks (including the\nfirst and last mask - neighboring in a cyclic sense) - will differ exactly by two bits, which is our objective (remove\na number, add a number).\n\nLet us prove this:\n\nFor the proof, we recall the fact that the sequence $G(N)$ (representing the $N$<sup>th</sup> Gray Code) can \nbe obtained as follows:\n\n$$G(N) = 0G(N-1) \\cup 1G(N-1)^\\text{R}$$\n\nThat is, consider the Gray Code sequence for $N-1$, and prefix $0$ before every term. And consider the \nreversed Gray Code sequence for $N-1$ and prefix a $1$ before every mask, and\nconcatenate these two sequences.\n\nNow we may produce our proof.\n\nFirst, we prove that the first and last masks differ exactly in two bits. To do this, it is sufficient to note\nthat the first mask of the sequence $G(N)$, will be of the form $N-K$ $0$s, followed by $K$ $1$s. As\nthe first bit is set as $0$, after which $(N-K-1)$ $0$s follow, after which $K$ set bits follow and the last mask will be of the form $1$, then $(N-K)$ $0$s, then $K-1$ $1$s.\nApplying the principle of mathematical induction, and using the formula for $G(N)$, concludes the proof.\n\nNow our task is to show that any two adjacent codes also differ exactly in two bits, we can do this by considering our recursive equation for the generation of Gray Codes. Let us assume the content of the two halves formed by $G(N-1)$ is true. Now we need to prove that the new consecutive pair formed at the junction (by the concatenation of these two halves) is also valid, i.e. they differ by exactly two bits.\n\nThis can be done, as we know the last mask of the first half and the first mask of the second half. The last mask of the first half would be $1$, then $(N-K-1)$ $0$s, then $K-1$ $1$s. And the first mask of the second half would be $0$, then $(N-K-2)$ $0$s would follow, and then $K$ $1$s. Thus, comparing the two masks, we find exactly two bits that differ.\n\nThe following is a naive implementation working by generating all $2^{n}$ possible subsets, and finding subsets of size\n$K$.\n\n```{.cpp file=generate_all_combinations_naive}\nint gray_code (int n) {\n    return n ^ (n >> 1);\n}\n\nint count_bits (int n) {\n    int res = 0;\n    for (; n; n >>= 1)\n        res += n & 1;\n    return res;\n}\n\nvoid all_combinations (int n, int k) {\n    for (int i = 0; i < (1 << n); i++) {\n        int cur = gray_code (i);\n        if (count_bits(cur) == k) {\n            for (int j = 0; j < n; j++) {\n                if (cur & (1 << j))\n                    cout << j + 1;\n            }\n            cout << \"\\n\";\n        }\n    }\n}\n```\n\nIt's worth mentioning that a more efficient implementation exists that only resorts to building valid combinations and thus\nworks in $O\\left(N \\cdot \\binom{N}{K}\\right)$ however it is recursive in nature and for smaller values of $N$ it probably has a larger constant\nthan the previous solution.\n\nThe implementation is derived from the formula:\n\n$$G(N, K) = 0G(N-1, K) \\cup 1G(N-1, K-1)^\\text{R}$$\n\nThis formula is obtained by modifying the general equation to determine the Gray code, and works by selecting the\nsubsequence from appropriate elements.\n\nIts implementation is as follows:\n\n```{.cpp file=generate_all_combinations_fast}\nvector<int> ans;\n\nvoid gen(int n, int k, int idx, bool rev) {\n    if (k > n || k < 0)\n        return;\n\n    if (!n) {\n        for (int i = 0; i < idx; ++i) {\n            if (ans[i])\n                cout << i + 1;\n        }\n        cout << \"\\n\";\n        return;\n    }\n\n    ans[idx] = rev;\n    gen(n - 1, k - rev, idx + 1, false);\n    ans[idx] = !rev;\n    gen(n - 1, k - !rev, idx + 1, true);\n}\n\nvoid all_combinations(int n, int k) {\n    ans.resize(n);\n    gen(n, k, 0, false);\n}\n```\n", "full_article": "---\ntitle: Generating all K-combinations\ntags:\n  - Translated\ne_maxx_link: generating_combinations\n---\n# Generating all $K$-combinations\n\nIn this article we will discuss the problem of generating all $K$-combinations.\nGiven the natural numbers $N$ and $K$, and considering a set of numbers from $1$ to $N$.\nThe task is to derive all **subsets of size $K$**.\n\n## Generate next lexicographical $K$-combination {data-toc-label=\"Generate next lexicographical K-combination\"}\n\nFirst we will generate them in lexicographical order.\nThe algorithm for this is simple. The first combination will be ${1, 2, ..., K}$. Now let's see how\nto find the combination that immediately follows this, lexicographically. To do so, we consider our\ncurrent combination, and find the rightmost element that has not yet reached its highest possible value. Once\nfinding this element, we increment it by $1$, and assign the lowest valid value to all subsequent\nelements.\n\n```{.cpp file=next_combination}\nbool next_combination(vector<int>& a, int n) {\n    int k = (int)a.size();\n    for (int i = k - 1; i >= 0; i--) {\n        if (a[i] < n - k + i + 1) {\n            a[i]++;\n            for (int j = i + 1; j < k; j++)\n                a[j] = a[j - 1] + 1;\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## Generate all $K$-combinations such that adjacent combinations differ by one element {data-toc-label=\"Generate all K-combinations such that adjacent combinations differ by one element\"}\n\nThis time we want to generate all $K$-combinations in such\nan order, that adjacent combinations differ exactly by one element.\n\nThis can be solved using the [Gray Code](../algebra/gray-code.md):\nIf we assign a bitmask to each subset, then by generating and iterating over these bitmasks with Gray codes, we can obtain our answer.\n\nThe task of generating $K$-combinations can also be solved using Gray Codes in a different way:\nGenerate Gray Codes for the numbers from $0$ to $2^N - 1$ and leave only those codes containing $K$ $1$s.\nThe surprising fact is that in the resulting sequence of $K$ set bits, any two neighboring masks (including the\nfirst and last mask - neighboring in a cyclic sense) - will differ exactly by two bits, which is our objective (remove\na number, add a number).\n\nLet us prove this:\n\nFor the proof, we recall the fact that the sequence $G(N)$ (representing the $N$<sup>th</sup> Gray Code) can \nbe obtained as follows:\n\n$$G(N) = 0G(N-1) \\cup 1G(N-1)^\\text{R}$$\n\nThat is, consider the Gray Code sequence for $N-1$, and prefix $0$ before every term. And consider the \nreversed Gray Code sequence for $N-1$ and prefix a $1$ before every mask, and\nconcatenate these two sequences.\n\nNow we may produce our proof.\n\nFirst, we prove that the first and last masks differ exactly in two bits. To do this, it is sufficient to note\nthat the first mask of the sequence $G(N)$, will be of the form $N-K$ $0$s, followed by $K$ $1$s. As\nthe first bit is set as $0$, after which $(N-K-1)$ $0$s follow, after which $K$ set bits follow and the last mask will be of the form $1$, then $(N-K)$ $0$s, then $K-1$ $1$s.\nApplying the principle of mathematical induction, and using the formula for $G(N)$, concludes the proof.\n\nNow our task is to show that any two adjacent codes also differ exactly in two bits, we can do this by considering our recursive equation for the generation of Gray Codes. Let us assume the content of the two halves formed by $G(N-1)$ is true. Now we need to prove that the new consecutive pair formed at the junction (by the concatenation of these two halves) is also valid, i.e. they differ by exactly two bits.\n\nThis can be done, as we know the last mask of the first half and the first mask of the second half. The last mask of the first half would be $1$, then $(N-K-1)$ $0$s, then $K-1$ $1$s. And the first mask of the second half would be $0$, then $(N-K-2)$ $0$s would follow, and then $K$ $1$s. Thus, comparing the two masks, we find exactly two bits that differ.\n\nThe following is a naive implementation working by generating all $2^{n}$ possible subsets, and finding subsets of size\n$K$.\n\n```{.cpp file=generate_all_combinations_naive}\nint gray_code (int n) {\n    return n ^ (n >> 1);\n}\n\nint count_bits (int n) {\n    int res = 0;\n    for (; n; n >>= 1)\n        res += n & 1;\n    return res;\n}\n\nvoid all_combinations (int n, int k) {\n    for (int i = 0; i < (1 << n); i++) {\n        int cur = gray_code (i);\n        if (count_bits(cur) == k) {\n            for (int j = 0; j < n; j++) {\n                if (cur & (1 << j))\n                    cout << j + 1;\n            }\n            cout << \"\\n\";\n        }\n    }\n}\n```\n\nIt's worth mentioning that a more efficient implementation exists that only resorts to building valid combinations and thus\nworks in $O\\left(N \\cdot \\binom{N}{K}\\right)$ however it is recursive in nature and for smaller values of $N$ it probably has a larger constant\nthan the previous solution.\n\nThe implementation is derived from the formula:\n\n$$G(N, K) = 0G(N-1, K) \\cup 1G(N-1, K-1)^\\text{R}$$\n\nThis formula is obtained by modifying the general equation to determine the Gray code, and works by selecting the\nsubsequence from appropriate elements.\n\nIts implementation is as follows:\n\n```{.cpp file=generate_all_combinations_fast}\nvector<int> ans;\n\nvoid gen(int n, int k, int idx, bool rev) {\n    if (k > n || k < 0)\n        return;\n\n    if (!n) {\n        for (int i = 0; i < idx; ++i) {\n            if (ans[i])\n                cout << i + 1;\n        }\n        cout << \"\\n\";\n        return;\n    }\n\n    ans[idx] = rev;\n    gen(n - 1, k - rev, idx + 1, false);\n    ans[idx] = !rev;\n    gen(n - 1, k - !rev, idx + 1, true);\n}\n\nvoid all_combinations(int n, int k) {\n    ans.resize(n);\n    gen(n, k, 0, false);\n}\n```\n", "problem_ids": [], "title": "Generating all $K$-combinations"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: bishops_arrangement\n---\n\n# Placing Bishops on a Chessboard\n\nFind the number of ways to place $K$ bishops on an $N \\times N$ chessboard so that no two bishops attack each other.\n\n## Algorithm\n\nThis problem can be solved using dynamic programming.\n\nLet's enumerate the diagonals of the chessboard as follows: black diagonals have odd indices, white diagonals have even indices, and the diagonals are numbered in non-decreasing order of the number of squares in them. Here is an example for a $5 \\times 5$ chessboard.\n\n$$\\begin{matrix}\n\\bf{1} & 2 & \\bf{5} & 6 & \\bf{9} \\\\\\\n2 & \\bf{5} & 6 & \\bf{9} & 8 \\\\\\\n\\bf{5} & 6 & \\bf{9} & 8 & \\bf{7} \\\\\\\n6 & \\bf{9} & 8 & \\bf{7} & 4 \\\\\\\n\\bf{9} & 8 & \\bf{7} & 4 & \\bf{3} \\\\\\\n\\end{matrix}$$\n\nLet `D[i][j]` denote the number of ways to place `j` bishops on diagonals with indices up to `i` which have the same color as diagonal `i`.\nThen `i = 1...2N-1` and `j = 0...K`.\n\nWe can calculate `D[i][j]` using only values of `D[i-2]` (we subtract 2 because we only consider diagonals of the same color as $i$).\nThere are two ways to get `D[i][j]`.\nEither we place all `j` bishops on previous diagonals: then there are `D[i-2][j]` ways to achieve this.\nOr we place one bishop on diagonal `i` and `j-1` bishops on previous diagonals.\nThe number of ways to do this equals the number of squares in diagonal `i` minus `j-1`, because each of `j-1` bishops placed on previous diagonals will block one square on the current diagonal.\nThe number of squares in diagonal `i` can be calculated as follows:\n\n```cpp\nint squares (int i) {\n    if (i & 1)\n        return i / 4 * 2 + 1;\n    else\n        return (i - 1) / 4 * 2 + 2;\n}\n```\n\nThe base case is simple: `D[i][0] = 1`, `D[1][1] = 1`.\n\nOnce we have calculated all values of `D[i][j]`, the answer can be obtained as follows:\nconsider all possible numbers of bishops placed on black diagonals `i=0...K`, with corresponding numbers of bishops on white diagonals `K-i`.\nThe bishops placed on black and white diagonals never attack each other, so the placements can be done independently.\nThe index of the last black diagonal is `2N-1`, the last white one is `2N-2`.\nFor each `i` we add `D[2N-1][i] * D[2N-2][K-i]` to the answer.\n\n## Implementation\n\n```cpp\nint bishop_placements(int N, int K)\n{\n    if (K > 2 * N - 1)\n        return 0;\n\n    vector<vector<int>> D(N * 2, vector<int>(K + 1));\n    for (int i = 0; i < N * 2; ++i)\n        D[i][0] = 1;\n    D[1][1] = 1;\n    for (int i = 2; i < N * 2; ++i)\n        for (int j = 1; j <= K; ++j)\n            D[i][j] = D[i-2][j] + D[i-2][j-1] * (squares(i) - j + 1);\n\n    int ans = 0;\n    for (int i = 0; i <= K; ++i)\n        ans += D[N*2-1][i] * D[N*2-2][K-i];\n    return ans;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: bishops_arrangement\n---\n\n# Placing Bishops on a Chessboard\n\nFind the number of ways to place $K$ bishops on an $N \\times N$ chessboard so that no two bishops attack each other.\n\n## Algorithm\n\nThis problem can be solved using dynamic programming.\n\nLet's enumerate the diagonals of the chessboard as follows: black diagonals have odd indices, white diagonals have even indices, and the diagonals are numbered in non-decreasing order of the number of squares in them. Here is an example for a $5 \\times 5$ chessboard.\n\n$$\\begin{matrix}\n\\bf{1} & 2 & \\bf{5} & 6 & \\bf{9} \\\\\\\n2 & \\bf{5} & 6 & \\bf{9} & 8 \\\\\\\n\\bf{5} & 6 & \\bf{9} & 8 & \\bf{7} \\\\\\\n6 & \\bf{9} & 8 & \\bf{7} & 4 \\\\\\\n\\bf{9} & 8 & \\bf{7} & 4 & \\bf{3} \\\\\\\n\\end{matrix}$$\n\nLet `D[i][j]` denote the number of ways to place `j` bishops on diagonals with indices up to `i` which have the same color as diagonal `i`.\nThen `i = 1...2N-1` and `j = 0...K`.\n\nWe can calculate `D[i][j]` using only values of `D[i-2]` (we subtract 2 because we only consider diagonals of the same color as $i$).\nThere are two ways to get `D[i][j]`.\nEither we place all `j` bishops on previous diagonals: then there are `D[i-2][j]` ways to achieve this.\nOr we place one bishop on diagonal `i` and `j-1` bishops on previous diagonals.\nThe number of ways to do this equals the number of squares in diagonal `i` minus `j-1`, because each of `j-1` bishops placed on previous diagonals will block one square on the current diagonal.\nThe number of squares in diagonal `i` can be calculated as follows:\n\n```cpp\nint squares (int i) {\n    if (i & 1)\n        return i / 4 * 2 + 1;\n    else\n        return (i - 1) / 4 * 2 + 2;\n}\n```\n\nThe base case is simple: `D[i][0] = 1`, `D[1][1] = 1`.\n\nOnce we have calculated all values of `D[i][j]`, the answer can be obtained as follows:\nconsider all possible numbers of bishops placed on black diagonals `i=0...K`, with corresponding numbers of bishops on white diagonals `K-i`.\nThe bishops placed on black and white diagonals never attack each other, so the placements can be done independently.\nThe index of the last black diagonal is `2N-1`, the last white one is `2N-2`.\nFor each `i` we add `D[2N-1][i] * D[2N-2][K-i]` to the answer.\n\n## Implementation\n\n```cpp\nint bishop_placements(int N, int K)\n{\n    if (K > 2 * N - 1)\n        return 0;\n\n    vector<vector<int>> D(N * 2, vector<int>(K + 1));\n    for (int i = 0; i < N * 2; ++i)\n        D[i][0] = 1;\n    D[1][1] = 1;\n    for (int i = 2; i < N * 2; ++i)\n        for (int j = 1; j <= K; ++j)\n            D[i][j] = D[i-2][j] + D[i-2][j-1] * (squares(i) - j + 1);\n\n    int ans = 0;\n    for (int i = 0; i <= K; ++i)\n        ans += D[N*2-1][i] * D[N*2-2][K-i];\n    return ans;\n}\n```\n", "problem_ids": [], "title": "Placing Bishops on a Chessboard"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: catalan_numbers\n---\n\n# Catalan Numbers\nCatalan numbers is a number sequence, which is found useful in a number of combinatorial problems, often involving recursively-defined objects.\n\nThis sequence was named after the Belgian mathematician [Catalan](https://en.wikipedia.org/wiki/Eug%C3%A8ne_Charles_Catalan), who lived in the 19th century. (In fact it was known before to Euler, who lived a century before Catalan).\n\nThe first few Catalan numbers $C_n$ (starting from zero):\n\n $1, 1, 2, 5, 14, 42, 132, 429, 1430, \\ldots$\n\n### Application in some combinatorial problems\n\nThe Catalan number $C_n$ is the solution for\n\n- Number of correct bracket sequence consisting of $n$ opening and $n$ closing brackets.\n- The number of rooted full binary trees with $n + 1$ leaves (vertices are not numbered). A rooted binary tree is full if every vertex has either two children or no children.\n- The number of ways to completely parenthesize $n + 1$ factors.\n- The number of triangulations of a convex polygon with $n + 2$ sides (i.e. the number of partitions of polygon into disjoint triangles by using the diagonals).\n- The number of ways to connect the $2n$ points on a circle to form $n$ disjoint chords.\n- The number of [non-isomorphic](https://en.wikipedia.org/wiki/Graph_isomorphism) full binary trees with $n$ internal nodes (i.e. nodes having at least one son).\n- The number of monotonic lattice paths from point $(0, 0)$ to point $(n, n)$ in a square lattice of size $n \\times n$, which do not pass above the main diagonal (i.e. connecting $(0, 0)$ to $(n, n)$).\n- Number of permutations of length $n$ that can be [stack sorted](https://en.wikipedia.org/wiki/Stack-sortable_permutation) (i.e. it can be shown that the rearrangement is stack sorted if and only if there is no such index $i < j < k$, such that $a_k < a_i < a_j$ ).\n- The number of [non-crossing partitions](https://en.wikipedia.org/wiki/Noncrossing_partition) of a set of $n$ elements.\n- The number of ways to cover the ladder $1 \\ldots n$ using $n$ rectangles (The ladder consists of $n$ columns, where $i^{th}$ column has a height $i$).\n\n\n## Calculations\n\nThere are two formulas for the Catalan numbers: **Recursive and Analytical**. Since, we believe that all the mentioned above problems are equivalent (have the same solution), for the proof of the formulas below we will choose the task which it is easiest to do.\n\n### Recursive formula\n \n$$C_0 = C_1 = 1$$\n\n$$C_n = \\sum_{k = 0}^{n-1} C_k C_{n-1-k} , {n} \\geq 2$$\n\nThe recurrence formula can be easily deduced from the problem of the correct bracket sequence.\n\nThe leftmost opening parenthesis $l$ corresponds to certain closing bracket $r$, which divides the sequence into 2 parts which in turn should be a correct sequence of brackets. Thus formula is also divided into 2 parts. If we denote $k = {r - l - 1}$, then for fixed $r$, there will be exactly $C_k C_{n-1-k}$ such bracket sequences. Summing this over all admissible $k's$, we get the recurrence relation on $C_n$.\n\nYou can also think it in this manner. By definition, $C_n$ denotes number of correct bracket sequences. Now, the sequence may be divided into 2 parts of length $k$ and ${n - k}$, each of which should be a correct bracket sequence. Example :\n\n$( ) ( ( ) )$ can be divided into $( )$ and $( ( ) )$, but cannot be divided into $( ) ($ and $( ) )$. Again summing over all admissible $k's$, we get the recurrence relation on $C_n$.\n\n#### C++ implementation \n\n```cpp\nconst int MOD = ....\nconst int MAX = ....\nint catalan[MAX];\nvoid init() {\n    catalan[0] = catalan[1] = 1;\n    for (int i=2; i<=n; i++) {\n        catalan[i] = 0;\n        for (int j=0; j < i; j++) {\n            catalan[i] += (catalan[j] * catalan[i-j-1]) % MOD;\n            if (catalan[i] >= MOD) {\n                catalan[i] -= MOD;\n            }\n        }\n    }\n}\n```\n\n### Analytical formula\n\n$$C_n = \\frac{1}{n + 1} {\\binom{2n}{n}}$$\n\n(here $\\binom{n}{k}$ denotes the usual binomial coefficient, i.e. number of ways to select $k$ objects from set of $n$ objects).\n\nThe above formula can be easily concluded from the problem of the monotonic paths in square grid. The total number of  monotonic paths in the lattice size of $n \\times n$ is given by $\\binom{2n}{n}$.\n\nNow we count the number of monotonic paths which cross the main diagonal. Consider such paths crossing the main diagonal and find the first edge in it which is above the diagonal. Reflect the path about the diagonal all the way, going after this edge. The result is always a monotonic path in the grid $(n - 1) \\times (n + 1)$. On the other hand, any monotonic path in the lattice $(n - 1) \\times (n + 1)$ must intersect the diagonal. Hence, we enumerated all monotonic paths crossing the main diagonal in the lattice $n \\times n$.\n\nThe number of monotonic paths in the lattice $(n - 1) \\times (n + 1)$ are $\\binom{2n}{n-1}$ . Let us call such paths as \"bad\" paths. As a result, to obtain the number of monotonic paths which do not cross the main diagonal, we subtract the above \"bad\" paths, obtaining the formula:\n\n$$C_n = \\binom{2n}{n} - \\binom{2n}{n-1} = \\frac{1}{n + 1} \\binom{2n}{n} , {n} \\geq 0$$\n\n## Reference\n\n- [Catalan Number by Tom Davis](http://www.geometer.org/mathcircles/catalan.pdf)\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: catalan_numbers\n---\n\n# Catalan Numbers\nCatalan numbers is a number sequence, which is found useful in a number of combinatorial problems, often involving recursively-defined objects.\n\nThis sequence was named after the Belgian mathematician [Catalan](https://en.wikipedia.org/wiki/Eug%C3%A8ne_Charles_Catalan), who lived in the 19th century. (In fact it was known before to Euler, who lived a century before Catalan).\n\nThe first few Catalan numbers $C_n$ (starting from zero):\n\n $1, 1, 2, 5, 14, 42, 132, 429, 1430, \\ldots$\n\n### Application in some combinatorial problems\n\nThe Catalan number $C_n$ is the solution for\n\n- Number of correct bracket sequence consisting of $n$ opening and $n$ closing brackets.\n- The number of rooted full binary trees with $n + 1$ leaves (vertices are not numbered). A rooted binary tree is full if every vertex has either two children or no children.\n- The number of ways to completely parenthesize $n + 1$ factors.\n- The number of triangulations of a convex polygon with $n + 2$ sides (i.e. the number of partitions of polygon into disjoint triangles by using the diagonals).\n- The number of ways to connect the $2n$ points on a circle to form $n$ disjoint chords.\n- The number of [non-isomorphic](https://en.wikipedia.org/wiki/Graph_isomorphism) full binary trees with $n$ internal nodes (i.e. nodes having at least one son).\n- The number of monotonic lattice paths from point $(0, 0)$ to point $(n, n)$ in a square lattice of size $n \\times n$, which do not pass above the main diagonal (i.e. connecting $(0, 0)$ to $(n, n)$).\n- Number of permutations of length $n$ that can be [stack sorted](https://en.wikipedia.org/wiki/Stack-sortable_permutation) (i.e. it can be shown that the rearrangement is stack sorted if and only if there is no such index $i < j < k$, such that $a_k < a_i < a_j$ ).\n- The number of [non-crossing partitions](https://en.wikipedia.org/wiki/Noncrossing_partition) of a set of $n$ elements.\n- The number of ways to cover the ladder $1 \\ldots n$ using $n$ rectangles (The ladder consists of $n$ columns, where $i^{th}$ column has a height $i$).\n\n\n## Calculations\n\nThere are two formulas for the Catalan numbers: **Recursive and Analytical**. Since, we believe that all the mentioned above problems are equivalent (have the same solution), for the proof of the formulas below we will choose the task which it is easiest to do.\n\n### Recursive formula\n \n$$C_0 = C_1 = 1$$\n\n$$C_n = \\sum_{k = 0}^{n-1} C_k C_{n-1-k} , {n} \\geq 2$$\n\nThe recurrence formula can be easily deduced from the problem of the correct bracket sequence.\n\nThe leftmost opening parenthesis $l$ corresponds to certain closing bracket $r$, which divides the sequence into 2 parts which in turn should be a correct sequence of brackets. Thus formula is also divided into 2 parts. If we denote $k = {r - l - 1}$, then for fixed $r$, there will be exactly $C_k C_{n-1-k}$ such bracket sequences. Summing this over all admissible $k's$, we get the recurrence relation on $C_n$.\n\nYou can also think it in this manner. By definition, $C_n$ denotes number of correct bracket sequences. Now, the sequence may be divided into 2 parts of length $k$ and ${n - k}$, each of which should be a correct bracket sequence. Example :\n\n$( ) ( ( ) )$ can be divided into $( )$ and $( ( ) )$, but cannot be divided into $( ) ($ and $( ) )$. Again summing over all admissible $k's$, we get the recurrence relation on $C_n$.\n\n#### C++ implementation \n\n```cpp\nconst int MOD = ....\nconst int MAX = ....\nint catalan[MAX];\nvoid init() {\n    catalan[0] = catalan[1] = 1;\n    for (int i=2; i<=n; i++) {\n        catalan[i] = 0;\n        for (int j=0; j < i; j++) {\n            catalan[i] += (catalan[j] * catalan[i-j-1]) % MOD;\n            if (catalan[i] >= MOD) {\n                catalan[i] -= MOD;\n            }\n        }\n    }\n}\n```\n\n### Analytical formula\n\n$$C_n = \\frac{1}{n + 1} {\\binom{2n}{n}}$$\n\n(here $\\binom{n}{k}$ denotes the usual binomial coefficient, i.e. number of ways to select $k$ objects from set of $n$ objects).\n\nThe above formula can be easily concluded from the problem of the monotonic paths in square grid. The total number of  monotonic paths in the lattice size of $n \\times n$ is given by $\\binom{2n}{n}$.\n\nNow we count the number of monotonic paths which cross the main diagonal. Consider such paths crossing the main diagonal and find the first edge in it which is above the diagonal. Reflect the path about the diagonal all the way, going after this edge. The result is always a monotonic path in the grid $(n - 1) \\times (n + 1)$. On the other hand, any monotonic path in the lattice $(n - 1) \\times (n + 1)$ must intersect the diagonal. Hence, we enumerated all monotonic paths crossing the main diagonal in the lattice $n \\times n$.\n\nThe number of monotonic paths in the lattice $(n - 1) \\times (n + 1)$ are $\\binom{2n}{n-1}$ . Let us call such paths as \"bad\" paths. As a result, to obtain the number of monotonic paths which do not cross the main diagonal, we subtract the above \"bad\" paths, obtaining the formula:\n\n$$C_n = \\binom{2n}{n} - \\binom{2n}{n-1} = \\frac{1}{n + 1} \\binom{2n}{n} , {n} \\geq 0$$\n\n## Reference\n\n- [Catalan Number by Tom Davis](http://www.geometer.org/mathcircles/catalan.pdf)\n\n## Practice Problems\n- [Codechef - PANSTACK](https://www.codechef.com/APRIL12/problems/PANSTACK/)\n- [Spoj - Skyline](http://www.spoj.com/problems/SKYLINE/)\n- [UVA - Safe Salutations](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=932)\n- [Codeforces - How many trees?](http://codeforces.com/problemset/problem/9/D)\n- [SPOJ - FUNPROB](http://www.spoj.com/problems/FUNPROB/)\n* [LOJ - 1170 - Counting Perfect BST](http://lightoj.com/volume_showproblem.php?problem=1170)\n* [UVA - 12887 - The Soldier's Dilemma](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4752)\n", "problem_ids": ["9_D"], "title": "Catalan Numbers"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: burnside_polya\n---\n\n# Burnside's lemma / P\u00f3lya enumeration theorem\n\n## Burnside's lemma\n\n**Burnside's lemma** was formulated and proven by **Burnside** in 1897, but historically it was already discovered in 1887 by **Frobenius**, and even earlier in 1845 by **Cauchy**.\nTherefore it is also sometimes named the **Cauchy-Frobenius lemma**.\n\nBurnside's lemma allows us to count the number of equivalence classes in sets, based on internal symmetry.\n\n### Objects and representations\n\nWe have to clearly distinguish between the number of objects and the number of representations.\n\nDifferent representations can correspond to the same objects, but of course any representation corresponds to exactly one object.\nConsequently the set of all representations is divided into equivalence classes.\nOur task is to compute the number of objects, or equivalently, the number of equivalence classes.\nThe following example will make the difference between object and representation clearer.\n\n### Example: coloring of binary trees\n\nSuppose we have the following problem.\nWe have to count the number of ways to color a rooted binary tree with $n$ vertices with two colors, where at each vertex we do not distinguish between the left and the right children.\n\nHere the set of objects is the set of different colorings of the tree.\n\nWe now define the set of representations.\nA representation of a coloring is a function $f(v)$, which assigns each vertex a color (here we use the colors $0$ and $1$).\nThe set of representations is the set containing all possible functions of this kind, and its size is obviously equal to $2^n$.\n\nAt the same time we introduce a partition of this set into equivalence classes.\n\nFor example, suppose $n = 3$, and the tree consists of the root $1$ and its two children $2$ and $3$.\nThen the following functions $f_1$ and $f_2$ are considered equivalent.\n\n$$\\begin{array}{ll}\nf_1(1) = 0 & f_2(1) = 0\\\\\nf_1(2) = 1 & f_2(2) = 0\\\\\nf_1(3) = 0 & f_2(3) = 1\n\\end{array}$$\n\n### Invariant permutations\n\nWhy do these two function $f_1$ and $f_2$ belong to the same equivalence class?\nIntuitively this is understandable - we can rearrange the children of vertex $1$, the vertices $2$ and $3$, and after such a transformation of the function $f_1$ it will coincide with $f_2$.\n\nBut formally this means that there exists an **invariant permutation** $\\pi$ (i.e. a permutation which does not change the object itself, but only its representation), such that:\n\n$$f_2 \\pi \\equiv f_1$$\n\nSo starting from the definition of objects, we can find all the invariant permutations, i.e. all permutations which do not change the object when applying the permutation to the representation.\nThen we can check whether two functions $f_1$ and $f_2$ are equivalent (i.e. if they correspond to the same object) by checking the condition $f_2 \\pi \\equiv f_1$ for each invariant permutation (or equivalently $f_1 \\pi \\equiv f_2$).\nIf at least one permutation is found for which the condition is satisfied, then $f_1$ and $f_2$ are equivalent, otherwise they are not equivalent.\n\nFinding all such invariant permutations with respect to the object definition is a key step for the application of both Burnside's lemma and the P\u00f3lya enumeration theorem.\nIt is clear that these invariant permutations depend on the specific problem, and their finding is a purely heuristic process based on intuitive considerations.\nHowever in most cases it is sufficient to manually find several \"basic\" permutations, with which all other permutations can be generated (and this part of the work can be shifted to a computer).\n\nIt is not difficult to understand that invariant permutations form a **group**, since the product (composition) of invariant permutations is again an invariant permutation.\nWe denote the **group of invariant permutations** by $G$.\n\n### The statement of the lemma\n\nFor the formulation of the lemma we need one more definition from algebra.\nA **fixed point** $f$ for a permutation $\\pi$ is an element that is invariant under this permutation: $f \\equiv f \\pi$.\nFor example in our example the fixed points are those functions $f$, which correspond to colorings that do not change when the permutation $\\pi$ is applied to them (i.e. they do not change in the formal sense of the equality of functions).\nWe denote by $I(\\pi)$ the **number of fixed points** for the permutation $\\pi$.\n\nThen **Burnside's lemma** goes as follows:\nthe number of equivalence classes is equal to the sum of the numbers of fixed points with respect to all permutations from the group $G$, divided by the size of this group:\n\n$$|\\text{Classes}| = \\frac{1}{|G|} \\sum_{\\pi \\in G} I(\\pi)$$\n\nAlthough Burnside's lemma itself is not so convenient to use in practice (it is unclear how to quickly look for the value $I(\\pi)$, it most clearly reveals the mathematical essence on which the idea of calculating equivalence classes is based.\n\n### Proof of Burnside's lemma\n\nThe proof of Burnside's lemma described here is not important for the practical applications, so it can be skipped on the first reading.\n\nThe proof here is the simplest known, and does not use group theory.\nThe proof was published by Kenneth P. Bogart in 1991.\n\nWe need to prove the following statement:\n\n$$|\\text{Classes}| \\cdot |G| = \\sum_{\\pi \\in G} I(\\pi)$$\n\nThe value on the right side is nothing more than the number of \"invariant pairs\" $(f, \\pi)$, i.e. pairs such that $f \\pi \\equiv f$.\nIt is obvious that we can change the order of summation.\nWe let the sum iterate over all elements $f$ and sum over the values $J(f)$ - the number of permutations for which $f$ is a fixed point.\n\n$$|\\text{Classes}| \\cdot |G| = \\sum_{f} J(f)$$\n\nTo prove this formula we will compose a table with columns labeled with all functions $f_i$ and rows labeled with all permutations $\\pi_j$.\nAnd we fill the cells with $f_i \\pi_j$.\nIf we look at the columns in this table as sets, then some of them will coincide, and this means that the corresponding functions $f$ for these columns are also equivalent.\nThus the numbers of different (as sets) columns is equal to the number of classes.\nIncidentally, from the standpoint of group theory, the column labeled with $f_i$ is the orbit of this element.\nFor equivalent elements the orbits coincides, and the number of orbits gives exactly the number of classes.\n\nThus the columns of the table decompose into equivalence classes.\nLet us fix a class, and look at the columns in it.\nFirst, note that these columns can only contain elements $f_i$ of the equivalence class (otherwise some permutation $\\pi_j$ moved one of the functions into a different equivalence class, which is impossible since we only look at invariant permutations).\nSecondly each element $f_i$ will occur the same number of times in each column (this also follows from the fact that the columns correspond to equivalent elements).\nFrom this we can conclude, that all the columns within the same equivalence class coincide with each other as multisets.\n\nNow fix an arbitrary element $f$.\nOn the one hand, it occurs in its column exactly $J(f)$ times (by definition).\nOn the other hand, all columns within the same equivalence class are the same as multisets.\nTherefore within each column of a given equivalence class any element $g$ occurs exactly $J(g)$ times.\n\nThus if we arbitrarily take one column from each equivalence class, and sum the number of elements in them, we obtain on one hand $|\\text{Classes}| \\cdot |G|$ (simply by multiplying the number of columns by the number of rows), and on the other hand the sum of the quantities $J(f)$ for all $f$ (this follows from all the previous arguments):\n\n$$|\\text{Classes}| \\cdot |G| = \\sum_{f} J(f)$$\n\n## P\u00f3lya enumeration theorem\n\nThe P\u00f3lya enumeration theorem is a generalization of Burnside's lemma, and it also provides a more convenient tool for finding the number of equivalence classes.\nIt should be noted that this theorem was already discovered before P\u00f3lya by Redfield in 1927, but his publication went unnoticed by mathematicians.\nP\u00f3lya independently came to the same results in 1937, and his publication was more successful.\n\nHere we discuss only a special case of the P\u00f3lya enumeration theorem, which will turn out very useful in practice.\nThe general formula of the theorem will not be discussed.\n\nWe denote by $C(\\pi)$ the number of cycles in the permutation $\\pi$.\nThen the following formula (a **special case of the P\u00f3lya enumeration theorem**) holds:\n\n$$|\\text{Classes}| = \\frac{1}{|G|} \\sum_{\\pi \\in G} k^{C(\\pi)}$$\n\n$k$ is the number of values that each representation element can take, in the case of the coloring of a binary tree this would be $k = 2$.\n\n### Evidence\n\nThis formula is a direct consequence of Burnside's lemma.\nTo get it, we just need to find an explicit expression for $I(\\pi)$, which appears in the lemma.\nRecall, that $I(\\pi)$ is the number of fixed points in the permutation $\\pi$.\n\nThus we consider a permutation $\\pi$ and some element $f$.\nDuring the application of $\\pi$, the elements in $f$ move via the cycles in the permutation.\nSince the result should obtain $f \\equiv f \\pi$, the elements touched by one cycle must all be equal.\nAt the same time different cycles are independent.\nThus for each permutation cycle $\\pi$ we can choose one value (among $k$ possible) and thus we get the number of fixed points:\n\n$$I(\\pi) = k^{C(\\pi)}$$\n\n## Application: Coloring necklaces\n\nThe problem \"Necklace\" is one of the classical combinatorial problems.\nThe task is to count the number of different necklaces from $n$ beads, each of which can be painted in one of the $k$ colors.\nWhen comparing two necklaces, they can be rotated, but not reversed (i.e. a cyclic shift is permitted).\n\nIn this problem we can immediately find the group of invariant permutations:\n\n$$\\begin{align}\n\\pi_0 &= 1 2 3 \\dots n\\\\\n\\pi_1 &= 2 3 \\dots n 1\\\\\n\\pi_2 &= 3 \\dots n 12\\\\\n&\\dots\\\\\n\\pi_{n-1} &= n 1 2 3\\dots\\end{align}$$\n\nLet us find an explicit formula for calculating $C(\\pi_i)$.\nFirst we note, that the permutation $\\pi_i$ has at the $j$-th position the value $i + j$ (taken modulo $n$).\nIf we check the cycle structure for $\\pi_i$.\nWe see that $1$ goes to $1 + i$, $1 + i$ goes to $1 + 2i$, which goes to $1 + 3i$, etc., until we come to a number of the form $1 + k n$.\nSimilar statements can be made for the remaining elements.\nHence we see that all cycles have the same length, namely $\\frac{\\text{lcm}(i, n)}{i} = \\frac{n}{\\gcd(i, n)}$.\nThus the number of cycles in $\\pi_i$ will be equal to $\\gcd(i, n)$.\n\nSubstituting these values into the P\u00f3lya enumeration theorem, we obtain the solution:\n\n$$\\frac{1}{n} \\sum_{i=1}^n k^{\\gcd(i, n)}$$\n\nYou can leave this formula in this form, or you can simplify it even more.\nLet transfer the sum so that it iterates over all divisors of $n$.\nIn the original sum there will be many equivalent terms: if $i$ is not a divisor of $n$, then such a divisor can be found after computing $\\gcd(i, n)$.\nTherefore for each divisor $d ~|~ n$ its term $k^{\\gcd(d, n)} = k^d$ will appear in the sum multiple times, i.e. the answer to the problem can be rewritten as\n\n$$\\frac{1}{n} \\sum_{d ~|~ n} C_d k^d,$$\n\nwhere $C_d$ is the number of such numbers $i$ with $\\gcd(i, n) = d$.\nWe can find an explicit expression for this value.\nAny such number $i$ has the form $i = d j$ with $\\gcd(j, n / d) = 1$ (otherwise $\\gcd(i, n) > d$).\nSo we can count the number of $j$ with this behavior.\n[Euler's phi function](../algebra/phi-function.md) gives us the result $C_d = \\phi(n / d)$, and therefore we get the answer:\n\n$$\\frac{1}{n} \\sum_{d ~|~ n} \\phi\\left(\\frac{n}{d}\\right) k^d$$\n\n## Application: Coloring a torus\n\nQuite often we cannot obtain an explicit formula for the number of equivalence classes.\nIn many problems the number of permutations in a group can be too large for manual calculations and it is not possible to compute analytically the number of cycles in them.\n\nIn that case we should manually find several \"basic\" permutations, so that they can generate the entire group $G$.\nNext we can write a program that will generate all permutations of the group $G$, count the number of cycles in them, and compute the answer with the formula.\n\nConsider the example of the problem for coloring a torus.\nThere is a checkered sheet of paper $n \\times m$ ($n < m$), some of the cells are black.\nThen a cylinder is obtained from this sheet by gluing together the two sides with lengths $m$.\nThen a torus is obtained from the cylinder by gluing together the two circles (top and bottom) without twisting.\nThe task is to compute the number of different colored tori, assuming that we cannot see the glued lines, and the torus can be turned and turned.\n\nWe again start with a piece of $n \\times m$ paper.\nIt is easy to see that the following types of transformations preserve the equivalence class:\na cyclic shift of the rows, a cyclic shift of the columns, and a rotation of the sheet by 180 degrees.\nIt is also easy to see, that these transformations can generate the entire group of invariant transformations.\nIf we somehow number the cells of the paper, then we can write three permutations $p_1$, $p_2$, $p_3$ corresponding to these types of transformation.\n\nNext it only remains to generate all permutations obtained as a product.\nIt is obvious that all such permutations have the form $p_1^{i_1} p_2^{i_2} p_3^{i_3}$ where $i_1 = 0 \\dots m-1$, $i_2 = 0 \\dots n-1$, $i_3 = 0 \\dots 1$.\n\nThus we can write the implementations to this problem.\n\n```{.cpp file=burnside_tori}\nusing Permutation = vector<int>;\n\nvoid operator*=(Permutation& p, Permutation const& q) {\n    Permutation copy = p;\n    for (int i = 0; i < p.size(); i++)\n        p[i] = copy[q[i]];\n}\n\nint count_cycles(Permutation p) {\n    int cnt = 0;\n    for (int i = 0; i < p.size(); i++) {\n        if (p[i] != -1) {\n            cnt++;\n            for (int j = i; p[j] != -1;) {\n                int next = p[j];\n                p[j] = -1;\n                j = next;\n            }\n        }\n    }\n    return cnt;\n}\n\nint solve(int n, int m) {\n    Permutation p(n*m), p1(n*m), p2(n*m), p3(n*m);\n    for (int i = 0; i < n*m; i++) {\n        p[i] = i;\n        p1[i] = (i % n + 1) % n + i / n * n;\n        p2[i] = (i / n + 1) % m * n + i % n;\n        p3[i] = (m - 1 - i / n) * n + (n - 1 - i % n);\n    }\n\n    set<Permutation> s;\n    for (int i1 = 0; i1 < n; i1++) {\n        for (int i2 = 0; i2 < m; i2++) {\n            for (int i3 = 0; i3 < 2; i3++) {\n                s.insert(p);\n                p *= p3;\n            }\n            p *= p2;\n        }\n        p *= p1;\n    }\n\n    int sum = 0;\n    for (Permutation const& p : s) {\n        sum += 1 << count_cycles(p);\n    }\n    return sum / s.size();\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: burnside_polya\n---\n\n# Burnside's lemma / P\u00f3lya enumeration theorem\n\n## Burnside's lemma\n\n**Burnside's lemma** was formulated and proven by **Burnside** in 1897, but historically it was already discovered in 1887 by **Frobenius**, and even earlier in 1845 by **Cauchy**.\nTherefore it is also sometimes named the **Cauchy-Frobenius lemma**.\n\nBurnside's lemma allows us to count the number of equivalence classes in sets, based on internal symmetry.\n\n### Objects and representations\n\nWe have to clearly distinguish between the number of objects and the number of representations.\n\nDifferent representations can correspond to the same objects, but of course any representation corresponds to exactly one object.\nConsequently the set of all representations is divided into equivalence classes.\nOur task is to compute the number of objects, or equivalently, the number of equivalence classes.\nThe following example will make the difference between object and representation clearer.\n\n### Example: coloring of binary trees\n\nSuppose we have the following problem.\nWe have to count the number of ways to color a rooted binary tree with $n$ vertices with two colors, where at each vertex we do not distinguish between the left and the right children.\n\nHere the set of objects is the set of different colorings of the tree.\n\nWe now define the set of representations.\nA representation of a coloring is a function $f(v)$, which assigns each vertex a color (here we use the colors $0$ and $1$).\nThe set of representations is the set containing all possible functions of this kind, and its size is obviously equal to $2^n$.\n\nAt the same time we introduce a partition of this set into equivalence classes.\n\nFor example, suppose $n = 3$, and the tree consists of the root $1$ and its two children $2$ and $3$.\nThen the following functions $f_1$ and $f_2$ are considered equivalent.\n\n$$\\begin{array}{ll}\nf_1(1) = 0 & f_2(1) = 0\\\\\nf_1(2) = 1 & f_2(2) = 0\\\\\nf_1(3) = 0 & f_2(3) = 1\n\\end{array}$$\n\n### Invariant permutations\n\nWhy do these two function $f_1$ and $f_2$ belong to the same equivalence class?\nIntuitively this is understandable - we can rearrange the children of vertex $1$, the vertices $2$ and $3$, and after such a transformation of the function $f_1$ it will coincide with $f_2$.\n\nBut formally this means that there exists an **invariant permutation** $\\pi$ (i.e. a permutation which does not change the object itself, but only its representation), such that:\n\n$$f_2 \\pi \\equiv f_1$$\n\nSo starting from the definition of objects, we can find all the invariant permutations, i.e. all permutations which do not change the object when applying the permutation to the representation.\nThen we can check whether two functions $f_1$ and $f_2$ are equivalent (i.e. if they correspond to the same object) by checking the condition $f_2 \\pi \\equiv f_1$ for each invariant permutation (or equivalently $f_1 \\pi \\equiv f_2$).\nIf at least one permutation is found for which the condition is satisfied, then $f_1$ and $f_2$ are equivalent, otherwise they are not equivalent.\n\nFinding all such invariant permutations with respect to the object definition is a key step for the application of both Burnside's lemma and the P\u00f3lya enumeration theorem.\nIt is clear that these invariant permutations depend on the specific problem, and their finding is a purely heuristic process based on intuitive considerations.\nHowever in most cases it is sufficient to manually find several \"basic\" permutations, with which all other permutations can be generated (and this part of the work can be shifted to a computer).\n\nIt is not difficult to understand that invariant permutations form a **group**, since the product (composition) of invariant permutations is again an invariant permutation.\nWe denote the **group of invariant permutations** by $G$.\n\n### The statement of the lemma\n\nFor the formulation of the lemma we need one more definition from algebra.\nA **fixed point** $f$ for a permutation $\\pi$ is an element that is invariant under this permutation: $f \\equiv f \\pi$.\nFor example in our example the fixed points are those functions $f$, which correspond to colorings that do not change when the permutation $\\pi$ is applied to them (i.e. they do not change in the formal sense of the equality of functions).\nWe denote by $I(\\pi)$ the **number of fixed points** for the permutation $\\pi$.\n\nThen **Burnside's lemma** goes as follows:\nthe number of equivalence classes is equal to the sum of the numbers of fixed points with respect to all permutations from the group $G$, divided by the size of this group:\n\n$$|\\text{Classes}| = \\frac{1}{|G|} \\sum_{\\pi \\in G} I(\\pi)$$\n\nAlthough Burnside's lemma itself is not so convenient to use in practice (it is unclear how to quickly look for the value $I(\\pi)$, it most clearly reveals the mathematical essence on which the idea of calculating equivalence classes is based.\n\n### Proof of Burnside's lemma\n\nThe proof of Burnside's lemma described here is not important for the practical applications, so it can be skipped on the first reading.\n\nThe proof here is the simplest known, and does not use group theory.\nThe proof was published by Kenneth P. Bogart in 1991.\n\nWe need to prove the following statement:\n\n$$|\\text{Classes}| \\cdot |G| = \\sum_{\\pi \\in G} I(\\pi)$$\n\nThe value on the right side is nothing more than the number of \"invariant pairs\" $(f, \\pi)$, i.e. pairs such that $f \\pi \\equiv f$.\nIt is obvious that we can change the order of summation.\nWe let the sum iterate over all elements $f$ and sum over the values $J(f)$ - the number of permutations for which $f$ is a fixed point.\n\n$$|\\text{Classes}| \\cdot |G| = \\sum_{f} J(f)$$\n\nTo prove this formula we will compose a table with columns labeled with all functions $f_i$ and rows labeled with all permutations $\\pi_j$.\nAnd we fill the cells with $f_i \\pi_j$.\nIf we look at the columns in this table as sets, then some of them will coincide, and this means that the corresponding functions $f$ for these columns are also equivalent.\nThus the numbers of different (as sets) columns is equal to the number of classes.\nIncidentally, from the standpoint of group theory, the column labeled with $f_i$ is the orbit of this element.\nFor equivalent elements the orbits coincides, and the number of orbits gives exactly the number of classes.\n\nThus the columns of the table decompose into equivalence classes.\nLet us fix a class, and look at the columns in it.\nFirst, note that these columns can only contain elements $f_i$ of the equivalence class (otherwise some permutation $\\pi_j$ moved one of the functions into a different equivalence class, which is impossible since we only look at invariant permutations).\nSecondly each element $f_i$ will occur the same number of times in each column (this also follows from the fact that the columns correspond to equivalent elements).\nFrom this we can conclude, that all the columns within the same equivalence class coincide with each other as multisets.\n\nNow fix an arbitrary element $f$.\nOn the one hand, it occurs in its column exactly $J(f)$ times (by definition).\nOn the other hand, all columns within the same equivalence class are the same as multisets.\nTherefore within each column of a given equivalence class any element $g$ occurs exactly $J(g)$ times.\n\nThus if we arbitrarily take one column from each equivalence class, and sum the number of elements in them, we obtain on one hand $|\\text{Classes}| \\cdot |G|$ (simply by multiplying the number of columns by the number of rows), and on the other hand the sum of the quantities $J(f)$ for all $f$ (this follows from all the previous arguments):\n\n$$|\\text{Classes}| \\cdot |G| = \\sum_{f} J(f)$$\n\n## P\u00f3lya enumeration theorem\n\nThe P\u00f3lya enumeration theorem is a generalization of Burnside's lemma, and it also provides a more convenient tool for finding the number of equivalence classes.\nIt should be noted that this theorem was already discovered before P\u00f3lya by Redfield in 1927, but his publication went unnoticed by mathematicians.\nP\u00f3lya independently came to the same results in 1937, and his publication was more successful.\n\nHere we discuss only a special case of the P\u00f3lya enumeration theorem, which will turn out very useful in practice.\nThe general formula of the theorem will not be discussed.\n\nWe denote by $C(\\pi)$ the number of cycles in the permutation $\\pi$.\nThen the following formula (a **special case of the P\u00f3lya enumeration theorem**) holds:\n\n$$|\\text{Classes}| = \\frac{1}{|G|} \\sum_{\\pi \\in G} k^{C(\\pi)}$$\n\n$k$ is the number of values that each representation element can take, in the case of the coloring of a binary tree this would be $k = 2$.\n\n### Evidence\n\nThis formula is a direct consequence of Burnside's lemma.\nTo get it, we just need to find an explicit expression for $I(\\pi)$, which appears in the lemma.\nRecall, that $I(\\pi)$ is the number of fixed points in the permutation $\\pi$.\n\nThus we consider a permutation $\\pi$ and some element $f$.\nDuring the application of $\\pi$, the elements in $f$ move via the cycles in the permutation.\nSince the result should obtain $f \\equiv f \\pi$, the elements touched by one cycle must all be equal.\nAt the same time different cycles are independent.\nThus for each permutation cycle $\\pi$ we can choose one value (among $k$ possible) and thus we get the number of fixed points:\n\n$$I(\\pi) = k^{C(\\pi)}$$\n\n## Application: Coloring necklaces\n\nThe problem \"Necklace\" is one of the classical combinatorial problems.\nThe task is to count the number of different necklaces from $n$ beads, each of which can be painted in one of the $k$ colors.\nWhen comparing two necklaces, they can be rotated, but not reversed (i.e. a cyclic shift is permitted).\n\nIn this problem we can immediately find the group of invariant permutations:\n\n$$\\begin{align}\n\\pi_0 &= 1 2 3 \\dots n\\\\\n\\pi_1 &= 2 3 \\dots n 1\\\\\n\\pi_2 &= 3 \\dots n 12\\\\\n&\\dots\\\\\n\\pi_{n-1} &= n 1 2 3\\dots\\end{align}$$\n\nLet us find an explicit formula for calculating $C(\\pi_i)$.\nFirst we note, that the permutation $\\pi_i$ has at the $j$-th position the value $i + j$ (taken modulo $n$).\nIf we check the cycle structure for $\\pi_i$.\nWe see that $1$ goes to $1 + i$, $1 + i$ goes to $1 + 2i$, which goes to $1 + 3i$, etc., until we come to a number of the form $1 + k n$.\nSimilar statements can be made for the remaining elements.\nHence we see that all cycles have the same length, namely $\\frac{\\text{lcm}(i, n)}{i} = \\frac{n}{\\gcd(i, n)}$.\nThus the number of cycles in $\\pi_i$ will be equal to $\\gcd(i, n)$.\n\nSubstituting these values into the P\u00f3lya enumeration theorem, we obtain the solution:\n\n$$\\frac{1}{n} \\sum_{i=1}^n k^{\\gcd(i, n)}$$\n\nYou can leave this formula in this form, or you can simplify it even more.\nLet transfer the sum so that it iterates over all divisors of $n$.\nIn the original sum there will be many equivalent terms: if $i$ is not a divisor of $n$, then such a divisor can be found after computing $\\gcd(i, n)$.\nTherefore for each divisor $d ~|~ n$ its term $k^{\\gcd(d, n)} = k^d$ will appear in the sum multiple times, i.e. the answer to the problem can be rewritten as\n\n$$\\frac{1}{n} \\sum_{d ~|~ n} C_d k^d,$$\n\nwhere $C_d$ is the number of such numbers $i$ with $\\gcd(i, n) = d$.\nWe can find an explicit expression for this value.\nAny such number $i$ has the form $i = d j$ with $\\gcd(j, n / d) = 1$ (otherwise $\\gcd(i, n) > d$).\nSo we can count the number of $j$ with this behavior.\n[Euler's phi function](../algebra/phi-function.md) gives us the result $C_d = \\phi(n / d)$, and therefore we get the answer:\n\n$$\\frac{1}{n} \\sum_{d ~|~ n} \\phi\\left(\\frac{n}{d}\\right) k^d$$\n\n## Application: Coloring a torus\n\nQuite often we cannot obtain an explicit formula for the number of equivalence classes.\nIn many problems the number of permutations in a group can be too large for manual calculations and it is not possible to compute analytically the number of cycles in them.\n\nIn that case we should manually find several \"basic\" permutations, so that they can generate the entire group $G$.\nNext we can write a program that will generate all permutations of the group $G$, count the number of cycles in them, and compute the answer with the formula.\n\nConsider the example of the problem for coloring a torus.\nThere is a checkered sheet of paper $n \\times m$ ($n < m$), some of the cells are black.\nThen a cylinder is obtained from this sheet by gluing together the two sides with lengths $m$.\nThen a torus is obtained from the cylinder by gluing together the two circles (top and bottom) without twisting.\nThe task is to compute the number of different colored tori, assuming that we cannot see the glued lines, and the torus can be turned and turned.\n\nWe again start with a piece of $n \\times m$ paper.\nIt is easy to see that the following types of transformations preserve the equivalence class:\na cyclic shift of the rows, a cyclic shift of the columns, and a rotation of the sheet by 180 degrees.\nIt is also easy to see, that these transformations can generate the entire group of invariant transformations.\nIf we somehow number the cells of the paper, then we can write three permutations $p_1$, $p_2$, $p_3$ corresponding to these types of transformation.\n\nNext it only remains to generate all permutations obtained as a product.\nIt is obvious that all such permutations have the form $p_1^{i_1} p_2^{i_2} p_3^{i_3}$ where $i_1 = 0 \\dots m-1$, $i_2 = 0 \\dots n-1$, $i_3 = 0 \\dots 1$.\n\nThus we can write the implementations to this problem.\n\n```{.cpp file=burnside_tori}\nusing Permutation = vector<int>;\n\nvoid operator*=(Permutation& p, Permutation const& q) {\n    Permutation copy = p;\n    for (int i = 0; i < p.size(); i++)\n        p[i] = copy[q[i]];\n}\n\nint count_cycles(Permutation p) {\n    int cnt = 0;\n    for (int i = 0; i < p.size(); i++) {\n        if (p[i] != -1) {\n            cnt++;\n            for (int j = i; p[j] != -1;) {\n                int next = p[j];\n                p[j] = -1;\n                j = next;\n            }\n        }\n    }\n    return cnt;\n}\n\nint solve(int n, int m) {\n    Permutation p(n*m), p1(n*m), p2(n*m), p3(n*m);\n    for (int i = 0; i < n*m; i++) {\n        p[i] = i;\n        p1[i] = (i % n + 1) % n + i / n * n;\n        p2[i] = (i / n + 1) % m * n + i % n;\n        p3[i] = (m - 1 - i / n) * n + (n - 1 - i % n);\n    }\n\n    set<Permutation> s;\n    for (int i1 = 0; i1 < n; i1++) {\n        for (int i2 = 0; i2 < m; i2++) {\n            for (int i3 = 0; i3 < 2; i3++) {\n                s.insert(p);\n                p *= p3;\n            }\n            p *= p2;\n        }\n        p *= p1;\n    }\n\n    int sum = 0;\n    for (Permutation const& p : s) {\n        sum += 1 << count_cycles(p);\n    }\n    return sum / s.size();\n}\n```\n", "problem_ids": [], "title": "Burnside's lemma / P\u00f3lya enumeration theorem"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: counting_connected_graphs\n---\n\n# Counting labeled graphs\n\n## Labeled graphs\n\nLet the number of vertices in a graph be $n$.\nWe have to compute the number $G_n$ of labeled graphs with $n$ vertices (labeled means that the vertices are marked with the numbers from $1$ to $n$).\nThe edges of the graphs are considered undirected, and loops and multiple edges are forbidden.\n\nWe consider the set of all possible edges of the graph.\nFor each edge $(i, j)$ we can assume that $i < j$ (because the graph is undirected, and there are no loops).\nTherefore the set of all edges has the cardinality $\\binom{n}{2}$, i.e. $\\frac{n(n-1)}{2}$.\n\nSince any labeled graph is uniquely determined by its edges, the number of labeled graphs with $n$ vertices is equal to:\n\n$$G_n = 2^{\\frac{n(n-1)}{2}}$$\n\n## Connected labeled graphs\n\nHere, we additionally impose the restriction that the graph has to be connected.\n\nLet's denote the required number of connected graphs with $n$ vertices as $C_n$.\n\nWe will first discuss how many **disconnected** graphs exists.\nThen the number of connected graphs will be $G_n$ minus the number of disconnected graphs.\nEven more, we will count the number of **disconnected, rooted graphs**.A rooted graph is a graph, where we emphasize one vertex by labeling it as root.\nObviously we have $n$ possibilities to root a graph with $n$ labeled vertices, therefore we will need to divide the number of disconnected rooted graphs by $n$ at the end to get the number of disconnected graphs.\n\nThe root vertex will appear in a connected component of size $1, \\dots n-1$.\nThere are $k \\binom{n}{k} C_k G_{n-k}$ graphs such that the root vertex is in a connected component with $k$ vertices (there are $\\binom{n}{k}$ ways to choose $k$ vertices for the component, these are connected in one of $C_k$ ways, the root vertex can be any of the $k$ vertices, and the remainder $n-k$ vertices can be connected/disconnected in any way, which gives a factor of $G_{n-k}$).\nTherefore the number of disconnected graphs with $n$ vertices is:\n\n$$\\frac{1}{n} \\sum_{k=1}^{n-1} k \\binom{n}{k} C_k G_{n-k}$$\n\nAnd finally the number of connected graphs is:\n\n$$C_n = G_n - \\frac{1}{n} \\sum_{k=1}^{n-1} k \\binom{n}{k} C_k G_{n-k}$$\n\n## Labeled graphs with $k$ connected components {data-toc-label=\"Labeled graphs with k connected components\"}\n\nBased on the formula from the previous section, we will learn how to count the number of labeled graphs with $n$ vertices and $k$ connected components.\n\nThis number can be computed using dynamic programming.\nWe will compute $D[i][j]$ - the number of labeled graphs with $i$ vertices and $j$ components - for each $i \\le n$ and $j \\le k$.\n\nLet's discuss how to compute the next element $D[n][k]$ if we already know the previous values.\nWe use a common approach, we take the last vertex (index $n$).\nThis vertex belongs to some component.\nIf the size of this component be $s$, then there are $\\binom{n-1}{s-1}$ ways to choose such a set of vertices, and $C_s$ ways to connect them.After removing this component from the graph we have $n-s$ remaining vertices with $k-1$ connected components.\nTherefore we obtain the following recurrence relation:\n\n$$D[n][k] = \\sum_{s=1}^{n} \\binom{n-1}{s-1} C_s D[n-s][k-1]$$\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: counting_connected_graphs\n---\n\n# Counting labeled graphs\n\n## Labeled graphs\n\nLet the number of vertices in a graph be $n$.\nWe have to compute the number $G_n$ of labeled graphs with $n$ vertices (labeled means that the vertices are marked with the numbers from $1$ to $n$).\nThe edges of the graphs are considered undirected, and loops and multiple edges are forbidden.\n\nWe consider the set of all possible edges of the graph.\nFor each edge $(i, j)$ we can assume that $i < j$ (because the graph is undirected, and there are no loops).\nTherefore the set of all edges has the cardinality $\\binom{n}{2}$, i.e. $\\frac{n(n-1)}{2}$.\n\nSince any labeled graph is uniquely determined by its edges, the number of labeled graphs with $n$ vertices is equal to:\n\n$$G_n = 2^{\\frac{n(n-1)}{2}}$$\n\n## Connected labeled graphs\n\nHere, we additionally impose the restriction that the graph has to be connected.\n\nLet's denote the required number of connected graphs with $n$ vertices as $C_n$.\n\nWe will first discuss how many **disconnected** graphs exists.\nThen the number of connected graphs will be $G_n$ minus the number of disconnected graphs.\nEven more, we will count the number of **disconnected, rooted graphs**.A rooted graph is a graph, where we emphasize one vertex by labeling it as root.\nObviously we have $n$ possibilities to root a graph with $n$ labeled vertices, therefore we will need to divide the number of disconnected rooted graphs by $n$ at the end to get the number of disconnected graphs.\n\nThe root vertex will appear in a connected component of size $1, \\dots n-1$.\nThere are $k \\binom{n}{k} C_k G_{n-k}$ graphs such that the root vertex is in a connected component with $k$ vertices (there are $\\binom{n}{k}$ ways to choose $k$ vertices for the component, these are connected in one of $C_k$ ways, the root vertex can be any of the $k$ vertices, and the remainder $n-k$ vertices can be connected/disconnected in any way, which gives a factor of $G_{n-k}$).\nTherefore the number of disconnected graphs with $n$ vertices is:\n\n$$\\frac{1}{n} \\sum_{k=1}^{n-1} k \\binom{n}{k} C_k G_{n-k}$$\n\nAnd finally the number of connected graphs is:\n\n$$C_n = G_n - \\frac{1}{n} \\sum_{k=1}^{n-1} k \\binom{n}{k} C_k G_{n-k}$$\n\n## Labeled graphs with $k$ connected components {data-toc-label=\"Labeled graphs with k connected components\"}\n\nBased on the formula from the previous section, we will learn how to count the number of labeled graphs with $n$ vertices and $k$ connected components.\n\nThis number can be computed using dynamic programming.\nWe will compute $D[i][j]$ - the number of labeled graphs with $i$ vertices and $j$ components - for each $i \\le n$ and $j \\le k$.\n\nLet's discuss how to compute the next element $D[n][k]$ if we already know the previous values.\nWe use a common approach, we take the last vertex (index $n$).\nThis vertex belongs to some component.\nIf the size of this component be $s$, then there are $\\binom{n-1}{s-1}$ ways to choose such a set of vertices, and $C_s$ ways to connect them.After removing this component from the graph we have $n-s$ remaining vertices with $k-1$ connected components.\nTherefore we obtain the following recurrence relation:\n\n$$D[n][k] = \\sum_{s=1}^{n} \\binom{n-1}{s-1} C_s D[n-s][k-1]$$\n", "problem_ids": [], "title": "Counting labeled graphs"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: bracket_sequences\n---\n\n# Balanced bracket sequences\n\nA **balanced bracket sequence** is a string consisting of only brackets, such that this sequence, when inserted certain numbers and mathematical operations, gives a valid mathematical expression.\nFormally you can define balanced bracket sequence with:\n\n- $e$ (the empty string) is a balanced bracket sequence.\n- if $s$ is a balanced bracket sequence, then so is $(s)$.\n- if $s$ and $t$ are balanced bracket sequences, then so is $s t$.\n\nFor instance $(())()$ is a balanced bracket sequence, but $())($ is not.\n\nOf course you can define other bracket sequences also with multiple bracket types in a similar fashion.\n\nIn this article we discuss some classic problems involving balanced bracket sequences (for simplicity we will only call them sequences): validation, number of sequences, finding the lexicographical next sequence, generating all sequences of a certain size, finding the index of sequence, and generating the $k$-th sequences.\nWe will also discuss two variations for the problems, the simpler version when only one type of brackets is allowed, and the harder case when there are multiple types.\n\n## Balance validation\n\nWe want to check if a given string is balanced or not.\n\nAt first suppose there is only one type of bracket.\nFor this case there exists a very simple algorithm.\nLet $\\text{depth}$ be the current number of open brackets.\nInitially $\\text{depth} = 0$.\nWe iterate over all character of the string, if the current bracket character is an opening bracket, then we increment $\\text{depth}$, otherwise we decrement it.\nIf at any time the variable $\\text{depth}$ gets negative, or at the end it is different from $0$, then the string is not a balanced sequence.\nOtherwise it is.\n\nIf there are several bracket types involved, then the algorithm needs to be changes.\nInstead of a counter $\\text{depth}$ we create a stack, in which we will store all opening brackets that we meet.\nIf the current bracket character is an opening one, we put it onto the stack.\nIf it is a closing one, then we check if the stack is non-empty, and if the top element of the stack is of the same type as the current closing bracket.\nIf both conditions are fulfilled, then we remove the opening bracket from the stack.\nIf at any time one of the conditions is not fulfilled, or at the end the stack is not empty, then the string is not balanced.\nOtherwise it is.\n\n## Number of balanced sequences\n\n### Formula\n\nThe number of balanced bracket sequences with only one bracket type can be calculated using the [Catalan numbers](catalan-numbers.md).\nThe number of balanced bracket sequences of length $2n$ ($n$ pairs of brackets) is:\n\n$$\\frac{1}{n+1} \\binom{2n}{n}$$\n\nIf we allow $k$ types of brackets, then each pair be of any of the $k$ types (independently of the others), thus the number of balanced bracket sequences is:\n\n$$\\frac{1}{n+1} \\binom{2n}{n} k^n$$\n\n### Dynamic programming\n\nOn the other hand these numbers can be computed using **dynamic programming**.\nLet $d[n]$ be the number of regular bracket sequences with $n$ pairs of bracket.\nNote that in the first position there is always an opening bracket.\nAnd somewhere later is the corresponding closing bracket of the pair.\nIt is clear that inside this pair there is a balanced bracket sequence, and similarly after this pair there is a balanced bracket sequence.\nSo to compute $d[n]$, we will look at how many balanced sequences of $i$ pairs of brackets are inside this first bracket pair, and how many balanced sequences with $n-1-i$ pairs are after this pair.\nConsequently the formula has the form:\n\n$$d[n] = \\sum_{i=0}^{n-1} d[i] \\cdot d[n-1-i]$$\n\nThe initial value for this recurrence is $d[0] = 1$.\n\n## Finding the lexicographical next balanced sequence\n\nHere we only consider the case with one valid bracket type.\n\nGiven a balanced sequence, we have to find the next (in lexicographical order) balanced sequence.\n\nIt should be obvious, that we have to find the rightmost opening bracket, which we can replace by a closing bracket without violation the condition, that there are more closing brackets than opening brackets up to this position.\nAfter replacing this position, we can fill the remaining part of the string with the lexicographically minimal one: i.e. first with as much opening brackets as possible, and then fill up the remaining positions with closing brackets.\nIn other words we try to leave a long as possible prefix unchanged, and the suffix gets replaced by the lexicographically minimal one.\n\nTo find this position, we can iterate over the character from right to left, and maintain the balance $\\text{depth}$ of open and closing brackets.\nWhen we meet an opening brackets, we will decrement $\\text{depth}$, and when we meet a closing bracket, we increase it.\nIf we are at some point meet an opening bracket, and the balance after processing this symbol is positive, then we have found the rightmost position that we can change.\nWe change the symbol, compute the number of opening and closing brackets that we have to add to the right side, and arrange them in the lexicographically minimal way.\n\nIf we find do suitable position, then this sequence is already the maximal possible one, and there is no answer.\n\n```{.cpp file=next_balanced_brackets_sequence}\nbool next_balanced_sequence(string & s) {\n    int n = s.size();\n    int depth = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == '(')\n            depth--;\n        else\n            depth++;\n\n        if (s[i] == '(' && depth > 0) {\n            depth--;\n            int open = (n - i - 1 - depth) / 2;\n            int close = n - i - 1 - open;\n            string next = s.substr(0, i) + ')' + string(open, '(') + string(close, ')');\n            s.swap(next);\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nThis function computes in $O(n)$ time the next balanced bracket sequence, and returns false if there is no next one.\n\n## Finding all balanced sequences\n\nSometimes it is required to find and output all balanced bracket sequences of a specific length $n$.\n\nTo generate then, we can start with the lexicographically smallest sequence $((\\dots(())\\dots))$, and then continue to find the next lexicographically sequences with the algorithm described in the previous section.\n\nHowever, if the length of the sequence is not very long (e.g. $n$ smaller than $12$), then we can also generate all permutations conveniently with the C++ STL function `next_permutation`, and check each one for balanceness.\n\nAlso they can be generate using the ideas we used for counting all sequences with dynamic programming.\nWe will discuss the ideas in the next two sections.\n\n## Sequence index\n\nGiven a balanced bracket sequence with $n$ pairs of brackets.\nWe have to find its index in the lexicographically ordered list of all balanced sequences with $n$ bracket pairs.\n\nLet's define an auxiliary array $d[i][j]$, where $i$ is the length of the bracket sequence (semi-balanced, each closing bracket has a corresponding opening bracket, but not every opening bracket has necessarily a corresponding closing one), and $j$ is the current balance (difference between opening and closing brackets).\n$d[i][j]$ is the number of such sequences that fit the parameters.\nWe will calculate these numbers with only one bracket type.\n\nFor the start value $i = 0$ the answer is obvious: $d[0][0] = 1$, and $d[0][j] = 0$ for $j > 0$.\nNow let $i > 0$, and we look at the last character in the sequence.\nIf the last character was an opening bracket $($, then the state before was $(i-1, j-1)$, if it was a closing bracket $)$, then the previous state was $(i-1, j+1)$.\nThus we obtain the recursion formula:\n\n$$d[i][j] = d[i-1][j-1] + d[i-1][j+1]$$\n\n$d[i][j] = 0$ holds obviously for negative $j$.\nThus we can compute this array in $O(n^2)$.\n\nNow let us generate the index for a given sequence.\n\nFirst let there be only one type of brackets.\nWe will us the counter $\\text{depth}$ which tells us how nested we currently are, and iterate over the characters of the sequence.\nIf the current character $s[i]$ is equal to $($, then we increment $\\text{depth}$.\nIf the current character $s[i]$ is equal to $)$, then we must add $d[2n-i-1][\\text{depth}+1]$ to the answer, taking all possible endings starting with a $($ into account (which are lexicographically smaller sequences), and then decrement $\\text{depth}$.\n\nNew let there be $k$ different bracket types.\n\nThus, when we look at the current character $s[i]$ before recomputing $\\text{depth}$, we have to go through all bracket types that are smaller than the current character, and try to put this bracket into the current position (obtaining a new balance $\\text{ndepth} = \\text{depth} \\pm 1$), and add the number of ways to finish the sequence (length $2n-i-1$, balance $ndepth$) to the answer:\n\n$$d[2n - i - 1][\\text{ndepth}] \\cdot k^{\\frac{2n - i - 1 - ndepth}{2}}$$\n\nThis formula can be derived as follows:\nFirst we \"forget\" that there are multiple bracket types, and just take the answer $d[2n - i - 1][\\text{ndepth}]$.\nNow we consider how the answer will change is we have $k$ types of brackets.\nWe have $2n - i - 1$ undefined positions, of which $\\text{ndepth}$ are already predetermined because of the opening brackets.\nBut all the other brackets ($(2n - i - 1 - \\text{ndepth})/2$ pairs) can be of any type, therefore we multiply the number by such a power of $k$.\n\n## Finding the $k$-th sequence {data-toc-label=\"Finding the k-th sequence\"}\n\nLet $n$ be the number of bracket pairs in the sequence.\nWe have to find the $k$-th balanced sequence in lexicographically sorted list of all balanced sequences for a given $k$.\n\nAs in the previous section we compute the auxiliary array $d[i][j]$, the number of semi-balanced bracket sequences of length $i$ with balance $j$.\n\nFirst, we start with only one bracket type.\n\nWe will iterate over the characters in the string we want to generate.\nAs in the previous problem we store a counter $\\text{depth}$, the current nesting depth.\nIn each position we have to decide if we use an opening of a closing bracket.\nTo have to put an opening bracket character, it $d[2n - i - 1][\\text{depth}+1] \\ge k$.\nWe increment the counter $\\text{depth}$, and move on to the next character.\nOtherwise we decrement $k$ by $d[2n - i - 1][\\text{depth}+1]$, put a closing bracket and move on.\n\n```{.cpp file=kth_balances_bracket}\nstring kth_balanced(int n, int k) {\n    vector<vector<int>> d(2*n+1, vector<int>(n+1, 0));\n    d[0][0] = 1;\n    for (int i = 1; i <= 2*n; i++) {\n        d[i][0] = d[i-1][1];\n        for (int j = 1; j < n; j++)\n            d[i][j] = d[i-1][j-1] + d[i-1][j+1];\n        d[i][n] = d[i-1][n-1];\n    }\n\n    string ans;\n    int depth = 0;\n    for (int i = 0; i < 2*n; i++) {\n        if (depth + 1 <= n && d[2*n-i-1][depth+1] >= k) {\n            ans += '(';\n            depth++;\n        } else {\n            ans += ')';\n            if (depth + 1 <= n)\n                k -= d[2*n-i-1][depth+1];\n            depth--;\n        }\n    }\n    return ans;\n}\n```\n\nNow let there be $k$ types of brackets.\nThe solution will only differ slightly in that we have to multiply the value $d[2n-i-1][\\text{ndepth}]$ by $k^{(2n-i-1-\\text{ndepth})/2}$ and take into account that there can be different bracket types for the next character.\n\nHere is an implementation using two types of brackets: round and square:\n\n```{.cpp file=kth_balances_bracket_multiple}\nstring kth_balanced2(int n, int k) {\n    vector<vector<int>> d(2*n+1, vector<int>(n+1, 0));\n    d[0][0] = 1;\n    for (int i = 1; i <= 2*n; i++) {\n        d[i][0] = d[i-1][1];\n        for (int j = 1; j < n; j++)\n            d[i][j] = d[i-1][j-1] + d[i-1][j+1];\n        d[i][n] = d[i-1][n-1];\n    }\n\n    string ans;\n    int shift, depth = 0;\n\n    stack<char> st;\n    for (int i = 0; i < 2*n; i++) {\n\n        // '('\n        shift = ((2*n-i-1-depth-1) / 2);\n        if (shift >= 0 && depth + 1 <= n) {\n            int cnt = d[2*n-i-1][depth+1] << shift;\n            if (cnt >= k) {\n                ans += '(';\n                st.push('(');\n                depth++;\n                continue;\n            }\n            k -= cnt;\n        }\n\n        // ')'\n        shift = ((2*n-i-1-depth+1) / 2);\n        if (shift >= 0 && depth && st.top() == '(') {\n            int cnt = d[2*n-i-1][depth-1] << shift;\n            if (cnt >= k) {\n                ans += ')';\n                st.pop();\n                depth--;\n                continue;\n            }\n            k -= cnt;\n        }\n            \n        // '['\n        shift = ((2*n-i-1-depth-1) / 2);\n        if (shift >= 0 && depth + 1 <= n) {\n            int cnt = d[2*n-i-1][depth+1] << shift;\n            if (cnt >= k) {\n                ans += '[';\n                st.push('[');\n                depth++;\n                continue;\n            }\n            k -= cnt;\n        }\n\n        // ']'\n        ans += ']';\n        st.pop();\n        depth--;\n    }\n    return ans;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: bracket_sequences\n---\n\n# Balanced bracket sequences\n\nA **balanced bracket sequence** is a string consisting of only brackets, such that this sequence, when inserted certain numbers and mathematical operations, gives a valid mathematical expression.\nFormally you can define balanced bracket sequence with:\n\n- $e$ (the empty string) is a balanced bracket sequence.\n- if $s$ is a balanced bracket sequence, then so is $(s)$.\n- if $s$ and $t$ are balanced bracket sequences, then so is $s t$.\n\nFor instance $(())()$ is a balanced bracket sequence, but $())($ is not.\n\nOf course you can define other bracket sequences also with multiple bracket types in a similar fashion.\n\nIn this article we discuss some classic problems involving balanced bracket sequences (for simplicity we will only call them sequences): validation, number of sequences, finding the lexicographical next sequence, generating all sequences of a certain size, finding the index of sequence, and generating the $k$-th sequences.\nWe will also discuss two variations for the problems, the simpler version when only one type of brackets is allowed, and the harder case when there are multiple types.\n\n## Balance validation\n\nWe want to check if a given string is balanced or not.\n\nAt first suppose there is only one type of bracket.\nFor this case there exists a very simple algorithm.\nLet $\\text{depth}$ be the current number of open brackets.\nInitially $\\text{depth} = 0$.\nWe iterate over all character of the string, if the current bracket character is an opening bracket, then we increment $\\text{depth}$, otherwise we decrement it.\nIf at any time the variable $\\text{depth}$ gets negative, or at the end it is different from $0$, then the string is not a balanced sequence.\nOtherwise it is.\n\nIf there are several bracket types involved, then the algorithm needs to be changes.\nInstead of a counter $\\text{depth}$ we create a stack, in which we will store all opening brackets that we meet.\nIf the current bracket character is an opening one, we put it onto the stack.\nIf it is a closing one, then we check if the stack is non-empty, and if the top element of the stack is of the same type as the current closing bracket.\nIf both conditions are fulfilled, then we remove the opening bracket from the stack.\nIf at any time one of the conditions is not fulfilled, or at the end the stack is not empty, then the string is not balanced.\nOtherwise it is.\n\n## Number of balanced sequences\n\n### Formula\n\nThe number of balanced bracket sequences with only one bracket type can be calculated using the [Catalan numbers](catalan-numbers.md).\nThe number of balanced bracket sequences of length $2n$ ($n$ pairs of brackets) is:\n\n$$\\frac{1}{n+1} \\binom{2n}{n}$$\n\nIf we allow $k$ types of brackets, then each pair be of any of the $k$ types (independently of the others), thus the number of balanced bracket sequences is:\n\n$$\\frac{1}{n+1} \\binom{2n}{n} k^n$$\n\n### Dynamic programming\n\nOn the other hand these numbers can be computed using **dynamic programming**.\nLet $d[n]$ be the number of regular bracket sequences with $n$ pairs of bracket.\nNote that in the first position there is always an opening bracket.\nAnd somewhere later is the corresponding closing bracket of the pair.\nIt is clear that inside this pair there is a balanced bracket sequence, and similarly after this pair there is a balanced bracket sequence.\nSo to compute $d[n]$, we will look at how many balanced sequences of $i$ pairs of brackets are inside this first bracket pair, and how many balanced sequences with $n-1-i$ pairs are after this pair.\nConsequently the formula has the form:\n\n$$d[n] = \\sum_{i=0}^{n-1} d[i] \\cdot d[n-1-i]$$\n\nThe initial value for this recurrence is $d[0] = 1$.\n\n## Finding the lexicographical next balanced sequence\n\nHere we only consider the case with one valid bracket type.\n\nGiven a balanced sequence, we have to find the next (in lexicographical order) balanced sequence.\n\nIt should be obvious, that we have to find the rightmost opening bracket, which we can replace by a closing bracket without violation the condition, that there are more closing brackets than opening brackets up to this position.\nAfter replacing this position, we can fill the remaining part of the string with the lexicographically minimal one: i.e. first with as much opening brackets as possible, and then fill up the remaining positions with closing brackets.\nIn other words we try to leave a long as possible prefix unchanged, and the suffix gets replaced by the lexicographically minimal one.\n\nTo find this position, we can iterate over the character from right to left, and maintain the balance $\\text{depth}$ of open and closing brackets.\nWhen we meet an opening brackets, we will decrement $\\text{depth}$, and when we meet a closing bracket, we increase it.\nIf we are at some point meet an opening bracket, and the balance after processing this symbol is positive, then we have found the rightmost position that we can change.\nWe change the symbol, compute the number of opening and closing brackets that we have to add to the right side, and arrange them in the lexicographically minimal way.\n\nIf we find do suitable position, then this sequence is already the maximal possible one, and there is no answer.\n\n```{.cpp file=next_balanced_brackets_sequence}\nbool next_balanced_sequence(string & s) {\n    int n = s.size();\n    int depth = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == '(')\n            depth--;\n        else\n            depth++;\n\n        if (s[i] == '(' && depth > 0) {\n            depth--;\n            int open = (n - i - 1 - depth) / 2;\n            int close = n - i - 1 - open;\n            string next = s.substr(0, i) + ')' + string(open, '(') + string(close, ')');\n            s.swap(next);\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nThis function computes in $O(n)$ time the next balanced bracket sequence, and returns false if there is no next one.\n\n## Finding all balanced sequences\n\nSometimes it is required to find and output all balanced bracket sequences of a specific length $n$.\n\nTo generate then, we can start with the lexicographically smallest sequence $((\\dots(())\\dots))$, and then continue to find the next lexicographically sequences with the algorithm described in the previous section.\n\nHowever, if the length of the sequence is not very long (e.g. $n$ smaller than $12$), then we can also generate all permutations conveniently with the C++ STL function `next_permutation`, and check each one for balanceness.\n\nAlso they can be generate using the ideas we used for counting all sequences with dynamic programming.\nWe will discuss the ideas in the next two sections.\n\n## Sequence index\n\nGiven a balanced bracket sequence with $n$ pairs of brackets.\nWe have to find its index in the lexicographically ordered list of all balanced sequences with $n$ bracket pairs.\n\nLet's define an auxiliary array $d[i][j]$, where $i$ is the length of the bracket sequence (semi-balanced, each closing bracket has a corresponding opening bracket, but not every opening bracket has necessarily a corresponding closing one), and $j$ is the current balance (difference between opening and closing brackets).\n$d[i][j]$ is the number of such sequences that fit the parameters.\nWe will calculate these numbers with only one bracket type.\n\nFor the start value $i = 0$ the answer is obvious: $d[0][0] = 1$, and $d[0][j] = 0$ for $j > 0$.\nNow let $i > 0$, and we look at the last character in the sequence.\nIf the last character was an opening bracket $($, then the state before was $(i-1, j-1)$, if it was a closing bracket $)$, then the previous state was $(i-1, j+1)$.\nThus we obtain the recursion formula:\n\n$$d[i][j] = d[i-1][j-1] + d[i-1][j+1]$$\n\n$d[i][j] = 0$ holds obviously for negative $j$.\nThus we can compute this array in $O(n^2)$.\n\nNow let us generate the index for a given sequence.\n\nFirst let there be only one type of brackets.\nWe will us the counter $\\text{depth}$ which tells us how nested we currently are, and iterate over the characters of the sequence.\nIf the current character $s[i]$ is equal to $($, then we increment $\\text{depth}$.\nIf the current character $s[i]$ is equal to $)$, then we must add $d[2n-i-1][\\text{depth}+1]$ to the answer, taking all possible endings starting with a $($ into account (which are lexicographically smaller sequences), and then decrement $\\text{depth}$.\n\nNew let there be $k$ different bracket types.\n\nThus, when we look at the current character $s[i]$ before recomputing $\\text{depth}$, we have to go through all bracket types that are smaller than the current character, and try to put this bracket into the current position (obtaining a new balance $\\text{ndepth} = \\text{depth} \\pm 1$), and add the number of ways to finish the sequence (length $2n-i-1$, balance $ndepth$) to the answer:\n\n$$d[2n - i - 1][\\text{ndepth}] \\cdot k^{\\frac{2n - i - 1 - ndepth}{2}}$$\n\nThis formula can be derived as follows:\nFirst we \"forget\" that there are multiple bracket types, and just take the answer $d[2n - i - 1][\\text{ndepth}]$.\nNow we consider how the answer will change is we have $k$ types of brackets.\nWe have $2n - i - 1$ undefined positions, of which $\\text{ndepth}$ are already predetermined because of the opening brackets.\nBut all the other brackets ($(2n - i - 1 - \\text{ndepth})/2$ pairs) can be of any type, therefore we multiply the number by such a power of $k$.\n\n## Finding the $k$-th sequence {data-toc-label=\"Finding the k-th sequence\"}\n\nLet $n$ be the number of bracket pairs in the sequence.\nWe have to find the $k$-th balanced sequence in lexicographically sorted list of all balanced sequences for a given $k$.\n\nAs in the previous section we compute the auxiliary array $d[i][j]$, the number of semi-balanced bracket sequences of length $i$ with balance $j$.\n\nFirst, we start with only one bracket type.\n\nWe will iterate over the characters in the string we want to generate.\nAs in the previous problem we store a counter $\\text{depth}$, the current nesting depth.\nIn each position we have to decide if we use an opening of a closing bracket.\nTo have to put an opening bracket character, it $d[2n - i - 1][\\text{depth}+1] \\ge k$.\nWe increment the counter $\\text{depth}$, and move on to the next character.\nOtherwise we decrement $k$ by $d[2n - i - 1][\\text{depth}+1]$, put a closing bracket and move on.\n\n```{.cpp file=kth_balances_bracket}\nstring kth_balanced(int n, int k) {\n    vector<vector<int>> d(2*n+1, vector<int>(n+1, 0));\n    d[0][0] = 1;\n    for (int i = 1; i <= 2*n; i++) {\n        d[i][0] = d[i-1][1];\n        for (int j = 1; j < n; j++)\n            d[i][j] = d[i-1][j-1] + d[i-1][j+1];\n        d[i][n] = d[i-1][n-1];\n    }\n\n    string ans;\n    int depth = 0;\n    for (int i = 0; i < 2*n; i++) {\n        if (depth + 1 <= n && d[2*n-i-1][depth+1] >= k) {\n            ans += '(';\n            depth++;\n        } else {\n            ans += ')';\n            if (depth + 1 <= n)\n                k -= d[2*n-i-1][depth+1];\n            depth--;\n        }\n    }\n    return ans;\n}\n```\n\nNow let there be $k$ types of brackets.\nThe solution will only differ slightly in that we have to multiply the value $d[2n-i-1][\\text{ndepth}]$ by $k^{(2n-i-1-\\text{ndepth})/2}$ and take into account that there can be different bracket types for the next character.\n\nHere is an implementation using two types of brackets: round and square:\n\n```{.cpp file=kth_balances_bracket_multiple}\nstring kth_balanced2(int n, int k) {\n    vector<vector<int>> d(2*n+1, vector<int>(n+1, 0));\n    d[0][0] = 1;\n    for (int i = 1; i <= 2*n; i++) {\n        d[i][0] = d[i-1][1];\n        for (int j = 1; j < n; j++)\n            d[i][j] = d[i-1][j-1] + d[i-1][j+1];\n        d[i][n] = d[i-1][n-1];\n    }\n\n    string ans;\n    int shift, depth = 0;\n\n    stack<char> st;\n    for (int i = 0; i < 2*n; i++) {\n\n        // '('\n        shift = ((2*n-i-1-depth-1) / 2);\n        if (shift >= 0 && depth + 1 <= n) {\n            int cnt = d[2*n-i-1][depth+1] << shift;\n            if (cnt >= k) {\n                ans += '(';\n                st.push('(');\n                depth++;\n                continue;\n            }\n            k -= cnt;\n        }\n\n        // ')'\n        shift = ((2*n-i-1-depth+1) / 2);\n        if (shift >= 0 && depth && st.top() == '(') {\n            int cnt = d[2*n-i-1][depth-1] << shift;\n            if (cnt >= k) {\n                ans += ')';\n                st.pop();\n                depth--;\n                continue;\n            }\n            k -= cnt;\n        }\n            \n        // '['\n        shift = ((2*n-i-1-depth-1) / 2);\n        if (shift >= 0 && depth + 1 <= n) {\n            int cnt = d[2*n-i-1][depth+1] << shift;\n            if (cnt >= k) {\n                ans += '[';\n                st.push('[');\n                depth++;\n                continue;\n            }\n            k -= cnt;\n        }\n\n        // ']'\n        ans += ']';\n        st.pop();\n        depth--;\n    }\n    return ans;\n}\n```\n", "problem_ids": [], "title": "Balanced bracket sequences"}, {"article": "---\ntags:\n  - Original\n---\n\n# Stars and bars\n\nStars and bars is a mathematical technique for solving certain combinatorial problems.\nIt occurs whenever you want to count the number of ways to group identical objects.\n\n## Theorem\n\nThe number of ways to put $n$ identical objects into $k$ labeled boxes is\n\n$$\\binom{n + k - 1}{n}.$$\n\nThe proof involves turning the objects into stars and separating the boxes using bars (therefore the name).\nE.g. we can represent with $\\bigstar | \\bigstar \\bigstar |~| \\bigstar \\bigstar$ the following situation:\nin the first box is one object, in the second box are two objects, the third one is empty and in the last box are two objects.\nThis is one way of dividing 5 objects into 4 boxes.\n\nIt should be pretty obvious, that every partition can be represented using $n$ stars and $k - 1$ bars and every stars and bars permutation using $n$ stars and $k - 1$ bars represents one partition.\nTherefore the number of ways to divide $n$ identical objects into $k$ labeled boxes is the same number as there are permutations of $n$ stars and $k - 1$ bars.\nThe [Binomial Coefficient](binomial-coefficients.md) gives us the desired formula.\n\n## Number of non-negative integer sums\n\nThis problem is a direct application of the theorem.\n\nYou want to count the number of solution of the equation \n\n$$x_1 + x_2 + \\dots + x_k = n$$\n\nwith $x_i \\ge 0$.\n\nAgain we can represent a solution using stars and bars.\nE.g. the solution $1 + 3 + 0 = 4$ for $n = 4$, $k = 3$ can be represented using $\\bigstar | \\bigstar \\bigstar \\bigstar |$.\n\nIt is easy to see, that this is exactly the stars and bars theorem.\nTherefore the solution is $\\binom{n + k - 1}{n}$.\n\n## Number of lower-bound integer sums\n\nThis can easily be extended to integer sums with different lower bounds.\nI.e. we want to count the number of solutions for  the equation\n\n$$x_1 + x_2 + \\dots + x_k = n$$\n\nwith $x_i \\ge a_i$.\n\nAfter substituting $x_i' := x_i - a_i$ we receive the modified equation\n\n$$(x_1' + a_i) + (x_2' + a_i) + \\dots + (x_k' + a_k) = n$$\n\n$$\\Leftrightarrow ~ ~ x_1' + x_2' + \\dots + x_k' = n - a_1 - a_2 - \\dots - a_k$$\n\nwith $x_i' \\ge 0$.\nSo we have reduced the problem to the simpler case with $x_i' \\ge 0$ and again can apply the stars and bars theorem.\n\n## Number of upper-bound integer sums\n\nWith some help of the [Inclusion-Exclusion Principle](./inclusion-exclusion.md), you can also restrict the integers with upper bounds.\nSee the [Number of upper-bound integer sums](./inclusion-exclusion.md#number-of-upper-bound-integer-sums) section in the corresponding article.\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Stars and bars\n\nStars and bars is a mathematical technique for solving certain combinatorial problems.\nIt occurs whenever you want to count the number of ways to group identical objects.\n\n## Theorem\n\nThe number of ways to put $n$ identical objects into $k$ labeled boxes is\n\n$$\\binom{n + k - 1}{n}.$$\n\nThe proof involves turning the objects into stars and separating the boxes using bars (therefore the name).\nE.g. we can represent with $\\bigstar | \\bigstar \\bigstar |~| \\bigstar \\bigstar$ the following situation:\nin the first box is one object, in the second box are two objects, the third one is empty and in the last box are two objects.\nThis is one way of dividing 5 objects into 4 boxes.\n\nIt should be pretty obvious, that every partition can be represented using $n$ stars and $k - 1$ bars and every stars and bars permutation using $n$ stars and $k - 1$ bars represents one partition.\nTherefore the number of ways to divide $n$ identical objects into $k$ labeled boxes is the same number as there are permutations of $n$ stars and $k - 1$ bars.\nThe [Binomial Coefficient](binomial-coefficients.md) gives us the desired formula.\n\n## Number of non-negative integer sums\n\nThis problem is a direct application of the theorem.\n\nYou want to count the number of solution of the equation \n\n$$x_1 + x_2 + \\dots + x_k = n$$\n\nwith $x_i \\ge 0$.\n\nAgain we can represent a solution using stars and bars.\nE.g. the solution $1 + 3 + 0 = 4$ for $n = 4$, $k = 3$ can be represented using $\\bigstar | \\bigstar \\bigstar \\bigstar |$.\n\nIt is easy to see, that this is exactly the stars and bars theorem.\nTherefore the solution is $\\binom{n + k - 1}{n}$.\n\n## Number of lower-bound integer sums\n\nThis can easily be extended to integer sums with different lower bounds.\nI.e. we want to count the number of solutions for  the equation\n\n$$x_1 + x_2 + \\dots + x_k = n$$\n\nwith $x_i \\ge a_i$.\n\nAfter substituting $x_i' := x_i - a_i$ we receive the modified equation\n\n$$(x_1' + a_i) + (x_2' + a_i) + \\dots + (x_k' + a_k) = n$$\n\n$$\\Leftrightarrow ~ ~ x_1' + x_2' + \\dots + x_k' = n - a_1 - a_2 - \\dots - a_k$$\n\nwith $x_i' \\ge 0$.\nSo we have reduced the problem to the simpler case with $x_i' \\ge 0$ and again can apply the stars and bars theorem.\n\n## Number of upper-bound integer sums\n\nWith some help of the [Inclusion-Exclusion Principle](./inclusion-exclusion.md), you can also restrict the integers with upper bounds.\nSee the [Number of upper-bound integer sums](./inclusion-exclusion.md#number-of-upper-bound-integer-sums) section in the corresponding article.\n\n## Practice Problems\n\n* [Codeforces - Array](https://codeforces.com/contest/57/problem/C)\n* [Codeforces - Kyoya and Coloured Balls](https://codeforces.com/problemset/problem/553/A)\n\n", "problem_ids": ["57_C"], "title": "Stars and bars"}, {"article": "# Garner's algorithm\n\nA consequence of the [Chinese Remainder Theorem](chinese-remainder-theorem.md) is, that we can represent big numbers using an array of small integers.\nFor example, let $p$ be the product of the first $1000$ primes. $p$ has around $3000$ digits.\n\nAny number $a$ less than $p$ can be represented as an array  $a_1, \\ldots, a_k$, where $a_i \\equiv a \\pmod{p_i}$.\nBut to do this we obviously need to know how to get back the number $a$ from its representation.\nOne way is discussed in the article about the Chinese Remainder Theorem.\n\nIn this article we discuss an alternative, Garner's Algorithm, which can also be used for this purpose.\n\n## Mixed Radix Representation\n\nWe can represent the number $a$ in the **mixed radix** representation:\n\n$$a = x_1 + x_2 p_1 + x_3 p_1 p_2 + \\ldots + x_k p_1 \\cdots p_{k-1} \\text{ with }x_i \\in [0, p_i)$$\n\nA mixed radix representation is a positional numeral system, that's a generalization of the typical number systems, like the binary numeral system or the decimal numeral system.\nFor instance the decimal numeral system is a positional numeral system with the radix (or base) 10.\nEvery a number is represented as a string of digits $d_1 d_2 d_3 \\dots d_n$ between $0$ and $9$, and \nE.g. the string $415$ represents the number $4 \\cdot 10^2 + 1 \\cdot 10^1 + 5 \\cdot 10^0$.\nIn general the string of digits $d_1 d_2 d_3 \\dots d_n$ represents the number $d_1 b^{n-1} + d_2 b^{n-2} + \\cdots + d_n b^0$ in the positional numeral system with radix $b$.\n\nIn a mixed radix system, we don't have one radix any more. The base varies from position to position.\n\n## Garner's algorithm\n\nGarner's algorithm computes the digits $x_1, \\ldots, x_k$.\nNotice, that the digits are relatively small.\nThe digit $x_i$ is an integer between $0$ and $p_i - 1$.\n\nLet $r_{ij}$ denote the inverse of $p_i$ modulo $p_j$\n\n$$r_{ij} = (p_i)^{-1} \\pmod{p_j}$$\n\nwhich can be found using the algorithm described in [Modular Inverse](module-inverse.md).\n\nSubstituting $a$ from the mixed radix representation into the first congruence equation we obtain\n\n$$a_1 \\equiv x_1 \\pmod{p_1}.$$\n\nSubstituting into the second equation yields\n\n$$a_2 \\equiv x_1 + x_2 p_1 \\pmod{p_2},$$\n\nwhich can be rewritten by subtracting $x_1$ and dividing by $p_1$ to get\n\n$$\\begin{array}{rclr}\n    a_2 - x_1 &\\equiv& x_2 p_1 &\\pmod{p_2} \\\\\n    (a_2 - x_1) r_{12} &\\equiv& x_2 &\\pmod{p_2} \\\\\n    x_2 &\\equiv& (a_2 - x_1) r_{12} &\\pmod{p_2}\n\\end{array}$$\n\nSimilarly we get that\n\n$$x_3 \\equiv ((a_3 - x_1) r_{13} - x_2) r_{23} \\pmod{p_3}.$$\n\nNow, we can clearly see an emerging pattern, which can be expressed by the following code:\n\n```cpp\nfor (int i = 0; i < k; ++i) {\n    x[i] = a[i];\n    for (int j = 0; j < i; ++j) {\n        x[i] = r[j][i] * (x[i] - x[j]);\n\n        x[i] = x[i] % p[i];\n        if (x[i] < 0)\n            x[i] += p[i];\n    }\n}\n```\n\nSo we learned how to calculate digits $x_i$ in $O(k^2)$ time. The number $a$ can now be calculated using the previously mentioned formula\n\n$$a = x_1 + x_2 \\cdot p_1 + x_3 \\cdot p_1 \\cdot p_2 + \\ldots + x_k \\cdot p_1 \\cdots p_{k-1}$$\n\nIt is worth noting that in practice, we almost probably need to compute the answer $a$ using [Arbitrary-Precision Arithmetic](big-integer.md), but the digits $x_i$ (because they are small) can usually be calculated using built-in types, and therefore Garner's algorithm is very efficient.\n\n## Implementation of Garner's Algorithm\n\nIt is convenient to implement this algorithm using Java, because it has built-in support for large numbers through the `BigInteger` class.\n\nHere we show an implementation that can store big numbers in the form of a set of congruence equations.\nIt supports addition, subtraction and multiplication.\nAnd with Garner's algorithm we can convert the set of equations into the unique integer.\nIn this code, we take 100 prime numbers greater than $10^9$, which allows representing numbers as large as $10^{900}$.\n\n```java\nfinal int SZ = 100;\nint pr[] = new int[SZ];\nint r[][] = new int[SZ][SZ];\n\nvoid init() {\n    for (int x = 1000 * 1000 * 1000, i = 0; i < SZ; ++x)\n        if (BigInteger.valueOf(x).isProbablePrime(100))\n            pr[i++] = x;\n\n    for (int i = 0; i < SZ; ++i)\n        for (int j = i + 1; j < SZ; ++j)\n            r[i][j] =\n                BigInteger.valueOf(pr[i]).modInverse(BigInteger.valueOf(pr[j])).intValue();\n}\n\nclass Number {\n    int a[] = new int[SZ];\n\n    public Number() {\n    }\n\n    public Number(int n) {\n        for (int i = 0; i < SZ; ++i)\n            a[i] = n % pr[i];\n    }\n\n    public Number(BigInteger n) {\n        for (int i = 0; i < SZ; ++i)\n            a[i] = n.mod(BigInteger.valueOf(pr[i])).intValue();\n    }\n\n    public Number add(Number n) {\n        Number result = new Number();\n        for (int i = 0; i < SZ; ++i)\n            result.a[i] = (a[i] + n.a[i]) % pr[i];\n        return result;\n    }\n\n    public Number subtract(Number n) {\n        Number result = new Number();\n        for (int i = 0; i < SZ; ++i)\n            result.a[i] = (a[i] - n.a[i] + pr[i]) % pr[i];\n        return result;\n    }\n\n    public Number multiply(Number n) {\n        Number result = new Number();\n        for (int i = 0; i < SZ; ++i)\n            result.a[i] = (int)((a[i] * 1l * n.a[i]) % pr[i]);\n        return result;\n    }\n\n    public BigInteger bigIntegerValue(boolean can_be_negative) {\n        BigInteger result = BigInteger.ZERO, mult = BigInteger.ONE;\n        int x[] = new int[SZ];\n        for (int i = 0; i < SZ; ++i) {\n            x[i] = a[i];\n            for (int j = 0; j < i; ++j) {\n                long cur = (x[i] - x[j]) * 1l * r[j][i];\n                x[i] = (int)((cur % pr[i] + pr[i]) % pr[i]);\n            }\n            result = result.add(mult.multiply(BigInteger.valueOf(x[i])));\n            mult = mult.multiply(BigInteger.valueOf(pr[i]));\n        }\n\n        if (can_be_negative)\n            if (result.compareTo(mult.shiftRight(1)) >= 0)\n                result = result.subtract(mult);\n\n        return result;\n    }\n}\n```\n", "full_article": "# Garner's algorithm\n\nA consequence of the [Chinese Remainder Theorem](chinese-remainder-theorem.md) is, that we can represent big numbers using an array of small integers.\nFor example, let $p$ be the product of the first $1000$ primes. $p$ has around $3000$ digits.\n\nAny number $a$ less than $p$ can be represented as an array  $a_1, \\ldots, a_k$, where $a_i \\equiv a \\pmod{p_i}$.\nBut to do this we obviously need to know how to get back the number $a$ from its representation.\nOne way is discussed in the article about the Chinese Remainder Theorem.\n\nIn this article we discuss an alternative, Garner's Algorithm, which can also be used for this purpose.\n\n## Mixed Radix Representation\n\nWe can represent the number $a$ in the **mixed radix** representation:\n\n$$a = x_1 + x_2 p_1 + x_3 p_1 p_2 + \\ldots + x_k p_1 \\cdots p_{k-1} \\text{ with }x_i \\in [0, p_i)$$\n\nA mixed radix representation is a positional numeral system, that's a generalization of the typical number systems, like the binary numeral system or the decimal numeral system.\nFor instance the decimal numeral system is a positional numeral system with the radix (or base) 10.\nEvery a number is represented as a string of digits $d_1 d_2 d_3 \\dots d_n$ between $0$ and $9$, and \nE.g. the string $415$ represents the number $4 \\cdot 10^2 + 1 \\cdot 10^1 + 5 \\cdot 10^0$.\nIn general the string of digits $d_1 d_2 d_3 \\dots d_n$ represents the number $d_1 b^{n-1} + d_2 b^{n-2} + \\cdots + d_n b^0$ in the positional numeral system with radix $b$.\n\nIn a mixed radix system, we don't have one radix any more. The base varies from position to position.\n\n## Garner's algorithm\n\nGarner's algorithm computes the digits $x_1, \\ldots, x_k$.\nNotice, that the digits are relatively small.\nThe digit $x_i$ is an integer between $0$ and $p_i - 1$.\n\nLet $r_{ij}$ denote the inverse of $p_i$ modulo $p_j$\n\n$$r_{ij} = (p_i)^{-1} \\pmod{p_j}$$\n\nwhich can be found using the algorithm described in [Modular Inverse](module-inverse.md).\n\nSubstituting $a$ from the mixed radix representation into the first congruence equation we obtain\n\n$$a_1 \\equiv x_1 \\pmod{p_1}.$$\n\nSubstituting into the second equation yields\n\n$$a_2 \\equiv x_1 + x_2 p_1 \\pmod{p_2},$$\n\nwhich can be rewritten by subtracting $x_1$ and dividing by $p_1$ to get\n\n$$\\begin{array}{rclr}\n    a_2 - x_1 &\\equiv& x_2 p_1 &\\pmod{p_2} \\\\\n    (a_2 - x_1) r_{12} &\\equiv& x_2 &\\pmod{p_2} \\\\\n    x_2 &\\equiv& (a_2 - x_1) r_{12} &\\pmod{p_2}\n\\end{array}$$\n\nSimilarly we get that\n\n$$x_3 \\equiv ((a_3 - x_1) r_{13} - x_2) r_{23} \\pmod{p_3}.$$\n\nNow, we can clearly see an emerging pattern, which can be expressed by the following code:\n\n```cpp\nfor (int i = 0; i < k; ++i) {\n    x[i] = a[i];\n    for (int j = 0; j < i; ++j) {\n        x[i] = r[j][i] * (x[i] - x[j]);\n\n        x[i] = x[i] % p[i];\n        if (x[i] < 0)\n            x[i] += p[i];\n    }\n}\n```\n\nSo we learned how to calculate digits $x_i$ in $O(k^2)$ time. The number $a$ can now be calculated using the previously mentioned formula\n\n$$a = x_1 + x_2 \\cdot p_1 + x_3 \\cdot p_1 \\cdot p_2 + \\ldots + x_k \\cdot p_1 \\cdots p_{k-1}$$\n\nIt is worth noting that in practice, we almost probably need to compute the answer $a$ using [Arbitrary-Precision Arithmetic](big-integer.md), but the digits $x_i$ (because they are small) can usually be calculated using built-in types, and therefore Garner's algorithm is very efficient.\n\n## Implementation of Garner's Algorithm\n\nIt is convenient to implement this algorithm using Java, because it has built-in support for large numbers through the `BigInteger` class.\n\nHere we show an implementation that can store big numbers in the form of a set of congruence equations.\nIt supports addition, subtraction and multiplication.\nAnd with Garner's algorithm we can convert the set of equations into the unique integer.\nIn this code, we take 100 prime numbers greater than $10^9$, which allows representing numbers as large as $10^{900}$.\n\n```java\nfinal int SZ = 100;\nint pr[] = new int[SZ];\nint r[][] = new int[SZ][SZ];\n\nvoid init() {\n    for (int x = 1000 * 1000 * 1000, i = 0; i < SZ; ++x)\n        if (BigInteger.valueOf(x).isProbablePrime(100))\n            pr[i++] = x;\n\n    for (int i = 0; i < SZ; ++i)\n        for (int j = i + 1; j < SZ; ++j)\n            r[i][j] =\n                BigInteger.valueOf(pr[i]).modInverse(BigInteger.valueOf(pr[j])).intValue();\n}\n\nclass Number {\n    int a[] = new int[SZ];\n\n    public Number() {\n    }\n\n    public Number(int n) {\n        for (int i = 0; i < SZ; ++i)\n            a[i] = n % pr[i];\n    }\n\n    public Number(BigInteger n) {\n        for (int i = 0; i < SZ; ++i)\n            a[i] = n.mod(BigInteger.valueOf(pr[i])).intValue();\n    }\n\n    public Number add(Number n) {\n        Number result = new Number();\n        for (int i = 0; i < SZ; ++i)\n            result.a[i] = (a[i] + n.a[i]) % pr[i];\n        return result;\n    }\n\n    public Number subtract(Number n) {\n        Number result = new Number();\n        for (int i = 0; i < SZ; ++i)\n            result.a[i] = (a[i] - n.a[i] + pr[i]) % pr[i];\n        return result;\n    }\n\n    public Number multiply(Number n) {\n        Number result = new Number();\n        for (int i = 0; i < SZ; ++i)\n            result.a[i] = (int)((a[i] * 1l * n.a[i]) % pr[i]);\n        return result;\n    }\n\n    public BigInteger bigIntegerValue(boolean can_be_negative) {\n        BigInteger result = BigInteger.ZERO, mult = BigInteger.ONE;\n        int x[] = new int[SZ];\n        for (int i = 0; i < SZ; ++i) {\n            x[i] = a[i];\n            for (int j = 0; j < i; ++j) {\n                long cur = (x[i] - x[j]) * 1l * r[j][i];\n                x[i] = (int)((cur % pr[i] + pr[i]) % pr[i]);\n            }\n            result = result.add(mult.multiply(BigInteger.valueOf(x[i])));\n            mult = mult.multiply(BigInteger.valueOf(pr[i]));\n        }\n\n        if (can_be_negative)\n            if (result.compareTo(mult.shiftRight(1)) >= 0)\n                result = result.subtract(mult);\n\n        return result;\n    }\n}\n```\n", "problem_ids": [], "title": "Garner's algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: factorial_divisors\n---\n\n# Finding Power of Factorial Divisor\n\nYou are given two numbers $n$ and $k$. Find the largest power of $k$ $x$ such that $n!$ is divisible by $k^x$.\n\n## Prime $k$ {data-toc-label=\"Prime k\"}\n\nLet's first consider the case of prime $k$. The explicit expression for factorial\n\n$$n! = 1 \\cdot 2 \\cdot 3 \\ldots (n-1) \\cdot n$$\n\nNote that every $k$-th element of the product is divisible by $k$, i.e. adds $+1$ to the answer; the number of such elements is $\\Bigl\\lfloor\\dfrac{n}{k}\\Bigr\\rfloor$.\n\nNext, every $k^2$-th element is divisible by $k^2$, i.e. adds another $+1$ to the answer (the first power of $k$ has already been counted in the previous paragraph). The number of such elements is $\\Bigl\\lfloor\\dfrac{n}{k^2}\\Bigr\\rfloor$.\n\nAnd so on, for every $i$ each $k^i$-th element adds another $+1$ to the answer, and there are $\\Bigl\\lfloor\\dfrac{n}{k^i}\\Bigr\\rfloor$ such elements.\n\nThe final answer is\n\n$$\\Bigl\\lfloor\\dfrac{n}{k}\\Bigr\\rfloor + \\Bigl\\lfloor\\dfrac{n}{k^2}\\Bigr\\rfloor + \\ldots + \\Bigl\\lfloor\\dfrac{n}{k^i}\\Bigr\\rfloor + \\ldots$$\n\nThis result is also known as [Legendre's formula](https://en.wikipedia.org/wiki/Legendre%27s_formula).\nThe sum is of course finite, since only approximately the first $\\log_k n$ elements are not zeros. Thus, the runtime of this algorithm is $O(\\log_k n)$.\n\n### Implementation\n\n```cpp\n\nint fact_pow (int n, int k) {\n\tint res = 0;\n\twhile (n) {\n\t\tn /= k;\n\t\tres += n;\n\t}\n\treturn res;\n}\n\n```\n\n## Composite $k$ {data-toc-label=\"Composite k\"}\n\nThe same idea can't be applied directly. Instead we can factor $k$, representing it as $k = k_1^{p_1} \\cdot \\ldots \\cdot k_m^{p_m}$. For each $k_i$, we find the number of times it is present in $n!$ using the algorithm described above - let's call this value $a_i$. The answer for composite $k$ will be\n\n$$\\min_ {i=1 \\ldots m} \\dfrac{a_i}{p_i}$$\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: factorial_divisors\n---\n\n# Finding Power of Factorial Divisor\n\nYou are given two numbers $n$ and $k$. Find the largest power of $k$ $x$ such that $n!$ is divisible by $k^x$.\n\n## Prime $k$ {data-toc-label=\"Prime k\"}\n\nLet's first consider the case of prime $k$. The explicit expression for factorial\n\n$$n! = 1 \\cdot 2 \\cdot 3 \\ldots (n-1) \\cdot n$$\n\nNote that every $k$-th element of the product is divisible by $k$, i.e. adds $+1$ to the answer; the number of such elements is $\\Bigl\\lfloor\\dfrac{n}{k}\\Bigr\\rfloor$.\n\nNext, every $k^2$-th element is divisible by $k^2$, i.e. adds another $+1$ to the answer (the first power of $k$ has already been counted in the previous paragraph). The number of such elements is $\\Bigl\\lfloor\\dfrac{n}{k^2}\\Bigr\\rfloor$.\n\nAnd so on, for every $i$ each $k^i$-th element adds another $+1$ to the answer, and there are $\\Bigl\\lfloor\\dfrac{n}{k^i}\\Bigr\\rfloor$ such elements.\n\nThe final answer is\n\n$$\\Bigl\\lfloor\\dfrac{n}{k}\\Bigr\\rfloor + \\Bigl\\lfloor\\dfrac{n}{k^2}\\Bigr\\rfloor + \\ldots + \\Bigl\\lfloor\\dfrac{n}{k^i}\\Bigr\\rfloor + \\ldots$$\n\nThis result is also known as [Legendre's formula](https://en.wikipedia.org/wiki/Legendre%27s_formula).\nThe sum is of course finite, since only approximately the first $\\log_k n$ elements are not zeros. Thus, the runtime of this algorithm is $O(\\log_k n)$.\n\n### Implementation\n\n```cpp\n\nint fact_pow (int n, int k) {\n\tint res = 0;\n\twhile (n) {\n\t\tn /= k;\n\t\tres += n;\n\t}\n\treturn res;\n}\n\n```\n\n## Composite $k$ {data-toc-label=\"Composite k\"}\n\nThe same idea can't be applied directly. Instead we can factor $k$, representing it as $k = k_1^{p_1} \\cdot \\ldots \\cdot k_m^{p_m}$. For each $k_i$, we find the number of times it is present in $n!$ using the algorithm described above - let's call this value $a_i$. The answer for composite $k$ will be\n\n$$\\min_ {i=1 \\ldots m} \\dfrac{a_i}{p_i}$$\n", "problem_ids": [], "title": "Finding Power of Factorial Divisor"}, {"article": "---\ntags:\n  - Original\n---\n\n# Operations on polynomials and series\n\nProblems in competitive programming, especially the ones involving enumeration some kind, are often solved by reducing the problem to computing something on polynomials and formal power series.\n\nThis includes concepts such as polynomial multiplication, interpolation, and more complicated ones, such as polynomial logarithms and exponents. In this article, a brief overview of such operations and common approaches to them is presented.\n\n## Basic Notion and facts\n\nIn this section, we focus more on the definitions and \"intuitive\" properties of various polynomial operations. The technical details of their implementation and complexities will be covered in later sections.\n\n### Polynomial multiplication\n\n!!! info \"Definition\"\n\t**Univariate polynomial** is an expression of form $A(x) = a_0 + a_1 x + \\dots + a_n x^n$.\n\nThe values $a_0, \\dots, a_n$ are polynomial coefficients, typically taken from some set of numbers or number-like structures. In this article, we assume that the coefficients are taken from some [field](https://en.wikipedia.org/wiki/Field_(mathematics)), meaning that operations of addition, subtraction, multiplication and division are well-defined for them (except for division by $0$) and they generally behave in a similar way to real numbers.\n\t\nTypical example of such field is the field of remainders modulo prime number $p$.\n\nFor simplicity we will drop the term _univariate_, as this is the only kind of polynomials we consider in this article. We will also write $A$ instead of $A(x)$ wherever possible, which will be understandable from the context. It is assumed that either $a_n \\neq 0$ or $A(x)=0$.\n\n!!! info \"Definition\"\n\tThe **product** of two polynomials is defined by expanding it as an arithmetic expression:\n\n\t$$\n\tA(x) B(x) = \\left(\\sum\\limits_{i=0}^n a_i x^i \\right)\\left(\\sum\\limits_{j=0}^m b_j x^j\\right) = \\sum\\limits_{i,j} a_i b_j x^{i+j} = \\sum\\limits_{k=0}^{n+m} c_k x^k = C(x).\n\t$$\n\n\tThe sequence $c_0, c_1, \\dots, c_{n+m}$ of the coefficients of $C(x)$ is called the **convolution** of $a_0, \\dots, a_n$ and $b_0, \\dots, b_m$.\n\n!!! info \"Definition\"\n\tThe **degree** of a polynomial $A$ with $a_n \\neq 0$ is defined as $\\deg A = n$.\n\t\n\tFor consistency, degree of $A(x) = 0$ is defined as $\\deg A = -\\infty$.\n\nIn this notion, $\\deg AB = \\deg A + \\deg B$ for any polynomials $A$ and $B$.\n\nConvolutions are the basis of solving many enumerative problems.\n\n!!! Example\n\tYou have $n$ objects of the first kind and $m$ objects of the second kind.\n\n\tObjects of first kind are valued $a_1, \\dots, a_n$, and objects of the second kind are valued $b_1, \\dots, b_m$.\n\n\tYou pick a single object of the first kind and a single object of the second kind. How many ways are there to get the total value $k$?\n\n??? hint \"Solution\"\n\tConsider the product $(x^{a_1} + \\dots + x^{a_n})(x^{b_1} + \\dots + x^{b_m})$. If you expand it, each monomial will correspond to the pair $(a_i, b_j)$ and contribute to the coefficient near $x^{a_i+b_j}$. In other words, the answer is the coefficient near $x^k$ in the product.\n\n!!! Example\n\tYou throw a $6$-sided die $n$ times and sum up the results from all throws. What is the probability of getting sum of $k$?\n\n??? hint \"Solution\"\n\tThe answer is the number of outcomes having the sum $k$, divided by the total number of outcomes, which is $6^n$.\n\n\tWhat is the number of outcomes having the sum $k$? For $n=1$, it may be represented by a polynomial $A(x) = x^1+x^2+\\dots+x^6$.\n\n\tFor $n=2$, using the same approach as in the example above, we conclude that it is represented by the polynomial $(x^1+x^2+\\dots+x^6)^2$.\n\n\tThat being said, the answer to the problem is the $k$-th coefficient of $(x^1+x^2+\\dots+x^6)^n$, divided by $6^n$.\n\nThe coefficient near $x^k$ in the polynomial $A(x)$ is denoted shortly as $[x^k]A$.\n\n### Formal power series\n\n!!! info \"Definition\"\n\tA **formal power series** is an infinite sum $A(x) = a_0 + a_1 x + a_2 x^2 + \\dots$, considered regardless of its convergence properties.\n\nIn other words, when we consider e.g. a sum $1+\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\dots=2$, we imply that it _converges_ to $2$ when the number of summands approach infinity. However, formal series are only considered in terms of sequences that make them.\n\n!!! info \"Definition\"\n\tThe **product** of formal power series $A(x)$ and $B(x)$, is also defined by expanding it as an arithmetic expression:\n\n\n\t$$\n\tA(x) B(x) = \\left(\\sum\\limits_{i=0}^\\infty a_i x^i \\right)\\left(\\sum\\limits_{j=0}^\\infty b_j x^j\\right) = \\sum\\limits_{i,j} a_i b_j x^{i+j} = \\sum\\limits_{k=0}^{\\infty} c_k x^k = C(x),\n\t$$\n\n\twhere the coefficients $c_0, c_1, \\dots$ are define as finite sums\n\n\t$$\n\tc_k = \\sum\\limits_{i=0}^k a_i b_{k-i}.\n\t$$\n\n\tThe sequence $c_0, c_1, \\dots$ is also called a **convolution** of $a_0, a_1, \\dots$ and $b_0, b_1, \\dots$, generalizing the concept to infinite sequences.\n\nThus, polynomials may be considered formal power series, but with finite number of coefficients.\n\nFormal power series play a crucial role in enumerative combinatorics, where they're studied as [generating functions](https://en.wikipedia.org/wiki/Generating_function) for various sequences. Detailed explanation of generating functions and the intuition behind them will, unfortunately, be out of scope for this article, therefore the curious reader is referenced e.g. [here](https://codeforces.com/blog/entry/103979) for details about their combinatorial meaning.\n\nHowever, we will very briefly mention that if $A(x)$ and $B(x)$ are generating functions for sequences that enumerate some objects by number of \"atoms\" in them (e.g. trees by the number of vertices), then the product $A(x) B(x)$ enumerates objects that can be described as pairs of objects of kinds $A$ and $B$, enumerates by the total number of \"atoms\" in the pair.\n\n!!! Example\n\tLet $A(x) = \\sum\\limits_{i=0}^\\infty 2^i x^i$ enumerate packs of stones, each stone colored in one of $2$ colors (so, there are $2^i$ such packs of size $i$) and $B(x) = \\sum\\limits_{j=0}^{\\infty} 3^j x^j$ enumerate packs of stones, each stone colored in one of $3$ colors. Then $C(x) = A(x) B(x) = \\sum\\limits_{k=0}^\\infty c_k x^k$ would enumerate objects that may be described as \"two packs of stones, first pack only of stones of type $A$, second pack only of stones of type $B$, with total number of stones being $k$\" for $c_k$.\n\nIn a similar way, there is an intuitive meaning to some other functions over formal power series.\n\n### Long polynomial division\n\nSimilar to integers, it is possible to define long division on polynomials.\n\n!!! info \"Definition\"\n\n\tFor any polynomials $A$ and $B \\neq 0$, one may represent $A$ as\n\n\t$$\n\tA = D \\cdot B + R,~ \\deg R < \\deg B,\n\t$$\n\n\twhere $R$ is called the **remainder** of $A$ modulo $B$ and $D$ is called the **quotient**.\n\nDenoting $\\deg A = n$ and $\\deg B = m$, naive way to do it is to use long division, during which you multiply $B$ by the monomial $\\frac{a_n}{b_m} x^{n - m}$ and subtract it from $A$, until the degree of $A$ is smaller than that of $B$. What remains of $A$ in the end will be the remainder (hence the name), and the polynomials with which you multiplied $B$ in the process, summed together, form the quotient.\n\n!!! info \"Definition\"\n\tIf $A$ and $B$ have the same remainder modulo $C$, they're said to be **equivalent** modulo $C$, which is denoted as\n\t\n\t$$\n\tA \\equiv B \\pmod{C}.\n\t$$\n\t\nPolynomial long division is useful because of its many important properties:\n\n- $A$ is a multiple of $B$ if and only if $A \\equiv 0 \\pmod B$.\n\n- It implies that $A \\equiv B \\pmod C$ if and only if $A-B$ is a multiple of $C$.\n\n- In particular, $A \\equiv B \\pmod{C \\cdot D}$ implies $A \\equiv B \\pmod{C}$.\n\n- For any linear polynomial $x-r$ it holds that $A(x) \\equiv A(r) \\pmod{x-r}$.\n\n- It implies that $A$ is a multiple of $x-r$ if and only if $A(r)=0$.\n\n- For modulo being $x^k$, it holds that $A \\equiv a_0 + a_1 x + \\dots + a_{k-1} x^{k-1} \\pmod{x^k}$.\n\nNote that long division can't be properly defined for formal power series. Instead, for any $A(x)$ such that $a_0 \\neq 0$, it is possible to define an inverse formal power series $A^{-1}(x)$, such that $A(x) A^{-1}(x) = 1$. This fact, in turn, can be used to compute the result of long division for polynomials.\n\n## Basic implementation\n[Here](https://github.com/cp-algorithms/cp-algorithms-aux/blob/master/src/polynomial.cpp) you can find the basic implementation of polynomial algebra.\n\nIt supports all trivial operations and some other useful methods. The main class is `poly<T>` for polynomials with coefficients of type `T`.\n\nAll arithmetic operation `+`, `-`, `*`, `%` and `/` are supported, `%` and `/` standing for remainder and quotient in Euclidean division.\n\nThere is also the class `modular<m>` for performing arithmetic operations on remainders modulo a prime number `m`.\n\nOther useful functions:\n\n- `deriv()`: computes the derivative $P'(x)$ of $P(x)$.\n- `integr()`: computes the indefinite integral $Q(x) = \\int P(x)$ of $P(x)$ such that $Q(0)=0$.\n- `inv(size_t n)`: calculate the first $n$ coefficients of $P^{-1}(x)$ in $O(n \\log n)$.\n- `log(size_t n)`: calculate the first $n$ coefficients of $\\ln P(x)$ in $O(n \\log n)$.\n- `exp(size_t n)`: calculate the first $n$ coefficients of $\\exp P(x)$ in $O(n \\log n)$.\n- `pow(size_t k, size_t n)`: calculate the first $n$ coefficients for $P^{k}(x)$ in $O(n \\log nk)$.\n- `deg()`: returns the degree of $P(x)$.\n- `lead()`: returns the coefficient of $x^{\\deg P(x)}$.\n- `resultant(poly<T> a, poly<T> b)`: computes the resultant of $a$ and $b$ in $O(|a| \\cdot |b|)$.\n- `bpow(T x, size_t n)`: computes $x^n$.\n- `bpow(T x, size_t n, T m)`: computes $x^n \\pmod{m}$.\n- `chirpz(T z, size_t n)`: computes $P(1), P(z), P(z^2), \\dots, P(z^{n-1})$ in $O(n \\log n)$.\n- `vector<T> eval(vector<T> x)`: evaluates $P(x_1), \\dots, P(x_n)$ in $O(n \\log^2 n)$.\n- `poly<T> inter(vector<T> x, vector<T> y)`: interpolates a polynomial by a set of pairs $P(x_i) = y_i$ in $O(n \\log^2 n)$.\n- And some more, feel free to explore the code!\n\n## Arithmetic\n\n### Multiplication\n\nThe very core operation is the multiplication of two polynomials. That is, given the polynomials $A$ and $B$:\n\n$$A = a_0 + a_1 x + \\dots + a_n x^n$$\n\n$$B = b_0 + b_1 x + \\dots + b_m x^m$$\n\nYou have to compute polynomial $C = A \\cdot B$, which is defined as\n\n$$\\boxed{C = \\sum\\limits_{i=0}^n \\sum\\limits_{j=0}^m a_i b_j x^{i+j}}  = c_0 + c_1 x + \\dots + c_{n+m} x^{n+m}.$$\n\nIt can be computed in $O(n \\log n)$ via the [Fast Fourier transform](fft.md) and almost all methods here will use it as subroutine.\n\n### Inverse series\n\nIf $A(0) \\neq 0$ there always exists an infinite formal power series $A^{-1}(x) = q_0+q_1 x + q_2 x^2 + \\dots$ such that $A^{-1} A = 1$. It often proves useful to compute first $k$ coefficients of $A^{-1}$ (that is, to compute it modulo $x^k$). There are two major ways to calculate it.\n\n#### Divide and conquer\n\nThis algorithm was mentioned in [Sch\u00f6nhage's article](http://algo.inria.fr/seminars/sem00-01/schoenhage.pdf) and is inspired by [Graeffe's method](https://en.wikipedia.org/wiki/Graeffe's_method). It is known that for $B(x)=A(x)A(-x)$ it holds that $B(x)=B(-x)$, that is, $B(x)$ is an even polynomial. It means that it only has non-zero coefficients with even numbers and can be represented as $B(x)=T(x^2)$. Thus, we can do the following transition:\n\n$$A^{-1}(x) \\equiv \\frac{1}{A(x)} \\equiv \\frac{A(-x)}{A(x)A(-x)} \\equiv \\frac{A(-x)}{T(x^2)} \\pmod{x^k}$$\n\nNote that $T(x)$ can be computed with a single multiplication, after which we're only interested in the first half of coefficients of its inverse series. This effectively reduces the initial problem of computing $A^{-1} \\pmod{x^k}$ to computing $T^{-1} \\pmod{x^{\\lfloor k / 2 \\rfloor}}$.\n\nThe complexity of this method can be estimated as\n\n$$T(n) = T(n/2) + O(n \\log n) = O(n \\log n).$$\n\n#### Sieveking\u2013Kung algorithm\n\nThe generic process described here is known as Hensel lifting, as it follows from Hensel's lemma. We'll cover it in more detail further below, but for now let's focus on ad hoc solution. \"Lifting\" part here means that we start with the approximation $B_0=q_0=a_0^{-1}$, which is $A^{-1} \\pmod x$ and then iteratively lift from $\\bmod x^a$ to $\\bmod x^{2a}$.\n\nLet $B_k \\equiv A^{-1} \\pmod{x^a}$. The next approximation needs to follow the equation $A B_{k+1} \\equiv 1 \\pmod{x^{2a}}$ and may be represented as $B_{k+1} = B_k + x^a C$. From this follows the equation\n\n$$A(B_k + x^{a}C) \\equiv 1 \\pmod{x^{2a}}.$$\n\nLet $A B_k \\equiv 1 + x^a D \\pmod{x^{2a}}$, then the equation above implies\n\n$$x^a(D+AC) \\equiv 0 \\pmod{x^{2a}} \\implies D \\equiv -AC \\pmod{x^a} \\implies C \\equiv -B_k D \\pmod{x^a}.$$\n\nFrom this, one can obtain the final formula, which is\n\n$$x^a C \\equiv -B_k x^a D  \\equiv B_k(1-AB_k) \\pmod{x^{2a}} \\implies \\boxed{B_{k+1} \\equiv B_k(2-AB_k) \\pmod{x^{2a}}}$$\n\nThus starting with $B_0 \\equiv a_0^{-1} \\pmod x$ we will compute the sequence $B_k$ such that $AB_k \\equiv 1 \\pmod{x^{2^k}}$ with the complexity\n\n$$T(n) = T(n/2) + O(n \\log n) = O(n \\log n).$$\n\nThe algorithm here might seem a bit more complicated than the first one, but it has a very solid and practical reasoning behind it, as well as a great generalization potential if looked from a different perspective, which would be explained further below.\n\n### Euclidean division\n\nConsider two polynomials $A(x)$ and $B(x)$ of degrees $n$ and $m$. As it was said earlier you can rewrite $A(x)$ as\n\n$$A(x) = B(x) D(x) + R(x), \\deg R < \\deg B.$$\n\nLet $n \\geq m$, it would imply that $\\deg D = n - m$ and the leading $n-m+1$ coefficients of $A$ don't influence $R$. It means that you can recover $D(x)$ from the largest $n-m+1$ coefficients of $A(x)$ and $B(x)$ if you consider it as a system of equations.\n\nThe system of linear equations we're talking about can be written in the following form:\n\n$$\\begin{bmatrix} a_n \\\\ \\vdots \\\\ a_{m+1} \\\\ a_{m} \\end{bmatrix} = \\begin{bmatrix}\nb_m & \\dots & 0 & 0 \\\\\n\\vdots & \\ddots & \\vdots & \\vdots \\\\\n\\dots & \\dots & b_m & 0 \\\\\n\\dots & \\dots & b_{m-1} & b_m\n\\end{bmatrix} \\begin{bmatrix}d_{n-m} \\\\ \\vdots \\\\ d_1 \\\\ d_0\\end{bmatrix}$$\n\nFrom the looks of it, we can conclude that with the introduction of reversed polynomials\n\n$$A^R(x) = x^nA(x^{-1})= a_n + a_{n-1} x + \\dots + a_0 x^n$$\n\n$$B^R(x) = x^m B(x^{-1}) = b_m + b_{m-1} x + \\dots + b_0 x^m$$\n\n$$D^R(x) = x^{n-m}D(x^{-1}) = d_{n-m} + d_{n-m-1} x + \\dots + d_0 x^{n-m}$$\n\nthe system may be rewritten as\n\n$$A^R(x) \\equiv B^R(x) D^R(x) \\pmod{x^{n-m+1}}.$$\n\nFrom this you can unambiguously recover all coefficients of $D(x)$:\n\n$$\\boxed{D^R(x) \\equiv A^R(x) (B^R(x))^{-1} \\pmod{x^{n-m+1}}}$$\n\nAnd from this, in turn, you can recover $R(x)$ as $R(x) = A(x) - B(x)D(x)$.\n\nNote that the matrix above is a so-called triangular [Toeplitz matrix](https://en.wikipedia.org/wiki/Toeplitz_matrix) and, as we see here, solving system of linear equations with arbitrary Toeplitz matrix is, in fact, equivalent to polynomial inversion. Moreover, inverse matrix of it would also be triangular Toeplitz matrix and its entries, in terms used above, are the coefficients of $(B^R(x))^{-1} \\pmod{x^{n-m+1}}$.\n\n## Calculating functions of polynomial\n\n### Newton's method\n\nLet's generalize the Sieveking\u2013Kung algorithm. Consider equation $F(P) = 0$ where $P(x)$ should be a polynomial and $F(x)$ is some polynomial-valued function defined as\n\n$$F(x) = \\sum\\limits_{i=0}^\\infty \\alpha_i (x-\\beta)^i,$$\n\nwhere $\\beta$ is some constant. It can be proven that if we introduce a new formal variable $y$, we can express $F(x)$ as\n\n$$F(x) = F(y) + (x-y)F'(y) + (x-y)^2 G(x,y),$$\n\nwhere $F'(x)$ is the derivative formal power series defined as\n\n$$F'(x) = \\sum\\limits_{i=0}^\\infty (i+1)\\alpha_{i+1}(x-\\beta)^i,$$\n\nand $G(x, y)$ is some formal power series of $x$ and $y$. With this result we can find the solution iteratively.\n\nLet $F(Q_k) \\equiv 0 \\pmod{x^{a}}$. We need to find $Q_{k+1} \\equiv Q_k + x^a C \\pmod{x^{2a}}$ such that $F(Q_{k+1}) \\equiv 0 \\pmod{x^{2a}}$.\n\nSubstituting $x = Q_{k+1}$ and $y=Q_k$ in the formula above, we get\n\n$$F(Q_{k+1}) \\equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) + (Q_{k+1} - Q_k)^2 G(x, y) \\pmod x^{2a}.$$\n\nSince $Q_{k+1} - Q_k \\equiv 0 \\pmod{x^a}$, it also holds that $(Q_{k+1} - Q_k)^2 \\equiv 0 \\pmod{x^{2a}}$, thus\n\n$$0 \\equiv F(Q_{k+1}) \\equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) \\pmod{x^{2a}}.$$\n\nThe last formula gives us the value of $Q_{k+1}$:\n\n$$\\boxed{Q_{k+1} = Q_k - \\dfrac{F(Q_k)}{F'(Q_k)} \\pmod{x^{2a}}}$$\n\nThus, knowing how to invert polynomials and how to compute $F(Q_k)$, we can find $n$ coefficients of $P$ with the complexity\n\n$$T(n) = T(n/2) + f(n),$$\n\nwhere $f(n)$ is the time needed to compute $F(Q_k)$ and $F'(Q_k)^{-1}$ which is usually $O(n \\log n)$.\n\nThe iterative rule above is known in numerical analysis as [Newton's method](https://en.wikipedia.org/wiki/Newton%27s_method).\n\n#### Hensel's lemma\n\nAs was mentioned earlier, formally and generically this result is known as [Hensel's lemma](https://en.wikipedia.org/wiki/Hensel%27s_lemma) and it may in fact used in even broader sense when we work with a series of nested rings. In this particular case we worked with a sequence of polynomial remainders modulo $x$, $x^2$, $x^3$ and so on.\n\nAnother example where Hensel's lifting might be helpful are so-called [p-adic numbers](https://en.wikipedia.org/wiki/P-adic_number) where we, in fact, work with the sequence of integer remainders modulo $p$, $p^2$, $p^3$ and so on. For example, Newton's method can be used to find all possible [automorphic numbers](https://en.wikipedia.org/wiki/Automorphic_number) (numbers that end on itself when squared) with a given number base. The problem is left as an exercise to the reader. You might consider [this](https://acm.timus.ru/problem.aspx?space=1&num=1698) problem to check if your solution works for $10$-based numbers.\n\n\n### Logarithm\n\nFor the function $\\ln P(x)$ it's known that: \n\n$$\n\\boxed{(\\ln P(x))' = \\dfrac{P'(x)}{P(x)}}\n$$\n\nThus we can calculate $n$ coefficients of $\\ln P(x)$ in $O(n \\log n)$.\n\n\n### Inverse series\n\nTurns out, we can get the formula for $A^{-1}$ using Newton's method.\nFor this we take the equation $A=Q^{-1}$, thus:\n\n$$F(Q) = Q^{-1} - A$$\n\n$$F'(Q) = -Q^{-2}$$\n\n$$\\boxed{Q_{k+1} \\equiv Q_k(2-AQ_k) \\pmod{x^{2^{k+1}}}}$$\n\n### Exponent\n\nLet's learn to calculate $e^{P(x)}=Q(x)$. It should hold that $\\ln Q = P$, thus:\n\n$$F(Q) = \\ln Q - P$$\n\n$$F'(Q) = Q^{-1}$$\n\n$$\\boxed{Q_{k+1} \\equiv Q_k(1 + P - \\ln Q_k) \\pmod{x^{2^{k+1}}}}$$\n\n### $k$-th power { data-toc-label=\"k-th power\" }\n\nNow we need to calculate $P^k(x)=Q$. This may be done via the following formula:\n\n$$Q = \\exp\\left[k \\ln P(x)\\right]$$\n\nNote though, that you can calculate the logarithms and the exponents correctly only if you can find some initial $Q_0$.\n\nTo find it, you should calculate the logarithm or the exponent of the constant coefficient of the polynomial.\n\nBut the only reasonable way to do it is if $P(0)=1$ for $Q = \\ln P$ so $Q(0)=0$ and if $P(0)=0$ for $Q = e^P$ so $Q(0)=1$.\n\nThus you can use formula above only if $P(0) = 1$. Otherwise if $P(x) = \\alpha x^t T(x)$ where $T(0)=1$ you can write that:\n\n$$\\boxed{P^k(x) = \\alpha^kx^{kt} \\exp[k \\ln T(x)]}$$\n\nNote that you also can calculate some $k$-th root of a polynomial if you can calculate $\\sqrt[k]{\\alpha}$, for example for $\\alpha=1$.\n\n## Evaluation and Interpolation\n\n### Chirp-z Transform\n\nFor the particular case when you need to evaluate a polynomial in the points $x_r = z^{2r}$ you can do the following:\n\n$$A(z^{2r}) = \\sum\\limits_{k=0}^n a_k z^{2kr}$$\n\nLet's substitute $2kr = r^2+k^2-(r-k)^2$. Then this sum rewrites as:\n\n$$\\boxed{A(z^{2r}) = z^{r^2}\\sum\\limits_{k=0}^n (a_k z^{k^2}) z^{-(r-k)^2}}$$\n\nWhich is up to the factor $z^{r^2}$ equal to the convolution of the sequences $u_k = a_k z^{k^2}$ and $v_k = z^{-k^2}$.\n\nNote that $u_k$ has indexes from $0$ to $n$ here and $v_k$ has indexes from $-n$ to $m$ where $m$ is the maximum power of $z$ which you need.\n\nNow if you need to evaluate a polynomial in the points $x_r = z^{2r+1}$ you can reduce it to the previous task by the transformation $a_k \\to a_k z^k$.\n\nIt gives us an $O(n \\log n)$ algorithm when you need to compute values in powers of $z$, thus you may compute the DFT for non-powers of two.\n\nAnother observation is that $kr = \\binom{k+r}{2} - \\binom{k}{2} - \\binom{r}{2}$. Then we have\n\n$$\\boxed{A(z^r) = z^{-\\binom{r}{2}}\\sum\\limits_{k=0}^n \\left(a_k z^{-\\binom{k}{2}}\\right)z^{\\binom{k+r}{2}}}$$\n\nThe coefficient of $x^{n+r}$ of the product of the polynomials $A_0(x) = \\sum\\limits_{k=0}^n a_{n-k}z^{-\\binom{n-k}{2}}x^k$ and $A_1(x) = \\sum\\limits_{k\\geq 0}z^{\\binom{k}{2}}x^k$ equals $z^{\\binom{r}{2}}A(z^r)$. You can use the formula $z^{\\binom{k+1}{2}}=z^{\\binom{k}{2}+k}$ to calculate the coefficients of $A_0(x)$ and $A_1(x)$.\n\n### Multi-point Evaluation\nAssume you need to calculate $A(x_1), \\dots, A(x_n)$. As mentioned earlier, $A(x) \\equiv A(x_i) \\pmod{x-x_i}$. Thus you may do the following:\n\n1. Compute a segment tree such that in the segment $[l,r)$ stands the product $P_{l, r}(x) = (x-x_l)(x-x_{l+1})\\dots(x-x_{r-1})$.\n2. Starting with $l=1$ and $r=n+1$ at the root node. Let $m=\\lfloor(l+r)/2\\rfloor$. Let's move down to $[l,m)$ with the polynomial $A(x) \\pmod{P_{l,m}(x)}$.\n3. This will recursively compute $A(x_l), \\dots, A(x_{m-1})$, now do the same for $[m,r)$ with $A(x) \\pmod{P_{m,r}(x)}$.\n4. Concatenate the results from the first and second recursive call and return them.\n\nThe whole procedure will run in $O(n \\log^2 n)$.\n\n### Interpolation\n\nThere's a direct formula by Lagrange to interpolate a polynomial, given set of pairs $(x_i, y_i)$:\n\n$$\\boxed{A(x) = \\sum\\limits_{i=1}^n y_i \\prod\\limits_{j \\neq i}\\dfrac{x-x_j}{x_i - x_j}}$$\n\nComputing it directly is a hard thing but turns out, we may compute it in $O(n \\log^2 n)$ with a divide and conquer approach:\n\nConsider $P(x) = (x-x_1)\\dots(x-x_n)$. To know the coefficients of the denominators in $A(x)$ we should compute products like: \n\n$$\nP_i = \\prod\\limits_{j \\neq i} (x_i-x_j)\n$$\n\nBut if you consider the derivative $P'(x)$ you'll find out that $P'(x_i) = P_i$. Thus you can compute $P_i$'s via evaluation in $O(n \\log^2 n)$.\n\nNow consider the recursive algorithm done on same segment tree as in the multi-point evaluation. It starts in the leaves with the value $\\dfrac{y_i}{P_i}$ in each leaf.\n\nWhen we return from the recursion we should merge the results from the left and the right vertices as $A_{l,r} = A_{l,m}P_{m,r} + P_{l,m} A_{m,r}$.\n\nIn this way when you return back to the root you'll have exactly $A(x)$ in it.\nThe total procedure also works in $O(n \\log^2 n)$.\n\n## GCD and Resultants\n\nAssume you're given polynomials $A(x) = a_0 + a_1 x + \\dots + a_n x^n$ and $B(x) = b_0 + b_1 x + \\dots + b_m x^m$.\n\nLet $\\lambda_0, \\dots, \\lambda_n$ be the roots of $A(x)$ and let $\\mu_0, \\dots, \\mu_m$ be the roots of $B(x)$ counted with their multiplicities.\n\nYou want to know if $A(x)$ and $B(x)$ have any roots in common. There are two interconnected ways to do that.\n\n### Euclidean algorithm\n\nWell, we already have an [article](euclid-algorithm.md) about it. For an arbitrary  domain you can write the Euclidean algorithm as easy as:\n\n```cpp\ntemplate<typename T>\nT gcd(const T &a, const T &b) {\n\treturn b == T(0) ? a : gcd(b, a % b);\n}\n```\n\nIt can be proven that for polynomials $A(x)$ and $B(x)$ it will work in $O(nm)$.\n\n\n### Resultant\n\nLet's calculate the product $A(\\mu_0)\\cdots A(\\mu_m)$. It will be equal to zero if and only if some $\\mu_i$ is the root of $A(x)$.\n\nFor symmetry we can also multiply it with $b_m^n$ and rewrite the whole product in the following form:\n\n$$\\boxed{\\mathcal{R}(A, B) = b_m^n\\prod\\limits_{j=0}^m A(\\mu_j) = b_m^n a_m^n \\prod\\limits_{i=0}^n \\prod\\limits_{j=0}^m (\\mu_j - \\lambda_i)= (-1)^{mn}a_n^m \\prod\\limits_{i=0}^n B(\\lambda_i)}$$\n\nThe value defined above is called the resultant of the polynomials $A(x)$ and $B(x)$. From the definition you may find the following properties:\n\n1. $\\mathcal R(A, B) = (-1)^{nm} \\mathcal R(B, A)$.\n2. $\\mathcal R(A, B)= a_n^m b_m^n$ when $n=0$ or $m=0$.\n3. If $b_m=1$ then $\\mathcal R(A - CB, B) = \\mathcal R(A, B)$ for an arbitrary polynomial $C(x)$ and $n,m \\geq 1$.\n4. From this follows $\\mathcal R(A, B) = b_m^{\\deg(A) - \\deg(A-CB)}\\mathcal R(A - CB, B)$ for arbitrary $A(x)$, $B(x)$, $C(x)$.\n\nMiraculously it means that resultant of two polynomials is actually always from the same ring as their coefficients!\n\nAlso these properties allow us to calculate the resultant alongside the Euclidean algorithm, which works in $O(nm)$.\n\n\n```cpp\ntemplate<typename T>\nT resultant(poly<T> a, poly<T> b) {\n\tif(b.is_zero()) {\n\t\treturn 0;\n\t} else if(b.deg() == 0) {\n\t\treturn bpow(b.lead(), a.deg());\n\t} else {\n\t\tint pw = a.deg();\n\t\ta %= b;\n\t\tpw -= a.deg();\n\t\tbase mul = bpow(b.lead(), pw) * base((b.deg() & a.deg() & 1) ? -1 : 1);\n\t\tbase ans = resultant(b, a);\n\t\treturn ans * mul;\n\t}\n}\n```\n\n### Half-GCD algorithm\n\nThere is a way to calculate the GCD and resultants in $O(n \\log^2 n)$.\n\nThe procedure to do so implements a $2 \\times 2$ linear transform which maps a pair of polynomials $a(x)$, $b(x)$ into another pair $c(x), d(x)$ such that $\\deg d(x) \\leq \\frac{\\deg a(x)}{2}$. If you're careful enough, you can compute the half-GCD of any pair of polynomials with at most $2$ recursive calls to the polynomials which are at least $2$ times smaller.\n\nThe specific details of the algorithm are somewhat tedious to explain, however you can find its implementation in the library, as `half_gcd` function.\n\nAfter half-GCD is implemented, you can repeatedly apply it to polynomials until you're reduced to the pair of $\\gcd(a, b)$ and $0$.\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Operations on polynomials and series\n\nProblems in competitive programming, especially the ones involving enumeration some kind, are often solved by reducing the problem to computing something on polynomials and formal power series.\n\nThis includes concepts such as polynomial multiplication, interpolation, and more complicated ones, such as polynomial logarithms and exponents. In this article, a brief overview of such operations and common approaches to them is presented.\n\n## Basic Notion and facts\n\nIn this section, we focus more on the definitions and \"intuitive\" properties of various polynomial operations. The technical details of their implementation and complexities will be covered in later sections.\n\n### Polynomial multiplication\n\n!!! info \"Definition\"\n\t**Univariate polynomial** is an expression of form $A(x) = a_0 + a_1 x + \\dots + a_n x^n$.\n\nThe values $a_0, \\dots, a_n$ are polynomial coefficients, typically taken from some set of numbers or number-like structures. In this article, we assume that the coefficients are taken from some [field](https://en.wikipedia.org/wiki/Field_(mathematics)), meaning that operations of addition, subtraction, multiplication and division are well-defined for them (except for division by $0$) and they generally behave in a similar way to real numbers.\n\t\nTypical example of such field is the field of remainders modulo prime number $p$.\n\nFor simplicity we will drop the term _univariate_, as this is the only kind of polynomials we consider in this article. We will also write $A$ instead of $A(x)$ wherever possible, which will be understandable from the context. It is assumed that either $a_n \\neq 0$ or $A(x)=0$.\n\n!!! info \"Definition\"\n\tThe **product** of two polynomials is defined by expanding it as an arithmetic expression:\n\n\t$$\n\tA(x) B(x) = \\left(\\sum\\limits_{i=0}^n a_i x^i \\right)\\left(\\sum\\limits_{j=0}^m b_j x^j\\right) = \\sum\\limits_{i,j} a_i b_j x^{i+j} = \\sum\\limits_{k=0}^{n+m} c_k x^k = C(x).\n\t$$\n\n\tThe sequence $c_0, c_1, \\dots, c_{n+m}$ of the coefficients of $C(x)$ is called the **convolution** of $a_0, \\dots, a_n$ and $b_0, \\dots, b_m$.\n\n!!! info \"Definition\"\n\tThe **degree** of a polynomial $A$ with $a_n \\neq 0$ is defined as $\\deg A = n$.\n\t\n\tFor consistency, degree of $A(x) = 0$ is defined as $\\deg A = -\\infty$.\n\nIn this notion, $\\deg AB = \\deg A + \\deg B$ for any polynomials $A$ and $B$.\n\nConvolutions are the basis of solving many enumerative problems.\n\n!!! Example\n\tYou have $n$ objects of the first kind and $m$ objects of the second kind.\n\n\tObjects of first kind are valued $a_1, \\dots, a_n$, and objects of the second kind are valued $b_1, \\dots, b_m$.\n\n\tYou pick a single object of the first kind and a single object of the second kind. How many ways are there to get the total value $k$?\n\n??? hint \"Solution\"\n\tConsider the product $(x^{a_1} + \\dots + x^{a_n})(x^{b_1} + \\dots + x^{b_m})$. If you expand it, each monomial will correspond to the pair $(a_i, b_j)$ and contribute to the coefficient near $x^{a_i+b_j}$. In other words, the answer is the coefficient near $x^k$ in the product.\n\n!!! Example\n\tYou throw a $6$-sided die $n$ times and sum up the results from all throws. What is the probability of getting sum of $k$?\n\n??? hint \"Solution\"\n\tThe answer is the number of outcomes having the sum $k$, divided by the total number of outcomes, which is $6^n$.\n\n\tWhat is the number of outcomes having the sum $k$? For $n=1$, it may be represented by a polynomial $A(x) = x^1+x^2+\\dots+x^6$.\n\n\tFor $n=2$, using the same approach as in the example above, we conclude that it is represented by the polynomial $(x^1+x^2+\\dots+x^6)^2$.\n\n\tThat being said, the answer to the problem is the $k$-th coefficient of $(x^1+x^2+\\dots+x^6)^n$, divided by $6^n$.\n\nThe coefficient near $x^k$ in the polynomial $A(x)$ is denoted shortly as $[x^k]A$.\n\n### Formal power series\n\n!!! info \"Definition\"\n\tA **formal power series** is an infinite sum $A(x) = a_0 + a_1 x + a_2 x^2 + \\dots$, considered regardless of its convergence properties.\n\nIn other words, when we consider e.g. a sum $1+\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\dots=2$, we imply that it _converges_ to $2$ when the number of summands approach infinity. However, formal series are only considered in terms of sequences that make them.\n\n!!! info \"Definition\"\n\tThe **product** of formal power series $A(x)$ and $B(x)$, is also defined by expanding it as an arithmetic expression:\n\n\n\t$$\n\tA(x) B(x) = \\left(\\sum\\limits_{i=0}^\\infty a_i x^i \\right)\\left(\\sum\\limits_{j=0}^\\infty b_j x^j\\right) = \\sum\\limits_{i,j} a_i b_j x^{i+j} = \\sum\\limits_{k=0}^{\\infty} c_k x^k = C(x),\n\t$$\n\n\twhere the coefficients $c_0, c_1, \\dots$ are define as finite sums\n\n\t$$\n\tc_k = \\sum\\limits_{i=0}^k a_i b_{k-i}.\n\t$$\n\n\tThe sequence $c_0, c_1, \\dots$ is also called a **convolution** of $a_0, a_1, \\dots$ and $b_0, b_1, \\dots$, generalizing the concept to infinite sequences.\n\nThus, polynomials may be considered formal power series, but with finite number of coefficients.\n\nFormal power series play a crucial role in enumerative combinatorics, where they're studied as [generating functions](https://en.wikipedia.org/wiki/Generating_function) for various sequences. Detailed explanation of generating functions and the intuition behind them will, unfortunately, be out of scope for this article, therefore the curious reader is referenced e.g. [here](https://codeforces.com/blog/entry/103979) for details about their combinatorial meaning.\n\nHowever, we will very briefly mention that if $A(x)$ and $B(x)$ are generating functions for sequences that enumerate some objects by number of \"atoms\" in them (e.g. trees by the number of vertices), then the product $A(x) B(x)$ enumerates objects that can be described as pairs of objects of kinds $A$ and $B$, enumerates by the total number of \"atoms\" in the pair.\n\n!!! Example\n\tLet $A(x) = \\sum\\limits_{i=0}^\\infty 2^i x^i$ enumerate packs of stones, each stone colored in one of $2$ colors (so, there are $2^i$ such packs of size $i$) and $B(x) = \\sum\\limits_{j=0}^{\\infty} 3^j x^j$ enumerate packs of stones, each stone colored in one of $3$ colors. Then $C(x) = A(x) B(x) = \\sum\\limits_{k=0}^\\infty c_k x^k$ would enumerate objects that may be described as \"two packs of stones, first pack only of stones of type $A$, second pack only of stones of type $B$, with total number of stones being $k$\" for $c_k$.\n\nIn a similar way, there is an intuitive meaning to some other functions over formal power series.\n\n### Long polynomial division\n\nSimilar to integers, it is possible to define long division on polynomials.\n\n!!! info \"Definition\"\n\n\tFor any polynomials $A$ and $B \\neq 0$, one may represent $A$ as\n\n\t$$\n\tA = D \\cdot B + R,~ \\deg R < \\deg B,\n\t$$\n\n\twhere $R$ is called the **remainder** of $A$ modulo $B$ and $D$ is called the **quotient**.\n\nDenoting $\\deg A = n$ and $\\deg B = m$, naive way to do it is to use long division, during which you multiply $B$ by the monomial $\\frac{a_n}{b_m} x^{n - m}$ and subtract it from $A$, until the degree of $A$ is smaller than that of $B$. What remains of $A$ in the end will be the remainder (hence the name), and the polynomials with which you multiplied $B$ in the process, summed together, form the quotient.\n\n!!! info \"Definition\"\n\tIf $A$ and $B$ have the same remainder modulo $C$, they're said to be **equivalent** modulo $C$, which is denoted as\n\t\n\t$$\n\tA \\equiv B \\pmod{C}.\n\t$$\n\t\nPolynomial long division is useful because of its many important properties:\n\n- $A$ is a multiple of $B$ if and only if $A \\equiv 0 \\pmod B$.\n\n- It implies that $A \\equiv B \\pmod C$ if and only if $A-B$ is a multiple of $C$.\n\n- In particular, $A \\equiv B \\pmod{C \\cdot D}$ implies $A \\equiv B \\pmod{C}$.\n\n- For any linear polynomial $x-r$ it holds that $A(x) \\equiv A(r) \\pmod{x-r}$.\n\n- It implies that $A$ is a multiple of $x-r$ if and only if $A(r)=0$.\n\n- For modulo being $x^k$, it holds that $A \\equiv a_0 + a_1 x + \\dots + a_{k-1} x^{k-1} \\pmod{x^k}$.\n\nNote that long division can't be properly defined for formal power series. Instead, for any $A(x)$ such that $a_0 \\neq 0$, it is possible to define an inverse formal power series $A^{-1}(x)$, such that $A(x) A^{-1}(x) = 1$. This fact, in turn, can be used to compute the result of long division for polynomials.\n\n## Basic implementation\n[Here](https://github.com/cp-algorithms/cp-algorithms-aux/blob/master/src/polynomial.cpp) you can find the basic implementation of polynomial algebra.\n\nIt supports all trivial operations and some other useful methods. The main class is `poly<T>` for polynomials with coefficients of type `T`.\n\nAll arithmetic operation `+`, `-`, `*`, `%` and `/` are supported, `%` and `/` standing for remainder and quotient in Euclidean division.\n\nThere is also the class `modular<m>` for performing arithmetic operations on remainders modulo a prime number `m`.\n\nOther useful functions:\n\n- `deriv()`: computes the derivative $P'(x)$ of $P(x)$.\n- `integr()`: computes the indefinite integral $Q(x) = \\int P(x)$ of $P(x)$ such that $Q(0)=0$.\n- `inv(size_t n)`: calculate the first $n$ coefficients of $P^{-1}(x)$ in $O(n \\log n)$.\n- `log(size_t n)`: calculate the first $n$ coefficients of $\\ln P(x)$ in $O(n \\log n)$.\n- `exp(size_t n)`: calculate the first $n$ coefficients of $\\exp P(x)$ in $O(n \\log n)$.\n- `pow(size_t k, size_t n)`: calculate the first $n$ coefficients for $P^{k}(x)$ in $O(n \\log nk)$.\n- `deg()`: returns the degree of $P(x)$.\n- `lead()`: returns the coefficient of $x^{\\deg P(x)}$.\n- `resultant(poly<T> a, poly<T> b)`: computes the resultant of $a$ and $b$ in $O(|a| \\cdot |b|)$.\n- `bpow(T x, size_t n)`: computes $x^n$.\n- `bpow(T x, size_t n, T m)`: computes $x^n \\pmod{m}$.\n- `chirpz(T z, size_t n)`: computes $P(1), P(z), P(z^2), \\dots, P(z^{n-1})$ in $O(n \\log n)$.\n- `vector<T> eval(vector<T> x)`: evaluates $P(x_1), \\dots, P(x_n)$ in $O(n \\log^2 n)$.\n- `poly<T> inter(vector<T> x, vector<T> y)`: interpolates a polynomial by a set of pairs $P(x_i) = y_i$ in $O(n \\log^2 n)$.\n- And some more, feel free to explore the code!\n\n## Arithmetic\n\n### Multiplication\n\nThe very core operation is the multiplication of two polynomials. That is, given the polynomials $A$ and $B$:\n\n$$A = a_0 + a_1 x + \\dots + a_n x^n$$\n\n$$B = b_0 + b_1 x + \\dots + b_m x^m$$\n\nYou have to compute polynomial $C = A \\cdot B$, which is defined as\n\n$$\\boxed{C = \\sum\\limits_{i=0}^n \\sum\\limits_{j=0}^m a_i b_j x^{i+j}}  = c_0 + c_1 x + \\dots + c_{n+m} x^{n+m}.$$\n\nIt can be computed in $O(n \\log n)$ via the [Fast Fourier transform](fft.md) and almost all methods here will use it as subroutine.\n\n### Inverse series\n\nIf $A(0) \\neq 0$ there always exists an infinite formal power series $A^{-1}(x) = q_0+q_1 x + q_2 x^2 + \\dots$ such that $A^{-1} A = 1$. It often proves useful to compute first $k$ coefficients of $A^{-1}$ (that is, to compute it modulo $x^k$). There are two major ways to calculate it.\n\n#### Divide and conquer\n\nThis algorithm was mentioned in [Sch\u00f6nhage's article](http://algo.inria.fr/seminars/sem00-01/schoenhage.pdf) and is inspired by [Graeffe's method](https://en.wikipedia.org/wiki/Graeffe's_method). It is known that for $B(x)=A(x)A(-x)$ it holds that $B(x)=B(-x)$, that is, $B(x)$ is an even polynomial. It means that it only has non-zero coefficients with even numbers and can be represented as $B(x)=T(x^2)$. Thus, we can do the following transition:\n\n$$A^{-1}(x) \\equiv \\frac{1}{A(x)} \\equiv \\frac{A(-x)}{A(x)A(-x)} \\equiv \\frac{A(-x)}{T(x^2)} \\pmod{x^k}$$\n\nNote that $T(x)$ can be computed with a single multiplication, after which we're only interested in the first half of coefficients of its inverse series. This effectively reduces the initial problem of computing $A^{-1} \\pmod{x^k}$ to computing $T^{-1} \\pmod{x^{\\lfloor k / 2 \\rfloor}}$.\n\nThe complexity of this method can be estimated as\n\n$$T(n) = T(n/2) + O(n \\log n) = O(n \\log n).$$\n\n#### Sieveking\u2013Kung algorithm\n\nThe generic process described here is known as Hensel lifting, as it follows from Hensel's lemma. We'll cover it in more detail further below, but for now let's focus on ad hoc solution. \"Lifting\" part here means that we start with the approximation $B_0=q_0=a_0^{-1}$, which is $A^{-1} \\pmod x$ and then iteratively lift from $\\bmod x^a$ to $\\bmod x^{2a}$.\n\nLet $B_k \\equiv A^{-1} \\pmod{x^a}$. The next approximation needs to follow the equation $A B_{k+1} \\equiv 1 \\pmod{x^{2a}}$ and may be represented as $B_{k+1} = B_k + x^a C$. From this follows the equation\n\n$$A(B_k + x^{a}C) \\equiv 1 \\pmod{x^{2a}}.$$\n\nLet $A B_k \\equiv 1 + x^a D \\pmod{x^{2a}}$, then the equation above implies\n\n$$x^a(D+AC) \\equiv 0 \\pmod{x^{2a}} \\implies D \\equiv -AC \\pmod{x^a} \\implies C \\equiv -B_k D \\pmod{x^a}.$$\n\nFrom this, one can obtain the final formula, which is\n\n$$x^a C \\equiv -B_k x^a D  \\equiv B_k(1-AB_k) \\pmod{x^{2a}} \\implies \\boxed{B_{k+1} \\equiv B_k(2-AB_k) \\pmod{x^{2a}}}$$\n\nThus starting with $B_0 \\equiv a_0^{-1} \\pmod x$ we will compute the sequence $B_k$ such that $AB_k \\equiv 1 \\pmod{x^{2^k}}$ with the complexity\n\n$$T(n) = T(n/2) + O(n \\log n) = O(n \\log n).$$\n\nThe algorithm here might seem a bit more complicated than the first one, but it has a very solid and practical reasoning behind it, as well as a great generalization potential if looked from a different perspective, which would be explained further below.\n\n### Euclidean division\n\nConsider two polynomials $A(x)$ and $B(x)$ of degrees $n$ and $m$. As it was said earlier you can rewrite $A(x)$ as\n\n$$A(x) = B(x) D(x) + R(x), \\deg R < \\deg B.$$\n\nLet $n \\geq m$, it would imply that $\\deg D = n - m$ and the leading $n-m+1$ coefficients of $A$ don't influence $R$. It means that you can recover $D(x)$ from the largest $n-m+1$ coefficients of $A(x)$ and $B(x)$ if you consider it as a system of equations.\n\nThe system of linear equations we're talking about can be written in the following form:\n\n$$\\begin{bmatrix} a_n \\\\ \\vdots \\\\ a_{m+1} \\\\ a_{m} \\end{bmatrix} = \\begin{bmatrix}\nb_m & \\dots & 0 & 0 \\\\\n\\vdots & \\ddots & \\vdots & \\vdots \\\\\n\\dots & \\dots & b_m & 0 \\\\\n\\dots & \\dots & b_{m-1} & b_m\n\\end{bmatrix} \\begin{bmatrix}d_{n-m} \\\\ \\vdots \\\\ d_1 \\\\ d_0\\end{bmatrix}$$\n\nFrom the looks of it, we can conclude that with the introduction of reversed polynomials\n\n$$A^R(x) = x^nA(x^{-1})= a_n + a_{n-1} x + \\dots + a_0 x^n$$\n\n$$B^R(x) = x^m B(x^{-1}) = b_m + b_{m-1} x + \\dots + b_0 x^m$$\n\n$$D^R(x) = x^{n-m}D(x^{-1}) = d_{n-m} + d_{n-m-1} x + \\dots + d_0 x^{n-m}$$\n\nthe system may be rewritten as\n\n$$A^R(x) \\equiv B^R(x) D^R(x) \\pmod{x^{n-m+1}}.$$\n\nFrom this you can unambiguously recover all coefficients of $D(x)$:\n\n$$\\boxed{D^R(x) \\equiv A^R(x) (B^R(x))^{-1} \\pmod{x^{n-m+1}}}$$\n\nAnd from this, in turn, you can recover $R(x)$ as $R(x) = A(x) - B(x)D(x)$.\n\nNote that the matrix above is a so-called triangular [Toeplitz matrix](https://en.wikipedia.org/wiki/Toeplitz_matrix) and, as we see here, solving system of linear equations with arbitrary Toeplitz matrix is, in fact, equivalent to polynomial inversion. Moreover, inverse matrix of it would also be triangular Toeplitz matrix and its entries, in terms used above, are the coefficients of $(B^R(x))^{-1} \\pmod{x^{n-m+1}}$.\n\n## Calculating functions of polynomial\n\n### Newton's method\n\nLet's generalize the Sieveking\u2013Kung algorithm. Consider equation $F(P) = 0$ where $P(x)$ should be a polynomial and $F(x)$ is some polynomial-valued function defined as\n\n$$F(x) = \\sum\\limits_{i=0}^\\infty \\alpha_i (x-\\beta)^i,$$\n\nwhere $\\beta$ is some constant. It can be proven that if we introduce a new formal variable $y$, we can express $F(x)$ as\n\n$$F(x) = F(y) + (x-y)F'(y) + (x-y)^2 G(x,y),$$\n\nwhere $F'(x)$ is the derivative formal power series defined as\n\n$$F'(x) = \\sum\\limits_{i=0}^\\infty (i+1)\\alpha_{i+1}(x-\\beta)^i,$$\n\nand $G(x, y)$ is some formal power series of $x$ and $y$. With this result we can find the solution iteratively.\n\nLet $F(Q_k) \\equiv 0 \\pmod{x^{a}}$. We need to find $Q_{k+1} \\equiv Q_k + x^a C \\pmod{x^{2a}}$ such that $F(Q_{k+1}) \\equiv 0 \\pmod{x^{2a}}$.\n\nSubstituting $x = Q_{k+1}$ and $y=Q_k$ in the formula above, we get\n\n$$F(Q_{k+1}) \\equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) + (Q_{k+1} - Q_k)^2 G(x, y) \\pmod x^{2a}.$$\n\nSince $Q_{k+1} - Q_k \\equiv 0 \\pmod{x^a}$, it also holds that $(Q_{k+1} - Q_k)^2 \\equiv 0 \\pmod{x^{2a}}$, thus\n\n$$0 \\equiv F(Q_{k+1}) \\equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) \\pmod{x^{2a}}.$$\n\nThe last formula gives us the value of $Q_{k+1}$:\n\n$$\\boxed{Q_{k+1} = Q_k - \\dfrac{F(Q_k)}{F'(Q_k)} \\pmod{x^{2a}}}$$\n\nThus, knowing how to invert polynomials and how to compute $F(Q_k)$, we can find $n$ coefficients of $P$ with the complexity\n\n$$T(n) = T(n/2) + f(n),$$\n\nwhere $f(n)$ is the time needed to compute $F(Q_k)$ and $F'(Q_k)^{-1}$ which is usually $O(n \\log n)$.\n\nThe iterative rule above is known in numerical analysis as [Newton's method](https://en.wikipedia.org/wiki/Newton%27s_method).\n\n#### Hensel's lemma\n\nAs was mentioned earlier, formally and generically this result is known as [Hensel's lemma](https://en.wikipedia.org/wiki/Hensel%27s_lemma) and it may in fact used in even broader sense when we work with a series of nested rings. In this particular case we worked with a sequence of polynomial remainders modulo $x$, $x^2$, $x^3$ and so on.\n\nAnother example where Hensel's lifting might be helpful are so-called [p-adic numbers](https://en.wikipedia.org/wiki/P-adic_number) where we, in fact, work with the sequence of integer remainders modulo $p$, $p^2$, $p^3$ and so on. For example, Newton's method can be used to find all possible [automorphic numbers](https://en.wikipedia.org/wiki/Automorphic_number) (numbers that end on itself when squared) with a given number base. The problem is left as an exercise to the reader. You might consider [this](https://acm.timus.ru/problem.aspx?space=1&num=1698) problem to check if your solution works for $10$-based numbers.\n\n\n### Logarithm\n\nFor the function $\\ln P(x)$ it's known that: \n\n$$\n\\boxed{(\\ln P(x))' = \\dfrac{P'(x)}{P(x)}}\n$$\n\nThus we can calculate $n$ coefficients of $\\ln P(x)$ in $O(n \\log n)$.\n\n\n### Inverse series\n\nTurns out, we can get the formula for $A^{-1}$ using Newton's method.\nFor this we take the equation $A=Q^{-1}$, thus:\n\n$$F(Q) = Q^{-1} - A$$\n\n$$F'(Q) = -Q^{-2}$$\n\n$$\\boxed{Q_{k+1} \\equiv Q_k(2-AQ_k) \\pmod{x^{2^{k+1}}}}$$\n\n### Exponent\n\nLet's learn to calculate $e^{P(x)}=Q(x)$. It should hold that $\\ln Q = P$, thus:\n\n$$F(Q) = \\ln Q - P$$\n\n$$F'(Q) = Q^{-1}$$\n\n$$\\boxed{Q_{k+1} \\equiv Q_k(1 + P - \\ln Q_k) \\pmod{x^{2^{k+1}}}}$$\n\n### $k$-th power { data-toc-label=\"k-th power\" }\n\nNow we need to calculate $P^k(x)=Q$. This may be done via the following formula:\n\n$$Q = \\exp\\left[k \\ln P(x)\\right]$$\n\nNote though, that you can calculate the logarithms and the exponents correctly only if you can find some initial $Q_0$.\n\nTo find it, you should calculate the logarithm or the exponent of the constant coefficient of the polynomial.\n\nBut the only reasonable way to do it is if $P(0)=1$ for $Q = \\ln P$ so $Q(0)=0$ and if $P(0)=0$ for $Q = e^P$ so $Q(0)=1$.\n\nThus you can use formula above only if $P(0) = 1$. Otherwise if $P(x) = \\alpha x^t T(x)$ where $T(0)=1$ you can write that:\n\n$$\\boxed{P^k(x) = \\alpha^kx^{kt} \\exp[k \\ln T(x)]}$$\n\nNote that you also can calculate some $k$-th root of a polynomial if you can calculate $\\sqrt[k]{\\alpha}$, for example for $\\alpha=1$.\n\n## Evaluation and Interpolation\n\n### Chirp-z Transform\n\nFor the particular case when you need to evaluate a polynomial in the points $x_r = z^{2r}$ you can do the following:\n\n$$A(z^{2r}) = \\sum\\limits_{k=0}^n a_k z^{2kr}$$\n\nLet's substitute $2kr = r^2+k^2-(r-k)^2$. Then this sum rewrites as:\n\n$$\\boxed{A(z^{2r}) = z^{r^2}\\sum\\limits_{k=0}^n (a_k z^{k^2}) z^{-(r-k)^2}}$$\n\nWhich is up to the factor $z^{r^2}$ equal to the convolution of the sequences $u_k = a_k z^{k^2}$ and $v_k = z^{-k^2}$.\n\nNote that $u_k$ has indexes from $0$ to $n$ here and $v_k$ has indexes from $-n$ to $m$ where $m$ is the maximum power of $z$ which you need.\n\nNow if you need to evaluate a polynomial in the points $x_r = z^{2r+1}$ you can reduce it to the previous task by the transformation $a_k \\to a_k z^k$.\n\nIt gives us an $O(n \\log n)$ algorithm when you need to compute values in powers of $z$, thus you may compute the DFT for non-powers of two.\n\nAnother observation is that $kr = \\binom{k+r}{2} - \\binom{k}{2} - \\binom{r}{2}$. Then we have\n\n$$\\boxed{A(z^r) = z^{-\\binom{r}{2}}\\sum\\limits_{k=0}^n \\left(a_k z^{-\\binom{k}{2}}\\right)z^{\\binom{k+r}{2}}}$$\n\nThe coefficient of $x^{n+r}$ of the product of the polynomials $A_0(x) = \\sum\\limits_{k=0}^n a_{n-k}z^{-\\binom{n-k}{2}}x^k$ and $A_1(x) = \\sum\\limits_{k\\geq 0}z^{\\binom{k}{2}}x^k$ equals $z^{\\binom{r}{2}}A(z^r)$. You can use the formula $z^{\\binom{k+1}{2}}=z^{\\binom{k}{2}+k}$ to calculate the coefficients of $A_0(x)$ and $A_1(x)$.\n\n### Multi-point Evaluation\nAssume you need to calculate $A(x_1), \\dots, A(x_n)$. As mentioned earlier, $A(x) \\equiv A(x_i) \\pmod{x-x_i}$. Thus you may do the following:\n\n1. Compute a segment tree such that in the segment $[l,r)$ stands the product $P_{l, r}(x) = (x-x_l)(x-x_{l+1})\\dots(x-x_{r-1})$.\n2. Starting with $l=1$ and $r=n+1$ at the root node. Let $m=\\lfloor(l+r)/2\\rfloor$. Let's move down to $[l,m)$ with the polynomial $A(x) \\pmod{P_{l,m}(x)}$.\n3. This will recursively compute $A(x_l), \\dots, A(x_{m-1})$, now do the same for $[m,r)$ with $A(x) \\pmod{P_{m,r}(x)}$.\n4. Concatenate the results from the first and second recursive call and return them.\n\nThe whole procedure will run in $O(n \\log^2 n)$.\n\n### Interpolation\n\nThere's a direct formula by Lagrange to interpolate a polynomial, given set of pairs $(x_i, y_i)$:\n\n$$\\boxed{A(x) = \\sum\\limits_{i=1}^n y_i \\prod\\limits_{j \\neq i}\\dfrac{x-x_j}{x_i - x_j}}$$\n\nComputing it directly is a hard thing but turns out, we may compute it in $O(n \\log^2 n)$ with a divide and conquer approach:\n\nConsider $P(x) = (x-x_1)\\dots(x-x_n)$. To know the coefficients of the denominators in $A(x)$ we should compute products like: \n\n$$\nP_i = \\prod\\limits_{j \\neq i} (x_i-x_j)\n$$\n\nBut if you consider the derivative $P'(x)$ you'll find out that $P'(x_i) = P_i$. Thus you can compute $P_i$'s via evaluation in $O(n \\log^2 n)$.\n\nNow consider the recursive algorithm done on same segment tree as in the multi-point evaluation. It starts in the leaves with the value $\\dfrac{y_i}{P_i}$ in each leaf.\n\nWhen we return from the recursion we should merge the results from the left and the right vertices as $A_{l,r} = A_{l,m}P_{m,r} + P_{l,m} A_{m,r}$.\n\nIn this way when you return back to the root you'll have exactly $A(x)$ in it.\nThe total procedure also works in $O(n \\log^2 n)$.\n\n## GCD and Resultants\n\nAssume you're given polynomials $A(x) = a_0 + a_1 x + \\dots + a_n x^n$ and $B(x) = b_0 + b_1 x + \\dots + b_m x^m$.\n\nLet $\\lambda_0, \\dots, \\lambda_n$ be the roots of $A(x)$ and let $\\mu_0, \\dots, \\mu_m$ be the roots of $B(x)$ counted with their multiplicities.\n\nYou want to know if $A(x)$ and $B(x)$ have any roots in common. There are two interconnected ways to do that.\n\n### Euclidean algorithm\n\nWell, we already have an [article](euclid-algorithm.md) about it. For an arbitrary  domain you can write the Euclidean algorithm as easy as:\n\n```cpp\ntemplate<typename T>\nT gcd(const T &a, const T &b) {\n\treturn b == T(0) ? a : gcd(b, a % b);\n}\n```\n\nIt can be proven that for polynomials $A(x)$ and $B(x)$ it will work in $O(nm)$.\n\n\n### Resultant\n\nLet's calculate the product $A(\\mu_0)\\cdots A(\\mu_m)$. It will be equal to zero if and only if some $\\mu_i$ is the root of $A(x)$.\n\nFor symmetry we can also multiply it with $b_m^n$ and rewrite the whole product in the following form:\n\n$$\\boxed{\\mathcal{R}(A, B) = b_m^n\\prod\\limits_{j=0}^m A(\\mu_j) = b_m^n a_m^n \\prod\\limits_{i=0}^n \\prod\\limits_{j=0}^m (\\mu_j - \\lambda_i)= (-1)^{mn}a_n^m \\prod\\limits_{i=0}^n B(\\lambda_i)}$$\n\nThe value defined above is called the resultant of the polynomials $A(x)$ and $B(x)$. From the definition you may find the following properties:\n\n1. $\\mathcal R(A, B) = (-1)^{nm} \\mathcal R(B, A)$.\n2. $\\mathcal R(A, B)= a_n^m b_m^n$ when $n=0$ or $m=0$.\n3. If $b_m=1$ then $\\mathcal R(A - CB, B) = \\mathcal R(A, B)$ for an arbitrary polynomial $C(x)$ and $n,m \\geq 1$.\n4. From this follows $\\mathcal R(A, B) = b_m^{\\deg(A) - \\deg(A-CB)}\\mathcal R(A - CB, B)$ for arbitrary $A(x)$, $B(x)$, $C(x)$.\n\nMiraculously it means that resultant of two polynomials is actually always from the same ring as their coefficients!\n\nAlso these properties allow us to calculate the resultant alongside the Euclidean algorithm, which works in $O(nm)$.\n\n\n```cpp\ntemplate<typename T>\nT resultant(poly<T> a, poly<T> b) {\n\tif(b.is_zero()) {\n\t\treturn 0;\n\t} else if(b.deg() == 0) {\n\t\treturn bpow(b.lead(), a.deg());\n\t} else {\n\t\tint pw = a.deg();\n\t\ta %= b;\n\t\tpw -= a.deg();\n\t\tbase mul = bpow(b.lead(), pw) * base((b.deg() & a.deg() & 1) ? -1 : 1);\n\t\tbase ans = resultant(b, a);\n\t\treturn ans * mul;\n\t}\n}\n```\n\n### Half-GCD algorithm\n\nThere is a way to calculate the GCD and resultants in $O(n \\log^2 n)$.\n\nThe procedure to do so implements a $2 \\times 2$ linear transform which maps a pair of polynomials $a(x)$, $b(x)$ into another pair $c(x), d(x)$ such that $\\deg d(x) \\leq \\frac{\\deg a(x)}{2}$. If you're careful enough, you can compute the half-GCD of any pair of polynomials with at most $2$ recursive calls to the polynomials which are at least $2$ times smaller.\n\nThe specific details of the algorithm are somewhat tedious to explain, however you can find its implementation in the library, as `half_gcd` function.\n\nAfter half-GCD is implemented, you can repeatedly apply it to polynomials until you're reduced to the pair of $\\gcd(a, b)$ and $0$.\n\n## Problems\n\n- [CodeChef - RNG](https://www.codechef.com/problems/RNG)\n- [CodeForces - Basis Change](https://codeforces.com/gym/102129/problem/D)\n- [CodeForces - Permutant](https://codeforces.com/gym/102129/problem/G)\n- [CodeForces - Medium Hadron Collider](https://codeforces.com/gym/102129/problem/C)\n", "problem_ids": [], "title": "Operations on polynomials and series"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: eratosthenes_sieve\n---\n\n# Sieve of Eratosthenes\n\nSieve of Eratosthenes is an algorithm for finding all the prime numbers in a segment $[1;n]$ using $O(n \\log \\log n)$ operations.\n\nThe algorithm is very simple:\nat the beginning we write down all numbers between 2 and $n$.\nWe mark all proper multiples of 2 (since 2 is the smallest prime number) as composite.\nA proper multiple of a number $x$, is a number greater than $x$ and divisible by $x$.\nThen we find the next number that hasn't been marked as composite, in this case it is 3.\nWhich means 3 is prime, and we mark all proper multiples of 3 as composite.\nThe next unmarked number is 5, which is the next prime number, and we mark all proper multiples of it.\nAnd we continue this procedure until we processed all numbers in the row.\n\nIn the following image you can see a visualization of the algorithm for computing all prime numbers in the range $[1; 16]$. It can be seen, that quite often we mark numbers as composite multiple times.\n\n<center>![Sieve of Eratosthenes](sieve_eratosthenes.png)</center>\n\nThe idea behind is this:\nA number is prime, if none of the smaller prime numbers divides it.\nSince we iterate over the prime numbers in order, we already marked all numbers, who are divisible by at least one of the prime numbers, as divisible.\nHence if we reach a cell and it is not marked, then it isn't divisible by any smaller prime number and therefore has to be prime.\n\n## Implementation\n\n```cpp\nint n;\nvector<bool> is_prime(n+1, true);\nis_prime[0] = is_prime[1] = false;\nfor (int i = 2; i <= n; i++) {\n    if (is_prime[i] && (long long)i * i <= n) {\n        for (int j = i * i; j <= n; j += i)\n            is_prime[j] = false;\n    }\n}\n```\n\nThis code first marks all numbers except zero and one as potential prime numbers, then it begins the process of sifting composite numbers.\nFor this it iterates over all numbers from $2$ to $n$.\nIf the current number $i$ is a prime number, it marks all numbers that are multiples of $i$ as composite numbers, starting from $i^2$.\nThis is already an optimization over naive way of implementing it, and is allowed as all smaller numbers that are multiples of $i$ necessary also have a prime factor which is less than $i$, so all of them were already sifted earlier.\nSince $i^2$ can easily overflow the type `int`, the additional verification is done using type `long long` before the second nested loop.\n\nUsing such implementation the algorithm consumes $O(n)$ of the memory (obviously) and performs $O(n \\log \\log n)$ (see next section).\n\n## Asymptotic analysis\n\nIt's simple to prove a running time of $O(n \\log n)$ without knowing anything about the distribution of primes - ignoring the `is_prime` check, the inner loop runs (at most) $n/i$ times for $i = 2, 3, 4, \\dots$, leading the total number of operations in the inner loop to be a harmonic sum like $n(1/2 + 1/3 + 1/4 + \\cdots)$, which is bounded by $O(n \\log n)$.\n\nLet's prove that algorithm's running time is $O(n \\log \\log n)$.\nThe algorithm will perform $\\frac{n}{p}$ operations for every prime $p \\le n$ the inner loop.\nHence, we need to evaluate the next expression:\n\n$$\\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac n p = n \\cdot \\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac 1 p.$$\n\nLet's recall two known facts.\n\n  - The number of prime numbers less than or equal to $n$ is approximately $\\frac n {\\ln n}$.\n  - The $k$-th prime number approximately equals $k \\ln k$ (that follows immediately from the previous fact).\n\nThus we can write down the sum in the following way:\n\n$$\\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac 1 p \\approx \\frac 1 2 + \\sum_{k = 2}^{\\frac n {\\ln n}} \\frac 1 {k \\ln k}.$$\n\nHere we extracted the first prime number 2 from the sum, because $k = 1$ in approximation $k \\ln k$  is $0$ and causes a division by zero.\n\nNow, let's evaluate this sum using the integral of a same function over $k$ from $2$ to $\\frac n {\\ln n}$ (we can make such approximation because, in fact, the sum is related to the integral as its approximation using the rectangle method):\n\n$$\\sum_{k = 2}^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} \\approx \\int_2^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} dk.$$\n\nThe antiderivative for the integrand is  $\\ln \\ln k$. Using a substitution and removing terms of lower order, we'll get the result:\n\n$$\\int_2^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} dk = \\ln \\ln \\frac n {\\ln n} - \\ln \\ln 2 = \\ln(\\ln n - \\ln \\ln n) - \\ln \\ln 2 \\approx \\ln \\ln n.$$\n\nNow, returning to the original sum, we'll get its approximate evaluation:\n\n$$\\sum_{\\substack{p \\le n, \\\\\\ p\\ is\\ prime}} \\frac n p \\approx n \\ln \\ln n + o(n).$$\n\nYou can find a more strict proof (that gives more precise evaluation which is accurate within constant multipliers) in the book authored by Hardy & Wright \"An Introduction to the Theory of Numbers\" (p. 349).\n\n## Different optimizations of the Sieve of Eratosthenes\n\nThe biggest weakness of the algorithm is, that it \"walks\" along the memory multiple times, only manipulating single elements.\nThis is not very cache friendly.\nAnd because of that, the constant which is concealed in $O(n \\log \\log n)$ is comparably big.\n\nBesides, the consumed memory is a bottleneck for big $n$.\n\nThe methods presented below allow us to reduce the quantity of the performed operations, as well as to shorten the consumed memory noticeably.\n\n### Sieving till root\n\nObviously, to find all the prime numbers until $n$, it will be enough just to perform the sifting only by the prime numbers, which do not exceed the root of $n$.\n\n```cpp\nint n;\nvector<bool> is_prime(n+1, true);\nis_prime[0] = is_prime[1] = false;\nfor (int i = 2; i * i <= n; i++) {\n    if (is_prime[i]) {\n        for (int j = i * i; j <= n; j += i)\n            is_prime[j] = false;\n    }\n}\n```\n\nSuch optimization doesn't affect the complexity (indeed, by repeating the proof presented above we'll get the evaluation $n \\ln \\ln \\sqrt n + o(n)$, which is asymptotically the same according to the properties of logarithms), though the number of operations will reduce noticeably.\n\n### Sieving by the odd numbers only\n\nSince all even numbers (except $2$) are composite, we can stop checking even numbers at all. Instead, we need to operate with odd numbers only.\n\nFirst, it will allow us to half the needed memory. Second, it will reduce the number of operations performing by algorithm approximately in half.\n\n### Memory consumption and speed of operations\n\nWe should notice, that these two implementations of the Sieve of Eratosthenes use $n$ bits of memory by using the data structure `vector<bool>`.\n`vector<bool>` is not a regular container that stores a series of `bool` (as in most computer architectures a `bool` takes one byte of memory).\nIt's a memory-optimization specialization of `vector<T>`, that only consumes $\\frac{N}{8}$ bytes of memory.\n\nModern processors architectures work much more efficiently with bytes than with bits as they usually cannot access bits directly.\nSo underneath the `vector<bool>` stores the bits in a large continuous memory, accesses the memory in blocks of a few bytes, and extracts/sets the bits with bit operations like bit masking and bit shifting.\n\nBecause of that there is a certain overhead when you read or write bits with a `vector<bool>`, and quite often using a `vector<char>` (which uses 1 byte for each entry, so 8x the amount of memory) is faster.\n\nHowever, for the simple implementations of the Sieve of Eratosthenes using a `vector<bool>` is faster.\nYou are limited by how fast you can load the data into the cache, and therefore using less memory gives a big advantage.\nA benchmark ([link](https://gist.github.com/jakobkogler/e6359ea9ced24fe304f1a8af3c9bee0e)) shows, that using a `vector<bool>` is between 1.4x and 1.7x faster than using a `vector<char>`.\n\nThe same considerations also apply to `bitset`.\nIt's also an efficient way of storing bits, similar to `vector<bool>`, so it takes only $\\frac{N}{8}$ bytes of memory, but is a bit slower in accessing the elements.\nIn the benchmark above `bitset` performs a bit worse than `vector<bool>`.\nAnother drawback from `bitset` is that you need to know the size at compile time.\n\n### Segmented Sieve\n\nIt follows from the optimization \"sieving till root\" that there is no need to keep the whole array `is_prime[1...n]` at all time.\nFor sieving it is enough to just keep the prime numbers until the root of $n$, i.e. `prime[1... sqrt(n)]`, split the complete range into blocks, and sieve each block separately.\n\nLet $s$ be a constant which determines the size of the block, then we have $\\lceil {\\frac n s} \\rceil$ blocks altogether, and the block $k$ ($k = 0 ... \\lfloor {\\frac n s} \\rfloor$) contains the numbers in a segment $[ks; ks + s - 1]$.\nWe can work on blocks by turns, i.e. for every block $k$ we will go through all the prime numbers (from $1$ to $\\sqrt n$) and perform sieving using them.\nIt is worth noting, that we have to modify the strategy a little bit when handling the first numbers: first, all the prime numbers from $[1; \\sqrt n]$  shouldn't remove themselves; and second, the numbers $0$ and $1$ should be marked as non-prime numbers.\nWhile working on the last block it should not be forgotten that the last needed number $n$ is not necessary located in the end of the block.\n\nAs discussed previously, the typical implementation of the Sieve of Eratosthenes is limited by the speed how fast you can load data into the CPU caches.\nBy splitting the range of potential prime numbers $[1; n]$ into smaller blocks, we never have to keep multiple blocks in memory at the same time, and all operations are much more cache-friendlier.\nAs we are now no longer limited by the cache speeds, we can replace the `vector<bool>` with a `vector<char>`, and gain some additional performance as the processors can handle read and writes with bytes directly and don't need to rely on bit operations for extracting individual bits.\nThe benchmark ([link](https://gist.github.com/jakobkogler/e6359ea9ced24fe304f1a8af3c9bee0e)) shows, that using a `vector<char>` is about 3x faster in this situation than using a `vector<bool>`.\nA word of caution: those numbers might differ depending on architecture, compiler, and optimization levels.\n\nHere we have an implementation that counts the number of primes smaller than or equal to $n$ using block sieving.\n\n```cpp\nint count_primes(int n) {\n    const int S = 10000;\n\n    vector<int> primes;\n    int nsqrt = sqrt(n);\n    vector<char> is_prime(nsqrt + 2, true);\n    for (int i = 2; i <= nsqrt; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j <= nsqrt; j += i)\n                is_prime[j] = false;\n        }\n    }\n\n    int result = 0;\n    vector<char> block(S);\n    for (int k = 0; k * S <= n; k++) {\n        fill(block.begin(), block.end(), true);\n        int start = k * S;\n        for (int p : primes) {\n            int start_idx = (start + p - 1) / p;\n            int j = max(start_idx, p) * p - start;\n            for (; j < S; j += p)\n                block[j] = false;\n        }\n        if (k == 0)\n            block[0] = block[1] = false;\n        for (int i = 0; i < S && start + i <= n; i++) {\n            if (block[i])\n                result++;\n        }\n    }\n    return result;\n}\n```\n\nThe running time of block sieving is the same as for regular sieve of Eratosthenes (unless the size of the blocks is very small), but the needed memory will shorten to $O(\\sqrt{n} + S)$ and we have better caching results.\nOn the other hand, there will be a division for each pair of a block and prime number from $[1; \\sqrt{n}]$, and that will be far worse for smaller block sizes.\nHence, it is necessary to keep balance when selecting the constant $S$.\nWe achieved the best results for block sizes between $10^4$ and $10^5$.\n\n## Find primes in range\n\nSometimes we need to find all prime numbers in a range $[L,R]$ of small size (e.g. $R - L + 1 \\approx 1e7$), where $R$ can be very large (e.g. $1e12$).\n\nTo solve such a problem, we can use the idea of the Segmented sieve.\nWe pre-generate all prime numbers up to $\\sqrt R$, and use those primes to mark all composite numbers in the segment $[L, R]$.\n\n```cpp\nvector<char> segmentedSieve(long long L, long long R) {\n    // generate all primes up to sqrt(R)\n    long long lim = sqrt(R);\n    vector<char> mark(lim + 1, false);\n    vector<long long> primes;\n    for (long long i = 2; i <= lim; ++i) {\n        if (!mark[i]) {\n            primes.emplace_back(i);\n            for (long long j = i * i; j <= lim; j += i)\n                mark[j] = true;\n        }\n    }\n\n    vector<char> isPrime(R - L + 1, true);\n    for (long long i : primes)\n        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)\n            isPrime[j - L] = false;\n    if (L == 1)\n        isPrime[0] = false;\n    return isPrime;\n}\n```\nTime complexity of this approach is $O((R - L + 1) \\log \\log (R) + \\sqrt R \\log \\log \\sqrt R)$.\n\nIt's also possible that we don't pre-generate all prime numbers:\n\n```cpp\nvector<char> segmentedSieveNoPreGen(long long L, long long R) {\n    vector<char> isPrime(R - L + 1, true);\n    long long lim = sqrt(R);\n    for (long long i = 2; i <= lim; ++i)\n        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)\n            isPrime[j - L] = false;\n    if (L == 1)\n        isPrime[0] = false;\n    return isPrime;\n}\n```\n\nObviously, the complexity is worse, which is $O((R - L + 1) \\log (R) + \\sqrt R)$. However, it still runs very fast in practice.\n\n## Linear time modification\n\nWe can modify the algorithm in a such a way, that it only has linear time complexity.\nThis approach is described in the article [Linear Sieve](prime-sieve-linear.md).\nHowever, this algorithm also has its own weaknesses.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: eratosthenes_sieve\n---\n\n# Sieve of Eratosthenes\n\nSieve of Eratosthenes is an algorithm for finding all the prime numbers in a segment $[1;n]$ using $O(n \\log \\log n)$ operations.\n\nThe algorithm is very simple:\nat the beginning we write down all numbers between 2 and $n$.\nWe mark all proper multiples of 2 (since 2 is the smallest prime number) as composite.\nA proper multiple of a number $x$, is a number greater than $x$ and divisible by $x$.\nThen we find the next number that hasn't been marked as composite, in this case it is 3.\nWhich means 3 is prime, and we mark all proper multiples of 3 as composite.\nThe next unmarked number is 5, which is the next prime number, and we mark all proper multiples of it.\nAnd we continue this procedure until we processed all numbers in the row.\n\nIn the following image you can see a visualization of the algorithm for computing all prime numbers in the range $[1; 16]$. It can be seen, that quite often we mark numbers as composite multiple times.\n\n<center>![Sieve of Eratosthenes](sieve_eratosthenes.png)</center>\n\nThe idea behind is this:\nA number is prime, if none of the smaller prime numbers divides it.\nSince we iterate over the prime numbers in order, we already marked all numbers, who are divisible by at least one of the prime numbers, as divisible.\nHence if we reach a cell and it is not marked, then it isn't divisible by any smaller prime number and therefore has to be prime.\n\n## Implementation\n\n```cpp\nint n;\nvector<bool> is_prime(n+1, true);\nis_prime[0] = is_prime[1] = false;\nfor (int i = 2; i <= n; i++) {\n    if (is_prime[i] && (long long)i * i <= n) {\n        for (int j = i * i; j <= n; j += i)\n            is_prime[j] = false;\n    }\n}\n```\n\nThis code first marks all numbers except zero and one as potential prime numbers, then it begins the process of sifting composite numbers.\nFor this it iterates over all numbers from $2$ to $n$.\nIf the current number $i$ is a prime number, it marks all numbers that are multiples of $i$ as composite numbers, starting from $i^2$.\nThis is already an optimization over naive way of implementing it, and is allowed as all smaller numbers that are multiples of $i$ necessary also have a prime factor which is less than $i$, so all of them were already sifted earlier.\nSince $i^2$ can easily overflow the type `int`, the additional verification is done using type `long long` before the second nested loop.\n\nUsing such implementation the algorithm consumes $O(n)$ of the memory (obviously) and performs $O(n \\log \\log n)$ (see next section).\n\n## Asymptotic analysis\n\nIt's simple to prove a running time of $O(n \\log n)$ without knowing anything about the distribution of primes - ignoring the `is_prime` check, the inner loop runs (at most) $n/i$ times for $i = 2, 3, 4, \\dots$, leading the total number of operations in the inner loop to be a harmonic sum like $n(1/2 + 1/3 + 1/4 + \\cdots)$, which is bounded by $O(n \\log n)$.\n\nLet's prove that algorithm's running time is $O(n \\log \\log n)$.\nThe algorithm will perform $\\frac{n}{p}$ operations for every prime $p \\le n$ the inner loop.\nHence, we need to evaluate the next expression:\n\n$$\\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac n p = n \\cdot \\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac 1 p.$$\n\nLet's recall two known facts.\n\n  - The number of prime numbers less than or equal to $n$ is approximately $\\frac n {\\ln n}$.\n  - The $k$-th prime number approximately equals $k \\ln k$ (that follows immediately from the previous fact).\n\nThus we can write down the sum in the following way:\n\n$$\\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac 1 p \\approx \\frac 1 2 + \\sum_{k = 2}^{\\frac n {\\ln n}} \\frac 1 {k \\ln k}.$$\n\nHere we extracted the first prime number 2 from the sum, because $k = 1$ in approximation $k \\ln k$  is $0$ and causes a division by zero.\n\nNow, let's evaluate this sum using the integral of a same function over $k$ from $2$ to $\\frac n {\\ln n}$ (we can make such approximation because, in fact, the sum is related to the integral as its approximation using the rectangle method):\n\n$$\\sum_{k = 2}^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} \\approx \\int_2^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} dk.$$\n\nThe antiderivative for the integrand is  $\\ln \\ln k$. Using a substitution and removing terms of lower order, we'll get the result:\n\n$$\\int_2^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} dk = \\ln \\ln \\frac n {\\ln n} - \\ln \\ln 2 = \\ln(\\ln n - \\ln \\ln n) - \\ln \\ln 2 \\approx \\ln \\ln n.$$\n\nNow, returning to the original sum, we'll get its approximate evaluation:\n\n$$\\sum_{\\substack{p \\le n, \\\\\\ p\\ is\\ prime}} \\frac n p \\approx n \\ln \\ln n + o(n).$$\n\nYou can find a more strict proof (that gives more precise evaluation which is accurate within constant multipliers) in the book authored by Hardy & Wright \"An Introduction to the Theory of Numbers\" (p. 349).\n\n## Different optimizations of the Sieve of Eratosthenes\n\nThe biggest weakness of the algorithm is, that it \"walks\" along the memory multiple times, only manipulating single elements.\nThis is not very cache friendly.\nAnd because of that, the constant which is concealed in $O(n \\log \\log n)$ is comparably big.\n\nBesides, the consumed memory is a bottleneck for big $n$.\n\nThe methods presented below allow us to reduce the quantity of the performed operations, as well as to shorten the consumed memory noticeably.\n\n### Sieving till root\n\nObviously, to find all the prime numbers until $n$, it will be enough just to perform the sifting only by the prime numbers, which do not exceed the root of $n$.\n\n```cpp\nint n;\nvector<bool> is_prime(n+1, true);\nis_prime[0] = is_prime[1] = false;\nfor (int i = 2; i * i <= n; i++) {\n    if (is_prime[i]) {\n        for (int j = i * i; j <= n; j += i)\n            is_prime[j] = false;\n    }\n}\n```\n\nSuch optimization doesn't affect the complexity (indeed, by repeating the proof presented above we'll get the evaluation $n \\ln \\ln \\sqrt n + o(n)$, which is asymptotically the same according to the properties of logarithms), though the number of operations will reduce noticeably.\n\n### Sieving by the odd numbers only\n\nSince all even numbers (except $2$) are composite, we can stop checking even numbers at all. Instead, we need to operate with odd numbers only.\n\nFirst, it will allow us to half the needed memory. Second, it will reduce the number of operations performing by algorithm approximately in half.\n\n### Memory consumption and speed of operations\n\nWe should notice, that these two implementations of the Sieve of Eratosthenes use $n$ bits of memory by using the data structure `vector<bool>`.\n`vector<bool>` is not a regular container that stores a series of `bool` (as in most computer architectures a `bool` takes one byte of memory).\nIt's a memory-optimization specialization of `vector<T>`, that only consumes $\\frac{N}{8}$ bytes of memory.\n\nModern processors architectures work much more efficiently with bytes than with bits as they usually cannot access bits directly.\nSo underneath the `vector<bool>` stores the bits in a large continuous memory, accesses the memory in blocks of a few bytes, and extracts/sets the bits with bit operations like bit masking and bit shifting.\n\nBecause of that there is a certain overhead when you read or write bits with a `vector<bool>`, and quite often using a `vector<char>` (which uses 1 byte for each entry, so 8x the amount of memory) is faster.\n\nHowever, for the simple implementations of the Sieve of Eratosthenes using a `vector<bool>` is faster.\nYou are limited by how fast you can load the data into the cache, and therefore using less memory gives a big advantage.\nA benchmark ([link](https://gist.github.com/jakobkogler/e6359ea9ced24fe304f1a8af3c9bee0e)) shows, that using a `vector<bool>` is between 1.4x and 1.7x faster than using a `vector<char>`.\n\nThe same considerations also apply to `bitset`.\nIt's also an efficient way of storing bits, similar to `vector<bool>`, so it takes only $\\frac{N}{8}$ bytes of memory, but is a bit slower in accessing the elements.\nIn the benchmark above `bitset` performs a bit worse than `vector<bool>`.\nAnother drawback from `bitset` is that you need to know the size at compile time.\n\n### Segmented Sieve\n\nIt follows from the optimization \"sieving till root\" that there is no need to keep the whole array `is_prime[1...n]` at all time.\nFor sieving it is enough to just keep the prime numbers until the root of $n$, i.e. `prime[1... sqrt(n)]`, split the complete range into blocks, and sieve each block separately.\n\nLet $s$ be a constant which determines the size of the block, then we have $\\lceil {\\frac n s} \\rceil$ blocks altogether, and the block $k$ ($k = 0 ... \\lfloor {\\frac n s} \\rfloor$) contains the numbers in a segment $[ks; ks + s - 1]$.\nWe can work on blocks by turns, i.e. for every block $k$ we will go through all the prime numbers (from $1$ to $\\sqrt n$) and perform sieving using them.\nIt is worth noting, that we have to modify the strategy a little bit when handling the first numbers: first, all the prime numbers from $[1; \\sqrt n]$  shouldn't remove themselves; and second, the numbers $0$ and $1$ should be marked as non-prime numbers.\nWhile working on the last block it should not be forgotten that the last needed number $n$ is not necessary located in the end of the block.\n\nAs discussed previously, the typical implementation of the Sieve of Eratosthenes is limited by the speed how fast you can load data into the CPU caches.\nBy splitting the range of potential prime numbers $[1; n]$ into smaller blocks, we never have to keep multiple blocks in memory at the same time, and all operations are much more cache-friendlier.\nAs we are now no longer limited by the cache speeds, we can replace the `vector<bool>` with a `vector<char>`, and gain some additional performance as the processors can handle read and writes with bytes directly and don't need to rely on bit operations for extracting individual bits.\nThe benchmark ([link](https://gist.github.com/jakobkogler/e6359ea9ced24fe304f1a8af3c9bee0e)) shows, that using a `vector<char>` is about 3x faster in this situation than using a `vector<bool>`.\nA word of caution: those numbers might differ depending on architecture, compiler, and optimization levels.\n\nHere we have an implementation that counts the number of primes smaller than or equal to $n$ using block sieving.\n\n```cpp\nint count_primes(int n) {\n    const int S = 10000;\n\n    vector<int> primes;\n    int nsqrt = sqrt(n);\n    vector<char> is_prime(nsqrt + 2, true);\n    for (int i = 2; i <= nsqrt; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j <= nsqrt; j += i)\n                is_prime[j] = false;\n        }\n    }\n\n    int result = 0;\n    vector<char> block(S);\n    for (int k = 0; k * S <= n; k++) {\n        fill(block.begin(), block.end(), true);\n        int start = k * S;\n        for (int p : primes) {\n            int start_idx = (start + p - 1) / p;\n            int j = max(start_idx, p) * p - start;\n            for (; j < S; j += p)\n                block[j] = false;\n        }\n        if (k == 0)\n            block[0] = block[1] = false;\n        for (int i = 0; i < S && start + i <= n; i++) {\n            if (block[i])\n                result++;\n        }\n    }\n    return result;\n}\n```\n\nThe running time of block sieving is the same as for regular sieve of Eratosthenes (unless the size of the blocks is very small), but the needed memory will shorten to $O(\\sqrt{n} + S)$ and we have better caching results.\nOn the other hand, there will be a division for each pair of a block and prime number from $[1; \\sqrt{n}]$, and that will be far worse for smaller block sizes.\nHence, it is necessary to keep balance when selecting the constant $S$.\nWe achieved the best results for block sizes between $10^4$ and $10^5$.\n\n## Find primes in range\n\nSometimes we need to find all prime numbers in a range $[L,R]$ of small size (e.g. $R - L + 1 \\approx 1e7$), where $R$ can be very large (e.g. $1e12$).\n\nTo solve such a problem, we can use the idea of the Segmented sieve.\nWe pre-generate all prime numbers up to $\\sqrt R$, and use those primes to mark all composite numbers in the segment $[L, R]$.\n\n```cpp\nvector<char> segmentedSieve(long long L, long long R) {\n    // generate all primes up to sqrt(R)\n    long long lim = sqrt(R);\n    vector<char> mark(lim + 1, false);\n    vector<long long> primes;\n    for (long long i = 2; i <= lim; ++i) {\n        if (!mark[i]) {\n            primes.emplace_back(i);\n            for (long long j = i * i; j <= lim; j += i)\n                mark[j] = true;\n        }\n    }\n\n    vector<char> isPrime(R - L + 1, true);\n    for (long long i : primes)\n        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)\n            isPrime[j - L] = false;\n    if (L == 1)\n        isPrime[0] = false;\n    return isPrime;\n}\n```\nTime complexity of this approach is $O((R - L + 1) \\log \\log (R) + \\sqrt R \\log \\log \\sqrt R)$.\n\nIt's also possible that we don't pre-generate all prime numbers:\n\n```cpp\nvector<char> segmentedSieveNoPreGen(long long L, long long R) {\n    vector<char> isPrime(R - L + 1, true);\n    long long lim = sqrt(R);\n    for (long long i = 2; i <= lim; ++i)\n        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)\n            isPrime[j - L] = false;\n    if (L == 1)\n        isPrime[0] = false;\n    return isPrime;\n}\n```\n\nObviously, the complexity is worse, which is $O((R - L + 1) \\log (R) + \\sqrt R)$. However, it still runs very fast in practice.\n\n## Linear time modification\n\nWe can modify the algorithm in a such a way, that it only has linear time complexity.\nThis approach is described in the article [Linear Sieve](prime-sieve-linear.md).\nHowever, this algorithm also has its own weaknesses.\n\n## Practice Problems\n\n* [Leetcode - Four Divisors](https://leetcode.com/problems/four-divisors/)\n* [Leetcode - Count Primes](https://leetcode.com/problems/count-primes/)\n* [SPOJ - Printing Some Primes](http://www.spoj.com/problems/TDPRIMES/)\n* [SPOJ - A Conjecture of Paul Erdos](http://www.spoj.com/problems/HS08PAUL/)\n* [SPOJ - Primal Fear](http://www.spoj.com/problems/VECTAR8/)\n* [SPOJ - Primes Triangle (I)](http://www.spoj.com/problems/PTRI/)\n* [Codeforces - Almost Prime](http://codeforces.com/contest/26/problem/A)\n* [Codeforces - Sherlock And His Girlfriend](http://codeforces.com/contest/776/problem/B)\n* [SPOJ - Namit in Trouble](http://www.spoj.com/problems/NGIRL/)\n* [SPOJ - Bazinga!](http://www.spoj.com/problems/DCEPC505/)\n* [Project Euler - Prime pair connection](https://www.hackerrank.com/contests/projecteuler/challenges/euler134)\n* [SPOJ - N-Factorful](http://www.spoj.com/problems/NFACTOR/)\n* [SPOJ - Binary Sequence of Prime Numbers](http://www.spoj.com/problems/BSPRIME/)\n* [UVA 11353 - A Different Kind of Sorting](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2338)\n* [SPOJ - Prime Generator](http://www.spoj.com/problems/PRIME1/)\n* [SPOJ - Printing some primes (hard)](http://www.spoj.com/problems/PRIMES2/)\n* [Codeforces - Nodbach Problem](https://codeforces.com/problemset/problem/17/A)\n* [Codefoces - Colliders](https://codeforces.com/problemset/problem/154/B)\n", "problem_ids": ["26_A"], "title": "Sieve of Eratosthenes"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: binary_pow\n---\n\n# Binary Exponentiation\n\nBinary exponentiation (also known as exponentiation by squaring) is a trick which allows to calculate $a^n$ using only $O(\\log n)$ multiplications (instead of $O(n)$ multiplications required by the naive approach).\n\nIt also has important applications in many tasks unrelated to arithmetic, since it\ncan be used with any operations that have the property of **associativity**:\n\n$$(X \\cdot Y) \\cdot Z = X \\cdot (Y \\cdot Z)$$\n\nMost obviously this applies to modular multiplication, to multiplication of matrices and\nto other problems which we will discuss below.\n\n## Algorithm\n\nRaising $a$ to the power of $n$ is expressed naively as multiplication by $a$ done $n - 1$ times:\n$a^{n} = a \\cdot a \\cdot \\ldots \\cdot a$. However, this approach is not practical for large $a$ or $n$.\n\n$a^{b+c} = a^b \\cdot a^c$ and $a^{2b} = a^b \\cdot a^b = (a^b)^2$.\n\nThe idea of binary exponentiation is, that we split the work using the binary representation of the exponent.\n\nLet's write $n$ in base 2, for example:\n\n$$3^{13} = 3^{1101_2} = 3^8 \\cdot 3^4 \\cdot 3^1$$\n\nSince the number $n$ has exactly $\\lfloor \\log_2 n \\rfloor + 1$ digits in base 2, we only need to perform $O(\\log n)$ multiplications, if we know the powers $a^1, a^2, a^4, a^8, \\dots, a^{2^{\\lfloor \\log n \\rfloor}}$.\n\nSo we only need to know a fast way to compute those.\nLuckily this is very easy, since an element in the sequence is just the square of the previous element.\n\n$$\\begin{align}\n3^1 &= 3 \\\\\n3^2 &= \\left(3^1\\right)^2 = 3^2 = 9 \\\\\n3^4 &= \\left(3^2\\right)^2 = 9^2 = 81 \\\\\n3^8 &= \\left(3^4\\right)^2 = 81^2 = 6561\n\\end{align}$$\n\nSo to get the final answer for $3^{13}$, we only need to multiply three of them (skipping $3^2$ because the corresponding bit in $n$ is not set):\n$3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323$\n\nThe final complexity of this algorithm is $O(\\log n)$: we have to compute $\\log n$ powers of $a$, and then have to do at most $\\log n$ multiplications to get the final answer from them.\n\nThe following recursive approach expresses the same idea:\n\n$$a^n = \\begin{cases}\n1 &\\text{if } n == 0 \\\\\n\\left(a^{\\frac{n}{2}}\\right)^2 &\\text{if } n > 0 \\text{ and } n \\text{ even}\\\\\n\\left(a^{\\frac{n - 1}{2}}\\right)^2 \\cdot a &\\text{if } n > 0 \\text{ and } n \\text{ odd}\\\\\n\\end{cases}$$\n\n## Implementation\n\nFirst the recursive approach, which is a direct translation of the recursive formula:\n\n```cpp\nlong long binpow(long long a, long long b) {\n    if (b == 0)\n        return 1;\n    long long res = binpow(a, b / 2);\n    if (b % 2)\n        return res * res * a;\n    else\n        return res * res;\n}\n```\n\nThe second approach accomplishes the same task without recursion.\nIt computes all the powers in a loop, and multiplies the ones with the corresponding set bit in $n$.\nAlthough the complexity of both approaches is identical, this approach will be faster in practice since we don't have the overhead of the recursive calls.\n\n```cpp\nlong long binpow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        a = a * a;\n        b >>= 1;\n    }\n    return res;\n}\n```\n\n## Applications\n\n### Effective computation of large exponents modulo a number\n\n**Problem:**\nCompute $x^n \\bmod m$.\nThis is a very common operation. For instance it is used in computing the [modular multiplicative inverse](module-inverse.md).\n\n**Solution:**\nSince we know that the modulo operator doesn't interfere with multiplications ($a \\cdot b \\equiv (a \\bmod m) \\cdot (b \\bmod m) \\pmod m$), we can directly use the same code, and just replace every multiplication with a modular multiplication:\n\n```cpp\nlong long binpow(long long a, long long b, long long m) {\n    a %= m;\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a % m;\n        a = a * a % m;\n        b >>= 1;\n    }\n    return res;\n}\n```\n\n**Note:**\nIt's possible to speed this algorithm for large $b >> m$.\nIf $m$ is a prime number $x^n \\equiv x^{n \\bmod (m-1)} \\pmod{m}$ for prime $m$, and $x^n \\equiv x^{n \\bmod{\\phi(m)}} \\pmod{m}$ for composite $m$.\nThis follows directly from Fermat's little theorem and Euler's theorem, see the article about [Modular Inverses](module-inverse.md#fermat-euler) for more details.\n\n### Effective computation of Fibonacci numbers\n\n**Problem:** Compute $n$-th Fibonacci number $F_n$.\n\n**Solution:** For more details, see the [Fibonacci Number article](fibonacci-numbers.md).\nWe will only go through an overview of the algorithm.\nTo compute the next Fibonacci number, only the two previous ones are needed, as $F_n = F_{n-1} + F_{n-2}$.\nWe can build a $2 \\times 2$ matrix that describes this transformation:\nthe transition from $F_i$ and $F_{i+1}$ to $F_{i+1}$ and $F_{i+2}$.\nFor example, applying this transformation to the pair $F_0$ and $F_1$ would change it into $F_1$ and $F_2$.\nTherefore, we can raise this transformation matrix to the $n$-th power to find $F_n$ in time complexity $O(\\log n)$.\n\n### Applying a permutation $k$ times { data-toc-label='Applying a permutation <script type=\"math/tex\">k</script> times' }\n\n**Problem:** You are given a sequence of length $n$. Apply to it a given permutation $k$ times.\n\n**Solution:** Simply raise the permutation to $k$-th power using binary exponentiation, and then apply it to the sequence. This will give you a time complexity of $O(n \\log k)$.\n\n```cpp\nvector<int> applyPermutation(vector<int> sequence, vector<int> permutation) {\n    vector<int> newSequence(sequence.size());\n    for(int i = 0; i < sequence.size(); i++) {\n        newSequence[i] = sequence[permutation[i]];\n    }\n    return newSequence;\n}\n\nvector<int> permute(vector<int> sequence, vector<int> permutation, long long b) {\n    while (b > 0) {\n        if (b & 1) {\n            sequence = applyPermutation(sequence, permutation);\n        }\n        permutation = applyPermutation(permutation, permutation);\n        b >>= 1;\n    }\n    return sequence;\n}\n```\n\n**Note:** This task can be solved more efficiently in linear time by building the permutation graph and considering each cycle independently. You could then compute $k$ modulo the size of the cycle and find the final position for each number which is part of this cycle.\n\n### Fast application of a set of geometric operations to a set of points\n\n**Problem:** Given $n$ points $p_i$, apply $m$ transformations to each of these points. Each transformation can be a shift, a scaling or a rotation around a given axis by a given angle. There is also a \"loop\" operation which applies a given list of transformations $k$ times (\"loop\" operations can be nested). You should apply all transformations faster than $O(n \\cdot length)$, where $length$ is the total number of transformations to be applied (after unrolling \"loop\" operations).\n\n**Solution:** Let's look at how the different types of transformations change the coordinates:\n\n* Shift operation: adds a different constant to each of the coordinates.\n* Scaling operation: multiplies each of the coordinates by a different constant.\n* Rotation operation: the transformation is more complicated (we won't go in details here), but each of the new coordinates still can be represented as a linear combination of the old ones.\n\nAs you can see, each of the transformations can be represented as a linear operation on the coordinates. Thus, a transformation can be written as a $4 \\times 4$ matrix of the form:\n\n$$\\begin{pmatrix}\na_{11} & a_ {12} & a_ {13} & a_ {14} \\\\\na_{21} & a_ {22} & a_ {23} & a_ {24} \\\\\na_{31} & a_ {32} & a_ {33} & a_ {34} \\\\\na_{41} & a_ {42} & a_ {43} & a_ {44}\n\\end{pmatrix}$$\n\nthat, when multiplied by a vector with the old coordinates and an unit gives a new vector with the new coordinates and an unit:\n\n$$\\begin{pmatrix} x & y & z & 1 \\end{pmatrix} \\cdot\n\\begin{pmatrix}\na_{11} & a_ {12} & a_ {13} & a_ {14} \\\\\na_{21} & a_ {22} & a_ {23} & a_ {24} \\\\\na_{31} & a_ {32} & a_ {33} & a_ {34} \\\\\na_{41} & a_ {42} & a_ {43} & a_ {44}\n\\end{pmatrix}\n = \\begin{pmatrix} x' & y' & z' & 1 \\end{pmatrix}$$\n\n(Why introduce a fictitious fourth coordinate, you ask? That is the beauty of [homogeneous coordinates](https://en.wikipedia.org/wiki/Homogeneous_coordinates), which find great application in computer graphics. Without this, it would not be possible to implement affine operations like the shift operation as a single matrix multiplication, as it requires us to _add_ a constant to the coordinates. The affine transformation becomes a linear transformation in the higher dimension!)\n\nHere are some examples of how transformations are represented in matrix form:\n\n* Shift operation: shift $x$ coordinate by $5$, $y$ coordinate by $7$ and $z$ coordinate by $9$.\n\n$$\\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n5 & 7 & 9 & 1\n\\end{pmatrix}$$\n\n* Scaling operation: scale the $x$ coordinate by $10$ and the other two by $5$.\n\n$$\\begin{pmatrix}\n10 & 0 & 0 & 0 \\\\\n0 & 5 & 0 & 0 \\\\\n0 & 0 & 5 & 0 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}$$\n\n* Rotation operation: rotate $\\theta$ degrees around the $x$ axis following the right-hand rule (counter-clockwise direction).\n\n$$\\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & \\cos \\theta & -\\sin \\theta & 0 \\\\\n0 & \\sin \\theta & \\cos \\theta & 0 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}$$\n\nNow, once every transformation is described as a matrix, the sequence of transformations can be described as a product of these matrices, and a \"loop\" of $k$ repetitions can be described as the matrix raised to the power of $k$ (which can be calculated using binary exponentiation in $O(\\log{k})$). This way, the matrix which represents all transformations can be calculated first in $O(m \\log{k})$, and then it can be applied to each of the $n$ points in $O(n)$ for a total complexity of $O(n + m \\log{k})$.\n\n\n### Number of paths of length $k$ in a graph { data-toc-label='Number of paths of length <script type=\"math/tex\">k</script> in a graph' }\n\n**Problem:** Given a directed unweighted graph of $n$ vertices, find the number of paths of length $k$ from any vertex $u$ to any other vertex $v$.\n\n**Solution:** This problem is considered in more detail in [a separate article](../graph/fixed_length_paths.md). The algorithm consists of raising the adjacency matrix $M$ of the graph (a matrix where $m_{ij} = 1$ if there is an edge from $i$ to $j$, or $0$ otherwise) to the $k$-th power. Now $m_{ij}$ will be the number of paths of length $k$ from $i$ to $j$. The time complexity of this solution is $O(n^3 \\log k)$.\n\n**Note:** In that same article, another variation of this problem is considered: when the edges are weighted and it is required to find the minimum weight path containing exactly $k$ edges. As shown in that article, this problem is also solved by exponentiation of the adjacency matrix. The matrix would have the weight of the edge from $i$ to $j$, or $\\infty$ if there is no such edge.\nInstead of the usual operation of multiplying two matrices, a modified one should be used:\ninstead of multiplication, both values are added, and instead of a summation, a minimum is taken.\nThat is: $result_{ij} = \\min\\limits_{1\\ \\leq\\ k\\ \\leq\\ n}(a_{ik} + b_{kj})$.\n\n### Variation of binary exponentiation: multiplying two numbers modulo $m$ { data-toc-label='Variation of binary exponentiation: multiplying two numbers modulo <script type=\"math/tex\">m</script>' }\n\n**Problem:** Multiply two numbers $a$ and $b$ modulo $m$. $a$ and $b$ fit in the built-in data types, but their product is too big to fit in a 64-bit integer. The idea is to compute $a \\cdot b \\pmod m$ without using bignum arithmetics.\n\n**Solution:** We simply apply the binary construction algorithm described above, only performing additions instead of multiplications. In other words, we have \"expanded\" the multiplication of two numbers to $O (\\log m)$ operations of addition and multiplication by two (which, in essence, is an addition).\n\n$$a \\cdot b = \\begin{cases}\n0 &\\text{if }a = 0 \\\\\n2 \\cdot \\frac{a}{2} \\cdot b &\\text{if }a > 0 \\text{ and }a \\text{ even} \\\\\n2 \\cdot \\frac{a-1}{2} \\cdot b + b &\\text{if }a > 0 \\text{ and }a \\text{ odd}\n\\end{cases}$$\n\n**Note:** You can solve this task in a different way by using floating-point operations. First compute the expression $\\frac{a \\cdot b}{m}$ using floating-point numbers and cast it to an unsigned integer $q$. Subtract $q \\cdot m$ from $a \\cdot b$ using unsigned integer arithmetics and take it modulo $m$ to find the answer. This solution looks rather unreliable, but it is very fast, and very easy to implement. See [here](https://cs.stackexchange.com/questions/77016/modular-multiplication) for more information.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: binary_pow\n---\n\n# Binary Exponentiation\n\nBinary exponentiation (also known as exponentiation by squaring) is a trick which allows to calculate $a^n$ using only $O(\\log n)$ multiplications (instead of $O(n)$ multiplications required by the naive approach).\n\nIt also has important applications in many tasks unrelated to arithmetic, since it\ncan be used with any operations that have the property of **associativity**:\n\n$$(X \\cdot Y) \\cdot Z = X \\cdot (Y \\cdot Z)$$\n\nMost obviously this applies to modular multiplication, to multiplication of matrices and\nto other problems which we will discuss below.\n\n## Algorithm\n\nRaising $a$ to the power of $n$ is expressed naively as multiplication by $a$ done $n - 1$ times:\n$a^{n} = a \\cdot a \\cdot \\ldots \\cdot a$. However, this approach is not practical for large $a$ or $n$.\n\n$a^{b+c} = a^b \\cdot a^c$ and $a^{2b} = a^b \\cdot a^b = (a^b)^2$.\n\nThe idea of binary exponentiation is, that we split the work using the binary representation of the exponent.\n\nLet's write $n$ in base 2, for example:\n\n$$3^{13} = 3^{1101_2} = 3^8 \\cdot 3^4 \\cdot 3^1$$\n\nSince the number $n$ has exactly $\\lfloor \\log_2 n \\rfloor + 1$ digits in base 2, we only need to perform $O(\\log n)$ multiplications, if we know the powers $a^1, a^2, a^4, a^8, \\dots, a^{2^{\\lfloor \\log n \\rfloor}}$.\n\nSo we only need to know a fast way to compute those.\nLuckily this is very easy, since an element in the sequence is just the square of the previous element.\n\n$$\\begin{align}\n3^1 &= 3 \\\\\n3^2 &= \\left(3^1\\right)^2 = 3^2 = 9 \\\\\n3^4 &= \\left(3^2\\right)^2 = 9^2 = 81 \\\\\n3^8 &= \\left(3^4\\right)^2 = 81^2 = 6561\n\\end{align}$$\n\nSo to get the final answer for $3^{13}$, we only need to multiply three of them (skipping $3^2$ because the corresponding bit in $n$ is not set):\n$3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323$\n\nThe final complexity of this algorithm is $O(\\log n)$: we have to compute $\\log n$ powers of $a$, and then have to do at most $\\log n$ multiplications to get the final answer from them.\n\nThe following recursive approach expresses the same idea:\n\n$$a^n = \\begin{cases}\n1 &\\text{if } n == 0 \\\\\n\\left(a^{\\frac{n}{2}}\\right)^2 &\\text{if } n > 0 \\text{ and } n \\text{ even}\\\\\n\\left(a^{\\frac{n - 1}{2}}\\right)^2 \\cdot a &\\text{if } n > 0 \\text{ and } n \\text{ odd}\\\\\n\\end{cases}$$\n\n## Implementation\n\nFirst the recursive approach, which is a direct translation of the recursive formula:\n\n```cpp\nlong long binpow(long long a, long long b) {\n    if (b == 0)\n        return 1;\n    long long res = binpow(a, b / 2);\n    if (b % 2)\n        return res * res * a;\n    else\n        return res * res;\n}\n```\n\nThe second approach accomplishes the same task without recursion.\nIt computes all the powers in a loop, and multiplies the ones with the corresponding set bit in $n$.\nAlthough the complexity of both approaches is identical, this approach will be faster in practice since we don't have the overhead of the recursive calls.\n\n```cpp\nlong long binpow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        a = a * a;\n        b >>= 1;\n    }\n    return res;\n}\n```\n\n## Applications\n\n### Effective computation of large exponents modulo a number\n\n**Problem:**\nCompute $x^n \\bmod m$.\nThis is a very common operation. For instance it is used in computing the [modular multiplicative inverse](module-inverse.md).\n\n**Solution:**\nSince we know that the modulo operator doesn't interfere with multiplications ($a \\cdot b \\equiv (a \\bmod m) \\cdot (b \\bmod m) \\pmod m$), we can directly use the same code, and just replace every multiplication with a modular multiplication:\n\n```cpp\nlong long binpow(long long a, long long b, long long m) {\n    a %= m;\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a % m;\n        a = a * a % m;\n        b >>= 1;\n    }\n    return res;\n}\n```\n\n**Note:**\nIt's possible to speed this algorithm for large $b >> m$.\nIf $m$ is a prime number $x^n \\equiv x^{n \\bmod (m-1)} \\pmod{m}$ for prime $m$, and $x^n \\equiv x^{n \\bmod{\\phi(m)}} \\pmod{m}$ for composite $m$.\nThis follows directly from Fermat's little theorem and Euler's theorem, see the article about [Modular Inverses](module-inverse.md#fermat-euler) for more details.\n\n### Effective computation of Fibonacci numbers\n\n**Problem:** Compute $n$-th Fibonacci number $F_n$.\n\n**Solution:** For more details, see the [Fibonacci Number article](fibonacci-numbers.md).\nWe will only go through an overview of the algorithm.\nTo compute the next Fibonacci number, only the two previous ones are needed, as $F_n = F_{n-1} + F_{n-2}$.\nWe can build a $2 \\times 2$ matrix that describes this transformation:\nthe transition from $F_i$ and $F_{i+1}$ to $F_{i+1}$ and $F_{i+2}$.\nFor example, applying this transformation to the pair $F_0$ and $F_1$ would change it into $F_1$ and $F_2$.\nTherefore, we can raise this transformation matrix to the $n$-th power to find $F_n$ in time complexity $O(\\log n)$.\n\n### Applying a permutation $k$ times { data-toc-label='Applying a permutation <script type=\"math/tex\">k</script> times' }\n\n**Problem:** You are given a sequence of length $n$. Apply to it a given permutation $k$ times.\n\n**Solution:** Simply raise the permutation to $k$-th power using binary exponentiation, and then apply it to the sequence. This will give you a time complexity of $O(n \\log k)$.\n\n```cpp\nvector<int> applyPermutation(vector<int> sequence, vector<int> permutation) {\n    vector<int> newSequence(sequence.size());\n    for(int i = 0; i < sequence.size(); i++) {\n        newSequence[i] = sequence[permutation[i]];\n    }\n    return newSequence;\n}\n\nvector<int> permute(vector<int> sequence, vector<int> permutation, long long b) {\n    while (b > 0) {\n        if (b & 1) {\n            sequence = applyPermutation(sequence, permutation);\n        }\n        permutation = applyPermutation(permutation, permutation);\n        b >>= 1;\n    }\n    return sequence;\n}\n```\n\n**Note:** This task can be solved more efficiently in linear time by building the permutation graph and considering each cycle independently. You could then compute $k$ modulo the size of the cycle and find the final position for each number which is part of this cycle.\n\n### Fast application of a set of geometric operations to a set of points\n\n**Problem:** Given $n$ points $p_i$, apply $m$ transformations to each of these points. Each transformation can be a shift, a scaling or a rotation around a given axis by a given angle. There is also a \"loop\" operation which applies a given list of transformations $k$ times (\"loop\" operations can be nested). You should apply all transformations faster than $O(n \\cdot length)$, where $length$ is the total number of transformations to be applied (after unrolling \"loop\" operations).\n\n**Solution:** Let's look at how the different types of transformations change the coordinates:\n\n* Shift operation: adds a different constant to each of the coordinates.\n* Scaling operation: multiplies each of the coordinates by a different constant.\n* Rotation operation: the transformation is more complicated (we won't go in details here), but each of the new coordinates still can be represented as a linear combination of the old ones.\n\nAs you can see, each of the transformations can be represented as a linear operation on the coordinates. Thus, a transformation can be written as a $4 \\times 4$ matrix of the form:\n\n$$\\begin{pmatrix}\na_{11} & a_ {12} & a_ {13} & a_ {14} \\\\\na_{21} & a_ {22} & a_ {23} & a_ {24} \\\\\na_{31} & a_ {32} & a_ {33} & a_ {34} \\\\\na_{41} & a_ {42} & a_ {43} & a_ {44}\n\\end{pmatrix}$$\n\nthat, when multiplied by a vector with the old coordinates and an unit gives a new vector with the new coordinates and an unit:\n\n$$\\begin{pmatrix} x & y & z & 1 \\end{pmatrix} \\cdot\n\\begin{pmatrix}\na_{11} & a_ {12} & a_ {13} & a_ {14} \\\\\na_{21} & a_ {22} & a_ {23} & a_ {24} \\\\\na_{31} & a_ {32} & a_ {33} & a_ {34} \\\\\na_{41} & a_ {42} & a_ {43} & a_ {44}\n\\end{pmatrix}\n = \\begin{pmatrix} x' & y' & z' & 1 \\end{pmatrix}$$\n\n(Why introduce a fictitious fourth coordinate, you ask? That is the beauty of [homogeneous coordinates](https://en.wikipedia.org/wiki/Homogeneous_coordinates), which find great application in computer graphics. Without this, it would not be possible to implement affine operations like the shift operation as a single matrix multiplication, as it requires us to _add_ a constant to the coordinates. The affine transformation becomes a linear transformation in the higher dimension!)\n\nHere are some examples of how transformations are represented in matrix form:\n\n* Shift operation: shift $x$ coordinate by $5$, $y$ coordinate by $7$ and $z$ coordinate by $9$.\n\n$$\\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n5 & 7 & 9 & 1\n\\end{pmatrix}$$\n\n* Scaling operation: scale the $x$ coordinate by $10$ and the other two by $5$.\n\n$$\\begin{pmatrix}\n10 & 0 & 0 & 0 \\\\\n0 & 5 & 0 & 0 \\\\\n0 & 0 & 5 & 0 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}$$\n\n* Rotation operation: rotate $\\theta$ degrees around the $x$ axis following the right-hand rule (counter-clockwise direction).\n\n$$\\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & \\cos \\theta & -\\sin \\theta & 0 \\\\\n0 & \\sin \\theta & \\cos \\theta & 0 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}$$\n\nNow, once every transformation is described as a matrix, the sequence of transformations can be described as a product of these matrices, and a \"loop\" of $k$ repetitions can be described as the matrix raised to the power of $k$ (which can be calculated using binary exponentiation in $O(\\log{k})$). This way, the matrix which represents all transformations can be calculated first in $O(m \\log{k})$, and then it can be applied to each of the $n$ points in $O(n)$ for a total complexity of $O(n + m \\log{k})$.\n\n\n### Number of paths of length $k$ in a graph { data-toc-label='Number of paths of length <script type=\"math/tex\">k</script> in a graph' }\n\n**Problem:** Given a directed unweighted graph of $n$ vertices, find the number of paths of length $k$ from any vertex $u$ to any other vertex $v$.\n\n**Solution:** This problem is considered in more detail in [a separate article](../graph/fixed_length_paths.md). The algorithm consists of raising the adjacency matrix $M$ of the graph (a matrix where $m_{ij} = 1$ if there is an edge from $i$ to $j$, or $0$ otherwise) to the $k$-th power. Now $m_{ij}$ will be the number of paths of length $k$ from $i$ to $j$. The time complexity of this solution is $O(n^3 \\log k)$.\n\n**Note:** In that same article, another variation of this problem is considered: when the edges are weighted and it is required to find the minimum weight path containing exactly $k$ edges. As shown in that article, this problem is also solved by exponentiation of the adjacency matrix. The matrix would have the weight of the edge from $i$ to $j$, or $\\infty$ if there is no such edge.\nInstead of the usual operation of multiplying two matrices, a modified one should be used:\ninstead of multiplication, both values are added, and instead of a summation, a minimum is taken.\nThat is: $result_{ij} = \\min\\limits_{1\\ \\leq\\ k\\ \\leq\\ n}(a_{ik} + b_{kj})$.\n\n### Variation of binary exponentiation: multiplying two numbers modulo $m$ { data-toc-label='Variation of binary exponentiation: multiplying two numbers modulo <script type=\"math/tex\">m</script>' }\n\n**Problem:** Multiply two numbers $a$ and $b$ modulo $m$. $a$ and $b$ fit in the built-in data types, but their product is too big to fit in a 64-bit integer. The idea is to compute $a \\cdot b \\pmod m$ without using bignum arithmetics.\n\n**Solution:** We simply apply the binary construction algorithm described above, only performing additions instead of multiplications. In other words, we have \"expanded\" the multiplication of two numbers to $O (\\log m)$ operations of addition and multiplication by two (which, in essence, is an addition).\n\n$$a \\cdot b = \\begin{cases}\n0 &\\text{if }a = 0 \\\\\n2 \\cdot \\frac{a}{2} \\cdot b &\\text{if }a > 0 \\text{ and }a \\text{ even} \\\\\n2 \\cdot \\frac{a-1}{2} \\cdot b + b &\\text{if }a > 0 \\text{ and }a \\text{ odd}\n\\end{cases}$$\n\n**Note:** You can solve this task in a different way by using floating-point operations. First compute the expression $\\frac{a \\cdot b}{m}$ using floating-point numbers and cast it to an unsigned integer $q$. Subtract $q \\cdot m$ from $a \\cdot b$ using unsigned integer arithmetics and take it modulo $m$ to find the answer. This solution looks rather unreliable, but it is very fast, and very easy to implement. See [here](https://cs.stackexchange.com/questions/77016/modular-multiplication) for more information.\n\n## Practice Problems\n\n* [UVa 1230 - MODEX](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3671)\n* [UVa 374 - Big Mod](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=310)\n* [UVa 11029 - Leading and Trailing](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1970)\n* [Codeforces - Parking Lot](http://codeforces.com/problemset/problem/630/I)\n* [leetcode - Count good numbers](https://leetcode.com/problems/count-good-numbers/)\n* [Codechef - Chef and Riffles](https://www.codechef.com/JAN221B/problems/RIFFLES)\n* [Codeforces - Decoding Genome](https://codeforces.com/contest/222/problem/E)\n* [Codeforces - Neural Network Country](https://codeforces.com/contest/852/problem/B)\n* [Codeforces - Magic Gems](https://codeforces.com/problemset/problem/1117/D)\n* [SPOJ - The last digit](http://www.spoj.com/problems/LASTDIG/)\n* [SPOJ - Locker](http://www.spoj.com/problems/LOCKER/)\n* [LA - 3722 Jewel-eating Monsters](https://vjudge.net/problem/UVALive-3722)\n* [SPOJ - Just add it](http://www.spoj.com/problems/ZSUM/)\n* [Codeforces - Stairs and Lines](https://codeforces.com/contest/498/problem/E)\n\n\n", "problem_ids": ["630_I", "222_E", "1117_D", "498_E"], "title": "Binary Exponentiation"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: balanced_ternary\n---\n\n# Balanced Ternary\n\n![\"Setun computer using Balanced Ternary system\"](https://earltcampbell.files.wordpress.com/2014/12/setun.jpeg?w=300)\n\nThis is a non-standard but still positional **numeral system**. Its feature is that digits can have one of the values `-1`, `0` and `1`.\nNevertheless, its base is still `3` (because there are three possible values). Since it is not convenient to write `-1` as a digit,\nwe'll use letter `Z` further for this purpose. If you think it is quite a strange system - look at the picture - here is one of the\ncomputers utilizing it.\n\nSo here are few first numbers written in balanced ternary:\n\n```nohighlight\n    0    0\n    1    1\n    2    1Z\n    3    10\n    4    11\n    5    1ZZ\n    6    1Z0\n    7    1Z1\n    8    10Z\n    9    100\n```\n\nThis system allows you to write negative values without leading minus sign: you can simply invert digits in any positive number.\n\n```nohighlight\n    -1   Z\n    -2   Z1\n    -3   Z0\n    -4   ZZ\n    -5   Z11\n```\n\nNote that a negative number starts with `Z` and positive with `1`.\n\n## Conversion algorithm\n\nIt is easy to represent a given number in **balanced ternary** via temporary representing it in normal ternary number system. When value is\nin standard ternary, its digits are either `0` or `1` or `2`. Iterating from the lowest digit we can safely skip any `0`s and `1`s,\nhowever `2` should be turned into `Z` with adding `1` to the next digit. Digits `3` should be turned into `0` on the same terms -\nsuch digits are not present in the number initially but they can be encountered after increasing some `2`s.\n\n**Example 1:** Let us convert `64` to balanced ternary. At first we use normal ternary to rewrite the number:\n\n$$ 64_{10} = 02101_{3} $$\n\nLet us process it from the least significant (rightmost) digit:\n\n- `1`,`0` and `1` are skipped as it is.( Because `0` and `1` are allowed in balanced ternary )\n- `2` is turned into `Z` increasing the digit to its left, so we get `1Z101`.\n\nThe final result is `1Z101`.\n\nLet us convert it back to the decimal system by adding the weighted positional values:\n\n$$ 1Z101 = 81 \\cdot 1 + 27 \\cdot (-1) + 9 \\cdot 1 + 3 \\cdot 0 + 1 \\cdot 1 = 64_{10} $$\n\n**Example 2:** Let us convert `237` to balanced ternary. At first we use normal ternary to rewrite the number:\n\n$$ 237_{10} = 22210_{3} $$\n\nLet us process it from the least significant (rightmost) digit:\n\n- `0` and `1` are skipped as it is.( Because `0` and `1` are allowed in balanced ternary )\n- `2` is turned into `Z` increasing the digit to its left, so we get `23Z10`.\n- `3` is turned into `0` increasing the digit to its left, so we get `30Z10`.\n- `3` is turned into `0` increasing the digit to its left( which is by default `0` ), and so we get `100Z10`.\n\nThe final result is `100Z10`.\n\nLet us convert it back to the decimal system by adding the weighted positional values:\n\n$$ 100Z10 = 243 \\cdot 1 + 81 \\cdot 0 + 27 \\cdot 0 + 9 \\cdot (-1) + 3 \\cdot 1 + 1 \\cdot 0 = 237_{10} $$\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: balanced_ternary\n---\n\n# Balanced Ternary\n\n![\"Setun computer using Balanced Ternary system\"](https://earltcampbell.files.wordpress.com/2014/12/setun.jpeg?w=300)\n\nThis is a non-standard but still positional **numeral system**. Its feature is that digits can have one of the values `-1`, `0` and `1`.\nNevertheless, its base is still `3` (because there are three possible values). Since it is not convenient to write `-1` as a digit,\nwe'll use letter `Z` further for this purpose. If you think it is quite a strange system - look at the picture - here is one of the\ncomputers utilizing it.\n\nSo here are few first numbers written in balanced ternary:\n\n```nohighlight\n    0    0\n    1    1\n    2    1Z\n    3    10\n    4    11\n    5    1ZZ\n    6    1Z0\n    7    1Z1\n    8    10Z\n    9    100\n```\n\nThis system allows you to write negative values without leading minus sign: you can simply invert digits in any positive number.\n\n```nohighlight\n    -1   Z\n    -2   Z1\n    -3   Z0\n    -4   ZZ\n    -5   Z11\n```\n\nNote that a negative number starts with `Z` and positive with `1`.\n\n## Conversion algorithm\n\nIt is easy to represent a given number in **balanced ternary** via temporary representing it in normal ternary number system. When value is\nin standard ternary, its digits are either `0` or `1` or `2`. Iterating from the lowest digit we can safely skip any `0`s and `1`s,\nhowever `2` should be turned into `Z` with adding `1` to the next digit. Digits `3` should be turned into `0` on the same terms -\nsuch digits are not present in the number initially but they can be encountered after increasing some `2`s.\n\n**Example 1:** Let us convert `64` to balanced ternary. At first we use normal ternary to rewrite the number:\n\n$$ 64_{10} = 02101_{3} $$\n\nLet us process it from the least significant (rightmost) digit:\n\n- `1`,`0` and `1` are skipped as it is.( Because `0` and `1` are allowed in balanced ternary )\n- `2` is turned into `Z` increasing the digit to its left, so we get `1Z101`.\n\nThe final result is `1Z101`.\n\nLet us convert it back to the decimal system by adding the weighted positional values:\n\n$$ 1Z101 = 81 \\cdot 1 + 27 \\cdot (-1) + 9 \\cdot 1 + 3 \\cdot 0 + 1 \\cdot 1 = 64_{10} $$\n\n**Example 2:** Let us convert `237` to balanced ternary. At first we use normal ternary to rewrite the number:\n\n$$ 237_{10} = 22210_{3} $$\n\nLet us process it from the least significant (rightmost) digit:\n\n- `0` and `1` are skipped as it is.( Because `0` and `1` are allowed in balanced ternary )\n- `2` is turned into `Z` increasing the digit to its left, so we get `23Z10`.\n- `3` is turned into `0` increasing the digit to its left, so we get `30Z10`.\n- `3` is turned into `0` increasing the digit to its left( which is by default `0` ), and so we get `100Z10`.\n\nThe final result is `100Z10`.\n\nLet us convert it back to the decimal system by adding the weighted positional values:\n\n$$ 100Z10 = 243 \\cdot 1 + 81 \\cdot 0 + 27 \\cdot 0 + 9 \\cdot (-1) + 3 \\cdot 1 + 1 \\cdot 0 = 237_{10} $$\n\n## Practice Problems\n\n* [Topcoder SRM 604, Div1-250](http://community.topcoder.com/stat?c=problem_statement&pm=12917&rd=15837)\n", "problem_ids": [], "title": "Balanced Ternary"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: discrete_root\n---\n\n# Discrete Root\n\nThe problem of finding a discrete root is defined as follows. Given a prime $n$ and two integers $a$ and $k$, find all $x$ for which:\n\n$x^k \\equiv a \\pmod n$\n\n## The algorithm\n\nWe will solve this problem by reducing it to the [discrete logarithm problem](discrete-log.md).\n\nLet's apply the concept of a [primitive root](primitive-root.md) modulo $n$. Let $g$ be a primitive root modulo $n$. Note that since $n$ is prime, it must exist, and it can be found in $O(Ans \\cdot \\log \\phi (n) \\cdot \\log n) = O(Ans \\cdot \\log^2 n)$ plus time of factoring $\\phi (n)$.\n\nWe can easily discard the case where $a = 0$. In this case, obviously there is only one answer: $x = 0$.\n\nSince we know that $n$ is a prime and any number between 1 and $n-1$ can be represented as a power of the primitive root, we can represent the discrete root problem as follows:\n\n$(g^y)^k \\equiv a \\pmod n$\n\nwhere\n\n$x \\equiv g^y \\pmod n$\n\nThis, in turn, can be rewritten as\n\n$(g^k)^y \\equiv a \\pmod n$\n\nNow we have one unknown $y$, which is a discrete logarithm problem. The solution can be found using Shanks' baby-step giant-step algorithm in $O(\\sqrt {n} \\log n)$ (or we can verify that there are no solutions).\n\nHaving found one solution $y_0$, one of solutions of discrete root problem will be $x_0 = g^{y_0} \\pmod n$.\n\n## Finding all solutions from one known solution\n\nTo solve the given problem in full, we need to find all solutions knowing one of them: $x_0 = g^{y_0} \\pmod n$.\n\nLet's recall the fact that a primitive root always has order of $\\phi (n)$, i.e. the smallest power of $g$ which gives 1 is $\\phi (n)$. Therefore, if we add the term $\\phi (n)$ to the exponential, we still get the same value:\n\n$x^k \\equiv g^{ y_0 \\cdot k + l \\cdot \\phi (n)} \\equiv a \\pmod n \\forall l \\in Z$\n\nHence, all the solutions are of the form:\n\n$x = g^{y_0 + \\frac {l \\cdot \\phi (n)}{k}} \\pmod n \\forall l \\in Z$.\n\nwhere $l$ is chosen such that the fraction must be an integer. For this to be true, the numerator has to be divisible by the least common multiple of  $\\phi (n)$ and $k$. Remember that least common multiple of two numbers $lcm(a, b) = \\frac{a \\cdot b}{gcd(a, b)}$; we'll get\n\n$x = g^{y_0 + i \\frac {\\phi (n)}{gcd(k, \\phi (n))}} \\pmod n \\forall i \\in Z$.\n\nThis is the final formula for all solutions of the discrete root problem.\n\n## Implementation\n\nHere is a full implementation, including procedures for finding the primitive root, discrete log and finding and printing all solutions.\n\n```cpp\nint gcd(int a, int b) {\n\treturn a ? gcd(b % a, a) : b;\n}\n \nint powmod(int a, int b, int p) {\n\tint res = 1;\n\twhile (b > 0) {\n\t\tif (b & 1) {\n\t\t\tres = res * a % p;\n\t\t}\n\t\ta = a * a % p;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n \n// Finds the primitive root modulo p\nint generator(int p) {\n\tvector<int> fact;\n\tint phi = p-1, n = phi;\n\tfor (int i = 2; i * i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\tfact.push_back(i);\n\t\t\twhile (n % i == 0)\n\t\t\t\tn /= i;\n\t\t}\n\t}\n\tif (n > 1)\n\t\tfact.push_back(n);\n \n\tfor (int res = 2; res <= p; ++res) {\n\t\tbool ok = true;\n\t\tfor (int factor : fact) {\n\t\t\tif (powmod(res, phi / factor, p) == 1) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) return res;\n\t}\n\treturn -1;\n}\n \n// This program finds all numbers x such that x^k = a (mod n)\nint main() {\n\tint n, k, a;\n\tscanf(\"%d %d %d\", &n, &k, &a);\n\tif (a == 0) {\n\t\tputs(\"1\\n0\");\n\t\treturn 0;\n\t}\n \n\tint g = generator(n);\n \n\t// Baby-step giant-step discrete logarithm algorithm\n\tint sq = (int) sqrt (n + .0) + 1;\n\tvector<pair<int, int>> dec(sq);\n\tfor (int i = 1; i <= sq; ++i)\n\t\tdec[i-1] = {powmod(g, i * sq * k % (n - 1), n), i};\n\tsort(dec.begin(), dec.end());\n\tint any_ans = -1;\n\tfor (int i = 0; i < sq; ++i) {\n\t\tint my = powmod(g, i * k % (n - 1), n) * a % n;\n\t\tauto it = lower_bound(dec.begin(), dec.end(), make_pair(my, 0));\n\t\tif (it != dec.end() && it->first == my) {\n\t\t\tany_ans = it->second * sq - i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (any_ans == -1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n \n\t// Print all possible answers\n\tint delta = (n-1) / gcd(k, n-1);\n\tvector<int> ans;\n\tfor (int cur = any_ans % delta; cur < n-1; cur += delta)\n\t\tans.push_back(powmod(g, cur, n));\n\tsort(ans.begin(), ans.end());\n\tprintf(\"%d\\n\", ans.size());\n\tfor (int answer : ans)\n\t\tprintf(\"%d \", answer);\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: discrete_root\n---\n\n# Discrete Root\n\nThe problem of finding a discrete root is defined as follows. Given a prime $n$ and two integers $a$ and $k$, find all $x$ for which:\n\n$x^k \\equiv a \\pmod n$\n\n## The algorithm\n\nWe will solve this problem by reducing it to the [discrete logarithm problem](discrete-log.md).\n\nLet's apply the concept of a [primitive root](primitive-root.md) modulo $n$. Let $g$ be a primitive root modulo $n$. Note that since $n$ is prime, it must exist, and it can be found in $O(Ans \\cdot \\log \\phi (n) \\cdot \\log n) = O(Ans \\cdot \\log^2 n)$ plus time of factoring $\\phi (n)$.\n\nWe can easily discard the case where $a = 0$. In this case, obviously there is only one answer: $x = 0$.\n\nSince we know that $n$ is a prime and any number between 1 and $n-1$ can be represented as a power of the primitive root, we can represent the discrete root problem as follows:\n\n$(g^y)^k \\equiv a \\pmod n$\n\nwhere\n\n$x \\equiv g^y \\pmod n$\n\nThis, in turn, can be rewritten as\n\n$(g^k)^y \\equiv a \\pmod n$\n\nNow we have one unknown $y$, which is a discrete logarithm problem. The solution can be found using Shanks' baby-step giant-step algorithm in $O(\\sqrt {n} \\log n)$ (or we can verify that there are no solutions).\n\nHaving found one solution $y_0$, one of solutions of discrete root problem will be $x_0 = g^{y_0} \\pmod n$.\n\n## Finding all solutions from one known solution\n\nTo solve the given problem in full, we need to find all solutions knowing one of them: $x_0 = g^{y_0} \\pmod n$.\n\nLet's recall the fact that a primitive root always has order of $\\phi (n)$, i.e. the smallest power of $g$ which gives 1 is $\\phi (n)$. Therefore, if we add the term $\\phi (n)$ to the exponential, we still get the same value:\n\n$x^k \\equiv g^{ y_0 \\cdot k + l \\cdot \\phi (n)} \\equiv a \\pmod n \\forall l \\in Z$\n\nHence, all the solutions are of the form:\n\n$x = g^{y_0 + \\frac {l \\cdot \\phi (n)}{k}} \\pmod n \\forall l \\in Z$.\n\nwhere $l$ is chosen such that the fraction must be an integer. For this to be true, the numerator has to be divisible by the least common multiple of  $\\phi (n)$ and $k$. Remember that least common multiple of two numbers $lcm(a, b) = \\frac{a \\cdot b}{gcd(a, b)}$; we'll get\n\n$x = g^{y_0 + i \\frac {\\phi (n)}{gcd(k, \\phi (n))}} \\pmod n \\forall i \\in Z$.\n\nThis is the final formula for all solutions of the discrete root problem.\n\n## Implementation\n\nHere is a full implementation, including procedures for finding the primitive root, discrete log and finding and printing all solutions.\n\n```cpp\nint gcd(int a, int b) {\n\treturn a ? gcd(b % a, a) : b;\n}\n \nint powmod(int a, int b, int p) {\n\tint res = 1;\n\twhile (b > 0) {\n\t\tif (b & 1) {\n\t\t\tres = res * a % p;\n\t\t}\n\t\ta = a * a % p;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n \n// Finds the primitive root modulo p\nint generator(int p) {\n\tvector<int> fact;\n\tint phi = p-1, n = phi;\n\tfor (int i = 2; i * i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\tfact.push_back(i);\n\t\t\twhile (n % i == 0)\n\t\t\t\tn /= i;\n\t\t}\n\t}\n\tif (n > 1)\n\t\tfact.push_back(n);\n \n\tfor (int res = 2; res <= p; ++res) {\n\t\tbool ok = true;\n\t\tfor (int factor : fact) {\n\t\t\tif (powmod(res, phi / factor, p) == 1) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) return res;\n\t}\n\treturn -1;\n}\n \n// This program finds all numbers x such that x^k = a (mod n)\nint main() {\n\tint n, k, a;\n\tscanf(\"%d %d %d\", &n, &k, &a);\n\tif (a == 0) {\n\t\tputs(\"1\\n0\");\n\t\treturn 0;\n\t}\n \n\tint g = generator(n);\n \n\t// Baby-step giant-step discrete logarithm algorithm\n\tint sq = (int) sqrt (n + .0) + 1;\n\tvector<pair<int, int>> dec(sq);\n\tfor (int i = 1; i <= sq; ++i)\n\t\tdec[i-1] = {powmod(g, i * sq * k % (n - 1), n), i};\n\tsort(dec.begin(), dec.end());\n\tint any_ans = -1;\n\tfor (int i = 0; i < sq; ++i) {\n\t\tint my = powmod(g, i * k % (n - 1), n) * a % n;\n\t\tauto it = lower_bound(dec.begin(), dec.end(), make_pair(my, 0));\n\t\tif (it != dec.end() && it->first == my) {\n\t\t\tany_ans = it->second * sq - i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (any_ans == -1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n \n\t// Print all possible answers\n\tint delta = (n-1) / gcd(k, n-1);\n\tvector<int> ans;\n\tfor (int cur = any_ans % delta; cur < n-1; cur += delta)\n\t\tans.push_back(powmod(g, cur, n));\n\tsort(ans.begin(), ans.end());\n\tprintf(\"%d\\n\", ans.size());\n\tfor (int answer : ans)\n\t\tprintf(\"%d \", answer);\n}\n```\n\n## Practice problems\n\n* [Codeforces - Lunar New Year and a Recursive Sequence](https://codeforces.com/contest/1106/problem/F)\n", "problem_ids": ["1106_F"], "title": "Discrete Root"}, {"article": "---\ntags:\n  - Original\n---\n\n# Integer factorization\n\nIn this article we list several algorithms for factorizing integers, each of them can be both fast and also slow (some slower than others) depending on their input.\n\nNotice, if the number that you want to factorize is actually a prime number, most of the algorithms, especially Fermat's factorization algorithm, Pollard's p-1, Pollard's rho algorithm will run very slow.\nSo it makes sense to perform a probabilistic (or a fast deterministic) [primality test](primality_tests.md) before trying to factorize the number.\n\n## Trial division\n\nThis is the most basic algorithm to find a prime factorization.\n\nWe divide by each possible divisor $d$.\nWe can notice, that it is impossible that all prime factors of a composite number $n$ are bigger than $\\sqrt{n}$.\nTherefore, we only need to test the divisors $2 \\le d \\le \\sqrt{n}$, which gives us the prime factorization in $O(\\sqrt{n})$.\n(This is [pseudo-polynomial time](https://en.wikipedia.org/wiki/Pseudo-polynomial_time), i.e. polynomial in the value of the input but exponential in the number of bits of the input.)\n\nThe smallest divisor has to be a prime number.\nWe remove the factor from the number, and repeat the process.\nIf we cannot find any divisor in the range $[2; \\sqrt{n}]$, then the number itself has to be prime.\n\n```{.cpp file=factorization_trial_division1}\nvector<long long> trial_division1(long long n) {\n    vector<long long> factorization;\n    for (long long d = 2; d * d <= n; d++) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    if (n > 1)\n        factorization.push_back(n);\n    return factorization;\n}\n```\n\n### Wheel factorization\n\nThis is an optimization of the trial division.\nThe idea is the following.\nOnce we know that the number is not divisible by 2, we don't need to check every other even number.\nThis leaves us with only $50\\%$ of the numbers to check.\nAfter checking 2, we can simply start with 3 and skip every other number.\n\n```{.cpp file=factorization_trial_division2}\nvector<long long> trial_division2(long long n) {\n    vector<long long> factorization;\n    while (n % 2 == 0) {\n        factorization.push_back(2);\n        n /= 2;\n    }\n    for (long long d = 3; d * d <= n; d += 2) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    if (n > 1)\n        factorization.push_back(n);\n    return factorization;\n}\n```\n\nThis method can be extended.\nIf the number is not divisible by 3, we can also ignore all other multiples of 3 in the future computations.\nSo we only need to check the numbers $5, 7, 11, 13, 17, 19, 23, \\dots$.\nWe can observe a pattern of these remaining numbers.\nWe need to check all numbers with $d \\bmod 6 = 1$ and $d \\bmod 6 = 5$.\nSo this leaves us with only $33.3\\%$ percent of the numbers to check.\nWe can implement this by checking the primes 2 and 3 first, and then start checking with 5 and alternatively skip 1 or 3 numbers.\n\nWe can extend this even further.\nHere is an implementation for the prime number 2, 3 and 5.\nIt's convenient to use an array to store how much we have to skip.\n\n```{.cpp file=factorization_trial_division3}\nvector<long long> trial_division3(long long n) {\n    vector<long long> factorization;\n    for (int d : {2, 3, 5}) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    static array<int, 8> increments = {4, 2, 4, 2, 4, 6, 2, 6};\n    int i = 0;\n    for (long long d = 7; d * d <= n; d += increments[i++]) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n        if (i == 8)\n            i = 0;\n    }\n    if (n > 1)\n        factorization.push_back(n);\n    return factorization;\n}\n```\n\nIf we extend this further with more primes, we can even reach better percentages.\nHowever, also the skip lists will get a lot bigger.\n\n### Precomputed primes\n\nExtending the wheel factorization with more and more primes will leave exactly the primes to check.\nSo a good way of checking is just to precompute all prime numbers with the [Sieve of Eratosthenes](sieve-of-eratosthenes.md) until $\\sqrt{n}$ and test them individually.\n\n```{.cpp file=factorization_trial_division4}\nvector<long long> primes;\n\nvector<long long> trial_division4(long long n) {\n    vector<long long> factorization;\n    for (long long d : primes) {\n        if (d * d > n)\n            break;\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    if (n > 1)\n        factorization.push_back(n);\n    return factorization;\n}\n```\n\n## Fermat's factorization method\n\nWe can write an odd composite number $n = p \\cdot q$ as the difference of two squares $n = a^2 - b^2$:\n\n$$n = \\left(\\frac{p + q}{2}\\right)^2 - \\left(\\frac{p - q}{2}\\right)^2$$\n\nFermat's factorization method tries to exploit the fact, by guessing the first square $a^2$, and check if the remaining part $b^2 = a^2 - n$ is also a square number.\nIf it is, then we have found the factors $a - b$ and $a + b$ of $n$.\n\n```cpp\nint fermat(int n) {\n    int a = ceil(sqrt(n));\n    int b2 = a*a - n;\n    int b = round(sqrt(b2));\n    while (b * b != b2) {\n        a = a + 1;\n        b2 = a*a - n;\n        b = round(sqrt(b2));\n    }\n    return a - b;\n}\n```\n\nNotice, this factorization method can be very fast, if the difference between the two factors $p$ and $q$ is small.\nThe algorithm runs in $O(|p - q|)$ time.\nHowever since it is very slow, once the factors are far apart, it is rarely used in practice.\n\nHowever there are still a huge number of optimizations for this approach.\nE.g. by looking at the squares $a^2$ modulo a fixed small number, you can notice that you don't have to look at certain values $a$ since they cannot produce a square number $a^2 - n$.\n\n\n## Pollard's $p - 1$ method { data-toc-label=\"Pollard's <script type='math/tex'>p - 1</script> method\" }\n\nIt is very likely that at least one factor of a number is $B$**-powersmooth** for small $B$.\n$B$-powersmooth means that every prime power $d^k$ that divides $p-1$ is at most $B$.\nE.g. the prime factorization of $4817191$ is $1303 \\cdot 3697$.\nAnd the factors are $31$-powersmooth and $16$-powersmooth respectably, because $1303 - 1 = 2 \\cdot 3 \\cdot 7 \\cdot 31$ and $3697 - 1 = 2^4 \\cdot 3 \\cdot 7 \\cdot 11$.\nIn 1974 John Pollard invented a method to extracts $B$-powersmooth factors from a composite number.\n\nThe idea comes from [Fermat's little theorem](phi-function.md#application).\nLet a factorization of $n$ be $n = p \\cdot q$.\nIt says that if $a$ is coprime to $p$, the following statement holds:\n\n$$a^{p - 1} \\equiv 1 \\pmod{p}$$\n\nThis also means that\n\n$$a^{(p - 1)^k} \\equiv a^{k \\cdot (p - 1)} \\equiv 1 \\pmod{p}.$$\n\nSo for any $M$ with $p - 1 ~|~ M$ we know that $a^M \\equiv 1$.\nThis means that $a^M - 1 = p \\cdot r$, and because of that also $p ~|~ \\gcd(a^M - 1, n)$.\n\nTherefore, if $p - 1$ for a factor $p$ of $n$ divides $M$, we can extract a factor using [Euclid's algorithm](euclid-algorithm.md).\n\nIt is clear, that the smallest $M$ that is a multiple of every $B$-powersmooth number is $\\text{lcm}(1,~2~,3~,4~,~\\dots,~B)$.\nOr alternatively:\n\n$$M = \\prod_{\\text{prime } q \\le B} q^{\\lfloor \\log_q B \\rfloor}$$\n\nNotice, if $p-1$ divides $M$ for all prime factors $p$ of $n$, then $\\gcd(a^M - 1, n)$ will just be $n$.\nIn this case we don't receive a factor.\nTherefore we will try to perform the $\\gcd$ multiple time, while we compute $M$.\n\nSome composite numbers don't have $B$-powersmooth factors for small $B$.\nE.g. the factors of the composite number $100~000~000~000~000~493 = 763~013 \\cdot 131~059~365~961$ are $190~753$-powersmooth and $1~092~161~383$-powersmooth.\nWe would have to choose $B >= 190~753$ to factorize the number.\n\nIn the following implementation we start with $B = 10$ and increase $B$ after each each iteration.\n\n```{.cpp file=factorization_p_minus_1}\nlong long pollards_p_minus_1(long long n) {\n    int B = 10;\n    long long g = 1;\n    while (B <= 1000000 && g < n) {\n        long long a = 2 + rand() %  (n - 3);\n        g = gcd(a, n);\n        if (g > 1)\n            return g;\n\n        // compute a^M\n        for (int p : primes) {\n            if (p >= B)\n                continue;\n            long long p_power = 1;\n            while (p_power * p <= B)\n                p_power *= p;\n            a = power(a, p_power, n);\n\n            g = gcd(a - 1, n);\n            if (g > 1 && g < n)\n                return g;\n        }\n        B *= 2;\n    }\n    return 1;\n}\n\n```\n\nNotice, this is a probabilistic algorithm.\nIt can happen that the algorithm doesn't find a factor.\n\nThe complexity is $O(B \\log B \\log^2 n)$ per iteration.\n\n## Pollard's rho algorithm\n\nAnother factorization algorithm from John Pollard.\n\nLet the prime factorization of a number be $n = p q$.\nThe algorithm looks at a pseudo-random sequence $\\{x_i\\} = \\{x_0,~f(x_0),~f(f(x_0)),~\\dots\\}$ where $f$ is a polynomial function, usually $f(x) = (x^2 + c) \\bmod n$ is chosen with $c = 1$.\n\nActually we are not very interested in the sequence $\\{x_i\\}$, we are more interested in the sequence $\\{x_i \\bmod p\\}$.\nSince $f$ is a polynomial function and all the values are in the range $[0;~p)$ this sequence will begin to cycle sooner or later.\nThe **birthday paradox** actually suggests, that the expected number of elements is $O(\\sqrt{p})$ until the repetition starts.\nIf $p$ is smaller than $\\sqrt{n}$, the repetition will start very likely in $O(\\sqrt[4]{n})$.\n\nHere is a visualization of such a sequence $\\{x_i \\bmod p\\}$ with $n = 2206637$, $p = 317$, $x_0 = 2$ and $f(x) = x^2 + 1$.\nFrom the form of the sequence you can see very clearly why the algorithm is called Pollard's $\\rho$ algorithm.\n\n<center>![Pollard's rho visualization](pollard_rho.png)</center>\n\nThere is still one big open question.\nWe don't know $p$ yet, so how can we argue about the sequence $\\{x_i \\bmod p\\}$?\n\nIt's actually quite easy.\nThere is a cycle in the sequence $\\{x_i \\bmod p\\}_{i \\le j}$ if and only if there are two indices $s, t \\le j$ such that $x_s \\equiv x_t \\bmod p$.\nThis equation can be rewritten as $x_s - x_t \\equiv 0 \\bmod p$ which is the same as $p ~|~ \\gcd(x_s - x_t, n)$.\n\nTherefore, if we find two indices $s$ and $t$ with $g = \\gcd(x_s - x_t, n) > 1$, we have found a cycle and also a factor $g$ of $n$.\nNotice that it is possible that $g = n$.\nIn this case we haven't found a proper factor, and we have to repeat the algorithm with different parameter (different starting value $x_0$, different constant $c$ in the polynomial function $f$).\n\nTo find the cycle, we can use any common cycle detection algorithm.\n\n### Floyd's cycle-finding algorithm\n\nThis algorithm finds a cycle by using two pointers.\nThese pointers move over the sequence at different speeds.\nIn each iteration the first pointer advances to the next element, but the second pointer advances two elements.\nIt's not hard to see, that if there exists a cycle, the second pointer will make at least one full cycle and then meet the first pointer during the next few cycle loops.\nIf the cycle length is $\\lambda$ and the $\\mu$ is the first index at which the cycle starts, then the algorithm will run in $O(\\lambda + \\mu)$ time.\n\nThis algorithm is also known as **tortoise and the hare algorithm**, based on the tale in which a tortoise (here a slow pointer) and a hare (here a faster pointer) make a race.\n\nIt is actually possible to determine the parameter $\\lambda$ and $\\mu$ using this algorithm (also in $O(\\lambda + \\mu)$ time and $O(1)$ space), but here is just the simplified version for finding the cycle at all.\nThe algorithm and returns true as soon as it detects a cycle.\nIf the sequence doesn't have a cycle, then the function will never stop.\nHowever this cannot happen during Pollard's rho algorithm.\n\n```text\nfunction floyd(f, x0):\n    tortoise = x0\n    hare = f(x0)\n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(f(hare))\n    return true\n```\n\n### Implementation\n\nFirst here is a implementation using the **Floyd's cycle-finding algorithm**.\nThe algorithm runs (usually) in $O(\\sqrt[4]{n} \\log(n))$ time.\n\n```{.cpp file=pollard_rho}\nlong long mult(long long a, long long b, long long mod) {\n    return (__int128)a * b % mod;\n}\n\nlong long f(long long x, long long c, long long mod) {\n    return (mult(x, x, mod) + c) % mod;\n}\n\nlong long rho(long long n, long long x0=2, long long c=1) {\n    long long x = x0;\n    long long y = x0;\n    long long g = 1;\n    while (g == 1) {\n        x = f(x, c, n);\n        y = f(y, c, n);\n        y = f(y, c, n);\n        g = gcd(abs(x - y), n);\n    }\n    return g;\n}\n```\n\nThe following table shows the values of $x$ and $y$ during the algorithm for $n = 2206637$, $x_0 = 2$ and $c = 1$.\n\n$$\n\\newcommand\\T{\\Rule{0pt}{1em}{.3em}}\n\\begin{array}{|l|l|l|l|l|l|}\n\\hline\ni & x_i \\bmod n & x_{2i} \\bmod n & x_i \\bmod 317 & x_{2i} \\bmod 317 & \\gcd(x_i - x_{2i}, n) \\\\\n\\hline\n0   & 2       & 2       & 2       & 2       & -   \\\\\n1   & 5       & 26      & 5       & 26      & 1   \\\\\n2   & 26      & 458330  & 26      & 265     & 1   \\\\\n3   & 677     & 1671573 & 43      & 32      & 1   \\\\\n4   & 458330  & 641379  & 265     & 88      & 1   \\\\\n5   & 1166412 & 351937  & 169     & 67      & 1   \\\\\n6   & 1671573 & 1264682 & 32      & 169     & 1   \\\\\n7   & 2193080 & 2088470 & 74      & 74      & 317 \\\\\n\\hline\n\\end{array}$$\n\nThe implementation uses a function `mult`, that multiplies two integers $\\le 10^{18}$ without overflow by using a GCC's type `__int128` for 128-bit integer.\nIf GCC is not available, you can using a similar idea as [binary exponentiation](binary-exp.md).\n\n```{.cpp file=pollard_rho_mult2}\nlong long mult(long long a, long long b, long long mod) {\n    long long result = 0;\n    while (b) {\n        if (b & 1)\n            result = (result + a) % mod;\n        a = (a + a) % mod;\n        b >>= 1;\n    }\n    return result;\n}\n```\n\nAlternatively you can also implement the [Montgomery multiplication](montgomery_multiplication.md).\n\nAs already noticed above: if $n$ is composite and the algorithm returns $n$ as factor, you have to repeat the procedure with different parameter $x_0$ and $c$.\nE.g. the choice $x_0 = c = 1$ will not factor $25 = 5 \\cdot 5$.\nThe algorithm will just return $25$.\nHowever the choice $x_0 = 1$, $c = 2$ will factor it.\n\n### Brent's algorithm\n\nBrent uses a similar algorithm as Floyd.\nIt also uses two pointer.\nBut instead of advancing the pointers by one and two respectably, we advance them in powers of two.\nAs soon as $2^i$ is greater than $\\lambda$ and $\\mu$, we will find the cycle.\n\n```text\nfunction floyd(f, x0):\n    tortoise = x0\n    hare = f(x0)\n    l = 1\n    while tortoise != hare:\n        tortoise = hare\n        repeat l times:\n            hare = f(hare)\n            if tortoise == hare:\n                return true\n        l *= 2\n    return true\n```\n\nBrent's algorithm also runs in linear time, but is usually faster than Floyd's algorithm, since it uses less evaluations of the function $f$.\n\n### Implementation\n\nThe straightforward implementation using Brent's algorithms can be speeded up by noticing, that we can omit the terms $x_l - x_k$ if $k < \\frac{3 \\cdot l}{2}$.\nAlso, instead of performing the $\\gcd$ computation at every step, we multiply the terms and do it every few steps and backtrack if we overshoot.\n\n```{.cpp file=pollard_rho_brent}\nlong long brent(long long n, long long x0=2, long long c=1) {\n    long long x = x0;\n    long long g = 1;\n    long long q = 1;\n    long long xs, y;\n\n    int m = 128;\n    int l = 1;\n    while (g == 1) {\n        y = x;\n        for (int i = 1; i < l; i++)\n            x = f(x, c, n);\n        int k = 0;\n        while (k < l && g == 1) {\n            xs = x;\n            for (int i = 0; i < m && i < l - k; i++) {\n                x = f(x, c, n);\n                q = mult(q, abs(y - x), n);\n            }\n            g = gcd(q, n);\n            k += m;\n        }\n        l *= 2;\n    }\n    if (g == n) {\n        do {\n            xs = f(xs, c, n);\n            g = gcd(abs(xs - y), n);\n        } while (g == 1);\n    }\n    return g;\n}\n```\n\nThe combination of a trial division for small prime numbers together with Brent's version of Pollard's rho algorithm will make a very powerful factorization algorithm.\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Integer factorization\n\nIn this article we list several algorithms for factorizing integers, each of them can be both fast and also slow (some slower than others) depending on their input.\n\nNotice, if the number that you want to factorize is actually a prime number, most of the algorithms, especially Fermat's factorization algorithm, Pollard's p-1, Pollard's rho algorithm will run very slow.\nSo it makes sense to perform a probabilistic (or a fast deterministic) [primality test](primality_tests.md) before trying to factorize the number.\n\n## Trial division\n\nThis is the most basic algorithm to find a prime factorization.\n\nWe divide by each possible divisor $d$.\nWe can notice, that it is impossible that all prime factors of a composite number $n$ are bigger than $\\sqrt{n}$.\nTherefore, we only need to test the divisors $2 \\le d \\le \\sqrt{n}$, which gives us the prime factorization in $O(\\sqrt{n})$.\n(This is [pseudo-polynomial time](https://en.wikipedia.org/wiki/Pseudo-polynomial_time), i.e. polynomial in the value of the input but exponential in the number of bits of the input.)\n\nThe smallest divisor has to be a prime number.\nWe remove the factor from the number, and repeat the process.\nIf we cannot find any divisor in the range $[2; \\sqrt{n}]$, then the number itself has to be prime.\n\n```{.cpp file=factorization_trial_division1}\nvector<long long> trial_division1(long long n) {\n    vector<long long> factorization;\n    for (long long d = 2; d * d <= n; d++) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    if (n > 1)\n        factorization.push_back(n);\n    return factorization;\n}\n```\n\n### Wheel factorization\n\nThis is an optimization of the trial division.\nThe idea is the following.\nOnce we know that the number is not divisible by 2, we don't need to check every other even number.\nThis leaves us with only $50\\%$ of the numbers to check.\nAfter checking 2, we can simply start with 3 and skip every other number.\n\n```{.cpp file=factorization_trial_division2}\nvector<long long> trial_division2(long long n) {\n    vector<long long> factorization;\n    while (n % 2 == 0) {\n        factorization.push_back(2);\n        n /= 2;\n    }\n    for (long long d = 3; d * d <= n; d += 2) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    if (n > 1)\n        factorization.push_back(n);\n    return factorization;\n}\n```\n\nThis method can be extended.\nIf the number is not divisible by 3, we can also ignore all other multiples of 3 in the future computations.\nSo we only need to check the numbers $5, 7, 11, 13, 17, 19, 23, \\dots$.\nWe can observe a pattern of these remaining numbers.\nWe need to check all numbers with $d \\bmod 6 = 1$ and $d \\bmod 6 = 5$.\nSo this leaves us with only $33.3\\%$ percent of the numbers to check.\nWe can implement this by checking the primes 2 and 3 first, and then start checking with 5 and alternatively skip 1 or 3 numbers.\n\nWe can extend this even further.\nHere is an implementation for the prime number 2, 3 and 5.\nIt's convenient to use an array to store how much we have to skip.\n\n```{.cpp file=factorization_trial_division3}\nvector<long long> trial_division3(long long n) {\n    vector<long long> factorization;\n    for (int d : {2, 3, 5}) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    static array<int, 8> increments = {4, 2, 4, 2, 4, 6, 2, 6};\n    int i = 0;\n    for (long long d = 7; d * d <= n; d += increments[i++]) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n        if (i == 8)\n            i = 0;\n    }\n    if (n > 1)\n        factorization.push_back(n);\n    return factorization;\n}\n```\n\nIf we extend this further with more primes, we can even reach better percentages.\nHowever, also the skip lists will get a lot bigger.\n\n### Precomputed primes\n\nExtending the wheel factorization with more and more primes will leave exactly the primes to check.\nSo a good way of checking is just to precompute all prime numbers with the [Sieve of Eratosthenes](sieve-of-eratosthenes.md) until $\\sqrt{n}$ and test them individually.\n\n```{.cpp file=factorization_trial_division4}\nvector<long long> primes;\n\nvector<long long> trial_division4(long long n) {\n    vector<long long> factorization;\n    for (long long d : primes) {\n        if (d * d > n)\n            break;\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    if (n > 1)\n        factorization.push_back(n);\n    return factorization;\n}\n```\n\n## Fermat's factorization method\n\nWe can write an odd composite number $n = p \\cdot q$ as the difference of two squares $n = a^2 - b^2$:\n\n$$n = \\left(\\frac{p + q}{2}\\right)^2 - \\left(\\frac{p - q}{2}\\right)^2$$\n\nFermat's factorization method tries to exploit the fact, by guessing the first square $a^2$, and check if the remaining part $b^2 = a^2 - n$ is also a square number.\nIf it is, then we have found the factors $a - b$ and $a + b$ of $n$.\n\n```cpp\nint fermat(int n) {\n    int a = ceil(sqrt(n));\n    int b2 = a*a - n;\n    int b = round(sqrt(b2));\n    while (b * b != b2) {\n        a = a + 1;\n        b2 = a*a - n;\n        b = round(sqrt(b2));\n    }\n    return a - b;\n}\n```\n\nNotice, this factorization method can be very fast, if the difference between the two factors $p$ and $q$ is small.\nThe algorithm runs in $O(|p - q|)$ time.\nHowever since it is very slow, once the factors are far apart, it is rarely used in practice.\n\nHowever there are still a huge number of optimizations for this approach.\nE.g. by looking at the squares $a^2$ modulo a fixed small number, you can notice that you don't have to look at certain values $a$ since they cannot produce a square number $a^2 - n$.\n\n\n## Pollard's $p - 1$ method { data-toc-label=\"Pollard's <script type='math/tex'>p - 1</script> method\" }\n\nIt is very likely that at least one factor of a number is $B$**-powersmooth** for small $B$.\n$B$-powersmooth means that every prime power $d^k$ that divides $p-1$ is at most $B$.\nE.g. the prime factorization of $4817191$ is $1303 \\cdot 3697$.\nAnd the factors are $31$-powersmooth and $16$-powersmooth respectably, because $1303 - 1 = 2 \\cdot 3 \\cdot 7 \\cdot 31$ and $3697 - 1 = 2^4 \\cdot 3 \\cdot 7 \\cdot 11$.\nIn 1974 John Pollard invented a method to extracts $B$-powersmooth factors from a composite number.\n\nThe idea comes from [Fermat's little theorem](phi-function.md#application).\nLet a factorization of $n$ be $n = p \\cdot q$.\nIt says that if $a$ is coprime to $p$, the following statement holds:\n\n$$a^{p - 1} \\equiv 1 \\pmod{p}$$\n\nThis also means that\n\n$$a^{(p - 1)^k} \\equiv a^{k \\cdot (p - 1)} \\equiv 1 \\pmod{p}.$$\n\nSo for any $M$ with $p - 1 ~|~ M$ we know that $a^M \\equiv 1$.\nThis means that $a^M - 1 = p \\cdot r$, and because of that also $p ~|~ \\gcd(a^M - 1, n)$.\n\nTherefore, if $p - 1$ for a factor $p$ of $n$ divides $M$, we can extract a factor using [Euclid's algorithm](euclid-algorithm.md).\n\nIt is clear, that the smallest $M$ that is a multiple of every $B$-powersmooth number is $\\text{lcm}(1,~2~,3~,4~,~\\dots,~B)$.\nOr alternatively:\n\n$$M = \\prod_{\\text{prime } q \\le B} q^{\\lfloor \\log_q B \\rfloor}$$\n\nNotice, if $p-1$ divides $M$ for all prime factors $p$ of $n$, then $\\gcd(a^M - 1, n)$ will just be $n$.\nIn this case we don't receive a factor.\nTherefore we will try to perform the $\\gcd$ multiple time, while we compute $M$.\n\nSome composite numbers don't have $B$-powersmooth factors for small $B$.\nE.g. the factors of the composite number $100~000~000~000~000~493 = 763~013 \\cdot 131~059~365~961$ are $190~753$-powersmooth and $1~092~161~383$-powersmooth.\nWe would have to choose $B >= 190~753$ to factorize the number.\n\nIn the following implementation we start with $B = 10$ and increase $B$ after each each iteration.\n\n```{.cpp file=factorization_p_minus_1}\nlong long pollards_p_minus_1(long long n) {\n    int B = 10;\n    long long g = 1;\n    while (B <= 1000000 && g < n) {\n        long long a = 2 + rand() %  (n - 3);\n        g = gcd(a, n);\n        if (g > 1)\n            return g;\n\n        // compute a^M\n        for (int p : primes) {\n            if (p >= B)\n                continue;\n            long long p_power = 1;\n            while (p_power * p <= B)\n                p_power *= p;\n            a = power(a, p_power, n);\n\n            g = gcd(a - 1, n);\n            if (g > 1 && g < n)\n                return g;\n        }\n        B *= 2;\n    }\n    return 1;\n}\n\n```\n\nNotice, this is a probabilistic algorithm.\nIt can happen that the algorithm doesn't find a factor.\n\nThe complexity is $O(B \\log B \\log^2 n)$ per iteration.\n\n## Pollard's rho algorithm\n\nAnother factorization algorithm from John Pollard.\n\nLet the prime factorization of a number be $n = p q$.\nThe algorithm looks at a pseudo-random sequence $\\{x_i\\} = \\{x_0,~f(x_0),~f(f(x_0)),~\\dots\\}$ where $f$ is a polynomial function, usually $f(x) = (x^2 + c) \\bmod n$ is chosen with $c = 1$.\n\nActually we are not very interested in the sequence $\\{x_i\\}$, we are more interested in the sequence $\\{x_i \\bmod p\\}$.\nSince $f$ is a polynomial function and all the values are in the range $[0;~p)$ this sequence will begin to cycle sooner or later.\nThe **birthday paradox** actually suggests, that the expected number of elements is $O(\\sqrt{p})$ until the repetition starts.\nIf $p$ is smaller than $\\sqrt{n}$, the repetition will start very likely in $O(\\sqrt[4]{n})$.\n\nHere is a visualization of such a sequence $\\{x_i \\bmod p\\}$ with $n = 2206637$, $p = 317$, $x_0 = 2$ and $f(x) = x^2 + 1$.\nFrom the form of the sequence you can see very clearly why the algorithm is called Pollard's $\\rho$ algorithm.\n\n<center>![Pollard's rho visualization](pollard_rho.png)</center>\n\nThere is still one big open question.\nWe don't know $p$ yet, so how can we argue about the sequence $\\{x_i \\bmod p\\}$?\n\nIt's actually quite easy.\nThere is a cycle in the sequence $\\{x_i \\bmod p\\}_{i \\le j}$ if and only if there are two indices $s, t \\le j$ such that $x_s \\equiv x_t \\bmod p$.\nThis equation can be rewritten as $x_s - x_t \\equiv 0 \\bmod p$ which is the same as $p ~|~ \\gcd(x_s - x_t, n)$.\n\nTherefore, if we find two indices $s$ and $t$ with $g = \\gcd(x_s - x_t, n) > 1$, we have found a cycle and also a factor $g$ of $n$.\nNotice that it is possible that $g = n$.\nIn this case we haven't found a proper factor, and we have to repeat the algorithm with different parameter (different starting value $x_0$, different constant $c$ in the polynomial function $f$).\n\nTo find the cycle, we can use any common cycle detection algorithm.\n\n### Floyd's cycle-finding algorithm\n\nThis algorithm finds a cycle by using two pointers.\nThese pointers move over the sequence at different speeds.\nIn each iteration the first pointer advances to the next element, but the second pointer advances two elements.\nIt's not hard to see, that if there exists a cycle, the second pointer will make at least one full cycle and then meet the first pointer during the next few cycle loops.\nIf the cycle length is $\\lambda$ and the $\\mu$ is the first index at which the cycle starts, then the algorithm will run in $O(\\lambda + \\mu)$ time.\n\nThis algorithm is also known as **tortoise and the hare algorithm**, based on the tale in which a tortoise (here a slow pointer) and a hare (here a faster pointer) make a race.\n\nIt is actually possible to determine the parameter $\\lambda$ and $\\mu$ using this algorithm (also in $O(\\lambda + \\mu)$ time and $O(1)$ space), but here is just the simplified version for finding the cycle at all.\nThe algorithm and returns true as soon as it detects a cycle.\nIf the sequence doesn't have a cycle, then the function will never stop.\nHowever this cannot happen during Pollard's rho algorithm.\n\n```text\nfunction floyd(f, x0):\n    tortoise = x0\n    hare = f(x0)\n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(f(hare))\n    return true\n```\n\n### Implementation\n\nFirst here is a implementation using the **Floyd's cycle-finding algorithm**.\nThe algorithm runs (usually) in $O(\\sqrt[4]{n} \\log(n))$ time.\n\n```{.cpp file=pollard_rho}\nlong long mult(long long a, long long b, long long mod) {\n    return (__int128)a * b % mod;\n}\n\nlong long f(long long x, long long c, long long mod) {\n    return (mult(x, x, mod) + c) % mod;\n}\n\nlong long rho(long long n, long long x0=2, long long c=1) {\n    long long x = x0;\n    long long y = x0;\n    long long g = 1;\n    while (g == 1) {\n        x = f(x, c, n);\n        y = f(y, c, n);\n        y = f(y, c, n);\n        g = gcd(abs(x - y), n);\n    }\n    return g;\n}\n```\n\nThe following table shows the values of $x$ and $y$ during the algorithm for $n = 2206637$, $x_0 = 2$ and $c = 1$.\n\n$$\n\\newcommand\\T{\\Rule{0pt}{1em}{.3em}}\n\\begin{array}{|l|l|l|l|l|l|}\n\\hline\ni & x_i \\bmod n & x_{2i} \\bmod n & x_i \\bmod 317 & x_{2i} \\bmod 317 & \\gcd(x_i - x_{2i}, n) \\\\\n\\hline\n0   & 2       & 2       & 2       & 2       & -   \\\\\n1   & 5       & 26      & 5       & 26      & 1   \\\\\n2   & 26      & 458330  & 26      & 265     & 1   \\\\\n3   & 677     & 1671573 & 43      & 32      & 1   \\\\\n4   & 458330  & 641379  & 265     & 88      & 1   \\\\\n5   & 1166412 & 351937  & 169     & 67      & 1   \\\\\n6   & 1671573 & 1264682 & 32      & 169     & 1   \\\\\n7   & 2193080 & 2088470 & 74      & 74      & 317 \\\\\n\\hline\n\\end{array}$$\n\nThe implementation uses a function `mult`, that multiplies two integers $\\le 10^{18}$ without overflow by using a GCC's type `__int128` for 128-bit integer.\nIf GCC is not available, you can using a similar idea as [binary exponentiation](binary-exp.md).\n\n```{.cpp file=pollard_rho_mult2}\nlong long mult(long long a, long long b, long long mod) {\n    long long result = 0;\n    while (b) {\n        if (b & 1)\n            result = (result + a) % mod;\n        a = (a + a) % mod;\n        b >>= 1;\n    }\n    return result;\n}\n```\n\nAlternatively you can also implement the [Montgomery multiplication](montgomery_multiplication.md).\n\nAs already noticed above: if $n$ is composite and the algorithm returns $n$ as factor, you have to repeat the procedure with different parameter $x_0$ and $c$.\nE.g. the choice $x_0 = c = 1$ will not factor $25 = 5 \\cdot 5$.\nThe algorithm will just return $25$.\nHowever the choice $x_0 = 1$, $c = 2$ will factor it.\n\n### Brent's algorithm\n\nBrent uses a similar algorithm as Floyd.\nIt also uses two pointer.\nBut instead of advancing the pointers by one and two respectably, we advance them in powers of two.\nAs soon as $2^i$ is greater than $\\lambda$ and $\\mu$, we will find the cycle.\n\n```text\nfunction floyd(f, x0):\n    tortoise = x0\n    hare = f(x0)\n    l = 1\n    while tortoise != hare:\n        tortoise = hare\n        repeat l times:\n            hare = f(hare)\n            if tortoise == hare:\n                return true\n        l *= 2\n    return true\n```\n\nBrent's algorithm also runs in linear time, but is usually faster than Floyd's algorithm, since it uses less evaluations of the function $f$.\n\n### Implementation\n\nThe straightforward implementation using Brent's algorithms can be speeded up by noticing, that we can omit the terms $x_l - x_k$ if $k < \\frac{3 \\cdot l}{2}$.\nAlso, instead of performing the $\\gcd$ computation at every step, we multiply the terms and do it every few steps and backtrack if we overshoot.\n\n```{.cpp file=pollard_rho_brent}\nlong long brent(long long n, long long x0=2, long long c=1) {\n    long long x = x0;\n    long long g = 1;\n    long long q = 1;\n    long long xs, y;\n\n    int m = 128;\n    int l = 1;\n    while (g == 1) {\n        y = x;\n        for (int i = 1; i < l; i++)\n            x = f(x, c, n);\n        int k = 0;\n        while (k < l && g == 1) {\n            xs = x;\n            for (int i = 0; i < m && i < l - k; i++) {\n                x = f(x, c, n);\n                q = mult(q, abs(y - x), n);\n            }\n            g = gcd(q, n);\n            k += m;\n        }\n        l *= 2;\n    }\n    if (g == n) {\n        do {\n            xs = f(xs, c, n);\n            g = gcd(abs(xs - y), n);\n        } while (g == 1);\n    }\n    return g;\n}\n```\n\nThe combination of a trial division for small prime numbers together with Brent's version of Pollard's rho algorithm will make a very powerful factorization algorithm.\n\n## Practice Problems\n\n- [SPOJ - FACT0](https://www.spoj.com/problems/FACT0/)\n- [SPOJ - FACT1](https://www.spoj.com/problems/FACT1/)\n- [SPOJ - FACT2](https://www.spoj.com/problems/FACT2/)\n- [GCPC 15 - Divisions](https://codeforces.com/gym/100753)\n", "problem_ids": [], "title": "Integer factorization"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: all_submasks\n---\n\n# Submask Enumeration\n\n## Enumerating all submasks of a given mask\n\nGiven a bitmask $m$, you want to efficiently iterate through all of its submasks, that is, masks $s$ in which only bits that were included in mask $m$ are set.\n\nConsider the implementation of this algorithm, based on tricks with bit operations:\n\n```cpp\nint s = m;\nwhile (s > 0) {\n ... you can use s ...\n s = (s-1) & m;\n}\n```\n\nor, using a more compact `for` statement:\n\n```cpp\nfor (int s=m; s; s=(s-1)&m)\n ... you can use s ...\n```\n\nIn both variants of the code, the submask equal to zero will not be processed. We can either process it outside the loop, or use a less elegant design, for example:\n\n```cpp\nfor (int s=m; ; s=(s-1)&m) {\n ... you can use s ...\n if (s==0)  break;\n}\n```\n\nLet us examine why the above code visits all submasks of $m$, without repetition, and in descending order.\n\nSuppose we have a current bitmask $s$, and we want to move on to the next bitmask. By subtracting from the mask $s$ one unit, we will remove the rightmost set bit and all bits to the right of it will become 1. Then we remove all the \"extra\" one bits that are not included in the mask $m$ and therefore can't be a part of a submask. We do this removal by using the bitwise operation `(s-1) & m`. As a result, we \"cut\" mask $s-1$ to determine the highest value that it can take, that is, the next submask after $s$ in descending order.\n\nThus, this algorithm generates all submasks of this mask in descending order, performing only two operations per iteration.\n\nA special case is when $s = 0$. After executing $s-1$ we get a mask where all bits are set (bit representation of -1), and after `(s-1) & m` we will have that $s$ will be equal to $m$. Therefore, with the mask $s = 0$ be careful \u2014 if the loop does not end at zero, the algorithm may enter an infinite loop.\n\n## Iterating through all masks with their submasks. Complexity $O(3^n)$\n\nIn many problems, especially those that use bitmask dynamic programming, you want to iterate through all bitmasks and for each mask, iterate through all of its submasks:\n\n```cpp\nfor (int m=0; m<(1<<n); ++m)\n\tfor (int s=m; s; s=(s-1)&m)\n ... s and m ...\n```\n\nLet's prove that the inner loop will execute a total of $O(3^n)$ iterations.\n\n**First proof**: Consider the $i$-th bit. There are exactly three options for it:\n\n1. it is not included in the mask $m$ (and therefore not included in submask $s$),\n2. it is included in $m$, but not included in $s$, or\n3. it is included in both $m$ and $s$.\n\nAs there are a total of $n$ bits, there will be $3^n$ different combinations.\n\n**Second proof**: Note that if mask $m$ has $k$ enabled bits, then it will have $2^k$ submasks. As we have a total of $\\binom{n}{k}$ masks with $k$ enabled bits (see [binomial coefficients](../combinatorics/binomial-coefficients.md)), then the total number of combinations for all masks will be:\n\n$$\\sum_{k=0}^n \\binom{n}{k} \\cdot 2^k$$\n\nTo calculate this number, note that the sum above is equal to the expansion of $(1+2)^n$ using the binomial theorem. Therefore, we have $3^n$ combinations, as we wanted to prove.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: all_submasks\n---\n\n# Submask Enumeration\n\n## Enumerating all submasks of a given mask\n\nGiven a bitmask $m$, you want to efficiently iterate through all of its submasks, that is, masks $s$ in which only bits that were included in mask $m$ are set.\n\nConsider the implementation of this algorithm, based on tricks with bit operations:\n\n```cpp\nint s = m;\nwhile (s > 0) {\n ... you can use s ...\n s = (s-1) & m;\n}\n```\n\nor, using a more compact `for` statement:\n\n```cpp\nfor (int s=m; s; s=(s-1)&m)\n ... you can use s ...\n```\n\nIn both variants of the code, the submask equal to zero will not be processed. We can either process it outside the loop, or use a less elegant design, for example:\n\n```cpp\nfor (int s=m; ; s=(s-1)&m) {\n ... you can use s ...\n if (s==0)  break;\n}\n```\n\nLet us examine why the above code visits all submasks of $m$, without repetition, and in descending order.\n\nSuppose we have a current bitmask $s$, and we want to move on to the next bitmask. By subtracting from the mask $s$ one unit, we will remove the rightmost set bit and all bits to the right of it will become 1. Then we remove all the \"extra\" one bits that are not included in the mask $m$ and therefore can't be a part of a submask. We do this removal by using the bitwise operation `(s-1) & m`. As a result, we \"cut\" mask $s-1$ to determine the highest value that it can take, that is, the next submask after $s$ in descending order.\n\nThus, this algorithm generates all submasks of this mask in descending order, performing only two operations per iteration.\n\nA special case is when $s = 0$. After executing $s-1$ we get a mask where all bits are set (bit representation of -1), and after `(s-1) & m` we will have that $s$ will be equal to $m$. Therefore, with the mask $s = 0$ be careful \u2014 if the loop does not end at zero, the algorithm may enter an infinite loop.\n\n## Iterating through all masks with their submasks. Complexity $O(3^n)$\n\nIn many problems, especially those that use bitmask dynamic programming, you want to iterate through all bitmasks and for each mask, iterate through all of its submasks:\n\n```cpp\nfor (int m=0; m<(1<<n); ++m)\n\tfor (int s=m; s; s=(s-1)&m)\n ... s and m ...\n```\n\nLet's prove that the inner loop will execute a total of $O(3^n)$ iterations.\n\n**First proof**: Consider the $i$-th bit. There are exactly three options for it:\n\n1. it is not included in the mask $m$ (and therefore not included in submask $s$),\n2. it is included in $m$, but not included in $s$, or\n3. it is included in both $m$ and $s$.\n\nAs there are a total of $n$ bits, there will be $3^n$ different combinations.\n\n**Second proof**: Note that if mask $m$ has $k$ enabled bits, then it will have $2^k$ submasks. As we have a total of $\\binom{n}{k}$ masks with $k$ enabled bits (see [binomial coefficients](../combinatorics/binomial-coefficients.md)), then the total number of combinations for all masks will be:\n\n$$\\sum_{k=0}^n \\binom{n}{k} \\cdot 2^k$$\n\nTo calculate this number, note that the sum above is equal to the expansion of $(1+2)^n$ using the binomial theorem. Therefore, we have $3^n$ combinations, as we wanted to prove.\n\n## Practice Problems\n\n* [Atcoder - Close Group](https://atcoder.jp/contests/abc187/tasks/abc187_f)\n* [Codeforces - Nuclear Fusion](http://codeforces.com/problemset/problem/71/E)\n* [Codeforces - Sandy and Nuts](http://codeforces.com/problemset/problem/599/E)\n* [Uva 1439 - Exclusive Access 2](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4185)\n* [UVa 11825 - Hackers' Crackdown](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2925)\n", "problem_ids": ["71_E", "599_E"], "title": "Submask Enumeration"}, {"article": "---\ntags:\n  - Original\n---\n\n<!--?title Continued fractions -->\n# Continued fractions\n\n**Continued fraction** is a representation of a real number as a specific convergent sequence of rational numbers. They are useful in competitive programming because they are easy to compute and can be efficiently used to find the best possible rational approximation of the underlying real number (among all numbers whose denominator doesn't exceed a given value).\n\nBesides that, continued fractions are closely related to Euclidean algorithm which makes them useful in a bunch of number-theoretical problems.\n\n## Continued fraction representation\n\n!!! info \"Definition\"\n    Let $a_0, a_1, \\dots, a_k \\in \\mathbb Z$ and $a_1, a_2, \\dots, a_k \\geq 1$. Then the expression\n\n    $$r=a_0 + \\frac{1}{a_1 + \\frac{1}{\\dots + \\frac{1}{a_k}}},$$\n\n    is called the **continued fraction representation** of the rational number $r$ and is denoted shortly as $r=[a_0;a_1,a_2,\\dots,a_k]$.\n\n??? example\n    Let $r = \\frac{5}{3}$. There are two ways to represent it as a continued fraction:\n\n    $$\n    \\begin{align}\n    r = [1;1,1,1] &= 1+\\frac{1}{1+\\frac{1}{1+\\frac{1}{1}}},\\\\\n    r = [1;1,2] &= 1+\\frac{1}{1+\\frac{1}{2}}.\n    \\end{align}\n    $$\n\nIt can be proven that any rational number can be represented as a continued fraction in exactly $2$ ways:\n\n$$r = [a_0;a_1,\\dots,a_k,1] = [a_0;a_1,\\dots,a_k+1].$$\n\nMoreover, the length $k$ of such continued fraction is estimated as $k = O(\\log \\min(p, q))$ for $r=\\frac{p}{q}$.\n\nThe reasoning behind this will be clear once we delve into the details of the continued fraction construction.\n\n!!! info \"Definition\"\n    Let $a_0,a_1,a_2, \\dots$ be an integer sequence such that $a_1, a_2, \\dots \\geq 1$. Let $r_k = [a_0; a_1, \\dots, a_k]$. Then the expression\n\n    $$r = a_0 + \\frac{1}{a_1 + \\frac{1}{a_2+\\dots}} = \\lim\\limits_{k \\to \\infty} r_k.$$\n\n    is called the **continued fraction representation** of the irrational number $r$ and is denoted shortly as $r = [a_0;a_1,a_2,\\dots]$.\n\nNote that for $r=[a_0;a_1,\\dots]$ and integer $k$, it holds that $r+k = [a_0+k; a_1, \\dots]$.\n\nAnother important observation is that $\\frac{1}{r}=[0;a_0, a_1, \\dots]$ when $a_0 > 0$ and $\\frac{1}{r} = [a_1; a_2, \\dots]$ when $a_0 = 0$.\n\n!!! info \"Definition\"\n    In the definition above, rational numbers $r_0, r_1, r_2, \\dots$ are called the **convergents** of $r$.\n\n    Correspondingly, individual $r_k = [a_0; a_1, \\dots, a_k] = \\frac{p_k}{q_k}$ is called the $k$-th **convergent** of $r$.\n\n??? example\n    Consider $r = [1; 1, 1, 1, \\dots]$. It can be proven by induction that $r_k = \\frac{F_{k+2}}{F_{k+1}}$, where $F_k$ is the Fibonacci sequence defined as $F_0 = 0$, $F_1 = 1$ and $F_{k} = F_{k-1} + F_{k-2}$. From the Binet's formula, it is known that\n\n    $$r_k = \\frac{\\phi^{k+2} - \\psi^{k+2}}{\\phi^{k+1} - \\psi^{k+1}},$$\n\n    where $\\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618$ is the golden ratio and $\\psi = \\frac{1-\\sqrt{5}}{2} = -\\frac{1}{\\phi} \\approx -0.618$. Thus,\n\n    $$r = 1+\\frac{1}{1+\\frac{1}{1+\\dots}}=\\lim\\limits_{k \\to \\infty} r_k = \\phi = \\frac{1+\\sqrt{5}}{2}.$$\n\n    Note that in this specific case, an alternative way to find $r$ would be to solve the equation\n\n    $$r = 1+\\frac{1}{r} \\implies r^2 = r + 1. $$\n\n\n!!! info \"Definition\"\n    Let $r_k = [a_0; a_1, \\dots, a_{k-1}, a_k]$. The numbers $[a_0; a_1, \\dots, a_{k-1}, t]$ for $1 \\leq t \\leq a_k$ are called **semiconvergents**.\n\n    We will typically refer to (semi)convergents that are greater than $r$ as **upper** (semi)convergents and to those that are less than $r$ as **lower** (semi)convergents.\n\n!!! info \"Definition\"\n    Complementary to convergents, we define the **[complete quotients](https://en.wikipedia.org/wiki/Complete_quotient)** as $s_k = [a_k; a_{k+1}, a_{k+2}, \\dots]$.\n\n    Correspondingly, we will call an individual $s_k$ the $k$-th complete quotient of $r$.\n\nFrom the definitions above, one can conclude that $s_k \\geq 1$ for $k \\geq 1$.\n\nTreating $[a_0; a_1, \\dots, a_k]$ as a formal algebraic expression and allowing arbitrary real numbers instead of $a_i$, we obtain\n\n$$r = [a_0; a_1, \\dots, a_{k-1}, s_k].$$\n\nIn particular, $r = [s_0] = s_0$. On the other hand, we can express $s_k$ as\n\n$$s_k = [a_k; s_{k+1}] = a_k + \\frac{1}{s_{k+1}},$$\n\nmeaning that we can compute $a_k = \\lfloor s_k \\rfloor$ and $s_{k+1} = (s_k - a_k)^{-1}$ from $s_k$.\n\nThe sequence $a_0, a_1, \\dots$ is well-defined unless $s_k=a_k$ which only happens when $r$ is a rational number.\n\nThus the continued fraction representation is uniquely defined for any irrational number $r$.\n\n### Implementation\n\nIn the code snippets we will mostly assume finite continued fractions.\n\nFrom $s_k$, the transition to $s_{k+1}$ looks like\n\n$$s_k =\\left\\lfloor s_k \\right\\rfloor + \\frac{1}{s_{k+1}}.$$\n\nFrom this expression, the next complete quotient $s_{k+1}$ is obtained as\n\n$$s_{k+1} = \\left(s_k-\\left\\lfloor s_k\\right\\rfloor\\right)^{-1}.$$\n\nFor $s_k=\\frac{p}{q}$ it means that\n\n$$\ns_{k+1} = \\left(\\frac{p}{q}-\\left\\lfloor \\frac{p}{q} \\right\\rfloor\\right)^{-1} = \\frac{q}{p-q\\cdot \\lfloor \\frac{p}{q} \\rfloor} = \\frac{q}{p \\bmod q}.\n$$\n\nThus, the computation of a continued fraction representation for $r=\\frac{p}{q}$ follows the steps of the Euclidean algorithm for $p$ and $q$.\n\nFrom this also follows that $\\gcd(p_k, q_k) = 1$ for $\\frac{p_k}{q_k} = [a_0; a_1, \\dots, a_k]$. Hence, convergents are always irreducible.\n\n=== \"C++\"\n    ```cpp\n    auto fraction(int p, int q) {\n        vector<int> a;\n        while(q) {\n            a.push_back(p / q);\n            tie(p, q) = make_pair(q, p % q);\n        }\n        return a;\n    }\n    ```\n=== \"Python\"\n    ```py\n    def fraction(p, q):\n        a = []\n        while q:\n            a.append(p // q)\n            p, q = q, p % q\n        return a\n    ```\n\n## Key results\n\nTo provide some motivation for further study of continued fraction, we give some key facts now.\n\n??? note \"Recurrence\"\n    For the convergents $r_k = \\frac{p_k}{q_k}$, the following recurrence stands, allowing their fast computation:\n    \n    $$\\frac{p_k}{q_k}=\\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}},$$\n    \n    where $\\frac{p_{-1}}{q_{-1}}=\\frac{1}{0}$ and $\\frac{p_{-2}}{q_{-2}}=\\frac{0}{1}$.\n\n??? note \"Deviations\"\n    The deviation of $r_k = \\frac{p_k}{q_k}$ from $r$ can be generally estimated as\n    \n    $$\\left|\\frac{p_k}{q_k}-r\\right| \\leq \\frac{1}{q_k q_{k+1}} \\leq \\frac{1}{q_k^2}.$$\n    \n    Multiplying both sides with $q_k$, we obtain alternate estimation:\n    \n    $$|p_k - q_k r| \\leq \\frac{1}{q_{k+1}}.$$\n\n    From the recurrence above it follows that $q_k$ grows at least as fast as Fibonacci numbers.\n\n    On the picture below you may see the visualization of how convergents $r_k$ approach $r=\\frac{1+\\sqrt 5}{2}$:\n\n    ![](https://upload.wikimedia.org/wikipedia/commons/b/b4/Golden_ration_convergents.svg)\n\n    $r=\\frac{1+\\sqrt 5}{2}$ is depicted by blue dotted line. Odd convergents approach it from above and even convergents approach it from below.\n\n??? note \"Lattice hulls\"\n    Consider convex hulls of points above and below the line $y=rx$.\n    \n    Odd convergents $(q_k;p_k)$ are the vertices of the upper hull, while the even convergents $(q_k;p_k)$ are the vertices of the bottom hull.\n    \n    All integers vertices on the hulls are obtained as $(q;p)$ such that\n    \n    $$\\frac{p}{q} = \\frac{tp_{k-1} + p_{k-2}}{tq_{k-1} + q_{k-2}}$$\n    \n    for integer $0 \\leq t \\leq a_k$. In other words, the set of lattice points on the hulls corresponds to the set of semiconvergents.\n\n    On the picture below, you may see the convergents and semiconvergents (intermediate gray points) of $r=\\frac{9}{7}$.\n\n    ![](https://upload.wikimedia.org/wikipedia/commons/9/92/Continued_convergents_geometry.svg)\n\n??? note \"Best approximations\"\n    Let $\\frac{p}{q}$ be the fraction to minimize $\\left|r-\\frac{p}{q}\\right|$ subject to $q \\leq x$ for some $x$.\n    \n    Then $\\frac{p}{q}$ is a semiconvergent of $r$.\n\nThe last fact allows to find the best rational approximations of $r$ by checking its semiconvergents.\n\nBelow you will find the further explanation and a bit of intuition and interpretation for these facts.\n\n## Convergents\n\nLet's take a closer look at the convergents that were defined earlier. For $r=[a_0, a_1, a_2, \\dots]$, its convergents are\n\n\\begin{gather}\nr_0=[a_0],\\\\r_1=[a_0, a_1],\\\\ \\dots,\\\\ r_k=[a_0, a_1, \\dots, a_k].\n\\end{gather}\n\nConvergents are the core concept of continued fractions, so it is important to study their properties.\n\nFor the number $r$, its $k$-th convergent $r_k = \\frac{p_k}{q_k}$ can be computed as\n\n$$r_k = \\frac{P_k(a_0,a_1,\\dots,a_k)}{P_{k-1}(a_1,\\dots,a_k)} = \\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}},$$\n\nwhere $P_k(a_0,\\dots,a_k)$ is [the continuant](https://en.wikipedia.org/wiki/Continuant_(mathematics)), a multivariate polynomial defined as\n\n$$P_k(x_0,x_1,\\dots,x_k) = \\det \\begin{bmatrix}\nx_k & 1 & 0 & \\dots & 0 \\\\\n-1 & x_{k-1} & 1 & \\dots & 0 \\\\\n0 & -1 & x_2 & . & \\vdots \\\\\n\\vdots & \\vdots & . & \\ddots & 1 \\\\\n0 & 0 & \\dots & -1 & x_0\n\\end{bmatrix}_{\\textstyle .}$$\n\nThus, $r_k$ is a weighted [mediant](https://en.wikipedia.org/wiki/Mediant_(mathematics)) of $r_{k-1}$ and $r_{k-2}$.\n\nFor consistency, two additional convergents $r_{-1} = \\frac{1}{0}$ and $r_{-2} = \\frac{0}{1}$ are defined.\n\n??? hint \"Detailed explanation\"\n\n    The numerator and the denominator of $r_k$ can be seen as multivariate polynomials of $a_0, a_1, \\dots, a_k$:\n\n    $$r_k = \\frac{P_k(a_0, a_1, \\dots, a_k)}{Q_k(a_0,a_1, \\dots, a_k)}.$$\n\n    From the definition of convergents,\n\n    $$r_k = a_0 + \\frac{1}{[a_1;a_2,\\dots, a_k]}= a_0 + \\frac{Q_{k-1}(a_1, \\dots, a_k)}{P_{k-1}(a_1, \\dots, a_k)} = \\frac{a_0 P_{k-1}(a_1, \\dots, a_k) + Q_{k-1}(a_1, \\dots, a_k)}{P_{k-1}(a_1, \\dots, a_k)}.$$\n\n    From this follows $Q_k(a_0, \\dots, a_k) = P_{k-1}(a_1, \\dots, a_k)$. This yields the relation\n\n    $$P_k(a_0, \\dots, a_k) = a_0 P_{k-1}(a_1, \\dots, a_k) + P_{k-2}(a_2, \\dots, a_k).$$\n\n    Initially, $r_0 = \\frac{a_0}{1}$ and $r_1 = \\frac{a_0 a_1 + 1}{a_1}$, thus\n\n    $$\\begin{align}P_0(a_0)&=a_0,\\\\ P_1(a_0, a_1) &= a_0 a_1 + 1.\\end{align}$$\n\n    For consistency, it is convenient to define $P_{-1} = 1$ and $P_{-2}=0$ and formally say that $r_{-1} = \\frac{1}{0}$ and $r_{-2}=\\frac{0}{1}$.\n\n    From numerical analysis, it is known that the determinant of an arbitrary tridiagonal matrix\n\n    $$T_k = \\det \\begin{bmatrix}\n    a_0 & b_0 & 0 & \\dots & 0 \\\\\n    c_0 & a_1 & b_1 & \\dots & 0 \\\\\n    0 & c_1 & a_2 & . & \\vdots \\\\\n    \\vdots & \\vdots & . & \\ddots & c_{k-1} \\\\\n    0 & 0 & \\dots & b_{k-1} & a_k\n    \\end{bmatrix}$$\n\n    can be computed recursively as $T_k = a_k T_{k-1} - b_{k-1} c_{k-1} T_{k-2}$. Comparing it to $P_k$, we get a direct expression\n\n    $$P_k = \\det \\begin{bmatrix}\n    x_k & 1 & 0 & \\dots & 0 \\\\\n    -1 & x_{k-1} & 1 & \\dots & 0 \\\\\n    0 & -1 & x_2 & . & \\vdots \\\\\n    \\vdots & \\vdots & . & \\ddots & 1 \\\\\n    0 & 0 & \\dots & -1 & x_0\n    \\end{bmatrix}_{\\textstyle .}$$\n\n    This polynomial is also known as [the continuant](https://en.wikipedia.org/wiki/Continuant_(mathematics)) due to its close relation with continued fraction. The continuant won't change if the sequence on the main diagonal is reversed. This yields an alternative formula to compute it:\n\n    $$P_k(a_0, \\dots, a_k) = a_k P_{k-1}(a_0, \\dots, a_{k-1}) + P_{k-2}(a_0, \\dots, a_{k-2}).$$\n\n### Implementation\n\nWe will compute the convergents as a pair of sequences $p_{-2}, p_{-1}, p_0, p_1, \\dots, p_k$ and $q_{-2}, q_{-1}, q_0, q_1, \\dots, q_k$:\n\n=== \"C++\"\n    ```cpp\n    auto convergents(vector<int> a) {\n        vector<int> p = {0, 1};\n        vector<int> q = {1, 0};\n        for(auto it: a) {\n            p.push_back(p[p.size() - 1] * it + p[p.size() - 2]);\n            q.push_back(q[q.size() - 1] * it + q[q.size() - 2]);\n        }\n        return make_pair(p, q);\n    }\n    ```\n=== \"Python\"\n    ```py\n    def convergents(a):\n        p = [0, 1]\n        q = [1, 0]\n        for it in a:\n            p.append(p[-1]*it + p[-2])\n            q.append(q[-1]*it + q[-2])\n        return p, q\n    ```\n\n## Trees of continued fractions\n\nThere are two major ways to unite all possible continued fractions into useful tree structures.\n\n### Stern-Brocot tree\n\n[The Stern-Brocot tree](../others/stern_brocot_tree_farey_sequences.md) is a binary search tree that contains all distinct positive rational numbers.\n\nThe tree generally looks as follows:\n\n<figure>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/3/37/SternBrocotTree.svg\">\n<figcaption>\n<a href=\"https://commons.wikimedia.org/wiki/File:SternBrocotTree.svg\">The image</a> by <a href=\"https://commons.wikimedia.org/wiki/User:Aaron_Rotenberg\">Aaron Rotenberg</a> is licensed under <a href=\"https://creativecommons.org/licenses/by-sa/3.0/deed.en\">CC BY-SA 3.0</a>\n</figcaption>\n</figure>\n\nFractions $\\frac{0}{1}$ and $\\frac{1}{0}$ are \"virtually\" kept on the left and right sides of the tree correspondingly.\n\nThen the fraction in a node is a mediant $\\frac{a+c}{b+d}$ of two fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ above it.\n\nThe recurrence $\\frac{p_k}{q_k}=\\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}}$ means that the continued fraction representation encodes the path to $\\frac{p_k}{q_k}$ in the tree. To find $[a_0; a_1, \\dots, a_{k}, 1]$, one has to make $a_0$ moves to the right, $a_1$ moves to the left, $a_2$ moves to the right and so on up to $a_k$.\n\nThe parent of $[a_0; a_1, \\dots, a_k,1]$ then is the fraction obtained by taking one step back in the last used direction.\n\nIn other words, it is $[a_0; a_1, \\dots, a_k-1,1]$ when $a_k > 1$ and $[a_0; a_1, \\dots, a_{k-1}, 1]$ when $a_k = 1$.\n\nThus the children of $[a_0; a_1, \\dots, a_k, 1]$ are $[a_0; a_1, \\dots, a_k+1, 1]$ and $[a_0; a_1, \\dots, a_k, 1, 1]$.\n\nLet's index the Stern-Brocot tree. The root vertex is assigned an index $1$. Then for a vertex $v$, the index of its left child is assigned by changing the leading bit of $v$ from $1$ to $10$ and for the right child, it's assigned by changing the leading bit from $1$ to $11$:\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/1/18/Stern-brocot-index.svg\" width=\"500px\"/></figure>\n\nIn this indexing, the continued fraction representation of a rational number specifies the [run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding) of its binary index.\n\nFor $\\frac{5}{2} = [2;2] = [2;1,1]$, its index is $1011_2$ and its run-length encoding, considering bits in the ascending order, is $[2;1,1]$.\n\nAnother example is $\\frac{2}{5} = [0;2,2]=[0;2,1,1]$, which has index $1100_2$ and its run-length encoding is, indeed, $[0;2,2]$.\n\nIt is worth noting that the Stern-Brocot tree is, in fact, a [treap](../data_structures/treap.md). That is, it is a binary search tree by $\\frac{p}{q}$, but it is a heap by both $p$ and $q$.\n\n!!! example \"Comparing continued fractions\"\n    You're given $A=[a_0; a_1, \\dots, a_n]$ and $B=[b_0; b_1, \\dots, b_m]$. Which fraction is smaller?\n??? hint \"Solution\"\n    Assume for now that $A$ and $B$ are irrational and their continued fraction representations denote an infinite descent in the Stern-Brocot tree.\n\n    As we already mentioned, in this representation $a_0$ denotes the number of right turns in the descent, $a_1$ denotes the number of consequent left turns and so on. Therefore, when we compare $a_k$ and $b_k$, if $a_k = b_k$ we should just move on to comparing $a_{k+1}$ and $b_{k+1}$. Otherwise, if we're at right descents, we should check if $a_k < b_k$ and if we're at left descents, we should check if $a_k > b_k$ to tell whether $A < B$.\n\n    In other words, for irrational $A$ and $B$ it would be $A < B$ if and only if $(a_0, -a_1, a_2, -a_3, \\dots) < (b_0, -b_1, b_2, -b_3, \\dots)$ with lexicographical comparison.\n\n    Now, formally using $\\infty$ as an element of continued fraction representation it is possible to emulate irrational numbers $A-\\varepsilon$ and $A+\\varepsilon$, that is, elements that are smaller (greater) than $A$, but greater (smaller) than any other real number. Specifically, for $A=[a_0; a_1, \\dots, a_n]$, one of these two elements can be emulated as $[a_0; a_1, \\dots, a_n, \\infty]$ and the other can be emulated as $[a_0; a_1, \\dots, a_n - 1, 1, \\infty]$.\n\n    Which one corresponds to $A-\\varepsilon$ and which one to $A+\\varepsilon$ can be determined by the parity of $n$ or by comparing them as irrational numbers.\n\n    === \"Python\"\n        ```py\n        # check if a < b assuming that a[-1] = b[-1] = infty and a != b\n        def less(a, b):\n            a = [(-1)**i*a[i] for i in range(len(a))]\n            b = [(-1)**i*b[i] for i in range(len(b))]\n            return a < b\n\n        # [a0; a1, ..., ak] -> [a0, a1, ..., ak-1, 1]\n        def expand(a):\n            if a: # empty a = inf\n                a[-1] -= 1\n                a.append(1)\n            return a\n\n        # return a-eps, a+eps\n        def pm_eps(a):\n            b = expand(a.copy())\n            a.append(float('inf'))\n            b.append(float('inf'))\n            return (a, b) if less(a, b) else (b, a)\n        ```\n\n!!! example \"Best inner point\"\n    You're given $\\frac{0}{1} \\leq \\frac{p_0}{q_0} < \\frac{p_1}{q_1} \\leq \\frac{1}{0}$. Find the rational number $\\frac{p}{q}$ such that $(q; p)$ is lexicographically smallest and $\\frac{p_0}{q_0} < \\frac{p}{q} < \\frac{p_1}{q_1}$.\n\n??? hint \"Solution\"\n    In terms of the Stern-Brocot tree it means that we need to find the LCA of $\\frac{p_0}{q_0}$ and $\\frac{p_1}{q_1}$. Due to the connection between Stern-Brocot tree and continued fraction, this LCA would roughly correspond to the largest common prefix of continued fraction representations for $\\frac{p_0}{q_0}$ and $\\frac{p_1}{q_1}$.\n\n    So, if $\\frac{p_0}{q_0} = [a_0; a_1, \\dots, a_{k-1}, a_k, \\dots]$ and $\\frac{p_1}{q_1} = [a_0; a_1, \\dots, a_{k-1}, b_k, \\dots]$ are irrational numbers, the LCA is $[a_0; a_1, \\dots, \\min(a_k, b_k)+1]$.\n\n    For rational $r_0$ and $r_1$, one of them could be the LCA itself which would require us to casework it. To simplify the solution for rational $r_0$ and $r_1$, it is possible to use continued fraction representation of $r_0 + \\varepsilon$ and $r_1 - \\varepsilon$ which was derived in the previous problem.\n\n    === \"Python\"\n        ```py\n        # finds lexicographically smallest (q, p)\n        # such that p0/q0 < p/q < p1/q1\n        def middle(p0, q0, p1, q1):\n            a0 = pm_eps(fraction(p0, q0))[1]\n            a1 = pm_eps(fraction(p1, q1))[0]\n            a = []\n            for i in range(min(len(a0), len(a1))):\n                a.append(min(a0[i], a1[i]))\n                if a0[i] != a1[i]:\n                    break\n            a[-1] += 1\n            p, q = convergents(a)\n            return p[-1], q[-1]\n        ```\n\n!!! example \"[GCJ 2019, Round 2 - New Elements: Part 2](https://codingcompetitions.withgoogle.com/codejam/round/0000000000051679/0000000000146184)\"\n    You're given $N$ positive integer pairs $(C_i, J_i)$. You need to find a positive integer pair $(x, y)$ such that $C_i x + J_i y$ is a strictly increasing sequence.\n\n    Among such pairs, find the lexicographically minimum one.\n??? hint \"Solution\"\n    Rephrasing the statement, $A_i x + B_i y$ must be positive for all $i$, where $A_i = C_i - C_{i-1}$ and $B_i = J_i - J_{i-1}$.\n\n    Among such equations we have four significant groups for $A_i x + B_i y > 0$:\n\n    1. $A_i, B_i > 0$ can be ignored since we're looking for $x, y > 0$.\n    2. $A_i, B_i \\leq 0$ would provide \"IMPOSSIBLE\" as an answer.\n    3. $A_i > 0$, $B_i \\leq 0$. Such constraints are equivalent to $\\frac{y}{x} < \\frac{A_i}{-B_i}$.\n    4. $A_i \\leq 0$, $B_i > 0$. Such constraints are equivalent to $\\frac{y}{x} > \\frac{-A_i}{B_i}$.\n\n    Let $\\frac{p_0}{q_0}$ be the largest $\\frac{-A_i}{B_i}$ from the fourth group and $\\frac{p_1}{q_1}$ be the smallest $\\frac{A_i}{-B_i}$ from the third group.\n\n    The problem is now, given $\\frac{p_0}{q_0} < \\frac{p_1}{q_1}$, find a fraction $\\frac{p}{q}$ such that $(q;p)$ is lexicographically smallest and $\\frac{p_0}{q_0} < \\frac{p}{q} < \\frac{p_1}{q_1}$.\n    === \"Python\"\n        ```py\n            def solve():\n            n = int(input())\n            C = [0] * n\n            J = [0] * n\n            # p0/q0 < y/x < p1/q1\n            p0, q0 = 0, 1\n            p1, q1 = 1, 0\n            fail = False\n            for i in range(n):\n                C[i], J[i] = map(int, input().split())\n                if i > 0:\n                    A = C[i] - C[i-1]\n                    B = J[i] - J[i-1]\n                    if A <= 0 and B <= 0:\n                        fail = True\n                    elif B > 0 and A < 0: # y/x > (-A)/B if B > 0\n                        if (-A)*q0 > p0*B:\n                            p0, q0 = -A, B\n                    elif B < 0 and A > 0: # y/x < A/(-B) if B < 0\n                        if A*q1 < p1*(-B):\n                            p1, q1 = A, -B\n            if p0*q1 >= p1*q0 or fail:\n                return 'IMPOSSIBLE'\n\n            p, q = middle(p0, q0, p1, q1)\n            return str(q) + ' ' + str(p)\n        ```\n\n### Calkin-Wilf tree\n\nA somewhat simpler way to organize continued fractions in a binary tree is the [Calkin-Wilf tree](https://en.wikipedia.org/wiki/Calkin\u2013Wilf_tree).\n\nThe tree generally looks like this:\n\n<figure>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/82/Calkin\u2013Wilf_tree.svg\" width=\"500px\"/>\n<figcaption><a href=\"https://commons.wikimedia.org/wiki/File:Calkin\u2013Wilf_tree.svg\">The image</a> by <a href=\"https://commons.wikimedia.org/wiki/User:Olli_Niemitalo\">Olli Niemitalo</a>, <a href=\"https://commons.wikimedia.org/wiki/User:Proz\">Proz</a> is licensed under <a href=\"https://creativecommons.org/publicdomain/zero/1.0/deed.en\">CC0 1.0</a></figcaption>\n</figure>\n\nIn the root of the tree, the number $\\frac{1}{1}$ is located. Then, for the vertex with a number $\\frac{p}{q}$, its children are $\\frac{p}{p+q}$ and $\\frac{p+q}{q}$.\n\nUnlike the Stern-Brocot tree, the Calkin-Wilf tree is not a binary _search_ tree, so it can't be used to perform rational binary search.\n\nIn the Calkin-Wilf tree, the direct parent of a fraction $\\frac{p}{q}$ is $\\frac{p-q}{q}$ when $p>q$ and $\\frac{p}{q-p}$ otherwise.\n\nFor the Stern-Brocot tree, we used the recurrence for convergents. To draw the connection between the continued fraction and the Calkin-Wilf tree, we should recall the recurrence for complete quotients. If $s_k = \\frac{p}{q}$, then $s_{k+1} = \\frac{q}{p \\mod q} = \\frac{q}{p-\\lfloor p/q \\rfloor \\cdot q}$.\n\nOn the other hand, if we repeatedly go from $s_k = \\frac{p}{q}$ to its parent in the Calkin-Wilf tree when $p > q$, we will end up in $\\frac{p \\mod q}{q} = \\frac{1}{s_{k+1}}$. If we continue doing so, we will end up in $s_{k+2}$, then $\\frac{1}{s_{k+3}}$ and so on. From this we can deduce that:\n\n1. When $a_0> 0$, the direct parent of $[a_0; a_1, \\dots, a_k]$ in the Calkin-Wilf tree is $\\frac{p-q}{q}=[a_0 - 1; a_1, \\dots, a_k]$.\n2. When $a_0 = 0$ and $a_1 > 1$, its direct parent is $\\frac{p}{q-p} = [0; a_1 - 1, a_2, \\dots, a_k]$.\n3. And when $a_0 = 0$ and $a_1 = 1$, its direct parent is $\\frac{p}{q-p} = [a_2; a_3, \\dots, a_k]$.\n\nCorrespondingly, children of $\\frac{p}{q} = [a_0; a_1, \\dots, a_k]$ are\n\n1. $\\frac{p+q}{q}=1+\\frac{p}{q}$, which is $[a_0+1; a_1, \\dots, a_k]$,\n2. $\\frac{p}{p+q} = \\frac{1}{1+\\frac{q}{p}}$, which is $[0, 1, a_0, a_1, \\dots, a_k]$ for $a_0 > 0$ and $[0, a_1+1, a_2, \\dots, a_k]$ for $a_0=0$.\n\nNoteworthy, if we enumerate vertices of the Calkin-Wilf tree in the breadth-first search order (that is, the root has a number $1$, and the children of the vertex $v$ have indices $2v$ and $2v+1$ correspondingly), the index of the rational number in the Calkin-Wilf tree would be the same as in the Stern-Brocot tree.\n\nThus, numbers on the same levels of the Stern-Brocot tree and the Calkin-Wilf tree are the same, but their ordering differs through the [bit-reversal permutation](https://en.wikipedia.org/wiki/Bit-reversal_permutation).\n## Convergence\n\nFor the number $r$ and its $k$-th convergent $r_k=\\frac{p_k}{q_k}$ the following formula stands:\n\n$$r_k = a_0 + \\sum\\limits_{i=1}^k \\frac{(-1)^{i-1}}{q_i q_{i-1}}.$$\n\nIn particular, it means that \n\n$$r_k - r_{k-1} = \\frac{(-1)^{k-1}}{q_k q_{k-1}}$$\n\nand \n\n$$p_k q_{k-1} - p_{k-1} q_k = (-1)^{k-1}.$$\n\nFrom this we can conclude that\n\n$$\\left| r-\\frac{p_k}{q_k} \\right| \\leq \\frac{1}{q_{k+1}q_k} \\leq \\frac{1}{q_k^2}.$$\n\nThe latter inequality is due to the fact that $r_k$ and $r_{k+1}$ are generally located on different sides of $r$, thus\n\n$$|r-r_k| = |r_k-r_{k+1}|-|r-r_{k+1}| \\leq |r_k - r_{k+1}|.$$\n\n??? tip \"Detailed explanation\"\n\n    To estimate $|r-r_k|$, we start by estimating the difference between adjacent convergents. By definition,\n\n    $$\\frac{p_k}{q_k} - \\frac{p_{k-1}}{q_{k-1}} = \\frac{p_k q_{k-1} - p_{k-1} q_k}{q_k q_{k-1}}.$$\n\n    Replacing $p_k$ and $q_k$ in the numerator with their recurrences, we get\n\n    $$\\begin{align} p_k q_{k-1} - p_{k-1} q_k &= (a_k p_{k-1} + p_{k-2}) q_{k-1} - p_{k-1} (a_k q_{k-1} + q_{k-2})\n    \\\\&= p_{k-2} q_{k-1} - p_{k-1} q_{k-2},\\end{align}$$\n\n    thus the numerator of $r_k - r_{k-1}$ is always the negated numerator of $r_{k-1} - r_{k-2}$. It, in turn, equals to $1$ for\n\n    $$r_1 - r_0=\\left(a_0+\\frac{1}{a_1}\\right)-a_0=\\frac{1}{a_1},$$\n\n    thus\n\n    $$r_k - r_{k-1} = \\frac{(-1)^{k-1}}{q_k q_{k-1}}.$$\n\n    This yields an alternative representation of $r_k$ as a partial sum of infinite series:\n\n    $$r_k = (r_k - r_{k-1}) + \\dots + (r_1 - r_0) + r_0\n    = a_0 + \\sum\\limits_{i=1}^k \\frac{(-1)^{i-1}}{q_i q_{i-1}}.$$\n\n    From the recurrent relation it follows that $q_k$ monotonously increases at least as fast as Fibonacci numbers, thus\n\n    $$r = \\lim\\limits_{k \\to \\infty} r_k = a_0 + \\sum\\limits_{i=1}^\\infty \\frac{(-1)^{i-1}}{q_i q_{i-1}}$$\n\n    is always well-defined, as the underlying series always converge. Noteworthy, the residual series\n\n    $$r-r_k = \\sum\\limits_{i=k+1}^\\infty \\frac{(-1)^{i-1}}{q_i q_{i-1}}$$\n\n    has the same sign as $(-1)^k$ due to how fast $q_i q_{i-1}$ decreases. Hence even-indexed $r_k$ approach $r$ from below while odd-indexed $r_k$ approach it from above:\n\n    <figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/b/b4/Golden_ration_convergents.svg\" width=\"600px\"/>\n    <figcaption>_Convergents of $r=\\phi = \\frac{1+\\sqrt{5}}{2}=[1;1,1,\\dots]$ and their distance from $r$._</figcaption></figure>\n\n    From this picture we can see that\n\n    $$|r-r_k| = |r_k - r_{k+1}| - |r-r_{k+1}| \\leq |r_k - r_{k+1}|,$$\n\n    thus the distance between $r$ and $r_k$ is never larger than the distance between $r_k$ and $r_{k+1}$:\n\n    $$\\left|r-\\frac{p_k}{q_k}\\right| \\leq \\frac{1}{q_k q_{k+1}} \\leq \\frac{1}{q_k^2}.$$\n\n!!! example \"Extended Euclidean?\"\n    You're given $A, B, C \\in \\mathbb Z$. Find $x, y \\in \\mathbb Z$ such that $Ax + By = C$.\n??? hint \"Solution\"\n    Although this problem is typically solved with the [extended Euclidean algorithm](../algebra/extended-euclid-algorithm.md), there is a simple and straightforward solution with continued fractions.\n\n    Let $\\frac{A}{B}=[a_0; a_1, \\dots, a_k]$. It was proved above that $p_k q_{k-1} - p_{k-1} q_k = (-1)^{k-1}$. Substituting $p_k$ and $q_k$ with $A$ and $B$, we get\n\n    $$Aq_{k-1} - Bp_{k-1} = (-1)^{k-1} g,$$\n\n    where $g = \\gcd(A, B)$. If $C$ is divisible by $g$, then the solution is $x = (-1)^{k-1}\\frac{C}{g} q_{k-1}$ and $y = (-1)^{k}\\frac{C}{g} p_{k-1}$.\n    \n    === \"Python\"\n        ```py\n        # return (x, y) such that Ax+By=C\n        # assumes that such (x, y) exists\n        def dio(A, B, C):\n            p, q = convergents(fraction(A, B))\n            C //= A // p[-1] # divide by gcd(A, B)\n            t = (-1) if len(p) % 2 else 1\n            return t*C*q[-2], -t*C*p[-2]\n        ```\n\n## Linear fractional transformations\n\nAnother important concept for continued fractions are the so-called [linear fractional transformations](https://en.wikipedia.org/wiki/Linear_fractional_transformation).\n\n!!! info \"Definition\"\n    A **linear fractional transformation** is a function $f : \\mathbb R \\to \\mathbb R$ such that $f(x) = \\frac{ax+b}{cx+d}$ for some $a,b,c,d \\in \\mathbb R$.\n\nA composition $(L_0 \\circ L_1)(x) = L_0(L_1(x))$ of linear fractional transforms $L_0(x)=\\frac{a_0 x + b_0}{c_0 x + d_0}$ and $L_1(x)=\\frac{a_1 x + b_1}{c_1 x + d_1}$ is itself a linear fractional transform:\n\n$$\\frac{a_0\\frac{a_1 x + b_1}{c_1 x + d_1} + b_0}{c_0 \\frac{a_1 x + b_1}{c_1 x + d_1} + d_0} = \\frac{a_0(a_1 x + b_1) + b_0 (c_1 x + d_1)}{c_0 (a_1 x + b_1) + d_0 (c_1 x + d_1)} = \\frac{(a_0 a_1 + b_0 c_1) x + (a_0 b_1 + b_0 d_1)}{(c_0 a_1 + d_0 c_1) x + (c_0 b_1 + d_0 d_1)}.$$\n\nInverse of a linear fractional transform, is also a linear fractional transform:\n\n$$y = \\frac{ax+b}{cx+d} \\iff y(cx+d) = ax + b \\iff x = -\\frac{dy-b}{cy-a}.$$\n!!! example \"[DMOPC '19 Contest 7 P4 - Bob and Continued Fractions](https://dmoj.ca/problem/dmopc19c7p4)\"\n    You're given an array of positive integers $a_1, \\dots, a_n$. You need to answer $m$ queries. Each query is to compute $[a_l; a_{l+1}, \\dots, a_r]$.\n??? hint \"Solution\"\n    We can solve this problem with the segment tree if we're able to concatenate continued fractions.\n\n    It's generally true that $[a_0; a_1, \\dots, a_k, b_0, b_1, \\dots, b_k] = [a_0; a_1, \\dots, a_k, [b_1; b_2, \\dots, b_k]]$.\n\n    Let's denote $L_{k}(x) = [a_k; x] = a_k + \\frac{1}{x} = \\frac{a_k\\cdot x+1}{1\\cdot x + 0}$. Note that $L_k(\\infty) = a_k$. In this notion, it holds that\n\n    $$[a_0; a_1, \\dots, a_k, x] = [a_0; [a_1; [\\dots; [a_k; x]]]] = (L_0 \\circ L_1 \\circ \\dots \\circ L_k)(x) = \\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}.$$\n\n    Thus, the problem boils down to the computation of\n\n    $$(L_l \\circ L_{l+1} \\circ \\dots \\circ L_r)(\\infty).$$\n\n    Composition of transforms is associative, so it's possible to compute in each node of a segment tree the composition of transforms in its subtree.\n\n!!! example \"Linear fractional transformation of a continued fraction\"\n    Let $L(x) = \\frac{ax+b}{cx+d}$. Compute the continued fraction representation $[b_0; b_1, \\dots, b_m]$ of $L(A)$ for $A=[a_0; a_1, \\dots, a_n]$.\n\n    _This allows to compute $A + \\frac{p}{q} = \\frac{qA + p}{q}$ and $A \\cdot \\frac{p}{q} = \\frac{p A}{q}$ for any $\\frac{p}{q}$._\n\n??? hint \"Solution\"\n    As we noted above, $[a_0; a_1, \\dots, a_k] = (L_{a_0} \\circ L_{a_1} \\circ \\dots \\circ L_{a_k})(\\infty)$, hence $L([a_0; a_1, \\dots, a_k]) = (L \\circ L_{a_0} \\circ L_{a_1} \\circ \\dots L_{a_k})(\\infty)$.\n\n    Hence, by consequentially adding $L_{a_0}$, $L_{a_1}$ and so on we would be able to compute\n\n    $$(L \\circ L_{a_0} \\circ \\dots \\circ L_{a_k})(x) = L\\left(\\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}\\right)=\\frac{a_k x + b_k}{c_k x + d_k}.$$\n\n    Since $L(x)$ is invertible, it is also monotonous in $x$. Therefore, for any $x \\geq 0$ it holds that $L(\\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}})$ is between $L(\\frac{p_k}{q_k}) = \\frac{a_k}{c_k}$ and $L(\\frac{p_{k-1}}{q_{k-1}}) = \\frac{b_k}{d_k}$.\n\n    Moreover, for $x=[a_{k+1}; \\dots, a_n]$ it is equal to $L(A)$. Hence, $b_0 = \\lfloor L(A) \\rfloor$ is between $\\lfloor L(\\frac{p_k}{q_k}) \\rfloor$ and $\\lfloor L(\\frac{p_{k-1}}{q_{k-1}}) \\rfloor$. When they're equal, they're also equal to $b_0$.\n\n    Note that $L(A) = (L_{b_0} \\circ L_{b_1} \\circ \\dots \\circ L_{b_m})(\\infty)$. Knowing $b_0$, we can compose $L_{b_0}^{-1}$ with the current transform and continue adding $L_{a_{k+1}}$, $L_{a_{k+2}}$ and so on, looking for new floors to agree, from which we would be able to deduce $b_1$ and so on until we recover all values of $[b_0; b_1, \\dots, b_m]$.\n\n!!! example \"Continued fraction arithmetics\"\n    Let $A=[a_0; a_1, \\dots, a_n]$ and $B=[b_0; b_1, \\dots, b_m]$. Compute the continued fraction representations of $A+B$ and $A \\cdot B$.\n??? hint \"Solution\"\n    Idea here is similar to the previous problem, but instead of $L(x) = \\frac{ax+b}{cx+d}$ you should consider bilinear fractional transform $L(x, y) = \\frac{axy+bx+cy+d}{exy+fx+gy+h}$.\n\n    Rather than $L(x) \\mapsto L(L_{a_k}(x))$ you would change your current transform as $L(x, y) \\mapsto L(L_{a_k}(x), y)$ or $L(x, y) \\mapsto L(x, L_{b_k}(y))$.\n\n    Then, you check if $\\lfloor \\frac{a}{e} \\rfloor = \\lfloor \\frac{b}{f} \\rfloor = \\lfloor \\frac{c}{g} \\rfloor = \\lfloor \\frac{d}{h} \\rfloor$ and if they all agree, you use this value as $c_k$ in the resulting fraction and change the transform as\n\n    $$L(x, y) \\mapsto \\frac{1}{L(x, y) - c_k}.$$\n\n!!! info \"Definition\"\n    A continued fraction $x = [a_0; a_1, \\dots]$ is said to be **periodic** if $x = [a_0; a_1, \\dots, a_k, x]$ for some $k$.\n\n    A continued fraction $x = [a_0; a_1, \\dots]$ is said to be **eventually periodic** if $x = [a_0; a_1, \\dots, a_k, y]$, where $y$ is periodic.\n\nFor $x = [1; 1, 1, \\dots]$ it holds that $x = 1 + \\frac{1}{x}$, thus $x^2 = x + 1$. There is a generic connection between periodic continued fractions and quadratic equations. Consider the following equation:\n\n$$ x = [a_0; a_1, \\dots, a_k, x].$$\n\nOn one hand, this equation means that the continued fraction representation of $x$ is periodic with the period $k+1$.\n\nOn the other hand, using the formula for convergents, this equation means that\n\n$$x = \\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}.$$\n\nThat is, $x$ is a linear fractional transformation of itself. It follows from the equation that $x$ is a root of the second degree equation:\n\n$$q_k x^2 + (q_{k-1}-p_k)x - p_{k-1} = 0.$$\n\nSimilar reasoning stands for continued fractions that are eventually periodic, that is $x = [a_0; a_1, \\dots, a_k, y]$ for $y=[b_0; b_1, \\dots, b_k, y]$. Indeed, from first equation we derive that $x = L_0(y)$ and from second equation that $y = L_1(y)$, where $L_0$ and $L_1$ are linear fractional transformations. Therefore,\n\n$$x = (L_0 \\circ L_1)(y) = (L_0 \\circ L_1 \\circ L_0^{-1})(x).$$\n\nOne can further prove (and it was first done by Lagrange) that for arbitrary quadratic equation $ax^2+bx+c=0$ with integer coefficients, its solution $x$ is an eventually periodic continued fraction.\n\n!!! example \"Quadratic irrationality\"\n    Find the continued fraction of $\\alpha = \\frac{x+y\\sqrt{n}}{z}$ where $x, y, z, n \\in \\mathbb Z$ and $n > 0$ is not a perfect square.\n??? hint \"Solution\"\n    For the $k$-th complete quotient $s_k$ of the number it generally holds that\n\n    $$\\alpha = [a_0; a_1, \\dots, a_{k-1}, s_k] = \\frac{s_k p_{k-1} + p_{k-2}}{s_k q_{k-1} + q_{k-2}}.$$\n\n    Therefore, \n\n    $$s_k = -\\frac{\\alpha q_{k-1} - p_{k-1}}{\\alpha q_k - p_k} = -\\frac{q_{k-1} y \\sqrt n + (x q_{k-1} - z p_{k-1})}{q_k y \\sqrt n + (xq_k-zp_k)}.$$\n\n    Multiplying the numerator and denominator by $(xq_k - zp_k) - q_k y \\sqrt n$, we'll get rid of $\\sqrt n$ in the denominator, thus the complete quotients are of form\n\n    $$s_k = \\frac{x_k + y_k \\sqrt n}{z_k}.$$\n\n    Let's find $s_{k+1}$, assuming that $s_k$ is known.\n\n    First of all, $a_k = \\lfloor s_k \\rfloor = \\left\\lfloor \\frac{x_k + y_k \\lfloor \\sqrt n \\rfloor}{z_k} \\right\\rfloor$. Then,\n\n    $$s_{k+1} = \\frac{1}{s_k-a_k} = \\frac{z_k}{(x_k - z_k a_k) + y_k \\sqrt n} = \\frac{z_k (x_k - y_k a_k) - y_k z_k \\sqrt n}{(x_k - y_k a_k)^2 - y_k^2 n}.$$\n\n    Thus, if we denote $t_k = x_k - y_k a_k$, it will hold that\n\n    \\begin{align}x_{k+1} &=& z_k t_k, \\\\ y_{k+1} &=& -y_k z_k, \\\\ z_{k+1} &=& t_k^2 - y_k^2 n.\\end{align}\n\n    Nice thing about such representation is that if we reduce $x_{k+1}, y_{k+1}, z_{k+1}$ by their greatest common divisor, the result would be unique. Therefore, we may use it to check whether the current state has already been repeated and also to check where was the previous index that had this state.\n\n    Below is the code to compute the continued fraction representation for $\\alpha = \\sqrt n$:\n\n    === \"Python\"\n        ```py\n        # compute the continued fraction of sqrt(n)\n        def sqrt(n):\n            n0 = math.floor(math.sqrt(n))\n            x, y, z = 1, 0, 1\n            a = []\n            def step(x, y, z):\n                a.append((x * n0 + y) // z)\n                t = y - a[-1]*z\n                x, y, z = -z*x, z*t, t**2 - n*x**2\n                g = math.gcd(x, math.gcd(y, z))\n                return x // g, y // g, z // g\n\n            used = dict()\n            for i in range(n):\n                used[x, y, z] = i\n                x, y, z = step(x, y, z)\n                if (x, y, z) in used:\n                    return a\n        ```\n\n    Using the same `step` function but different initial $x$, $y$ and $z$ it is possible to compute it for arbitrary $\\frac{x+y \\sqrt{n}}{z}$.\n\n!!! example \"[Tavrida NU Akai Contest - Continued Fraction](https://timus.online/problem.aspx?space=1&num=1814)\"\n    You're given $x$ and $k$, $x$ is not a perfect square. Let $\\sqrt x = [a_0; a_1, \\dots]$, find $\\frac{p_k}{q_k}=[a_0; a_1, \\dots, a_k]$ for $0 \\leq k \\leq 10^9$.\n??? hint \"Solution\"\n    After computing the period of $\\sqrt x$, it is possible to compute $a_k$ using binary exponentiation on the linear fractional transformation induced by the continued fraction representation. To find the resulting transformation, you compress the period of size $T$ into a single transformation and repeat it $\\lfloor \\frac{k-1}{T}\\rfloor$ times, after which you manually combine it with the remaining transformations.\n\n    === \"Python\"\n        ```py\n        x, k = map(int, input().split())\n\n        mod = 10**9+7\n        \n        # compose (A[0]*x + A[1]) / (A[2]*x + A[3]) and (B[0]*x + B[1]) / (B[2]*x + B[3])\n        def combine(A, B):\n            return [t % mod for t in [A[0]*B[0]+A[1]*B[2], A[0]*B[1]+A[1]*B[3], A[2]*B[0]+A[3]*B[2], A[2]*B[1]+A[3]*B[3]]]\n\n        A = [1, 0, 0, 1] # (x + 0) / (0*x + 1) = x\n\n        a = sqrt(x)\n\n        T = len(a) - 1 # period of a\n\n        # apply ak + 1/x = (ak*x+1)/(1x+0) to (Ax + B) / (Cx + D)\n        for i in reversed(range(1, len(a))):\n            A = combine([a[i], 1, 1, 0], A)\n\n        def bpow(A, n):\n            return [1, 0, 0, 1] if not n else combine(A, bpow(A, n-1)) if n % 2 else bpow(combine(A, A), n // 2)\n\n\n        C = (0, 1, 0, 0) # = 1 / 0\n        while k % T:\n            i = k % T\n            C = combine([a[i], 1, 1, 0], C)\n            k -= 1\n\n        C = combine(bpow(A, k // T), C)\n        C = combine([a[0], 1, 1, 0], C)\n        print(str(C[1]) + '/' + str(C[3]))\n        ```\n\n## Geometric interpretation\n\nLet $\\vec r_k = (q_k;p_k)$ for the convergent $r_k = \\frac{p_k}{q_k}$. Then, the following recurrence holds:\n\n$$\\vec r_k = a_k \\vec r_{k-1} + \\vec r_{k-2}.$$\n\nLet $\\vec r = (1;r)$. Then, each vector $(x;y)$ corresponds to the number that is equal to its slope coefficient $\\frac{y}{x}$.\n\nWith the notion of [pseudoscalar product](../geometry/basic-geometry.md) $(x_1;y_1) \\times (x_2;y_2) = x_1 y_2 - x_2 y_1$, it can be shown (see the explanation below) that\n\n$$s_k = -\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r} = \\left|\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r}\\right|.$$\n\nThe last equation is due to the fact that $r_{k-1}$ and $r_{k-2}$ lie on the different sides of $r$, thus pseudoscalar products of $\\vec r_{k-1}$ and $\\vec r_{k-2}$ with $\\vec r$ have distinct signs. With $a_k = \\lfloor s_k \\rfloor$ in mind, formula for $\\vec r_k$ now looks like\n\n$$\\vec r_k = \\vec r_{k-2} + \\left\\lfloor \\left| \\frac{\\vec r \\times \\vec r_{k-2}}{\\vec r \\times \\vec r_{k-1}}\\right|\\right\\rfloor \\vec r_{k-1}.$$\n\nNote that $\\vec r_k \\times r = (q;p) \\times (1;r) = qr - p$, thus\n\n$$a_k = \\left\\lfloor \\left| \\frac{q_{k-1}r-p_{k-1}}{q_{k-2}r-p_{k-2}} \\right| \\right\\rfloor.$$\n\n??? hint \"Explanation\"\n    As we have already noted, $a_k = \\lfloor s_k \\rfloor$, where $s_k = [a_k; a_{k+1}, a_{k+2}, \\dots]$. On the other hand, from the convergent recurrence we derive that\n\n    $$r = [a_0; a_1, \\dots, a_{k-1}, s_k] = \\frac{s_k p_{k-1} + p_{k-2}}{s_k q_{k-1} + q_{k-2}}.$$\n\n    In vector form, it rewrites as\n\n    $$\\vec r \\parallel s_k \\vec r_{k-1} + \\vec r_{k-2},$$\n\n    meaning that $\\vec r$ and $s_k \\vec r_{k-1} + \\vec r_{k-2}$ are collinear (that is, have the same slope coefficient). Taking the [pseudoscalar product](../geometry/basic-geometry.md) of both parts with $\\vec r$, we get\n\n    $$0 = s_k (\\vec r_{k-1} \\times \\vec r) + (\\vec r_{k-2} \\times \\vec r),$$\n\n    which yields the final formula\n\n    $$s_k = -\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r}.$$\n\n!!! example \"Nose stretching algorithm\"\n    Each time you add $\\vec r_{k-1}$ to the vector $\\vec p$, the value of $\\vec p \\times \\vec r$ is increased by $\\vec r_{k-1} \\times \\vec r$.\n\n    Thus, $a_k=\\lfloor s_k \\rfloor$ is the maximum integer number of $\\vec r_{k-1}$ vectors that can be added to $\\vec r_{k-2}$ without changing the sign of the cross product with $\\vec r$.\n\n    In other words, $a_k$ is the maximum integer number of times you can add $\\vec r_{k-1}$ to $\\vec r_{k-2}$ without crossing the line defined by $\\vec r$:\n\n    <figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/9/92/Continued_convergents_geometry.svg\" width=\"700px\"/>\n    <figcaption>_Convergents of $r=\\frac{7}{9}=[0;1,3,2]$. Semiconvergents correspond to intermediate points between gray arrows._</figcaption></figure>\n\n    On the picture above, $\\vec r_2 = (4;3)$ is obtained by repeatedly adding $\\vec r_1 = (1;1)$ to $\\vec r_0 = (1;0)$.\n\n    When it is not possible to further add $\\vec r_1$ to $\\vec r_0$ without crossing the $y=rx$ line, we go to the other side and repeatedly add $\\vec r_2$ to $\\vec r_1$ to obtain $\\vec r_3 = (9;7)$.\n\n    This procedure generates exponentially longer vectors, that approach the line.\n\n    For this property, the procedure of generating consequent convergent vectors was dubbed the **nose stretching algorithm** by Boris Delaunay.\n\nIf we look on the triangle drawn on points $\\vec r_{k-2}$, $\\vec r_{k}$ and $\\vec 0$ we will notice that its doubled area is\n\n$$|\\vec r_{k-2} \\times \\vec r_k| = |\\vec r_{k-2} \\times (\\vec r_{k-2} + a_k \\vec r_{k-1})| = a_k |\\vec r_{k-2} \\times \\vec r_{k-1}| = a_k.$$\n\nCombined with the [Pick's theorem](../geometry/picks-theorem.md), it means that there are no lattice points strictly inside the triangle and the only lattice points on its border are $\\vec 0$ and $\\vec r_{k-2} + t \\cdot \\vec r_{k-1}$ for all integer $t$ such that $0 \\leq t \\leq a_k$. When joined for all possible $k$ it means that there are no integer points in the space between polygons formed by even-indexed and odd-indexed convergent vectors.\n\nThis, in turn, means that $\\vec r_k$ with odd coefficients form a convex hull of lattice points with $x \\geq 0$ above the line $y=rx$, while $\\vec r_k$ with even coefficients form a convex hull of lattice points with $x > 0$ below the line $y=rx$.\n\n\n!!! info \"Definition\"\n\n    These polygons are also known as **Klein polygons**, named after Felix Klein who first suggested this geometric interpretation to the continued fractions.\n\n## Problem examples\n\nNow that the most important facts and concepts were introduced, it is time to delve into specific problem examples.\n\n!!! example \"Convex hull under the line\"\n    Find the convex hull of lattice points $(x;y)$ such that $0 \\leq x \\leq N$ and $0 \\leq y \\leq rx$ for $r=[a_0;a_1,\\dots,a_k]=\\frac{p_k}{q_k}$.\n\n??? hint \"Solution\"\n    If we were considering the unbounded set $0 \\leq x$, the upper convex hull would be given by the line $y=rx$ itself.\n\n    However, with additional constraint $x \\leq N$ we'd need to eventually deviate from the line to maintain proper convex hull.\n\n    Let $t = \\lfloor \\frac{N}{q_k}\\rfloor$, then first $t$ lattice points on the hull after $(0;0)$ are $\\alpha \\cdot (q_k; p_k)$ for integer $1 \\leq \\alpha \\leq t$.\n\n    However $(t+1)(q_k; p_k)$ can't be next lattice point since $(t+1)q_k$ is greater than $N$.\n\n    To get to the next lattice points in the hull, we should get to the point $(x;y)$ which diverges from $y=rx$ by the smallest margin, while maintaining $x \\leq N$.\n\n    <figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/b/b1/Lattice-hull.svg\" width=\"500px\"/>\n    <figcaption>Convex hull of lattice points under $y=\\frac{4}{7}x$ for $0 \\leq x \\leq 19$ consists of points $(0;0), (7;4), (14;8), (16;9), (18;10), (19;10)$.</figcaption></figure>\n\n    Let $(x; y)$ be the last current point in the convex hull. Then the next point $(x'; y')$ is such that $x' \\leq N$ and $(x'; y') - (x; y) = (\\Delta x; \\Delta y)$ is as close to the line $y=rx$ as possible. In other words, $(\\Delta x; \\Delta y)$ maximizes $r \\Delta x - \\Delta y$ subject to $\\Delta x \\leq N - x$ and $\\Delta y \\leq r \\Delta x$.\n\n    Points like that lie on the convex hull of lattice points below $y=rx$. In other words, $(\\Delta x; \\Delta y)$ must be a lower semiconvergent of $r$.\n\n    That being said, $(\\Delta x; \\Delta y)$ is of form $(q_{i-1}; p_{i-1}) + t \\cdot (q_i; p_i)$ for some odd number $i$ and $0 \\leq t < a_i$.\n\n    To find such $i$, we can traverse all possible $i$ starting from the largest one and use $t = \\lfloor \\frac{N-x-q_{i-1}}{q_i} \\rfloor$ for $i$ such that $N-x-q_{i-1} \\geq 0$.\n\n    With $(\\Delta x; \\Delta y) = (q_{i-1}; p_{i-1}) + t \\cdot (q_i; p_i)$, the condition $\\Delta y \\leq r \\Delta x$ would be preserved by semiconvergent properties.\n\n    And $t < a_i$ would hold because we already exhausted semiconvergents obtained from $i+2$, hence $x + q_{i-1} + a_i q_i = x+q_{i+1}$ is greater than $N$.\n\n    Now that we may add $(\\Delta x; \\Delta y)$, to $(x;y)$ for $k = \\lfloor \\frac{N-x}{\\Delta x} \\rfloor$ times before we exceed $N$, after which we would try the next semiconvergent.\n\n    === \"C++\"\n        ```cpp\n        // returns [ah, ph, qh] such that points r[i]=(ph[i], qh[i]) constitute upper convex hull\n        // of lattice points on 0 <= x <= N and 0 <= y <= r * x, where r = [a0; a1, a2, ...]\n        // and there are ah[i]-1 integer points on the segment between r[i] and r[i+1]\n        auto hull(auto a, int N) {\n            auto [p, q] = convergents(a);\n            int t = N / q.back();\n            vector ah = {t};\n            vector ph = {0, t*p.back()};\n            vector qh = {0, t*q.back()};\n\n            for(int i = q.size() - 1; i >= 0; i--) {\n                if(i % 2) {\n                    while(qh.back() + q[i - 1] <= N) {\n                        t = (N - qh.back() - q[i - 1]) / q[i];\n                        int dp = p[i - 1] + t * p[i];\n                        int dq = q[i - 1] + t * q[i];\n                        int k = (N - qh.back()) / dq;\n                        ah.push_back(k);\n                        ph.push_back(ph.back() + k * dp);\n                        qh.push_back(qh.back() + k * dq);\n                    }\n                }\n            }\n            return make_tuple(ah, ph, qh);\n        }\n        ```\n    === \"Python\"\n        ```py\n        # returns [ah, ph, qh] such that points r[i]=(ph[i], qh[i]) constitute upper convex hull\n        # of lattice points on 0 <= x <= N and 0 <= y <= r * x, where r = [a0; a1, a2, ...]\n        # and there are ah[i]-1 integer points on the segment between r[i] and r[i+1]\n        def hull(a, N):\n            p, q = convergents(a)\n            t = N // q[-1]\n            ah = [t]\n            ph = [0, t*p[-1]]\n            qh = [0, t*q[-1]]\n            for i in reversed(range(len(q))):\n                if i % 2 == 1:\n                    while qh[-1] + q[i-1] <= N:\n                        t = (N - qh[-1] - q[i-1]) // q[i]\n                        dp = p[i-1] + t*p[i]\n                        dq = q[i-1] + t*q[i]\n                        k = (N - qh[-1]) // dq\n                        ah.append(k)\n                        ph.append(ph[-1] + k * dp)\n                        qh.append(qh[-1] + k * dq)\n            return ah, ph, qh\n        ```\n\n!!! example \"[Timus - Crime and Punishment](https://timus.online/problem.aspx?space=1&num=1430)\"\n    You're given integer numbers $A$, $B$ and $N$. Find $x \\geq 0$ and $y \\geq 0$ such that $Ax + By \\leq N$ and $Ax + By$ is the maximum possible.\n\n??? hint \"Solution\"\n    In this problem it holds that $1 \\leq A, B, N \\leq 2 \\cdot 10^9$, so it can be solved in $O(\\sqrt N)$. However, there is $O(\\log N)$ solution with continued fractions.\n\n    For our convenience, we will invert the direction of $x$ by doing a substitution $x \\mapsto \\lfloor \\frac{N}{A}\\rfloor - x$, so that now we need to find the point $(x; y)$ such that $0 \\leq x \\leq \\lfloor \\frac{N}{A} \\rfloor$, $By - Ax \\leq N \\;\\bmod\\; A$ and $By - Ax$ is the maximum possible. Optimal $y$ for each $x$ has a value of $\\lfloor \\frac{Ax + (N \\bmod A)}{B} \\rfloor$.\n\n    To treat it more generically, we will write a function that finds the best point on $0 \\leq x \\leq N$ and $y = \\lfloor \\frac{Ax+B}{C} \\rfloor$.\n\n    Core solution idea in this problem essentially repeats the previous problem, but instead of using lower semiconvergents to diverge from line, you use upper semiconvergents to get closer to the line without crossing it and without violating $x \\leq N$. Unfortunately, unlike the previous problem, you need to make sure that you don't cross the $y=\\frac{Ax+B}{C}$ line while getting closer to it, so you should keep it in mind when calculating semiconvergent's coefficient $t$.\n\n    === \"Python\"\n        ```py\n        # (x, y) such that y = (A*x+B) // C,\n        # Cy - Ax is max and 0 <= x <= N.\n        def closest(A, B, C, N):\n            # y <= (A*x + B)/C <=> diff(x, y) <= B\n            def diff(x, y):\n                return C*y-A*x\n            a = fraction(A, C)\n            p, q = convergents(a)\n            ph = [B // C]\n            qh = [0]\n            for i in range(2, len(q) - 1):\n                if i % 2 == 0:\n                    while diff(qh[-1] + q[i+1], ph[-1] + p[i+1]) <= B:\n                        t = 1 + (diff(qh[-1] + q[i-1], ph[-1] + p[i-1]) - B - 1) // abs(diff(q[i], p[i]))\n                        dp = p[i-1] + t*p[i]\n                        dq = q[i-1] + t*q[i]\n                        k = (N - qh[-1]) // dq\n                        if k == 0:\n                            return qh[-1], ph[-1]\n                        if diff(dq, dp) != 0:\n                            k = min(k, (B - diff(qh[-1], ph[-1])) // diff(dq, dp))\n                        qh.append(qh[-1] + k*dq)\n                        ph.append(ph[-1] + k*dp)\n            return qh[-1], ph[-1]\n\n        def solve(A, B, N):\n            x, y = closest(A, N % A, B, N // A)\n            return N // A - x, y\n        ```\n\n!!! example \"[June Challenge 2017 - Euler Sum](https://www.codechef.com/problems/ES)\"\n    Compute $\\sum\\limits_{x=1}^N \\lfloor ex \\rfloor$, where $e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, \\dots, 1, 2n, 1, \\dots]$ is the Euler's number and $N \\leq 10^{4000}$.\n\n??? hint \"Solution\"\n    This sum is equal to the number of lattice point $(x;y)$ such that $1 \\leq x \\leq N$ and $1 \\leq y \\leq ex$.    \n\n    After constructing the convex hull of the points below $y=ex$, this number can be computed using [Pick's theorem](../geometry/picks-theorem.md):\n\n    === \"C++\"\n        ```cpp\n        // sum floor(k * x) for k in [1, N] and x = [a0; a1, a2, ...]\n        int sum_floor(auto a, int N) {\n            N++;\n            auto [ah, ph, qh] = hull(a, N);\n\n            // The number of lattice points within a vertical right trapezoid\n            // on points (0; 0) - (0; y1) - (dx; y2) - (dx; 0) that has\n            // a+1 integer points on the segment (0; y1) - (dx; y2).\n            auto picks = [](int y1, int y2, int dx, int a) {\n                int b = y1 + y2 + a + dx;\n                int A = (y1 + y2) * dx;\n                return (A - b + 2) / 2 + b - (y2 + 1);\n            };\n\n            int ans = 0;\n            for(size_t i = 1; i < qh.size(); i++) {\n                ans += picks(ph[i - 1], ph[i], qh[i] - qh[i - 1], ah[i - 1]);\n            }\n            return ans - N;\n        }\n        ```\n    === \"Python\"\n        ```py\n        # sum floor(k * x) for k in [1, N] and x = [a0; a1, a2, ...]\n        def sum_floor(a, N):\n            N += 1\n            ah, ph, qh = hull(a, N)\n\n            # The number of lattice points within a vertical right trapezoid\n            # on points (0; 0) - (0; y1) - (dx; y2) - (dx; 0) that has\n            # a+1 integer points on the segment (0; y1) - (dx; y2).\n            def picks(y1, y2, dx, a):\n                b = y1 + y2 + a + dx\n                A = (y1 + y2) * dx\n                return (A - b + 2) // 2 + b - (y2 + 1)\n\n            ans = 0\n            for i in range(1, len(qh)):\n                ans += picks(ph[i-1], ph[i], qh[i]-qh[i-1], ah[i-1])\n            return ans - N\n        ``` \n\n!!! example \"[NAIPC 2019 - It's a Mod, Mod, Mod, Mod World](https://open.kattis.com/problems/itsamodmodmodmodworld)\"\n    Given $p$, $q$ and $n$, compute $\\sum\\limits_{i=1}^n [p \\cdot i \\bmod q]$.\n\n??? hint \"Solution\"\n    This problem reduces to the previous one if you note that $a \\bmod b = a - \\lfloor \\frac{a}{b} \\rfloor b$. With this fact, the sum reduces to\n\n    $$\\sum\\limits_{i=1}^n \\left(p \\cdot i - \\left\\lfloor \\frac{p \\cdot i}{q} \\right\\rfloor q\\right) = \\frac{pn(n+1)}{2}-q\\sum\\limits_{i=1}^n \\left\\lfloor \\frac{p \\cdot i}{q}\\right\\rfloor.$$\n\n    However, summing up $\\lfloor rx \\rfloor$ for $x$ from $1$ to $N$ is something that we're capable of from the previous problem.\n\n    === \"C++\"\n        ```cpp\n        void solve(int p, int q, int N) {\n            cout << p * N * (N + 1) / 2 - q * sum_floor(fraction(p, q), N) << \"\\n\";\n        }\n        ```\n    === \"Python\"\n        ```py\n        def solve(p, q, N):\n            return p * N * (N + 1) // 2 - q * sum_floor(fraction(p, q), N)\n        ``` \n\n!!! example \"[Library Checker - Sum of Floor of Linear](https://judge.yosupo.jp/problem/sum_of_floor_of_linear)\"\n    Given $N$, $M$, $A$ and $B$, compute $\\sum\\limits_{i=0}^{N-1} \\lfloor \\frac{A \\cdot i + B}{M} \\rfloor$.\n\n??? hint \"Solution\"\n    This is the most technically troublesome problem so far.\n\n    It is possible to use the same approach and construct the full convex hull of points below the line $y = \\frac{Ax+B}{M}$.\n\n    We already know how to solve it for $B = 0$. Moreover, we already know how to construct this convex hull up to the closest lattice point to this line on $[0, N-1]$ segment (this is done in the \"Crime and Punishment\" problem above.\n\n    Now we should note that once we reached the closest point to the line, we can just assume that the line in fact passes through the closest point, as there are no other lattice points on $[0, N-1]$ in between the actual line and the line moved slightly below to pass through the closest point.\n\n    That being said, to construct the full convex hull below the line $y=\\frac{Ax+B}{M}$ on $[0, N-1]$, we can construct it up to the closest point to the line on $[0, N-1]$ and then continue as if the line passes through this point, reusing algorithm for constructing convex hull with $B=0$:\n\n    === \"Python\"\n        ```py\n        # hull of lattice (x, y) such that C*y <= A*x+B\n        def hull(A, B, C, N):\n            def diff(x, y):\n                return C*y-A*x\n            a = fraction(A, C)\n            p, q = convergents(a)\n            ah = []\n            ph = [B // C]\n            qh = [0]\n\n            def insert(dq, dp):\n                k = (N - qh[-1]) // dq\n                if diff(dq, dp) > 0:\n                    k = min(k, (B - diff(qh[-1], ph[-1])) // diff(dq, dp))\n                ah.append(k)\n                qh.append(qh[-1] + k*dq)\n                ph.append(ph[-1] + k*dp)\n\n            for i in range(1, len(q) - 1):\n                if i % 2 == 0:\n                    while diff(qh[-1] + q[i+1], ph[-1] + p[i+1]) <= B:\n                        t = (B - diff(qh[-1] + q[i+1], ph[-1] + p[i+1])) // abs(diff(q[i], p[i]))\n                        dp = p[i+1] - t*p[i]\n                        dq = q[i+1] - t*q[i]\n                        if dq < 0 or qh[-1] + dq > N:\n                            break\n                        insert(dq, dp)\n\n            insert(q[-1], p[-1])\n\n            for i in reversed(range(len(q))):\n                if i % 2 == 1:\n                    while qh[-1] + q[i-1] <= N:\n                        t = (N - qh[-1] - q[i-1]) // q[i]\n                        dp = p[i-1] + t*p[i]\n                        dq = q[i-1] + t*q[i]\n                        insert(dq, dp)\n            return ah, ph, qh\n        ```\n\n!!! example \"[OKC 2 - From Modular to Rational](https://codeforces.com/gym/102354/problem/I)\"\n    There is a rational number $\\frac{p}{q}$ such that $1 \\leq p, q \\leq 10^9$. You may ask the value of $p q^{-1}$ modulo $m \\sim 10^9$ for several prime numbers $m$. Recover $\\frac{p}{q}$.\n\n    _Equivalent formulation:_ Find $x$ that delivers the minimum of $Ax \\;\\bmod\\; M$ for $1 \\leq x \\leq N$.\n\n??? hint \"Solution\"\n    Due to Chinese remainder theorem, asking the result modulo several prime numbers is the same as asking it modulo their product. Due to this, without loss of generality we'll assume that we know the remainder modulo sufficiently large number $m$.\n\n    There could be several possible solutions $(p, q)$ to $p \\equiv qr \\pmod m$ for a given remainder $r$. However, if $(p_1, q_1)$ and $(p_2, q_2)$ are both the solutions then it also holds that $p_1 q_2 \\equiv p_2 q_1 \\pmod m$. Assuming that $\\frac{p_1}{q_1} \\neq \\frac{p_2}{q_2}$ it means that $|p_1 q_2 - p_2 q_1|$ is at least $m$.\n\n    In the statement we were told that $1 \\leq p, q \\leq 10^9$, so if both $p_1, q_1$ and $p_2, q_2$ are at most $10^9$, then the difference is at most $10^{18}$. For $m > 10^{18}$ it means that the solution $\\frac{p}{q}$ with $1 \\leq p, q \\leq 10^9$ is unique, as a rational number.\n\n    So, the problem boils down, given $r$ modulo $m$, to finding any $q$ such that $1 \\leq q \\leq 10^9$ and $qr \\;\\bmod\\; m \\leq 10^9$.\n\n    This is effectively the same as finding $q$ that delivers the minimum possible $qr \\bmod m$ for $1 \\leq q \\leq 10^9$.\n\n    For $qr = km + b$ it means that we need to find a pair $(q, m)$ such that $1 \\leq q \\leq 10^9$ and $qr - km \\geq 0$ is the minimum possible.\n\n    Since $m$ is constant, we can divide by it and further restate it as find $q$ such that $1 \\leq q \\leq 10^9$ and $\\frac{r}{m} q - k \\geq 0$ is the minimum possible.\n\n    In terms of continued fractions it means that $\\frac{k}{q}$ is the best diophantine approximation to $\\frac{r}{m}$ and it is sufficient to only check lower semiconvergents of $\\frac{r}{m}$.\n\n    === \"Python\"\n        ```py\n        # find Q that minimizes Q*r mod m for 1 <= k <= n < m \n        def mod_min(r, n, m):\n            a = fraction(r, m)\n            p, q = convergents(a)\n            for i in range(2, len(q)):\n                if i % 2 == 1 and (i + 1 == len(q) or q[i+1] > n):\n                    t = (n - q[i-1]) // q[i]\n                    return q[i-1] + t*q[i]\n        ```\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n<!--?title Continued fractions -->\n# Continued fractions\n\n**Continued fraction** is a representation of a real number as a specific convergent sequence of rational numbers. They are useful in competitive programming because they are easy to compute and can be efficiently used to find the best possible rational approximation of the underlying real number (among all numbers whose denominator doesn't exceed a given value).\n\nBesides that, continued fractions are closely related to Euclidean algorithm which makes them useful in a bunch of number-theoretical problems.\n\n## Continued fraction representation\n\n!!! info \"Definition\"\n    Let $a_0, a_1, \\dots, a_k \\in \\mathbb Z$ and $a_1, a_2, \\dots, a_k \\geq 1$. Then the expression\n\n    $$r=a_0 + \\frac{1}{a_1 + \\frac{1}{\\dots + \\frac{1}{a_k}}},$$\n\n    is called the **continued fraction representation** of the rational number $r$ and is denoted shortly as $r=[a_0;a_1,a_2,\\dots,a_k]$.\n\n??? example\n    Let $r = \\frac{5}{3}$. There are two ways to represent it as a continued fraction:\n\n    $$\n    \\begin{align}\n    r = [1;1,1,1] &= 1+\\frac{1}{1+\\frac{1}{1+\\frac{1}{1}}},\\\\\n    r = [1;1,2] &= 1+\\frac{1}{1+\\frac{1}{2}}.\n    \\end{align}\n    $$\n\nIt can be proven that any rational number can be represented as a continued fraction in exactly $2$ ways:\n\n$$r = [a_0;a_1,\\dots,a_k,1] = [a_0;a_1,\\dots,a_k+1].$$\n\nMoreover, the length $k$ of such continued fraction is estimated as $k = O(\\log \\min(p, q))$ for $r=\\frac{p}{q}$.\n\nThe reasoning behind this will be clear once we delve into the details of the continued fraction construction.\n\n!!! info \"Definition\"\n    Let $a_0,a_1,a_2, \\dots$ be an integer sequence such that $a_1, a_2, \\dots \\geq 1$. Let $r_k = [a_0; a_1, \\dots, a_k]$. Then the expression\n\n    $$r = a_0 + \\frac{1}{a_1 + \\frac{1}{a_2+\\dots}} = \\lim\\limits_{k \\to \\infty} r_k.$$\n\n    is called the **continued fraction representation** of the irrational number $r$ and is denoted shortly as $r = [a_0;a_1,a_2,\\dots]$.\n\nNote that for $r=[a_0;a_1,\\dots]$ and integer $k$, it holds that $r+k = [a_0+k; a_1, \\dots]$.\n\nAnother important observation is that $\\frac{1}{r}=[0;a_0, a_1, \\dots]$ when $a_0 > 0$ and $\\frac{1}{r} = [a_1; a_2, \\dots]$ when $a_0 = 0$.\n\n!!! info \"Definition\"\n    In the definition above, rational numbers $r_0, r_1, r_2, \\dots$ are called the **convergents** of $r$.\n\n    Correspondingly, individual $r_k = [a_0; a_1, \\dots, a_k] = \\frac{p_k}{q_k}$ is called the $k$-th **convergent** of $r$.\n\n??? example\n    Consider $r = [1; 1, 1, 1, \\dots]$. It can be proven by induction that $r_k = \\frac{F_{k+2}}{F_{k+1}}$, where $F_k$ is the Fibonacci sequence defined as $F_0 = 0$, $F_1 = 1$ and $F_{k} = F_{k-1} + F_{k-2}$. From the Binet's formula, it is known that\n\n    $$r_k = \\frac{\\phi^{k+2} - \\psi^{k+2}}{\\phi^{k+1} - \\psi^{k+1}},$$\n\n    where $\\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618$ is the golden ratio and $\\psi = \\frac{1-\\sqrt{5}}{2} = -\\frac{1}{\\phi} \\approx -0.618$. Thus,\n\n    $$r = 1+\\frac{1}{1+\\frac{1}{1+\\dots}}=\\lim\\limits_{k \\to \\infty} r_k = \\phi = \\frac{1+\\sqrt{5}}{2}.$$\n\n    Note that in this specific case, an alternative way to find $r$ would be to solve the equation\n\n    $$r = 1+\\frac{1}{r} \\implies r^2 = r + 1. $$\n\n\n!!! info \"Definition\"\n    Let $r_k = [a_0; a_1, \\dots, a_{k-1}, a_k]$. The numbers $[a_0; a_1, \\dots, a_{k-1}, t]$ for $1 \\leq t \\leq a_k$ are called **semiconvergents**.\n\n    We will typically refer to (semi)convergents that are greater than $r$ as **upper** (semi)convergents and to those that are less than $r$ as **lower** (semi)convergents.\n\n!!! info \"Definition\"\n    Complementary to convergents, we define the **[complete quotients](https://en.wikipedia.org/wiki/Complete_quotient)** as $s_k = [a_k; a_{k+1}, a_{k+2}, \\dots]$.\n\n    Correspondingly, we will call an individual $s_k$ the $k$-th complete quotient of $r$.\n\nFrom the definitions above, one can conclude that $s_k \\geq 1$ for $k \\geq 1$.\n\nTreating $[a_0; a_1, \\dots, a_k]$ as a formal algebraic expression and allowing arbitrary real numbers instead of $a_i$, we obtain\n\n$$r = [a_0; a_1, \\dots, a_{k-1}, s_k].$$\n\nIn particular, $r = [s_0] = s_0$. On the other hand, we can express $s_k$ as\n\n$$s_k = [a_k; s_{k+1}] = a_k + \\frac{1}{s_{k+1}},$$\n\nmeaning that we can compute $a_k = \\lfloor s_k \\rfloor$ and $s_{k+1} = (s_k - a_k)^{-1}$ from $s_k$.\n\nThe sequence $a_0, a_1, \\dots$ is well-defined unless $s_k=a_k$ which only happens when $r$ is a rational number.\n\nThus the continued fraction representation is uniquely defined for any irrational number $r$.\n\n### Implementation\n\nIn the code snippets we will mostly assume finite continued fractions.\n\nFrom $s_k$, the transition to $s_{k+1}$ looks like\n\n$$s_k =\\left\\lfloor s_k \\right\\rfloor + \\frac{1}{s_{k+1}}.$$\n\nFrom this expression, the next complete quotient $s_{k+1}$ is obtained as\n\n$$s_{k+1} = \\left(s_k-\\left\\lfloor s_k\\right\\rfloor\\right)^{-1}.$$\n\nFor $s_k=\\frac{p}{q}$ it means that\n\n$$\ns_{k+1} = \\left(\\frac{p}{q}-\\left\\lfloor \\frac{p}{q} \\right\\rfloor\\right)^{-1} = \\frac{q}{p-q\\cdot \\lfloor \\frac{p}{q} \\rfloor} = \\frac{q}{p \\bmod q}.\n$$\n\nThus, the computation of a continued fraction representation for $r=\\frac{p}{q}$ follows the steps of the Euclidean algorithm for $p$ and $q$.\n\nFrom this also follows that $\\gcd(p_k, q_k) = 1$ for $\\frac{p_k}{q_k} = [a_0; a_1, \\dots, a_k]$. Hence, convergents are always irreducible.\n\n=== \"C++\"\n    ```cpp\n    auto fraction(int p, int q) {\n        vector<int> a;\n        while(q) {\n            a.push_back(p / q);\n            tie(p, q) = make_pair(q, p % q);\n        }\n        return a;\n    }\n    ```\n=== \"Python\"\n    ```py\n    def fraction(p, q):\n        a = []\n        while q:\n            a.append(p // q)\n            p, q = q, p % q\n        return a\n    ```\n\n## Key results\n\nTo provide some motivation for further study of continued fraction, we give some key facts now.\n\n??? note \"Recurrence\"\n    For the convergents $r_k = \\frac{p_k}{q_k}$, the following recurrence stands, allowing their fast computation:\n    \n    $$\\frac{p_k}{q_k}=\\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}},$$\n    \n    where $\\frac{p_{-1}}{q_{-1}}=\\frac{1}{0}$ and $\\frac{p_{-2}}{q_{-2}}=\\frac{0}{1}$.\n\n??? note \"Deviations\"\n    The deviation of $r_k = \\frac{p_k}{q_k}$ from $r$ can be generally estimated as\n    \n    $$\\left|\\frac{p_k}{q_k}-r\\right| \\leq \\frac{1}{q_k q_{k+1}} \\leq \\frac{1}{q_k^2}.$$\n    \n    Multiplying both sides with $q_k$, we obtain alternate estimation:\n    \n    $$|p_k - q_k r| \\leq \\frac{1}{q_{k+1}}.$$\n\n    From the recurrence above it follows that $q_k$ grows at least as fast as Fibonacci numbers.\n\n    On the picture below you may see the visualization of how convergents $r_k$ approach $r=\\frac{1+\\sqrt 5}{2}$:\n\n    ![](https://upload.wikimedia.org/wikipedia/commons/b/b4/Golden_ration_convergents.svg)\n\n    $r=\\frac{1+\\sqrt 5}{2}$ is depicted by blue dotted line. Odd convergents approach it from above and even convergents approach it from below.\n\n??? note \"Lattice hulls\"\n    Consider convex hulls of points above and below the line $y=rx$.\n    \n    Odd convergents $(q_k;p_k)$ are the vertices of the upper hull, while the even convergents $(q_k;p_k)$ are the vertices of the bottom hull.\n    \n    All integers vertices on the hulls are obtained as $(q;p)$ such that\n    \n    $$\\frac{p}{q} = \\frac{tp_{k-1} + p_{k-2}}{tq_{k-1} + q_{k-2}}$$\n    \n    for integer $0 \\leq t \\leq a_k$. In other words, the set of lattice points on the hulls corresponds to the set of semiconvergents.\n\n    On the picture below, you may see the convergents and semiconvergents (intermediate gray points) of $r=\\frac{9}{7}$.\n\n    ![](https://upload.wikimedia.org/wikipedia/commons/9/92/Continued_convergents_geometry.svg)\n\n??? note \"Best approximations\"\n    Let $\\frac{p}{q}$ be the fraction to minimize $\\left|r-\\frac{p}{q}\\right|$ subject to $q \\leq x$ for some $x$.\n    \n    Then $\\frac{p}{q}$ is a semiconvergent of $r$.\n\nThe last fact allows to find the best rational approximations of $r$ by checking its semiconvergents.\n\nBelow you will find the further explanation and a bit of intuition and interpretation for these facts.\n\n## Convergents\n\nLet's take a closer look at the convergents that were defined earlier. For $r=[a_0, a_1, a_2, \\dots]$, its convergents are\n\n\\begin{gather}\nr_0=[a_0],\\\\r_1=[a_0, a_1],\\\\ \\dots,\\\\ r_k=[a_0, a_1, \\dots, a_k].\n\\end{gather}\n\nConvergents are the core concept of continued fractions, so it is important to study their properties.\n\nFor the number $r$, its $k$-th convergent $r_k = \\frac{p_k}{q_k}$ can be computed as\n\n$$r_k = \\frac{P_k(a_0,a_1,\\dots,a_k)}{P_{k-1}(a_1,\\dots,a_k)} = \\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}},$$\n\nwhere $P_k(a_0,\\dots,a_k)$ is [the continuant](https://en.wikipedia.org/wiki/Continuant_(mathematics)), a multivariate polynomial defined as\n\n$$P_k(x_0,x_1,\\dots,x_k) = \\det \\begin{bmatrix}\nx_k & 1 & 0 & \\dots & 0 \\\\\n-1 & x_{k-1} & 1 & \\dots & 0 \\\\\n0 & -1 & x_2 & . & \\vdots \\\\\n\\vdots & \\vdots & . & \\ddots & 1 \\\\\n0 & 0 & \\dots & -1 & x_0\n\\end{bmatrix}_{\\textstyle .}$$\n\nThus, $r_k$ is a weighted [mediant](https://en.wikipedia.org/wiki/Mediant_(mathematics)) of $r_{k-1}$ and $r_{k-2}$.\n\nFor consistency, two additional convergents $r_{-1} = \\frac{1}{0}$ and $r_{-2} = \\frac{0}{1}$ are defined.\n\n??? hint \"Detailed explanation\"\n\n    The numerator and the denominator of $r_k$ can be seen as multivariate polynomials of $a_0, a_1, \\dots, a_k$:\n\n    $$r_k = \\frac{P_k(a_0, a_1, \\dots, a_k)}{Q_k(a_0,a_1, \\dots, a_k)}.$$\n\n    From the definition of convergents,\n\n    $$r_k = a_0 + \\frac{1}{[a_1;a_2,\\dots, a_k]}= a_0 + \\frac{Q_{k-1}(a_1, \\dots, a_k)}{P_{k-1}(a_1, \\dots, a_k)} = \\frac{a_0 P_{k-1}(a_1, \\dots, a_k) + Q_{k-1}(a_1, \\dots, a_k)}{P_{k-1}(a_1, \\dots, a_k)}.$$\n\n    From this follows $Q_k(a_0, \\dots, a_k) = P_{k-1}(a_1, \\dots, a_k)$. This yields the relation\n\n    $$P_k(a_0, \\dots, a_k) = a_0 P_{k-1}(a_1, \\dots, a_k) + P_{k-2}(a_2, \\dots, a_k).$$\n\n    Initially, $r_0 = \\frac{a_0}{1}$ and $r_1 = \\frac{a_0 a_1 + 1}{a_1}$, thus\n\n    $$\\begin{align}P_0(a_0)&=a_0,\\\\ P_1(a_0, a_1) &= a_0 a_1 + 1.\\end{align}$$\n\n    For consistency, it is convenient to define $P_{-1} = 1$ and $P_{-2}=0$ and formally say that $r_{-1} = \\frac{1}{0}$ and $r_{-2}=\\frac{0}{1}$.\n\n    From numerical analysis, it is known that the determinant of an arbitrary tridiagonal matrix\n\n    $$T_k = \\det \\begin{bmatrix}\n    a_0 & b_0 & 0 & \\dots & 0 \\\\\n    c_0 & a_1 & b_1 & \\dots & 0 \\\\\n    0 & c_1 & a_2 & . & \\vdots \\\\\n    \\vdots & \\vdots & . & \\ddots & c_{k-1} \\\\\n    0 & 0 & \\dots & b_{k-1} & a_k\n    \\end{bmatrix}$$\n\n    can be computed recursively as $T_k = a_k T_{k-1} - b_{k-1} c_{k-1} T_{k-2}$. Comparing it to $P_k$, we get a direct expression\n\n    $$P_k = \\det \\begin{bmatrix}\n    x_k & 1 & 0 & \\dots & 0 \\\\\n    -1 & x_{k-1} & 1 & \\dots & 0 \\\\\n    0 & -1 & x_2 & . & \\vdots \\\\\n    \\vdots & \\vdots & . & \\ddots & 1 \\\\\n    0 & 0 & \\dots & -1 & x_0\n    \\end{bmatrix}_{\\textstyle .}$$\n\n    This polynomial is also known as [the continuant](https://en.wikipedia.org/wiki/Continuant_(mathematics)) due to its close relation with continued fraction. The continuant won't change if the sequence on the main diagonal is reversed. This yields an alternative formula to compute it:\n\n    $$P_k(a_0, \\dots, a_k) = a_k P_{k-1}(a_0, \\dots, a_{k-1}) + P_{k-2}(a_0, \\dots, a_{k-2}).$$\n\n### Implementation\n\nWe will compute the convergents as a pair of sequences $p_{-2}, p_{-1}, p_0, p_1, \\dots, p_k$ and $q_{-2}, q_{-1}, q_0, q_1, \\dots, q_k$:\n\n=== \"C++\"\n    ```cpp\n    auto convergents(vector<int> a) {\n        vector<int> p = {0, 1};\n        vector<int> q = {1, 0};\n        for(auto it: a) {\n            p.push_back(p[p.size() - 1] * it + p[p.size() - 2]);\n            q.push_back(q[q.size() - 1] * it + q[q.size() - 2]);\n        }\n        return make_pair(p, q);\n    }\n    ```\n=== \"Python\"\n    ```py\n    def convergents(a):\n        p = [0, 1]\n        q = [1, 0]\n        for it in a:\n            p.append(p[-1]*it + p[-2])\n            q.append(q[-1]*it + q[-2])\n        return p, q\n    ```\n\n## Trees of continued fractions\n\nThere are two major ways to unite all possible continued fractions into useful tree structures.\n\n### Stern-Brocot tree\n\n[The Stern-Brocot tree](../others/stern_brocot_tree_farey_sequences.md) is a binary search tree that contains all distinct positive rational numbers.\n\nThe tree generally looks as follows:\n\n<figure>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/3/37/SternBrocotTree.svg\">\n<figcaption>\n<a href=\"https://commons.wikimedia.org/wiki/File:SternBrocotTree.svg\">The image</a> by <a href=\"https://commons.wikimedia.org/wiki/User:Aaron_Rotenberg\">Aaron Rotenberg</a> is licensed under <a href=\"https://creativecommons.org/licenses/by-sa/3.0/deed.en\">CC BY-SA 3.0</a>\n</figcaption>\n</figure>\n\nFractions $\\frac{0}{1}$ and $\\frac{1}{0}$ are \"virtually\" kept on the left and right sides of the tree correspondingly.\n\nThen the fraction in a node is a mediant $\\frac{a+c}{b+d}$ of two fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ above it.\n\nThe recurrence $\\frac{p_k}{q_k}=\\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}}$ means that the continued fraction representation encodes the path to $\\frac{p_k}{q_k}$ in the tree. To find $[a_0; a_1, \\dots, a_{k}, 1]$, one has to make $a_0$ moves to the right, $a_1$ moves to the left, $a_2$ moves to the right and so on up to $a_k$.\n\nThe parent of $[a_0; a_1, \\dots, a_k,1]$ then is the fraction obtained by taking one step back in the last used direction.\n\nIn other words, it is $[a_0; a_1, \\dots, a_k-1,1]$ when $a_k > 1$ and $[a_0; a_1, \\dots, a_{k-1}, 1]$ when $a_k = 1$.\n\nThus the children of $[a_0; a_1, \\dots, a_k, 1]$ are $[a_0; a_1, \\dots, a_k+1, 1]$ and $[a_0; a_1, \\dots, a_k, 1, 1]$.\n\nLet's index the Stern-Brocot tree. The root vertex is assigned an index $1$. Then for a vertex $v$, the index of its left child is assigned by changing the leading bit of $v$ from $1$ to $10$ and for the right child, it's assigned by changing the leading bit from $1$ to $11$:\n\n<figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/1/18/Stern-brocot-index.svg\" width=\"500px\"/></figure>\n\nIn this indexing, the continued fraction representation of a rational number specifies the [run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding) of its binary index.\n\nFor $\\frac{5}{2} = [2;2] = [2;1,1]$, its index is $1011_2$ and its run-length encoding, considering bits in the ascending order, is $[2;1,1]$.\n\nAnother example is $\\frac{2}{5} = [0;2,2]=[0;2,1,1]$, which has index $1100_2$ and its run-length encoding is, indeed, $[0;2,2]$.\n\nIt is worth noting that the Stern-Brocot tree is, in fact, a [treap](../data_structures/treap.md). That is, it is a binary search tree by $\\frac{p}{q}$, but it is a heap by both $p$ and $q$.\n\n!!! example \"Comparing continued fractions\"\n    You're given $A=[a_0; a_1, \\dots, a_n]$ and $B=[b_0; b_1, \\dots, b_m]$. Which fraction is smaller?\n??? hint \"Solution\"\n    Assume for now that $A$ and $B$ are irrational and their continued fraction representations denote an infinite descent in the Stern-Brocot tree.\n\n    As we already mentioned, in this representation $a_0$ denotes the number of right turns in the descent, $a_1$ denotes the number of consequent left turns and so on. Therefore, when we compare $a_k$ and $b_k$, if $a_k = b_k$ we should just move on to comparing $a_{k+1}$ and $b_{k+1}$. Otherwise, if we're at right descents, we should check if $a_k < b_k$ and if we're at left descents, we should check if $a_k > b_k$ to tell whether $A < B$.\n\n    In other words, for irrational $A$ and $B$ it would be $A < B$ if and only if $(a_0, -a_1, a_2, -a_3, \\dots) < (b_0, -b_1, b_2, -b_3, \\dots)$ with lexicographical comparison.\n\n    Now, formally using $\\infty$ as an element of continued fraction representation it is possible to emulate irrational numbers $A-\\varepsilon$ and $A+\\varepsilon$, that is, elements that are smaller (greater) than $A$, but greater (smaller) than any other real number. Specifically, for $A=[a_0; a_1, \\dots, a_n]$, one of these two elements can be emulated as $[a_0; a_1, \\dots, a_n, \\infty]$ and the other can be emulated as $[a_0; a_1, \\dots, a_n - 1, 1, \\infty]$.\n\n    Which one corresponds to $A-\\varepsilon$ and which one to $A+\\varepsilon$ can be determined by the parity of $n$ or by comparing them as irrational numbers.\n\n    === \"Python\"\n        ```py\n        # check if a < b assuming that a[-1] = b[-1] = infty and a != b\n        def less(a, b):\n            a = [(-1)**i*a[i] for i in range(len(a))]\n            b = [(-1)**i*b[i] for i in range(len(b))]\n            return a < b\n\n        # [a0; a1, ..., ak] -> [a0, a1, ..., ak-1, 1]\n        def expand(a):\n            if a: # empty a = inf\n                a[-1] -= 1\n                a.append(1)\n            return a\n\n        # return a-eps, a+eps\n        def pm_eps(a):\n            b = expand(a.copy())\n            a.append(float('inf'))\n            b.append(float('inf'))\n            return (a, b) if less(a, b) else (b, a)\n        ```\n\n!!! example \"Best inner point\"\n    You're given $\\frac{0}{1} \\leq \\frac{p_0}{q_0} < \\frac{p_1}{q_1} \\leq \\frac{1}{0}$. Find the rational number $\\frac{p}{q}$ such that $(q; p)$ is lexicographically smallest and $\\frac{p_0}{q_0} < \\frac{p}{q} < \\frac{p_1}{q_1}$.\n\n??? hint \"Solution\"\n    In terms of the Stern-Brocot tree it means that we need to find the LCA of $\\frac{p_0}{q_0}$ and $\\frac{p_1}{q_1}$. Due to the connection between Stern-Brocot tree and continued fraction, this LCA would roughly correspond to the largest common prefix of continued fraction representations for $\\frac{p_0}{q_0}$ and $\\frac{p_1}{q_1}$.\n\n    So, if $\\frac{p_0}{q_0} = [a_0; a_1, \\dots, a_{k-1}, a_k, \\dots]$ and $\\frac{p_1}{q_1} = [a_0; a_1, \\dots, a_{k-1}, b_k, \\dots]$ are irrational numbers, the LCA is $[a_0; a_1, \\dots, \\min(a_k, b_k)+1]$.\n\n    For rational $r_0$ and $r_1$, one of them could be the LCA itself which would require us to casework it. To simplify the solution for rational $r_0$ and $r_1$, it is possible to use continued fraction representation of $r_0 + \\varepsilon$ and $r_1 - \\varepsilon$ which was derived in the previous problem.\n\n    === \"Python\"\n        ```py\n        # finds lexicographically smallest (q, p)\n        # such that p0/q0 < p/q < p1/q1\n        def middle(p0, q0, p1, q1):\n            a0 = pm_eps(fraction(p0, q0))[1]\n            a1 = pm_eps(fraction(p1, q1))[0]\n            a = []\n            for i in range(min(len(a0), len(a1))):\n                a.append(min(a0[i], a1[i]))\n                if a0[i] != a1[i]:\n                    break\n            a[-1] += 1\n            p, q = convergents(a)\n            return p[-1], q[-1]\n        ```\n\n!!! example \"[GCJ 2019, Round 2 - New Elements: Part 2](https://codingcompetitions.withgoogle.com/codejam/round/0000000000051679/0000000000146184)\"\n    You're given $N$ positive integer pairs $(C_i, J_i)$. You need to find a positive integer pair $(x, y)$ such that $C_i x + J_i y$ is a strictly increasing sequence.\n\n    Among such pairs, find the lexicographically minimum one.\n??? hint \"Solution\"\n    Rephrasing the statement, $A_i x + B_i y$ must be positive for all $i$, where $A_i = C_i - C_{i-1}$ and $B_i = J_i - J_{i-1}$.\n\n    Among such equations we have four significant groups for $A_i x + B_i y > 0$:\n\n    1. $A_i, B_i > 0$ can be ignored since we're looking for $x, y > 0$.\n    2. $A_i, B_i \\leq 0$ would provide \"IMPOSSIBLE\" as an answer.\n    3. $A_i > 0$, $B_i \\leq 0$. Such constraints are equivalent to $\\frac{y}{x} < \\frac{A_i}{-B_i}$.\n    4. $A_i \\leq 0$, $B_i > 0$. Such constraints are equivalent to $\\frac{y}{x} > \\frac{-A_i}{B_i}$.\n\n    Let $\\frac{p_0}{q_0}$ be the largest $\\frac{-A_i}{B_i}$ from the fourth group and $\\frac{p_1}{q_1}$ be the smallest $\\frac{A_i}{-B_i}$ from the third group.\n\n    The problem is now, given $\\frac{p_0}{q_0} < \\frac{p_1}{q_1}$, find a fraction $\\frac{p}{q}$ such that $(q;p)$ is lexicographically smallest and $\\frac{p_0}{q_0} < \\frac{p}{q} < \\frac{p_1}{q_1}$.\n    === \"Python\"\n        ```py\n            def solve():\n            n = int(input())\n            C = [0] * n\n            J = [0] * n\n            # p0/q0 < y/x < p1/q1\n            p0, q0 = 0, 1\n            p1, q1 = 1, 0\n            fail = False\n            for i in range(n):\n                C[i], J[i] = map(int, input().split())\n                if i > 0:\n                    A = C[i] - C[i-1]\n                    B = J[i] - J[i-1]\n                    if A <= 0 and B <= 0:\n                        fail = True\n                    elif B > 0 and A < 0: # y/x > (-A)/B if B > 0\n                        if (-A)*q0 > p0*B:\n                            p0, q0 = -A, B\n                    elif B < 0 and A > 0: # y/x < A/(-B) if B < 0\n                        if A*q1 < p1*(-B):\n                            p1, q1 = A, -B\n            if p0*q1 >= p1*q0 or fail:\n                return 'IMPOSSIBLE'\n\n            p, q = middle(p0, q0, p1, q1)\n            return str(q) + ' ' + str(p)\n        ```\n\n### Calkin-Wilf tree\n\nA somewhat simpler way to organize continued fractions in a binary tree is the [Calkin-Wilf tree](https://en.wikipedia.org/wiki/Calkin\u2013Wilf_tree).\n\nThe tree generally looks like this:\n\n<figure>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/82/Calkin\u2013Wilf_tree.svg\" width=\"500px\"/>\n<figcaption><a href=\"https://commons.wikimedia.org/wiki/File:Calkin\u2013Wilf_tree.svg\">The image</a> by <a href=\"https://commons.wikimedia.org/wiki/User:Olli_Niemitalo\">Olli Niemitalo</a>, <a href=\"https://commons.wikimedia.org/wiki/User:Proz\">Proz</a> is licensed under <a href=\"https://creativecommons.org/publicdomain/zero/1.0/deed.en\">CC0 1.0</a></figcaption>\n</figure>\n\nIn the root of the tree, the number $\\frac{1}{1}$ is located. Then, for the vertex with a number $\\frac{p}{q}$, its children are $\\frac{p}{p+q}$ and $\\frac{p+q}{q}$.\n\nUnlike the Stern-Brocot tree, the Calkin-Wilf tree is not a binary _search_ tree, so it can't be used to perform rational binary search.\n\nIn the Calkin-Wilf tree, the direct parent of a fraction $\\frac{p}{q}$ is $\\frac{p-q}{q}$ when $p>q$ and $\\frac{p}{q-p}$ otherwise.\n\nFor the Stern-Brocot tree, we used the recurrence for convergents. To draw the connection between the continued fraction and the Calkin-Wilf tree, we should recall the recurrence for complete quotients. If $s_k = \\frac{p}{q}$, then $s_{k+1} = \\frac{q}{p \\mod q} = \\frac{q}{p-\\lfloor p/q \\rfloor \\cdot q}$.\n\nOn the other hand, if we repeatedly go from $s_k = \\frac{p}{q}$ to its parent in the Calkin-Wilf tree when $p > q$, we will end up in $\\frac{p \\mod q}{q} = \\frac{1}{s_{k+1}}$. If we continue doing so, we will end up in $s_{k+2}$, then $\\frac{1}{s_{k+3}}$ and so on. From this we can deduce that:\n\n1. When $a_0> 0$, the direct parent of $[a_0; a_1, \\dots, a_k]$ in the Calkin-Wilf tree is $\\frac{p-q}{q}=[a_0 - 1; a_1, \\dots, a_k]$.\n2. When $a_0 = 0$ and $a_1 > 1$, its direct parent is $\\frac{p}{q-p} = [0; a_1 - 1, a_2, \\dots, a_k]$.\n3. And when $a_0 = 0$ and $a_1 = 1$, its direct parent is $\\frac{p}{q-p} = [a_2; a_3, \\dots, a_k]$.\n\nCorrespondingly, children of $\\frac{p}{q} = [a_0; a_1, \\dots, a_k]$ are\n\n1. $\\frac{p+q}{q}=1+\\frac{p}{q}$, which is $[a_0+1; a_1, \\dots, a_k]$,\n2. $\\frac{p}{p+q} = \\frac{1}{1+\\frac{q}{p}}$, which is $[0, 1, a_0, a_1, \\dots, a_k]$ for $a_0 > 0$ and $[0, a_1+1, a_2, \\dots, a_k]$ for $a_0=0$.\n\nNoteworthy, if we enumerate vertices of the Calkin-Wilf tree in the breadth-first search order (that is, the root has a number $1$, and the children of the vertex $v$ have indices $2v$ and $2v+1$ correspondingly), the index of the rational number in the Calkin-Wilf tree would be the same as in the Stern-Brocot tree.\n\nThus, numbers on the same levels of the Stern-Brocot tree and the Calkin-Wilf tree are the same, but their ordering differs through the [bit-reversal permutation](https://en.wikipedia.org/wiki/Bit-reversal_permutation).\n## Convergence\n\nFor the number $r$ and its $k$-th convergent $r_k=\\frac{p_k}{q_k}$ the following formula stands:\n\n$$r_k = a_0 + \\sum\\limits_{i=1}^k \\frac{(-1)^{i-1}}{q_i q_{i-1}}.$$\n\nIn particular, it means that \n\n$$r_k - r_{k-1} = \\frac{(-1)^{k-1}}{q_k q_{k-1}}$$\n\nand \n\n$$p_k q_{k-1} - p_{k-1} q_k = (-1)^{k-1}.$$\n\nFrom this we can conclude that\n\n$$\\left| r-\\frac{p_k}{q_k} \\right| \\leq \\frac{1}{q_{k+1}q_k} \\leq \\frac{1}{q_k^2}.$$\n\nThe latter inequality is due to the fact that $r_k$ and $r_{k+1}$ are generally located on different sides of $r$, thus\n\n$$|r-r_k| = |r_k-r_{k+1}|-|r-r_{k+1}| \\leq |r_k - r_{k+1}|.$$\n\n??? tip \"Detailed explanation\"\n\n    To estimate $|r-r_k|$, we start by estimating the difference between adjacent convergents. By definition,\n\n    $$\\frac{p_k}{q_k} - \\frac{p_{k-1}}{q_{k-1}} = \\frac{p_k q_{k-1} - p_{k-1} q_k}{q_k q_{k-1}}.$$\n\n    Replacing $p_k$ and $q_k$ in the numerator with their recurrences, we get\n\n    $$\\begin{align} p_k q_{k-1} - p_{k-1} q_k &= (a_k p_{k-1} + p_{k-2}) q_{k-1} - p_{k-1} (a_k q_{k-1} + q_{k-2})\n    \\\\&= p_{k-2} q_{k-1} - p_{k-1} q_{k-2},\\end{align}$$\n\n    thus the numerator of $r_k - r_{k-1}$ is always the negated numerator of $r_{k-1} - r_{k-2}$. It, in turn, equals to $1$ for\n\n    $$r_1 - r_0=\\left(a_0+\\frac{1}{a_1}\\right)-a_0=\\frac{1}{a_1},$$\n\n    thus\n\n    $$r_k - r_{k-1} = \\frac{(-1)^{k-1}}{q_k q_{k-1}}.$$\n\n    This yields an alternative representation of $r_k$ as a partial sum of infinite series:\n\n    $$r_k = (r_k - r_{k-1}) + \\dots + (r_1 - r_0) + r_0\n    = a_0 + \\sum\\limits_{i=1}^k \\frac{(-1)^{i-1}}{q_i q_{i-1}}.$$\n\n    From the recurrent relation it follows that $q_k$ monotonously increases at least as fast as Fibonacci numbers, thus\n\n    $$r = \\lim\\limits_{k \\to \\infty} r_k = a_0 + \\sum\\limits_{i=1}^\\infty \\frac{(-1)^{i-1}}{q_i q_{i-1}}$$\n\n    is always well-defined, as the underlying series always converge. Noteworthy, the residual series\n\n    $$r-r_k = \\sum\\limits_{i=k+1}^\\infty \\frac{(-1)^{i-1}}{q_i q_{i-1}}$$\n\n    has the same sign as $(-1)^k$ due to how fast $q_i q_{i-1}$ decreases. Hence even-indexed $r_k$ approach $r$ from below while odd-indexed $r_k$ approach it from above:\n\n    <figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/b/b4/Golden_ration_convergents.svg\" width=\"600px\"/>\n    <figcaption>_Convergents of $r=\\phi = \\frac{1+\\sqrt{5}}{2}=[1;1,1,\\dots]$ and their distance from $r$._</figcaption></figure>\n\n    From this picture we can see that\n\n    $$|r-r_k| = |r_k - r_{k+1}| - |r-r_{k+1}| \\leq |r_k - r_{k+1}|,$$\n\n    thus the distance between $r$ and $r_k$ is never larger than the distance between $r_k$ and $r_{k+1}$:\n\n    $$\\left|r-\\frac{p_k}{q_k}\\right| \\leq \\frac{1}{q_k q_{k+1}} \\leq \\frac{1}{q_k^2}.$$\n\n!!! example \"Extended Euclidean?\"\n    You're given $A, B, C \\in \\mathbb Z$. Find $x, y \\in \\mathbb Z$ such that $Ax + By = C$.\n??? hint \"Solution\"\n    Although this problem is typically solved with the [extended Euclidean algorithm](../algebra/extended-euclid-algorithm.md), there is a simple and straightforward solution with continued fractions.\n\n    Let $\\frac{A}{B}=[a_0; a_1, \\dots, a_k]$. It was proved above that $p_k q_{k-1} - p_{k-1} q_k = (-1)^{k-1}$. Substituting $p_k$ and $q_k$ with $A$ and $B$, we get\n\n    $$Aq_{k-1} - Bp_{k-1} = (-1)^{k-1} g,$$\n\n    where $g = \\gcd(A, B)$. If $C$ is divisible by $g$, then the solution is $x = (-1)^{k-1}\\frac{C}{g} q_{k-1}$ and $y = (-1)^{k}\\frac{C}{g} p_{k-1}$.\n    \n    === \"Python\"\n        ```py\n        # return (x, y) such that Ax+By=C\n        # assumes that such (x, y) exists\n        def dio(A, B, C):\n            p, q = convergents(fraction(A, B))\n            C //= A // p[-1] # divide by gcd(A, B)\n            t = (-1) if len(p) % 2 else 1\n            return t*C*q[-2], -t*C*p[-2]\n        ```\n\n## Linear fractional transformations\n\nAnother important concept for continued fractions are the so-called [linear fractional transformations](https://en.wikipedia.org/wiki/Linear_fractional_transformation).\n\n!!! info \"Definition\"\n    A **linear fractional transformation** is a function $f : \\mathbb R \\to \\mathbb R$ such that $f(x) = \\frac{ax+b}{cx+d}$ for some $a,b,c,d \\in \\mathbb R$.\n\nA composition $(L_0 \\circ L_1)(x) = L_0(L_1(x))$ of linear fractional transforms $L_0(x)=\\frac{a_0 x + b_0}{c_0 x + d_0}$ and $L_1(x)=\\frac{a_1 x + b_1}{c_1 x + d_1}$ is itself a linear fractional transform:\n\n$$\\frac{a_0\\frac{a_1 x + b_1}{c_1 x + d_1} + b_0}{c_0 \\frac{a_1 x + b_1}{c_1 x + d_1} + d_0} = \\frac{a_0(a_1 x + b_1) + b_0 (c_1 x + d_1)}{c_0 (a_1 x + b_1) + d_0 (c_1 x + d_1)} = \\frac{(a_0 a_1 + b_0 c_1) x + (a_0 b_1 + b_0 d_1)}{(c_0 a_1 + d_0 c_1) x + (c_0 b_1 + d_0 d_1)}.$$\n\nInverse of a linear fractional transform, is also a linear fractional transform:\n\n$$y = \\frac{ax+b}{cx+d} \\iff y(cx+d) = ax + b \\iff x = -\\frac{dy-b}{cy-a}.$$\n!!! example \"[DMOPC '19 Contest 7 P4 - Bob and Continued Fractions](https://dmoj.ca/problem/dmopc19c7p4)\"\n    You're given an array of positive integers $a_1, \\dots, a_n$. You need to answer $m$ queries. Each query is to compute $[a_l; a_{l+1}, \\dots, a_r]$.\n??? hint \"Solution\"\n    We can solve this problem with the segment tree if we're able to concatenate continued fractions.\n\n    It's generally true that $[a_0; a_1, \\dots, a_k, b_0, b_1, \\dots, b_k] = [a_0; a_1, \\dots, a_k, [b_1; b_2, \\dots, b_k]]$.\n\n    Let's denote $L_{k}(x) = [a_k; x] = a_k + \\frac{1}{x} = \\frac{a_k\\cdot x+1}{1\\cdot x + 0}$. Note that $L_k(\\infty) = a_k$. In this notion, it holds that\n\n    $$[a_0; a_1, \\dots, a_k, x] = [a_0; [a_1; [\\dots; [a_k; x]]]] = (L_0 \\circ L_1 \\circ \\dots \\circ L_k)(x) = \\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}.$$\n\n    Thus, the problem boils down to the computation of\n\n    $$(L_l \\circ L_{l+1} \\circ \\dots \\circ L_r)(\\infty).$$\n\n    Composition of transforms is associative, so it's possible to compute in each node of a segment tree the composition of transforms in its subtree.\n\n!!! example \"Linear fractional transformation of a continued fraction\"\n    Let $L(x) = \\frac{ax+b}{cx+d}$. Compute the continued fraction representation $[b_0; b_1, \\dots, b_m]$ of $L(A)$ for $A=[a_0; a_1, \\dots, a_n]$.\n\n    _This allows to compute $A + \\frac{p}{q} = \\frac{qA + p}{q}$ and $A \\cdot \\frac{p}{q} = \\frac{p A}{q}$ for any $\\frac{p}{q}$._\n\n??? hint \"Solution\"\n    As we noted above, $[a_0; a_1, \\dots, a_k] = (L_{a_0} \\circ L_{a_1} \\circ \\dots \\circ L_{a_k})(\\infty)$, hence $L([a_0; a_1, \\dots, a_k]) = (L \\circ L_{a_0} \\circ L_{a_1} \\circ \\dots L_{a_k})(\\infty)$.\n\n    Hence, by consequentially adding $L_{a_0}$, $L_{a_1}$ and so on we would be able to compute\n\n    $$(L \\circ L_{a_0} \\circ \\dots \\circ L_{a_k})(x) = L\\left(\\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}\\right)=\\frac{a_k x + b_k}{c_k x + d_k}.$$\n\n    Since $L(x)$ is invertible, it is also monotonous in $x$. Therefore, for any $x \\geq 0$ it holds that $L(\\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}})$ is between $L(\\frac{p_k}{q_k}) = \\frac{a_k}{c_k}$ and $L(\\frac{p_{k-1}}{q_{k-1}}) = \\frac{b_k}{d_k}$.\n\n    Moreover, for $x=[a_{k+1}; \\dots, a_n]$ it is equal to $L(A)$. Hence, $b_0 = \\lfloor L(A) \\rfloor$ is between $\\lfloor L(\\frac{p_k}{q_k}) \\rfloor$ and $\\lfloor L(\\frac{p_{k-1}}{q_{k-1}}) \\rfloor$. When they're equal, they're also equal to $b_0$.\n\n    Note that $L(A) = (L_{b_0} \\circ L_{b_1} \\circ \\dots \\circ L_{b_m})(\\infty)$. Knowing $b_0$, we can compose $L_{b_0}^{-1}$ with the current transform and continue adding $L_{a_{k+1}}$, $L_{a_{k+2}}$ and so on, looking for new floors to agree, from which we would be able to deduce $b_1$ and so on until we recover all values of $[b_0; b_1, \\dots, b_m]$.\n\n!!! example \"Continued fraction arithmetics\"\n    Let $A=[a_0; a_1, \\dots, a_n]$ and $B=[b_0; b_1, \\dots, b_m]$. Compute the continued fraction representations of $A+B$ and $A \\cdot B$.\n??? hint \"Solution\"\n    Idea here is similar to the previous problem, but instead of $L(x) = \\frac{ax+b}{cx+d}$ you should consider bilinear fractional transform $L(x, y) = \\frac{axy+bx+cy+d}{exy+fx+gy+h}$.\n\n    Rather than $L(x) \\mapsto L(L_{a_k}(x))$ you would change your current transform as $L(x, y) \\mapsto L(L_{a_k}(x), y)$ or $L(x, y) \\mapsto L(x, L_{b_k}(y))$.\n\n    Then, you check if $\\lfloor \\frac{a}{e} \\rfloor = \\lfloor \\frac{b}{f} \\rfloor = \\lfloor \\frac{c}{g} \\rfloor = \\lfloor \\frac{d}{h} \\rfloor$ and if they all agree, you use this value as $c_k$ in the resulting fraction and change the transform as\n\n    $$L(x, y) \\mapsto \\frac{1}{L(x, y) - c_k}.$$\n\n!!! info \"Definition\"\n    A continued fraction $x = [a_0; a_1, \\dots]$ is said to be **periodic** if $x = [a_0; a_1, \\dots, a_k, x]$ for some $k$.\n\n    A continued fraction $x = [a_0; a_1, \\dots]$ is said to be **eventually periodic** if $x = [a_0; a_1, \\dots, a_k, y]$, where $y$ is periodic.\n\nFor $x = [1; 1, 1, \\dots]$ it holds that $x = 1 + \\frac{1}{x}$, thus $x^2 = x + 1$. There is a generic connection between periodic continued fractions and quadratic equations. Consider the following equation:\n\n$$ x = [a_0; a_1, \\dots, a_k, x].$$\n\nOn one hand, this equation means that the continued fraction representation of $x$ is periodic with the period $k+1$.\n\nOn the other hand, using the formula for convergents, this equation means that\n\n$$x = \\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}.$$\n\nThat is, $x$ is a linear fractional transformation of itself. It follows from the equation that $x$ is a root of the second degree equation:\n\n$$q_k x^2 + (q_{k-1}-p_k)x - p_{k-1} = 0.$$\n\nSimilar reasoning stands for continued fractions that are eventually periodic, that is $x = [a_0; a_1, \\dots, a_k, y]$ for $y=[b_0; b_1, \\dots, b_k, y]$. Indeed, from first equation we derive that $x = L_0(y)$ and from second equation that $y = L_1(y)$, where $L_0$ and $L_1$ are linear fractional transformations. Therefore,\n\n$$x = (L_0 \\circ L_1)(y) = (L_0 \\circ L_1 \\circ L_0^{-1})(x).$$\n\nOne can further prove (and it was first done by Lagrange) that for arbitrary quadratic equation $ax^2+bx+c=0$ with integer coefficients, its solution $x$ is an eventually periodic continued fraction.\n\n!!! example \"Quadratic irrationality\"\n    Find the continued fraction of $\\alpha = \\frac{x+y\\sqrt{n}}{z}$ where $x, y, z, n \\in \\mathbb Z$ and $n > 0$ is not a perfect square.\n??? hint \"Solution\"\n    For the $k$-th complete quotient $s_k$ of the number it generally holds that\n\n    $$\\alpha = [a_0; a_1, \\dots, a_{k-1}, s_k] = \\frac{s_k p_{k-1} + p_{k-2}}{s_k q_{k-1} + q_{k-2}}.$$\n\n    Therefore, \n\n    $$s_k = -\\frac{\\alpha q_{k-1} - p_{k-1}}{\\alpha q_k - p_k} = -\\frac{q_{k-1} y \\sqrt n + (x q_{k-1} - z p_{k-1})}{q_k y \\sqrt n + (xq_k-zp_k)}.$$\n\n    Multiplying the numerator and denominator by $(xq_k - zp_k) - q_k y \\sqrt n$, we'll get rid of $\\sqrt n$ in the denominator, thus the complete quotients are of form\n\n    $$s_k = \\frac{x_k + y_k \\sqrt n}{z_k}.$$\n\n    Let's find $s_{k+1}$, assuming that $s_k$ is known.\n\n    First of all, $a_k = \\lfloor s_k \\rfloor = \\left\\lfloor \\frac{x_k + y_k \\lfloor \\sqrt n \\rfloor}{z_k} \\right\\rfloor$. Then,\n\n    $$s_{k+1} = \\frac{1}{s_k-a_k} = \\frac{z_k}{(x_k - z_k a_k) + y_k \\sqrt n} = \\frac{z_k (x_k - y_k a_k) - y_k z_k \\sqrt n}{(x_k - y_k a_k)^2 - y_k^2 n}.$$\n\n    Thus, if we denote $t_k = x_k - y_k a_k$, it will hold that\n\n    \\begin{align}x_{k+1} &=& z_k t_k, \\\\ y_{k+1} &=& -y_k z_k, \\\\ z_{k+1} &=& t_k^2 - y_k^2 n.\\end{align}\n\n    Nice thing about such representation is that if we reduce $x_{k+1}, y_{k+1}, z_{k+1}$ by their greatest common divisor, the result would be unique. Therefore, we may use it to check whether the current state has already been repeated and also to check where was the previous index that had this state.\n\n    Below is the code to compute the continued fraction representation for $\\alpha = \\sqrt n$:\n\n    === \"Python\"\n        ```py\n        # compute the continued fraction of sqrt(n)\n        def sqrt(n):\n            n0 = math.floor(math.sqrt(n))\n            x, y, z = 1, 0, 1\n            a = []\n            def step(x, y, z):\n                a.append((x * n0 + y) // z)\n                t = y - a[-1]*z\n                x, y, z = -z*x, z*t, t**2 - n*x**2\n                g = math.gcd(x, math.gcd(y, z))\n                return x // g, y // g, z // g\n\n            used = dict()\n            for i in range(n):\n                used[x, y, z] = i\n                x, y, z = step(x, y, z)\n                if (x, y, z) in used:\n                    return a\n        ```\n\n    Using the same `step` function but different initial $x$, $y$ and $z$ it is possible to compute it for arbitrary $\\frac{x+y \\sqrt{n}}{z}$.\n\n!!! example \"[Tavrida NU Akai Contest - Continued Fraction](https://timus.online/problem.aspx?space=1&num=1814)\"\n    You're given $x$ and $k$, $x$ is not a perfect square. Let $\\sqrt x = [a_0; a_1, \\dots]$, find $\\frac{p_k}{q_k}=[a_0; a_1, \\dots, a_k]$ for $0 \\leq k \\leq 10^9$.\n??? hint \"Solution\"\n    After computing the period of $\\sqrt x$, it is possible to compute $a_k$ using binary exponentiation on the linear fractional transformation induced by the continued fraction representation. To find the resulting transformation, you compress the period of size $T$ into a single transformation and repeat it $\\lfloor \\frac{k-1}{T}\\rfloor$ times, after which you manually combine it with the remaining transformations.\n\n    === \"Python\"\n        ```py\n        x, k = map(int, input().split())\n\n        mod = 10**9+7\n        \n        # compose (A[0]*x + A[1]) / (A[2]*x + A[3]) and (B[0]*x + B[1]) / (B[2]*x + B[3])\n        def combine(A, B):\n            return [t % mod for t in [A[0]*B[0]+A[1]*B[2], A[0]*B[1]+A[1]*B[3], A[2]*B[0]+A[3]*B[2], A[2]*B[1]+A[3]*B[3]]]\n\n        A = [1, 0, 0, 1] # (x + 0) / (0*x + 1) = x\n\n        a = sqrt(x)\n\n        T = len(a) - 1 # period of a\n\n        # apply ak + 1/x = (ak*x+1)/(1x+0) to (Ax + B) / (Cx + D)\n        for i in reversed(range(1, len(a))):\n            A = combine([a[i], 1, 1, 0], A)\n\n        def bpow(A, n):\n            return [1, 0, 0, 1] if not n else combine(A, bpow(A, n-1)) if n % 2 else bpow(combine(A, A), n // 2)\n\n\n        C = (0, 1, 0, 0) # = 1 / 0\n        while k % T:\n            i = k % T\n            C = combine([a[i], 1, 1, 0], C)\n            k -= 1\n\n        C = combine(bpow(A, k // T), C)\n        C = combine([a[0], 1, 1, 0], C)\n        print(str(C[1]) + '/' + str(C[3]))\n        ```\n\n## Geometric interpretation\n\nLet $\\vec r_k = (q_k;p_k)$ for the convergent $r_k = \\frac{p_k}{q_k}$. Then, the following recurrence holds:\n\n$$\\vec r_k = a_k \\vec r_{k-1} + \\vec r_{k-2}.$$\n\nLet $\\vec r = (1;r)$. Then, each vector $(x;y)$ corresponds to the number that is equal to its slope coefficient $\\frac{y}{x}$.\n\nWith the notion of [pseudoscalar product](../geometry/basic-geometry.md) $(x_1;y_1) \\times (x_2;y_2) = x_1 y_2 - x_2 y_1$, it can be shown (see the explanation below) that\n\n$$s_k = -\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r} = \\left|\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r}\\right|.$$\n\nThe last equation is due to the fact that $r_{k-1}$ and $r_{k-2}$ lie on the different sides of $r$, thus pseudoscalar products of $\\vec r_{k-1}$ and $\\vec r_{k-2}$ with $\\vec r$ have distinct signs. With $a_k = \\lfloor s_k \\rfloor$ in mind, formula for $\\vec r_k$ now looks like\n\n$$\\vec r_k = \\vec r_{k-2} + \\left\\lfloor \\left| \\frac{\\vec r \\times \\vec r_{k-2}}{\\vec r \\times \\vec r_{k-1}}\\right|\\right\\rfloor \\vec r_{k-1}.$$\n\nNote that $\\vec r_k \\times r = (q;p) \\times (1;r) = qr - p$, thus\n\n$$a_k = \\left\\lfloor \\left| \\frac{q_{k-1}r-p_{k-1}}{q_{k-2}r-p_{k-2}} \\right| \\right\\rfloor.$$\n\n??? hint \"Explanation\"\n    As we have already noted, $a_k = \\lfloor s_k \\rfloor$, where $s_k = [a_k; a_{k+1}, a_{k+2}, \\dots]$. On the other hand, from the convergent recurrence we derive that\n\n    $$r = [a_0; a_1, \\dots, a_{k-1}, s_k] = \\frac{s_k p_{k-1} + p_{k-2}}{s_k q_{k-1} + q_{k-2}}.$$\n\n    In vector form, it rewrites as\n\n    $$\\vec r \\parallel s_k \\vec r_{k-1} + \\vec r_{k-2},$$\n\n    meaning that $\\vec r$ and $s_k \\vec r_{k-1} + \\vec r_{k-2}$ are collinear (that is, have the same slope coefficient). Taking the [pseudoscalar product](../geometry/basic-geometry.md) of both parts with $\\vec r$, we get\n\n    $$0 = s_k (\\vec r_{k-1} \\times \\vec r) + (\\vec r_{k-2} \\times \\vec r),$$\n\n    which yields the final formula\n\n    $$s_k = -\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r}.$$\n\n!!! example \"Nose stretching algorithm\"\n    Each time you add $\\vec r_{k-1}$ to the vector $\\vec p$, the value of $\\vec p \\times \\vec r$ is increased by $\\vec r_{k-1} \\times \\vec r$.\n\n    Thus, $a_k=\\lfloor s_k \\rfloor$ is the maximum integer number of $\\vec r_{k-1}$ vectors that can be added to $\\vec r_{k-2}$ without changing the sign of the cross product with $\\vec r$.\n\n    In other words, $a_k$ is the maximum integer number of times you can add $\\vec r_{k-1}$ to $\\vec r_{k-2}$ without crossing the line defined by $\\vec r$:\n\n    <figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/9/92/Continued_convergents_geometry.svg\" width=\"700px\"/>\n    <figcaption>_Convergents of $r=\\frac{7}{9}=[0;1,3,2]$. Semiconvergents correspond to intermediate points between gray arrows._</figcaption></figure>\n\n    On the picture above, $\\vec r_2 = (4;3)$ is obtained by repeatedly adding $\\vec r_1 = (1;1)$ to $\\vec r_0 = (1;0)$.\n\n    When it is not possible to further add $\\vec r_1$ to $\\vec r_0$ without crossing the $y=rx$ line, we go to the other side and repeatedly add $\\vec r_2$ to $\\vec r_1$ to obtain $\\vec r_3 = (9;7)$.\n\n    This procedure generates exponentially longer vectors, that approach the line.\n\n    For this property, the procedure of generating consequent convergent vectors was dubbed the **nose stretching algorithm** by Boris Delaunay.\n\nIf we look on the triangle drawn on points $\\vec r_{k-2}$, $\\vec r_{k}$ and $\\vec 0$ we will notice that its doubled area is\n\n$$|\\vec r_{k-2} \\times \\vec r_k| = |\\vec r_{k-2} \\times (\\vec r_{k-2} + a_k \\vec r_{k-1})| = a_k |\\vec r_{k-2} \\times \\vec r_{k-1}| = a_k.$$\n\nCombined with the [Pick's theorem](../geometry/picks-theorem.md), it means that there are no lattice points strictly inside the triangle and the only lattice points on its border are $\\vec 0$ and $\\vec r_{k-2} + t \\cdot \\vec r_{k-1}$ for all integer $t$ such that $0 \\leq t \\leq a_k$. When joined for all possible $k$ it means that there are no integer points in the space between polygons formed by even-indexed and odd-indexed convergent vectors.\n\nThis, in turn, means that $\\vec r_k$ with odd coefficients form a convex hull of lattice points with $x \\geq 0$ above the line $y=rx$, while $\\vec r_k$ with even coefficients form a convex hull of lattice points with $x > 0$ below the line $y=rx$.\n\n\n!!! info \"Definition\"\n\n    These polygons are also known as **Klein polygons**, named after Felix Klein who first suggested this geometric interpretation to the continued fractions.\n\n## Problem examples\n\nNow that the most important facts and concepts were introduced, it is time to delve into specific problem examples.\n\n!!! example \"Convex hull under the line\"\n    Find the convex hull of lattice points $(x;y)$ such that $0 \\leq x \\leq N$ and $0 \\leq y \\leq rx$ for $r=[a_0;a_1,\\dots,a_k]=\\frac{p_k}{q_k}$.\n\n??? hint \"Solution\"\n    If we were considering the unbounded set $0 \\leq x$, the upper convex hull would be given by the line $y=rx$ itself.\n\n    However, with additional constraint $x \\leq N$ we'd need to eventually deviate from the line to maintain proper convex hull.\n\n    Let $t = \\lfloor \\frac{N}{q_k}\\rfloor$, then first $t$ lattice points on the hull after $(0;0)$ are $\\alpha \\cdot (q_k; p_k)$ for integer $1 \\leq \\alpha \\leq t$.\n\n    However $(t+1)(q_k; p_k)$ can't be next lattice point since $(t+1)q_k$ is greater than $N$.\n\n    To get to the next lattice points in the hull, we should get to the point $(x;y)$ which diverges from $y=rx$ by the smallest margin, while maintaining $x \\leq N$.\n\n    <figure><img src=\"https://upload.wikimedia.org/wikipedia/commons/b/b1/Lattice-hull.svg\" width=\"500px\"/>\n    <figcaption>Convex hull of lattice points under $y=\\frac{4}{7}x$ for $0 \\leq x \\leq 19$ consists of points $(0;0), (7;4), (14;8), (16;9), (18;10), (19;10)$.</figcaption></figure>\n\n    Let $(x; y)$ be the last current point in the convex hull. Then the next point $(x'; y')$ is such that $x' \\leq N$ and $(x'; y') - (x; y) = (\\Delta x; \\Delta y)$ is as close to the line $y=rx$ as possible. In other words, $(\\Delta x; \\Delta y)$ maximizes $r \\Delta x - \\Delta y$ subject to $\\Delta x \\leq N - x$ and $\\Delta y \\leq r \\Delta x$.\n\n    Points like that lie on the convex hull of lattice points below $y=rx$. In other words, $(\\Delta x; \\Delta y)$ must be a lower semiconvergent of $r$.\n\n    That being said, $(\\Delta x; \\Delta y)$ is of form $(q_{i-1}; p_{i-1}) + t \\cdot (q_i; p_i)$ for some odd number $i$ and $0 \\leq t < a_i$.\n\n    To find such $i$, we can traverse all possible $i$ starting from the largest one and use $t = \\lfloor \\frac{N-x-q_{i-1}}{q_i} \\rfloor$ for $i$ such that $N-x-q_{i-1} \\geq 0$.\n\n    With $(\\Delta x; \\Delta y) = (q_{i-1}; p_{i-1}) + t \\cdot (q_i; p_i)$, the condition $\\Delta y \\leq r \\Delta x$ would be preserved by semiconvergent properties.\n\n    And $t < a_i$ would hold because we already exhausted semiconvergents obtained from $i+2$, hence $x + q_{i-1} + a_i q_i = x+q_{i+1}$ is greater than $N$.\n\n    Now that we may add $(\\Delta x; \\Delta y)$, to $(x;y)$ for $k = \\lfloor \\frac{N-x}{\\Delta x} \\rfloor$ times before we exceed $N$, after which we would try the next semiconvergent.\n\n    === \"C++\"\n        ```cpp\n        // returns [ah, ph, qh] such that points r[i]=(ph[i], qh[i]) constitute upper convex hull\n        // of lattice points on 0 <= x <= N and 0 <= y <= r * x, where r = [a0; a1, a2, ...]\n        // and there are ah[i]-1 integer points on the segment between r[i] and r[i+1]\n        auto hull(auto a, int N) {\n            auto [p, q] = convergents(a);\n            int t = N / q.back();\n            vector ah = {t};\n            vector ph = {0, t*p.back()};\n            vector qh = {0, t*q.back()};\n\n            for(int i = q.size() - 1; i >= 0; i--) {\n                if(i % 2) {\n                    while(qh.back() + q[i - 1] <= N) {\n                        t = (N - qh.back() - q[i - 1]) / q[i];\n                        int dp = p[i - 1] + t * p[i];\n                        int dq = q[i - 1] + t * q[i];\n                        int k = (N - qh.back()) / dq;\n                        ah.push_back(k);\n                        ph.push_back(ph.back() + k * dp);\n                        qh.push_back(qh.back() + k * dq);\n                    }\n                }\n            }\n            return make_tuple(ah, ph, qh);\n        }\n        ```\n    === \"Python\"\n        ```py\n        # returns [ah, ph, qh] such that points r[i]=(ph[i], qh[i]) constitute upper convex hull\n        # of lattice points on 0 <= x <= N and 0 <= y <= r * x, where r = [a0; a1, a2, ...]\n        # and there are ah[i]-1 integer points on the segment between r[i] and r[i+1]\n        def hull(a, N):\n            p, q = convergents(a)\n            t = N // q[-1]\n            ah = [t]\n            ph = [0, t*p[-1]]\n            qh = [0, t*q[-1]]\n            for i in reversed(range(len(q))):\n                if i % 2 == 1:\n                    while qh[-1] + q[i-1] <= N:\n                        t = (N - qh[-1] - q[i-1]) // q[i]\n                        dp = p[i-1] + t*p[i]\n                        dq = q[i-1] + t*q[i]\n                        k = (N - qh[-1]) // dq\n                        ah.append(k)\n                        ph.append(ph[-1] + k * dp)\n                        qh.append(qh[-1] + k * dq)\n            return ah, ph, qh\n        ```\n\n!!! example \"[Timus - Crime and Punishment](https://timus.online/problem.aspx?space=1&num=1430)\"\n    You're given integer numbers $A$, $B$ and $N$. Find $x \\geq 0$ and $y \\geq 0$ such that $Ax + By \\leq N$ and $Ax + By$ is the maximum possible.\n\n??? hint \"Solution\"\n    In this problem it holds that $1 \\leq A, B, N \\leq 2 \\cdot 10^9$, so it can be solved in $O(\\sqrt N)$. However, there is $O(\\log N)$ solution with continued fractions.\n\n    For our convenience, we will invert the direction of $x$ by doing a substitution $x \\mapsto \\lfloor \\frac{N}{A}\\rfloor - x$, so that now we need to find the point $(x; y)$ such that $0 \\leq x \\leq \\lfloor \\frac{N}{A} \\rfloor$, $By - Ax \\leq N \\;\\bmod\\; A$ and $By - Ax$ is the maximum possible. Optimal $y$ for each $x$ has a value of $\\lfloor \\frac{Ax + (N \\bmod A)}{B} \\rfloor$.\n\n    To treat it more generically, we will write a function that finds the best point on $0 \\leq x \\leq N$ and $y = \\lfloor \\frac{Ax+B}{C} \\rfloor$.\n\n    Core solution idea in this problem essentially repeats the previous problem, but instead of using lower semiconvergents to diverge from line, you use upper semiconvergents to get closer to the line without crossing it and without violating $x \\leq N$. Unfortunately, unlike the previous problem, you need to make sure that you don't cross the $y=\\frac{Ax+B}{C}$ line while getting closer to it, so you should keep it in mind when calculating semiconvergent's coefficient $t$.\n\n    === \"Python\"\n        ```py\n        # (x, y) such that y = (A*x+B) // C,\n        # Cy - Ax is max and 0 <= x <= N.\n        def closest(A, B, C, N):\n            # y <= (A*x + B)/C <=> diff(x, y) <= B\n            def diff(x, y):\n                return C*y-A*x\n            a = fraction(A, C)\n            p, q = convergents(a)\n            ph = [B // C]\n            qh = [0]\n            for i in range(2, len(q) - 1):\n                if i % 2 == 0:\n                    while diff(qh[-1] + q[i+1], ph[-1] + p[i+1]) <= B:\n                        t = 1 + (diff(qh[-1] + q[i-1], ph[-1] + p[i-1]) - B - 1) // abs(diff(q[i], p[i]))\n                        dp = p[i-1] + t*p[i]\n                        dq = q[i-1] + t*q[i]\n                        k = (N - qh[-1]) // dq\n                        if k == 0:\n                            return qh[-1], ph[-1]\n                        if diff(dq, dp) != 0:\n                            k = min(k, (B - diff(qh[-1], ph[-1])) // diff(dq, dp))\n                        qh.append(qh[-1] + k*dq)\n                        ph.append(ph[-1] + k*dp)\n            return qh[-1], ph[-1]\n\n        def solve(A, B, N):\n            x, y = closest(A, N % A, B, N // A)\n            return N // A - x, y\n        ```\n\n!!! example \"[June Challenge 2017 - Euler Sum](https://www.codechef.com/problems/ES)\"\n    Compute $\\sum\\limits_{x=1}^N \\lfloor ex \\rfloor$, where $e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, \\dots, 1, 2n, 1, \\dots]$ is the Euler's number and $N \\leq 10^{4000}$.\n\n??? hint \"Solution\"\n    This sum is equal to the number of lattice point $(x;y)$ such that $1 \\leq x \\leq N$ and $1 \\leq y \\leq ex$.    \n\n    After constructing the convex hull of the points below $y=ex$, this number can be computed using [Pick's theorem](../geometry/picks-theorem.md):\n\n    === \"C++\"\n        ```cpp\n        // sum floor(k * x) for k in [1, N] and x = [a0; a1, a2, ...]\n        int sum_floor(auto a, int N) {\n            N++;\n            auto [ah, ph, qh] = hull(a, N);\n\n            // The number of lattice points within a vertical right trapezoid\n            // on points (0; 0) - (0; y1) - (dx; y2) - (dx; 0) that has\n            // a+1 integer points on the segment (0; y1) - (dx; y2).\n            auto picks = [](int y1, int y2, int dx, int a) {\n                int b = y1 + y2 + a + dx;\n                int A = (y1 + y2) * dx;\n                return (A - b + 2) / 2 + b - (y2 + 1);\n            };\n\n            int ans = 0;\n            for(size_t i = 1; i < qh.size(); i++) {\n                ans += picks(ph[i - 1], ph[i], qh[i] - qh[i - 1], ah[i - 1]);\n            }\n            return ans - N;\n        }\n        ```\n    === \"Python\"\n        ```py\n        # sum floor(k * x) for k in [1, N] and x = [a0; a1, a2, ...]\n        def sum_floor(a, N):\n            N += 1\n            ah, ph, qh = hull(a, N)\n\n            # The number of lattice points within a vertical right trapezoid\n            # on points (0; 0) - (0; y1) - (dx; y2) - (dx; 0) that has\n            # a+1 integer points on the segment (0; y1) - (dx; y2).\n            def picks(y1, y2, dx, a):\n                b = y1 + y2 + a + dx\n                A = (y1 + y2) * dx\n                return (A - b + 2) // 2 + b - (y2 + 1)\n\n            ans = 0\n            for i in range(1, len(qh)):\n                ans += picks(ph[i-1], ph[i], qh[i]-qh[i-1], ah[i-1])\n            return ans - N\n        ``` \n\n!!! example \"[NAIPC 2019 - It's a Mod, Mod, Mod, Mod World](https://open.kattis.com/problems/itsamodmodmodmodworld)\"\n    Given $p$, $q$ and $n$, compute $\\sum\\limits_{i=1}^n [p \\cdot i \\bmod q]$.\n\n??? hint \"Solution\"\n    This problem reduces to the previous one if you note that $a \\bmod b = a - \\lfloor \\frac{a}{b} \\rfloor b$. With this fact, the sum reduces to\n\n    $$\\sum\\limits_{i=1}^n \\left(p \\cdot i - \\left\\lfloor \\frac{p \\cdot i}{q} \\right\\rfloor q\\right) = \\frac{pn(n+1)}{2}-q\\sum\\limits_{i=1}^n \\left\\lfloor \\frac{p \\cdot i}{q}\\right\\rfloor.$$\n\n    However, summing up $\\lfloor rx \\rfloor$ for $x$ from $1$ to $N$ is something that we're capable of from the previous problem.\n\n    === \"C++\"\n        ```cpp\n        void solve(int p, int q, int N) {\n            cout << p * N * (N + 1) / 2 - q * sum_floor(fraction(p, q), N) << \"\\n\";\n        }\n        ```\n    === \"Python\"\n        ```py\n        def solve(p, q, N):\n            return p * N * (N + 1) // 2 - q * sum_floor(fraction(p, q), N)\n        ``` \n\n!!! example \"[Library Checker - Sum of Floor of Linear](https://judge.yosupo.jp/problem/sum_of_floor_of_linear)\"\n    Given $N$, $M$, $A$ and $B$, compute $\\sum\\limits_{i=0}^{N-1} \\lfloor \\frac{A \\cdot i + B}{M} \\rfloor$.\n\n??? hint \"Solution\"\n    This is the most technically troublesome problem so far.\n\n    It is possible to use the same approach and construct the full convex hull of points below the line $y = \\frac{Ax+B}{M}$.\n\n    We already know how to solve it for $B = 0$. Moreover, we already know how to construct this convex hull up to the closest lattice point to this line on $[0, N-1]$ segment (this is done in the \"Crime and Punishment\" problem above.\n\n    Now we should note that once we reached the closest point to the line, we can just assume that the line in fact passes through the closest point, as there are no other lattice points on $[0, N-1]$ in between the actual line and the line moved slightly below to pass through the closest point.\n\n    That being said, to construct the full convex hull below the line $y=\\frac{Ax+B}{M}$ on $[0, N-1]$, we can construct it up to the closest point to the line on $[0, N-1]$ and then continue as if the line passes through this point, reusing algorithm for constructing convex hull with $B=0$:\n\n    === \"Python\"\n        ```py\n        # hull of lattice (x, y) such that C*y <= A*x+B\n        def hull(A, B, C, N):\n            def diff(x, y):\n                return C*y-A*x\n            a = fraction(A, C)\n            p, q = convergents(a)\n            ah = []\n            ph = [B // C]\n            qh = [0]\n\n            def insert(dq, dp):\n                k = (N - qh[-1]) // dq\n                if diff(dq, dp) > 0:\n                    k = min(k, (B - diff(qh[-1], ph[-1])) // diff(dq, dp))\n                ah.append(k)\n                qh.append(qh[-1] + k*dq)\n                ph.append(ph[-1] + k*dp)\n\n            for i in range(1, len(q) - 1):\n                if i % 2 == 0:\n                    while diff(qh[-1] + q[i+1], ph[-1] + p[i+1]) <= B:\n                        t = (B - diff(qh[-1] + q[i+1], ph[-1] + p[i+1])) // abs(diff(q[i], p[i]))\n                        dp = p[i+1] - t*p[i]\n                        dq = q[i+1] - t*q[i]\n                        if dq < 0 or qh[-1] + dq > N:\n                            break\n                        insert(dq, dp)\n\n            insert(q[-1], p[-1])\n\n            for i in reversed(range(len(q))):\n                if i % 2 == 1:\n                    while qh[-1] + q[i-1] <= N:\n                        t = (N - qh[-1] - q[i-1]) // q[i]\n                        dp = p[i-1] + t*p[i]\n                        dq = q[i-1] + t*q[i]\n                        insert(dq, dp)\n            return ah, ph, qh\n        ```\n\n!!! example \"[OKC 2 - From Modular to Rational](https://codeforces.com/gym/102354/problem/I)\"\n    There is a rational number $\\frac{p}{q}$ such that $1 \\leq p, q \\leq 10^9$. You may ask the value of $p q^{-1}$ modulo $m \\sim 10^9$ for several prime numbers $m$. Recover $\\frac{p}{q}$.\n\n    _Equivalent formulation:_ Find $x$ that delivers the minimum of $Ax \\;\\bmod\\; M$ for $1 \\leq x \\leq N$.\n\n??? hint \"Solution\"\n    Due to Chinese remainder theorem, asking the result modulo several prime numbers is the same as asking it modulo their product. Due to this, without loss of generality we'll assume that we know the remainder modulo sufficiently large number $m$.\n\n    There could be several possible solutions $(p, q)$ to $p \\equiv qr \\pmod m$ for a given remainder $r$. However, if $(p_1, q_1)$ and $(p_2, q_2)$ are both the solutions then it also holds that $p_1 q_2 \\equiv p_2 q_1 \\pmod m$. Assuming that $\\frac{p_1}{q_1} \\neq \\frac{p_2}{q_2}$ it means that $|p_1 q_2 - p_2 q_1|$ is at least $m$.\n\n    In the statement we were told that $1 \\leq p, q \\leq 10^9$, so if both $p_1, q_1$ and $p_2, q_2$ are at most $10^9$, then the difference is at most $10^{18}$. For $m > 10^{18}$ it means that the solution $\\frac{p}{q}$ with $1 \\leq p, q \\leq 10^9$ is unique, as a rational number.\n\n    So, the problem boils down, given $r$ modulo $m$, to finding any $q$ such that $1 \\leq q \\leq 10^9$ and $qr \\;\\bmod\\; m \\leq 10^9$.\n\n    This is effectively the same as finding $q$ that delivers the minimum possible $qr \\bmod m$ for $1 \\leq q \\leq 10^9$.\n\n    For $qr = km + b$ it means that we need to find a pair $(q, m)$ such that $1 \\leq q \\leq 10^9$ and $qr - km \\geq 0$ is the minimum possible.\n\n    Since $m$ is constant, we can divide by it and further restate it as find $q$ such that $1 \\leq q \\leq 10^9$ and $\\frac{r}{m} q - k \\geq 0$ is the minimum possible.\n\n    In terms of continued fractions it means that $\\frac{k}{q}$ is the best diophantine approximation to $\\frac{r}{m}$ and it is sufficient to only check lower semiconvergents of $\\frac{r}{m}$.\n\n    === \"Python\"\n        ```py\n        # find Q that minimizes Q*r mod m for 1 <= k <= n < m \n        def mod_min(r, n, m):\n            a = fraction(r, m)\n            p, q = convergents(a)\n            for i in range(2, len(q)):\n                if i % 2 == 1 and (i + 1 == len(q) or q[i+1] > n):\n                    t = (n - q[i-1]) // q[i]\n                    return q[i-1] + t*q[i]\n        ```\n\n## Practice problems\n\n* [UVa OJ - Continued Fractions](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=775)\n* [ProjectEuler+ #64: Odd period square roots](https://www.hackerrank.com/contests/projecteuler/challenges/euler064/problem)\n* [Codeforces Round #184 (Div. 2) - Continued Fractions](https://codeforces.com/contest/305/problem/B)\n* [Codeforces Round #201 (Div. 1) - Doodle Jump](https://codeforces.com/contest/346/problem/E)\n* [Codeforces Round #325 (Div. 1) - Alice, Bob, Oranges and Apples](https://codeforces.com/contest/585/problem/C)\n* [POJ Founder Monthly Contest 2008.03.16 - A Modular Arithmetic Challenge](http://poj.org/problem?id=3530)\n* [2019 Multi-University Training Contest 5 - fraction](http://acm.hdu.edu.cn/showproblem.php?pid=6624)\n* [SnackDown 2019 Elimination Round - Election Bait](https://www.codechef.com/SNCKEL19/problems/EBAIT)\n", "problem_ids": [], "title": "Continued fractions"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: prime_sieve_linear\n---\n\n# Linear Sieve\n\nGiven a number $n$, find all prime numbers in a segment $[2;n]$.\n\nThe standard way of solving a task is to use [the sieve of Eratosthenes](sieve-of-eratosthenes.md). This algorithm is very simple, but it has runtime $O(n \\log \\log n)$.\n\nAlthough there are a lot of known algorithms with sublinear runtime (i.e. $o(n)$), the algorithm described below is interesting by its simplicity: it isn't any more complex than the classic sieve of Eratosthenes.\n\nBesides, the algorithm given here calculates **factorizations of all numbers** in the segment $[2; n]$ as a side effect, and that can be helpful in many practical applications.\n\nThe weakness of the given algorithm is in using more memory than the classic sieve of Eratosthenes': it requires an array of $n$ numbers, while for the classic sieve of Eratosthenes it is enough to have $n$ bits of memory (which is 32 times less).\n\nThus, it makes sense to use the described algorithm only until for numbers of order $10^7$ and not greater.\n\nThe algorithm is due to Paul Pritchard. It is a variant of Algorithm 3.3 in (Pritchard, 1987: see references in the end of the article).\n\n## Algorithm\n\nOur goal is to calculate **minimum prime factor** $lp [i]$ for every number $i$ in the segment $[2; n]$.\n\nBesides, we need to store the list of all the found prime numbers - let's call it $pr []$.\n\nWe'll initialize the values $lp [i]$ with zeros, which means that we assume all numbers are prime. During the algorithm execution this array will be filled gradually.\n\nNow we'll go through the numbers from 2 to $n$. We have two cases for the current number $i$:\n\n- $lp[i] = 0$ - that means that $i$ is prime, i.e. we haven't found any smaller factors for it.  \n  Hence, we assign $lp [i] = i$ and add $i$ to the end of the list $pr[]$.\n\n- $lp[i] \\neq 0$ - that means that $i$ is composite, and its minimum prime factor is $lp [i]$.\n\nIn both cases we update values of $lp []$ for the numbers that are divisible by $i$. However, our goal is to learn to do so as to set a value $lp []$ at most once for every number. We can do it as follows:\n\nLet's consider numbers $x_j = i \\cdot p_j$, where $p_j$ are all prime numbers less than or equal to $lp [i]$ (this is why we need to store the list of all prime numbers).\n\nWe'll set a new value $lp [x_j] = p_j$ for all numbers of this form.\n\nThe proof of correctness of this algorithm and its runtime can be found after the implementation.\n\n## Implementation\n\n```cpp\nconst int N = 10000000;\nvector<int> lp(N+1);\nvector<int> pr;\n \nfor (int i=2; i <= N; ++i) {\n\tif (lp[i] == 0) {\n\t\tlp[i] = i;\n\t\tpr.push_back(i);\n\t}\n\tfor (int j = 0; i * pr[j] <= N; ++j) {\n\t\tlp[i * pr[j]] = pr[j];\n\t\tif (pr[j] == lp[i]) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n## Correctness Proof\n\nWe need to prove that the algorithm sets all values $lp []$ correctly, and that every value will be set exactly once. Hence, the algorithm will have linear runtime, since all the remaining actions of the algorithm, obviously, work for $O (n)$.\n\nNotice that every number $i$ has exactly one representation in form:\n\n$$i = lp [i] \\cdot x,$$\n\nwhere $lp [i]$ is the minimal prime factor of $i$, and the number $x$ doesn't have any prime factors less than $lp [i]$, i.e.\n\n$$lp [i] \\le lp [x].$$\n\nNow, let's compare this with the actions of our algorithm: in fact, for every $x$ it goes through all prime numbers it could be multiplied by, i.e. all prime numbers up to $lp [x]$ inclusive, in order to get the numbers in the form given above.\n\nHence, the algorithm will go through every composite number exactly once, setting the correct values $lp []$ there. Q.E.D.\n\n## Runtime and Memory\n\nAlthough the running time of $O(n)$ is better than $O(n \\log \\log n)$ of the classic sieve of Eratosthenes, the difference between them is not so big.\nIn practice the linear sieve runs about as fast as a typical implementation of the sieve of Eratosthenes.\n\nIn comparison to optimized versions of the sieve of Erathosthenes, e.g. the segmented sieve, it is much slower.\n\nConsidering the memory requirements of this algorithm - an array $lp []$ of length $n$, and an array of $pr []$ of length  $\\frac n {\\ln n}$, this algorithm seems to worse than the classic sieve in every way.\n\nHowever, its redeeming quality is that this algorithm calculates an array $lp []$, which allows us to find factorization of any number in the segment $[2; n]$ in the time of the size order of this factorization. Moreover, using just one extra array will allow us to avoid divisions when looking for factorization.\n\nKnowing the factorizations of all numbers is very useful for some tasks, and this algorithm is one of the few which allow to find them in linear time.\n\n## References\n\n- Paul Pritchard, **Linear Prime-Number Sieves: a Family Tree**, Science of Computer Programming, vol. 9 (1987), pp.17-35.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: prime_sieve_linear\n---\n\n# Linear Sieve\n\nGiven a number $n$, find all prime numbers in a segment $[2;n]$.\n\nThe standard way of solving a task is to use [the sieve of Eratosthenes](sieve-of-eratosthenes.md). This algorithm is very simple, but it has runtime $O(n \\log \\log n)$.\n\nAlthough there are a lot of known algorithms with sublinear runtime (i.e. $o(n)$), the algorithm described below is interesting by its simplicity: it isn't any more complex than the classic sieve of Eratosthenes.\n\nBesides, the algorithm given here calculates **factorizations of all numbers** in the segment $[2; n]$ as a side effect, and that can be helpful in many practical applications.\n\nThe weakness of the given algorithm is in using more memory than the classic sieve of Eratosthenes': it requires an array of $n$ numbers, while for the classic sieve of Eratosthenes it is enough to have $n$ bits of memory (which is 32 times less).\n\nThus, it makes sense to use the described algorithm only until for numbers of order $10^7$ and not greater.\n\nThe algorithm is due to Paul Pritchard. It is a variant of Algorithm 3.3 in (Pritchard, 1987: see references in the end of the article).\n\n## Algorithm\n\nOur goal is to calculate **minimum prime factor** $lp [i]$ for every number $i$ in the segment $[2; n]$.\n\nBesides, we need to store the list of all the found prime numbers - let's call it $pr []$.\n\nWe'll initialize the values $lp [i]$ with zeros, which means that we assume all numbers are prime. During the algorithm execution this array will be filled gradually.\n\nNow we'll go through the numbers from 2 to $n$. We have two cases for the current number $i$:\n\n- $lp[i] = 0$ - that means that $i$ is prime, i.e. we haven't found any smaller factors for it.  \n  Hence, we assign $lp [i] = i$ and add $i$ to the end of the list $pr[]$.\n\n- $lp[i] \\neq 0$ - that means that $i$ is composite, and its minimum prime factor is $lp [i]$.\n\nIn both cases we update values of $lp []$ for the numbers that are divisible by $i$. However, our goal is to learn to do so as to set a value $lp []$ at most once for every number. We can do it as follows:\n\nLet's consider numbers $x_j = i \\cdot p_j$, where $p_j$ are all prime numbers less than or equal to $lp [i]$ (this is why we need to store the list of all prime numbers).\n\nWe'll set a new value $lp [x_j] = p_j$ for all numbers of this form.\n\nThe proof of correctness of this algorithm and its runtime can be found after the implementation.\n\n## Implementation\n\n```cpp\nconst int N = 10000000;\nvector<int> lp(N+1);\nvector<int> pr;\n \nfor (int i=2; i <= N; ++i) {\n\tif (lp[i] == 0) {\n\t\tlp[i] = i;\n\t\tpr.push_back(i);\n\t}\n\tfor (int j = 0; i * pr[j] <= N; ++j) {\n\t\tlp[i * pr[j]] = pr[j];\n\t\tif (pr[j] == lp[i]) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n## Correctness Proof\n\nWe need to prove that the algorithm sets all values $lp []$ correctly, and that every value will be set exactly once. Hence, the algorithm will have linear runtime, since all the remaining actions of the algorithm, obviously, work for $O (n)$.\n\nNotice that every number $i$ has exactly one representation in form:\n\n$$i = lp [i] \\cdot x,$$\n\nwhere $lp [i]$ is the minimal prime factor of $i$, and the number $x$ doesn't have any prime factors less than $lp [i]$, i.e.\n\n$$lp [i] \\le lp [x].$$\n\nNow, let's compare this with the actions of our algorithm: in fact, for every $x$ it goes through all prime numbers it could be multiplied by, i.e. all prime numbers up to $lp [x]$ inclusive, in order to get the numbers in the form given above.\n\nHence, the algorithm will go through every composite number exactly once, setting the correct values $lp []$ there. Q.E.D.\n\n## Runtime and Memory\n\nAlthough the running time of $O(n)$ is better than $O(n \\log \\log n)$ of the classic sieve of Eratosthenes, the difference between them is not so big.\nIn practice the linear sieve runs about as fast as a typical implementation of the sieve of Eratosthenes.\n\nIn comparison to optimized versions of the sieve of Erathosthenes, e.g. the segmented sieve, it is much slower.\n\nConsidering the memory requirements of this algorithm - an array $lp []$ of length $n$, and an array of $pr []$ of length  $\\frac n {\\ln n}$, this algorithm seems to worse than the classic sieve in every way.\n\nHowever, its redeeming quality is that this algorithm calculates an array $lp []$, which allows us to find factorization of any number in the segment $[2; n]$ in the time of the size order of this factorization. Moreover, using just one extra array will allow us to avoid divisions when looking for factorization.\n\nKnowing the factorizations of all numbers is very useful for some tasks, and this algorithm is one of the few which allow to find them in linear time.\n\n## References\n\n- Paul Pritchard, **Linear Prime-Number Sieves: a Family Tree**, Science of Computer Programming, vol. 9 (1987), pp.17-35.\n", "problem_ids": [], "title": "Linear Sieve"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: big_integer\n---\n\n# Arbitrary-Precision Arithmetic\n\nArbitrary-Precision arithmetic, also known as \"bignum\" or simply \"long arithmetic\" is a set of data structures and algorithms which allows to process much greater numbers than can be fit in standard data types. Here are several types of arbitrary-precision arithmetic.\n\n## Classical Integer Long Arithmetic\n\nThe main idea is that the number is stored as an array of its \"digits\" in some base. Several most frequently used bases are decimal, powers of decimal ($10^4$ or $10^9$) and binary.\n\nOperations on numbers in this form are performed using \"school\" algorithms of column addition, subtraction, multiplication and division. It's also possible to use fast multiplication algorithms: fast Fourier transform and Karatsuba algorithm.\n\nHere we describe long arithmetic for only non-negative integers. To extend the algorithms to handle negative integers one has to introduce and maintain additional \"negative number\" flag or use two's complement integer representation.\n\n### Data Structure\n\nWe'll store numbers as a `vector<int>`, in which each element is a single \"digit\" of the number.\n\n```cpp\ntypedef vector<int> lnum;\n```\n\nTo improve performance we'll use $10^9$ as the base, so that each \"digit\" of the long number contains 9 decimal digits at once.\n\n```cpp\nconst int base = 1000*1000*1000;\n```\n\nDigits will be stored in order from least to most significant. All operations will be implemented so that after each of them the result doesn't have any leading zeros, as long as operands didn't have any leading zeros either. All operations which might result in a number with leading zeros should be followed by code which removes them. Note that in this representation there are two valid notations for number zero: and empty vector, and a vector with a single zero digit.\n\n### Output\n\nPrinting the long integer is the easiest operation. First we print the last element of the vector (or 0 if the vector is empty), followed by the rest of the elements padded with leading zeros if necessary so that they are exactly 9 digits long.\n\n```cpp\nprintf (\"%d\", a.empty() ? 0 : a.back());\nfor (int i=(int)a.size()-2; i>=0; --i)\n\tprintf (\"%09d\", a[i]);\n```\n\nNote that we cast `a.size()` to integer to avoid unsigned integer underflow if vector contains less than 2 elements.\n\n### Input\n\nTo read a long integer, read its notation into a `string` and then convert it to \"digits\":\n\n```cpp\nfor (int i=(int)s.length(); i>0; i-=9)\n\tif (i < 9)\n\t\ta.push_back (atoi (s.substr (0, i).c_str()));\n\telse\n\t\ta.push_back (atoi (s.substr (i-9, 9).c_str()));\n```\n\nIf we use an array of `char` instead of a `string`, the code will be even shorter:\n\n```cpp\nfor (int i=(int)strlen(s); i>0; i-=9) {\n\ts[i] = 0;\n\ta.push_back (atoi (i>=9 ? s+i-9 : s));\n}\n```\n\nIf the input can contain leading zeros, they can be removed as follows:\n\n```cpp\nwhile (a.size() > 1 && a.back() == 0)\n\ta.pop_back();\n```\n\n### Addition\n\nIncrement long integer $a$ by $b$ and store result in $a$:\n\n```cpp\nint carry = 0;\nfor (size_t i=0; i<max(a.size(),b.size()) || carry; ++i) {\n\tif (i == a.size())\n\t\ta.push_back (0);\n\ta[i] += carry + (i < b.size() ? b[i] : 0);\n\tcarry = a[i] >= base;\n\tif (carry)  a[i] -= base;\n}\n```\n\n### Subtraction\n\nDecrement long integer $a$ by $b$ ($a \\ge b$) and store result in $a$:\n\n```cpp\nint carry = 0;\nfor (size_t i=0; i<b.size() || carry; ++i) {\n\ta[i] -= carry + (i < b.size() ? b[i] : 0);\n\tcarry = a[i] < 0;\n\tif (carry)  a[i] += base;\n}\nwhile (a.size() > 1 && a.back() == 0)\n\ta.pop_back();\n```\n\nNote that after performing subtraction we remove leading zeros to keep up with the premise that our long integers don't have leading zeros.\n\n### Multiplication by short integer\n\nMultiply long integer $a$ by short integer $b$ ($b < base$) and store result in $a$:\n\n```cpp\nint carry = 0;\nfor (size_t i=0; i<a.size() || carry; ++i) {\n\tif (i == a.size())\n\t\ta.push_back (0);\n\tlong long cur = carry + a[i] * 1ll * b;\n\ta[i] = int (cur % base);\n\tcarry = int (cur / base);\n}\nwhile (a.size() > 1 && a.back() == 0)\n\ta.pop_back();\n```\n\nAdditional optimization: If runtime is extremely important, you can try to replace two divisions with one by finding only integer result of division (variable `carry`) and then use it to find modulo using multiplication. This usually makes the code faster, though not dramatically.\n\n### Multiplication by long integer\n\nMultiply long integers $a$ and $b$ and store result in $c$:\n\n```cpp\nlnum c (a.size()+b.size());\nfor (size_t i=0; i<a.size(); ++i)\n\tfor (int j=0, carry=0; j<(int)b.size() || carry; ++j) {\n\t\tlong long cur = c[i+j] + a[i] * 1ll * (j < (int)b.size() ? b[j] : 0) + carry;\n\t\tc[i+j] = int (cur % base);\n\t\tcarry = int (cur / base);\n\t}\nwhile (c.size() > 1 && c.back() == 0)\n\tc.pop_back();\n```\n\n### Division by short integer\n\nDivide long integer $a$ by short integer $b$ ($b < base$), store integer result in $a$ and remainder in `carry`:\n\n```cpp\nint carry = 0;\nfor (int i=(int)a.size()-1; i>=0; --i) {\n\tlong long cur = a[i] + carry * 1ll * base;\n\ta[i] = int (cur / b);\n\tcarry = int (cur % b);\n}\nwhile (a.size() > 1 && a.back() == 0)\n\ta.pop_back();\n```\n\n## Long Integer Arithmetic for Factorization Representation\n\nThe idea is to store the integer as its factorization, i.e. the powers of primes which divide it.\n\nThis approach is very easy to implement, and allows to do multiplication and division easily (asymptotically faster than the classical method), but not addition or subtraction. It is also very memory-efficient compared to the classical approach.\n\nThis method is often used for calculations modulo non-prime number M; in this case a number is stored as powers of divisors of M which divide the number, plus the remainder modulo M.\n\n## Long Integer Arithmetic in prime modulos (Garner Algorithm)\n\nThe idea is to choose a set of prime numbers (typically they are small enough to fit into standard integer data type) and to store an integer as a vector of remainders from division of the integer by each of those primes.\n\nChinese remainder theorem states that this representation is sufficient to uniquely restore any number from 0 to product of these primes minus one. [Garner algorithm](chinese-remainder-theorem.md) allows to restore the number from such representation to normal integer.\n\nThis method allows to save memory compared to the classical approach (though the savings are not as dramatic as in factorization representation). Besides, it allows to perform fast addition, subtraction and multiplication in time proportional to the number of prime numbers used as modulos (see [Chinese remainder theorem](chinese-remainder-theorem.md) article for implementation).\n\nThe tradeoff is that converting the integer back to normal form is rather laborious and requires implementing classical arbitrary-precision arithmetic with multiplication. Besides, this method doesn't support division.\n\n## Fractional Arbitrary-Precision Arithmetic\n\nFractions occur in programming competitions less frequently than integers, and long arithmetic is much trickier to implement for fractions, so programming competitions feature only a small subset of fractional long arithmetic.\n\n### Arithmetic in Irreducible Fractions\n\nA number is represented as an irreducible fraction $\\frac{a}{b}$, where $a$ and $b$ are integers. All operations on fractions can be represented as operations on integer numerators and denominators of these fractions. Usually this requires using classical arbitrary-precision arithmetic for storing numerator and denominator, but sometimes a built-in 64-bit integer data type suffices.\n\n### Storing Floating Point Position as Separate Type\n\nSometimes a problem requires handling very small or very large numbers without allowing overflow or underflow. Built-in double data type uses 8-10 bytes and allows values of the exponent in $[-308; 308]$ range, which sometimes might be insufficient.\n\nThe approach is very simple: a separate integer variable is used to store the value of the exponent, and after each operation the floating-point number is normalized, i.e. returned to $[0.1; 1)$ interval by adjusting the exponent accordingly. \n\nWhen two such numbers are multiplied or divided, their exponents should be added or subtracted, respectively. When numbers are added or subtracted, they have to be brought to common exponent first by multiplying one of them by 10 raised to the power equal to the difference of exponent values.\n\nAs a final note, the exponent base doesn't have to equal 10. Based on the internal representation of floating-point numbers, it makes most sense to use 2 as the exponent base.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: big_integer\n---\n\n# Arbitrary-Precision Arithmetic\n\nArbitrary-Precision arithmetic, also known as \"bignum\" or simply \"long arithmetic\" is a set of data structures and algorithms which allows to process much greater numbers than can be fit in standard data types. Here are several types of arbitrary-precision arithmetic.\n\n## Classical Integer Long Arithmetic\n\nThe main idea is that the number is stored as an array of its \"digits\" in some base. Several most frequently used bases are decimal, powers of decimal ($10^4$ or $10^9$) and binary.\n\nOperations on numbers in this form are performed using \"school\" algorithms of column addition, subtraction, multiplication and division. It's also possible to use fast multiplication algorithms: fast Fourier transform and Karatsuba algorithm.\n\nHere we describe long arithmetic for only non-negative integers. To extend the algorithms to handle negative integers one has to introduce and maintain additional \"negative number\" flag or use two's complement integer representation.\n\n### Data Structure\n\nWe'll store numbers as a `vector<int>`, in which each element is a single \"digit\" of the number.\n\n```cpp\ntypedef vector<int> lnum;\n```\n\nTo improve performance we'll use $10^9$ as the base, so that each \"digit\" of the long number contains 9 decimal digits at once.\n\n```cpp\nconst int base = 1000*1000*1000;\n```\n\nDigits will be stored in order from least to most significant. All operations will be implemented so that after each of them the result doesn't have any leading zeros, as long as operands didn't have any leading zeros either. All operations which might result in a number with leading zeros should be followed by code which removes them. Note that in this representation there are two valid notations for number zero: and empty vector, and a vector with a single zero digit.\n\n### Output\n\nPrinting the long integer is the easiest operation. First we print the last element of the vector (or 0 if the vector is empty), followed by the rest of the elements padded with leading zeros if necessary so that they are exactly 9 digits long.\n\n```cpp\nprintf (\"%d\", a.empty() ? 0 : a.back());\nfor (int i=(int)a.size()-2; i>=0; --i)\n\tprintf (\"%09d\", a[i]);\n```\n\nNote that we cast `a.size()` to integer to avoid unsigned integer underflow if vector contains less than 2 elements.\n\n### Input\n\nTo read a long integer, read its notation into a `string` and then convert it to \"digits\":\n\n```cpp\nfor (int i=(int)s.length(); i>0; i-=9)\n\tif (i < 9)\n\t\ta.push_back (atoi (s.substr (0, i).c_str()));\n\telse\n\t\ta.push_back (atoi (s.substr (i-9, 9).c_str()));\n```\n\nIf we use an array of `char` instead of a `string`, the code will be even shorter:\n\n```cpp\nfor (int i=(int)strlen(s); i>0; i-=9) {\n\ts[i] = 0;\n\ta.push_back (atoi (i>=9 ? s+i-9 : s));\n}\n```\n\nIf the input can contain leading zeros, they can be removed as follows:\n\n```cpp\nwhile (a.size() > 1 && a.back() == 0)\n\ta.pop_back();\n```\n\n### Addition\n\nIncrement long integer $a$ by $b$ and store result in $a$:\n\n```cpp\nint carry = 0;\nfor (size_t i=0; i<max(a.size(),b.size()) || carry; ++i) {\n\tif (i == a.size())\n\t\ta.push_back (0);\n\ta[i] += carry + (i < b.size() ? b[i] : 0);\n\tcarry = a[i] >= base;\n\tif (carry)  a[i] -= base;\n}\n```\n\n### Subtraction\n\nDecrement long integer $a$ by $b$ ($a \\ge b$) and store result in $a$:\n\n```cpp\nint carry = 0;\nfor (size_t i=0; i<b.size() || carry; ++i) {\n\ta[i] -= carry + (i < b.size() ? b[i] : 0);\n\tcarry = a[i] < 0;\n\tif (carry)  a[i] += base;\n}\nwhile (a.size() > 1 && a.back() == 0)\n\ta.pop_back();\n```\n\nNote that after performing subtraction we remove leading zeros to keep up with the premise that our long integers don't have leading zeros.\n\n### Multiplication by short integer\n\nMultiply long integer $a$ by short integer $b$ ($b < base$) and store result in $a$:\n\n```cpp\nint carry = 0;\nfor (size_t i=0; i<a.size() || carry; ++i) {\n\tif (i == a.size())\n\t\ta.push_back (0);\n\tlong long cur = carry + a[i] * 1ll * b;\n\ta[i] = int (cur % base);\n\tcarry = int (cur / base);\n}\nwhile (a.size() > 1 && a.back() == 0)\n\ta.pop_back();\n```\n\nAdditional optimization: If runtime is extremely important, you can try to replace two divisions with one by finding only integer result of division (variable `carry`) and then use it to find modulo using multiplication. This usually makes the code faster, though not dramatically.\n\n### Multiplication by long integer\n\nMultiply long integers $a$ and $b$ and store result in $c$:\n\n```cpp\nlnum c (a.size()+b.size());\nfor (size_t i=0; i<a.size(); ++i)\n\tfor (int j=0, carry=0; j<(int)b.size() || carry; ++j) {\n\t\tlong long cur = c[i+j] + a[i] * 1ll * (j < (int)b.size() ? b[j] : 0) + carry;\n\t\tc[i+j] = int (cur % base);\n\t\tcarry = int (cur / base);\n\t}\nwhile (c.size() > 1 && c.back() == 0)\n\tc.pop_back();\n```\n\n### Division by short integer\n\nDivide long integer $a$ by short integer $b$ ($b < base$), store integer result in $a$ and remainder in `carry`:\n\n```cpp\nint carry = 0;\nfor (int i=(int)a.size()-1; i>=0; --i) {\n\tlong long cur = a[i] + carry * 1ll * base;\n\ta[i] = int (cur / b);\n\tcarry = int (cur % b);\n}\nwhile (a.size() > 1 && a.back() == 0)\n\ta.pop_back();\n```\n\n## Long Integer Arithmetic for Factorization Representation\n\nThe idea is to store the integer as its factorization, i.e. the powers of primes which divide it.\n\nThis approach is very easy to implement, and allows to do multiplication and division easily (asymptotically faster than the classical method), but not addition or subtraction. It is also very memory-efficient compared to the classical approach.\n\nThis method is often used for calculations modulo non-prime number M; in this case a number is stored as powers of divisors of M which divide the number, plus the remainder modulo M.\n\n## Long Integer Arithmetic in prime modulos (Garner Algorithm)\n\nThe idea is to choose a set of prime numbers (typically they are small enough to fit into standard integer data type) and to store an integer as a vector of remainders from division of the integer by each of those primes.\n\nChinese remainder theorem states that this representation is sufficient to uniquely restore any number from 0 to product of these primes minus one. [Garner algorithm](chinese-remainder-theorem.md) allows to restore the number from such representation to normal integer.\n\nThis method allows to save memory compared to the classical approach (though the savings are not as dramatic as in factorization representation). Besides, it allows to perform fast addition, subtraction and multiplication in time proportional to the number of prime numbers used as modulos (see [Chinese remainder theorem](chinese-remainder-theorem.md) article for implementation).\n\nThe tradeoff is that converting the integer back to normal form is rather laborious and requires implementing classical arbitrary-precision arithmetic with multiplication. Besides, this method doesn't support division.\n\n## Fractional Arbitrary-Precision Arithmetic\n\nFractions occur in programming competitions less frequently than integers, and long arithmetic is much trickier to implement for fractions, so programming competitions feature only a small subset of fractional long arithmetic.\n\n### Arithmetic in Irreducible Fractions\n\nA number is represented as an irreducible fraction $\\frac{a}{b}$, where $a$ and $b$ are integers. All operations on fractions can be represented as operations on integer numerators and denominators of these fractions. Usually this requires using classical arbitrary-precision arithmetic for storing numerator and denominator, but sometimes a built-in 64-bit integer data type suffices.\n\n### Storing Floating Point Position as Separate Type\n\nSometimes a problem requires handling very small or very large numbers without allowing overflow or underflow. Built-in double data type uses 8-10 bytes and allows values of the exponent in $[-308; 308]$ range, which sometimes might be insufficient.\n\nThe approach is very simple: a separate integer variable is used to store the value of the exponent, and after each operation the floating-point number is normalized, i.e. returned to $[0.1; 1)$ interval by adjusting the exponent accordingly. \n\nWhen two such numbers are multiplied or divided, their exponents should be added or subtracted, respectively. When numbers are added or subtracted, they have to be brought to common exponent first by multiplying one of them by 10 raised to the power equal to the difference of exponent values.\n\nAs a final note, the exponent base doesn't have to equal 10. Based on the internal representation of floating-point numbers, it makes most sense to use 2 as the exponent base.\n\n## Practice Problems\n\n\n* [UVA - How Many Fibs?](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1124)\n* [UVA - Product](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1047)\n* [UVA - Maximum Sub-sequence Product](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=728)\n* [SPOJ - Fast Multiplication](http://www.spoj.com/problems/MUL/en/)\n* [SPOJ - GCD2](http://www.spoj.com/problems/GCD2/)\n* [UVA - Division](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1024)\n* [UVA - Fibonacci Freeze](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=436)\n* [UVA - Krakovia](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1866)\n* [UVA - Simplifying Fractions](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1755)\n* [UVA - 500!](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=564)\n* [Hackerrank - Factorial digit sum](https://www.hackerrank.com/contests/projecteuler/challenges/euler020/problem)\n* [UVA - Immortal Rabbits](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4803)\n* [SPOJ - 0110SS](http://www.spoj.com/problems/IWGBS/)\n* [Codeforces - Notepad](http://codeforces.com/contest/17/problem/D)\n", "problem_ids": ["17_D"], "title": "Arbitrary-Precision Arithmetic"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: gray_code\n---\n\n# Gray code\n\nGray code is a binary numeral system where two successive values differ in only one bit. \n\nFor example, the sequence of Gray codes for 3-bit numbers is: 000, 001, 011, 010, 110, 111, 101, 100, so $G(4) = 6$.\n\nThis code was invented by Frank Gray in 1953.\n\n## Finding Gray code\n\nLet's look at the bits of number $n$ and the bits of number $G(n)$. Notice that $i$-th bit of $G(n)$ equals 1 only when $i$-th bit of $n$ equals 1 and $i + 1$-th bit equals 0 or the other way around ($i$-th bit equals 0 and $i + 1$-th bit equals 1). Thus, $G(n) = n \\oplus (n >> 1)$:  \n\n```cpp\nint g (int n) {\n    return n ^ (n >> 1);\n}\n```\n\n## Finding inverse Gray code\n\nGiven Gray code $g$, restore the original number $n$.\n\nWe will move from the most significant bits to the least significant ones (the least significant bit has index 1 and the most significant bit has index $k$). The relation between the bits $n_i$ of number $n$ and the bits $g_i$ of number $g$:\n\n$$\\begin{align}\n  n_k &= g_k, \\\\\n  n_{k-1} &= g_{k-1} \\oplus n_k = g_k \\oplus g_{k-1}, \\\\\n  n_{k-2} &= g_{k-2} \\oplus n_{k-1} = g_k \\oplus g_{k-1} \\oplus g_{k-2}, \\\\\n  n_{k-3} &= g_{k-3} \\oplus n_{k-2} = g_k \\oplus g_{k-1} \\oplus g_{k-2} \\oplus g_{k-3},\n  \\vdots\n\\end{align}$$\n\nThe easiest way to write it in code is:\n\n```cpp\nint rev_g (int g) {\n  int n = 0;\n  for (; g; g >>= 1)\n    n ^= g;\n  return n;\n}\n```\n\n## Practical applications\nGray codes have some useful applications, sometimes quite unexpected:\n\n*   Gray code of $n$ bits forms a Hamiltonian cycle on a hypercube, where each bit corresponds to one dimension. \n\n*   Gray codes are used to minimize the errors in digital-to-analog signals conversion (for example, in sensors). \n\n*   Gray code can be used to solve the Towers of Hanoi problem.\n    Let $n$ denote number of disks. Start with Gray code of length $n$ which\n    consists of all zeroes ($G(0)$) and move between consecutive Gray codes (from $G(i)$ to $G(i+1)$).\n    Let $i$-th bit of current Gray code represent $n$-th disk \n    (the least significant bit corresponds to the smallest disk and the most significant bit to the biggest disk). \n    Since exactly one bit changes on each step, we can treat changing $i$-th bit as moving $i$-th disk.\n    Notice that there is exactly one move option for each disk (except the smallest one) on each step (except start and finish positions).\n    There are always two move options for the smallest disk but there is a strategy which will always lead to answer:\n    if $n$ is odd then sequence of the smallest disk moves looks like $f \\to t \\to r \\to f \\to t \\to r \\to ...$\n    where $f$ is the initial rod, $t$ is the terminal rod and $r$ is the remaining rod), and \n    if $n$ is even: $f \\to r \\to t \\to f \\to r \\to t \\to ...$.\n\n*   Gray codes are also used in genetic algorithms theory.\n\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: gray_code\n---\n\n# Gray code\n\nGray code is a binary numeral system where two successive values differ in only one bit. \n\nFor example, the sequence of Gray codes for 3-bit numbers is: 000, 001, 011, 010, 110, 111, 101, 100, so $G(4) = 6$.\n\nThis code was invented by Frank Gray in 1953.\n\n## Finding Gray code\n\nLet's look at the bits of number $n$ and the bits of number $G(n)$. Notice that $i$-th bit of $G(n)$ equals 1 only when $i$-th bit of $n$ equals 1 and $i + 1$-th bit equals 0 or the other way around ($i$-th bit equals 0 and $i + 1$-th bit equals 1). Thus, $G(n) = n \\oplus (n >> 1)$:  \n\n```cpp\nint g (int n) {\n    return n ^ (n >> 1);\n}\n```\n\n## Finding inverse Gray code\n\nGiven Gray code $g$, restore the original number $n$.\n\nWe will move from the most significant bits to the least significant ones (the least significant bit has index 1 and the most significant bit has index $k$). The relation between the bits $n_i$ of number $n$ and the bits $g_i$ of number $g$:\n\n$$\\begin{align}\n  n_k &= g_k, \\\\\n  n_{k-1} &= g_{k-1} \\oplus n_k = g_k \\oplus g_{k-1}, \\\\\n  n_{k-2} &= g_{k-2} \\oplus n_{k-1} = g_k \\oplus g_{k-1} \\oplus g_{k-2}, \\\\\n  n_{k-3} &= g_{k-3} \\oplus n_{k-2} = g_k \\oplus g_{k-1} \\oplus g_{k-2} \\oplus g_{k-3},\n  \\vdots\n\\end{align}$$\n\nThe easiest way to write it in code is:\n\n```cpp\nint rev_g (int g) {\n  int n = 0;\n  for (; g; g >>= 1)\n    n ^= g;\n  return n;\n}\n```\n\n## Practical applications\nGray codes have some useful applications, sometimes quite unexpected:\n\n*   Gray code of $n$ bits forms a Hamiltonian cycle on a hypercube, where each bit corresponds to one dimension. \n\n*   Gray codes are used to minimize the errors in digital-to-analog signals conversion (for example, in sensors). \n\n*   Gray code can be used to solve the Towers of Hanoi problem.\n    Let $n$ denote number of disks. Start with Gray code of length $n$ which\n    consists of all zeroes ($G(0)$) and move between consecutive Gray codes (from $G(i)$ to $G(i+1)$).\n    Let $i$-th bit of current Gray code represent $n$-th disk \n    (the least significant bit corresponds to the smallest disk and the most significant bit to the biggest disk). \n    Since exactly one bit changes on each step, we can treat changing $i$-th bit as moving $i$-th disk.\n    Notice that there is exactly one move option for each disk (except the smallest one) on each step (except start and finish positions).\n    There are always two move options for the smallest disk but there is a strategy which will always lead to answer:\n    if $n$ is odd then sequence of the smallest disk moves looks like $f \\to t \\to r \\to f \\to t \\to r \\to ...$\n    where $f$ is the initial rod, $t$ is the terminal rod and $r$ is the remaining rod), and \n    if $n$ is even: $f \\to r \\to t \\to f \\to r \\to t \\to ...$.\n\n*   Gray codes are also used in genetic algorithms theory.\n\n\n## Practice Problems\n*   <a href=\"http://codeforces.com/problemsets/acmsguru/problem/99999/249\">SGU #249 <b>\"Matrix\"</b> &nbsp;&nbsp;&nbsp;&nbsp; [Difficulty: medium]</a>\n", "problem_ids": [], "title": "Gray code"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: diofant_2_equation\n---\n\n# Linear Diophantine Equation\n\nA Linear Diophantine Equation (in two variables) is an equation of the general form:\n\n$$ax + by = c$$\n\nwhere $a$, $b$, $c$ are given integers, and $x$, $y$ are unknown integers.\n\nIn this article, we consider several classical problems on these equations:\n\n* finding one solution\n* finding all solutions\n* finding the number of solutions and the solutions themselves in a given interval\n* finding a solution with minimum value of $x + y$\n\n## The degenerate case\n\nA degenerate case that need to be taken care of is when $a = b = 0$. It is easy to see that we either have no solutions or infinitely many solutions, depending on whether $c = 0$ or not. In the rest of this article, we will ignore this case.\n\n## Analytic solution\n\nWhen $a \\neq 0$ and $b \\neq 0$, the equation $ax+by=c$ can be equivalently treated as either of the following:\n\n\\begin{gather}\nax \\equiv c \\pmod b,\\newline\nby \\equiv c \\pmod a.\n\\end{gather}\n\nWithout loss of generality, assume that $b \\neq 0$ and consider the first equation. When $a$ and $b$ are co-prime, the solution to it is given as\n\n$$x \\equiv ca^{-1} \\pmod b,$$\n\nwhere $a^{-1}$ is the [modular inverse](module-inverse.md) of $a$ modulo $b$.\n\nWhen $a$ and $b$ are not co-prime, values of $ax$ modulo $b$ for all integer $x$ are divisible by $g=\\gcd(a, b)$, so the solution only exists when $c$ is divisible by $g$. In this case, one of solutions can be found by reducing the equation by $g$:\n\n$$(a/g) x \\equiv (c/g) \\pmod{b/g}.$$\n\nBy the definition of $g$, the numbers $a/g$ and $b/g$ are co-prime, so the solution is given explicitly as\n\n$$\\begin{cases}\nx \\equiv (c/g)(a/g)^{-1}\\pmod{b/g},\\\\\ny = \\frac{c-ax}{b}.\n\\end{cases}$$\n\n## Algorithmic solution\n\nTo find one solution of the Diophantine equation with 2 unknowns, you can use the [Extended Euclidean algorithm](extended-euclid-algorithm.md). First, assume that $a$ and $b$ are non-negative. When we apply Extended Euclidean algorithm for $a$ and $b$, we can find their greatest common divisor $g$ and 2 numbers $x_g$ and $y_g$ such that:\n\n$$a x_g + b y_g = g$$\n\nIf $c$ is divisible by $g = \\gcd(a, b)$, then the given Diophantine equation has a solution, otherwise it does not have any solution. The proof is straight-forward: a linear combination of two numbers is divisible by their common divisor.\n\nNow supposed that $c$ is divisible by $g$, then we have:\n\n$$a \\cdot x_g \\cdot \\frac{c}{g} + b \\cdot y_g \\cdot \\frac{c}{g} = c$$\n\nTherefore one of the solutions of the Diophantine equation is:\n\n$$x_0 = x_g \\cdot \\frac{c}{g},$$\n\n$$y_0 = y_g \\cdot \\frac{c}{g}.$$\n\nThe above idea still works when $a$ or $b$ or both of them are negative. We only need to change the sign of $x_0$ and $y_0$ when necessary.\n\nFinally, we can implement this idea as follows (note that this code does not consider the case $a = b = 0$):\n\n```{.cpp file=linear_diophantine_any}\nint gcd(int a, int b, int& x, int& y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int x1, y1;\n    int d = gcd(b, a % b, x1, y1);\n    x = y1;\n    y = x1 - y1 * (a / b);\n    return d;\n}\n\nbool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {\n    g = gcd(abs(a), abs(b), x0, y0);\n    if (c % g) {\n        return false;\n    }\n\n    x0 *= c / g;\n    y0 *= c / g;\n    if (a < 0) x0 = -x0;\n    if (b < 0) y0 = -y0;\n    return true;\n}\n```\n\n## Getting all solutions\n\nFrom one solution $(x_0, y_0)$, we can obtain all the solutions of the given equation.\n\nLet $g = \\gcd(a, b)$ and let $x_0, y_0$ be integers which satisfy the following:\n\n$$a \\cdot x_0 + b \\cdot y_0 = c$$\n\nNow, we should see that adding $b / g$ to $x_0$, and, at the same time subtracting $a / g$ from $y_0$ will not break the equality:\n\n$$a \\cdot \\left(x_0 + \\frac{b}{g}\\right) + b \\cdot \\left(y_0 - \\frac{a}{g}\\right) = a \\cdot x_0 + b \\cdot y_0 + a \\cdot \\frac{b}{g} - b \\cdot \\frac{a}{g} = c$$\n\nObviously, this process can be repeated again, so all the numbers of the form:\n\n$$x = x_0 + k \\cdot \\frac{b}{g}$$\n\n$$y = y_0 - k \\cdot \\frac{a}{g}$$\n\nare solutions of the given Diophantine equation.\n\nMoreover, this is the set of all possible solutions of the given Diophantine equation.\n\n## Finding the number of solutions and the solutions in a given interval\n\nFrom previous section, it should be clear that if we don't impose any restrictions on the solutions, there would be infinite number of them. So in this section, we add some restrictions on the interval of $x$ and $y$, and we will try to count and enumerate all the solutions.\n\nLet there be two intervals: $[min_x; max_x]$ and $[min_y; max_y]$ and let's say we only want to find the solutions in these two intervals.\n\nNote that if $a$ or $b$ is $0$, then the problem only has one solution. We don't consider this case here.\n\nFirst, we can find a solution which have minimum value of $x$, such that $x \\ge min_x$. To do this, we first find any solution of the Diophantine equation. Then, we shift this solution to get $x \\ge min_x$ (using what we know about the set of all solutions in previous section). This can be done in $O(1)$.\nDenote this minimum value of $x$ by $l_{x1}$.\n\nSimilarly, we can find the maximum value of $x$ which satisfy $x \\le max_x$. Denote this maximum value of $x$ by $r_{x1}$.\n\nSimilarly, we can find the minimum value of $y$ $(y \\ge min_y)$ and maximum values of $y$ $(y \\le max_y)$. Denote the corresponding values of $x$ by $l_{x2}$ and $r_{x2}$.\n\nThe final solution is all solutions with x in intersection of $[l_{x1}, r_{x1}]$ and $[l_{x2}, r_{x2}]$. Let denote this intersection by $[l_x, r_x]$.\n\nFollowing is the code implementing this idea.\nNotice that we divide $a$ and $b$ at the beginning by $g$.\nSince the equation $a x + b y = c$ is equivalent to the equation $\\frac{a}{g} x + \\frac{b}{g} y = \\frac{c}{g}$, we can use this one instead and have $\\gcd(\\frac{a}{g}, \\frac{b}{g}) = 1$, which simplifies the formulas.\n\n```{.cpp file=linear_diophantine_all}\nvoid shift_solution(int & x, int & y, int a, int b, int cnt) {\n    x += cnt * b;\n    y -= cnt * a;\n}\n\nint find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {\n    int x, y, g;\n    if (!find_any_solution(a, b, c, x, y, g))\n        return 0;\n    a /= g;\n    b /= g;\n\n    int sign_a = a > 0 ? +1 : -1;\n    int sign_b = b > 0 ? +1 : -1;\n\n    shift_solution(x, y, a, b, (minx - x) / b);\n    if (x < minx)\n        shift_solution(x, y, a, b, sign_b);\n    if (x > maxx)\n        return 0;\n    int lx1 = x;\n\n    shift_solution(x, y, a, b, (maxx - x) / b);\n    if (x > maxx)\n        shift_solution(x, y, a, b, -sign_b);\n    int rx1 = x;\n\n    shift_solution(x, y, a, b, -(miny - y) / a);\n    if (y < miny)\n        shift_solution(x, y, a, b, -sign_a);\n    if (y > maxy)\n        return 0;\n    int lx2 = x;\n\n    shift_solution(x, y, a, b, -(maxy - y) / a);\n    if (y > maxy)\n        shift_solution(x, y, a, b, sign_a);\n    int rx2 = x;\n\n    if (lx2 > rx2)\n        swap(lx2, rx2);\n    int lx = max(lx1, lx2);\n    int rx = min(rx1, rx2);\n\n    if (lx > rx)\n        return 0;\n    return (rx - lx) / abs(b) + 1;\n}\n```\n\nOnce we have $l_x$ and $r_x$, it is also simple to enumerate through all the solutions. Just need to iterate through $x = l_x + k \\cdot \\frac{b}{g}$ for all $k \\ge 0$ until $x = r_x$, and find the corresponding $y$ values using the equation $a x + b y = c$.\n\n## Find the solution with minimum value of $x + y$ { data-toc-label='Find the solution with minimum value of <script type=\"math/tex\">x + y</script>' }\n\nHere, $x$ and $y$ also need to be given some restriction, otherwise, the answer may become negative infinity.\n\nThe idea is similar to previous section: We find any solution of the Diophantine equation, and then shift the solution to satisfy some conditions.\n\nFinally, use the knowledge of the set of all solutions to find the minimum:\n\n$$x' = x + k \\cdot \\frac{b}{g},$$\n\n$$y' = y - k \\cdot \\frac{a}{g}.$$\n\nNote that $x + y$ change as follows:\n\n$$x' + y' = x + y + k \\cdot \\left(\\frac{b}{g} - \\frac{a}{g}\\right) = x + y + k \\cdot \\frac{b-a}{g}$$\n\nIf $a < b$, we need to select smallest possible value of $k$. If $a > b$, we need to select the largest possible value of $k$. If $a = b$, all solution will have the same sum $x + y$.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: diofant_2_equation\n---\n\n# Linear Diophantine Equation\n\nA Linear Diophantine Equation (in two variables) is an equation of the general form:\n\n$$ax + by = c$$\n\nwhere $a$, $b$, $c$ are given integers, and $x$, $y$ are unknown integers.\n\nIn this article, we consider several classical problems on these equations:\n\n* finding one solution\n* finding all solutions\n* finding the number of solutions and the solutions themselves in a given interval\n* finding a solution with minimum value of $x + y$\n\n## The degenerate case\n\nA degenerate case that need to be taken care of is when $a = b = 0$. It is easy to see that we either have no solutions or infinitely many solutions, depending on whether $c = 0$ or not. In the rest of this article, we will ignore this case.\n\n## Analytic solution\n\nWhen $a \\neq 0$ and $b \\neq 0$, the equation $ax+by=c$ can be equivalently treated as either of the following:\n\n\\begin{gather}\nax \\equiv c \\pmod b,\\newline\nby \\equiv c \\pmod a.\n\\end{gather}\n\nWithout loss of generality, assume that $b \\neq 0$ and consider the first equation. When $a$ and $b$ are co-prime, the solution to it is given as\n\n$$x \\equiv ca^{-1} \\pmod b,$$\n\nwhere $a^{-1}$ is the [modular inverse](module-inverse.md) of $a$ modulo $b$.\n\nWhen $a$ and $b$ are not co-prime, values of $ax$ modulo $b$ for all integer $x$ are divisible by $g=\\gcd(a, b)$, so the solution only exists when $c$ is divisible by $g$. In this case, one of solutions can be found by reducing the equation by $g$:\n\n$$(a/g) x \\equiv (c/g) \\pmod{b/g}.$$\n\nBy the definition of $g$, the numbers $a/g$ and $b/g$ are co-prime, so the solution is given explicitly as\n\n$$\\begin{cases}\nx \\equiv (c/g)(a/g)^{-1}\\pmod{b/g},\\\\\ny = \\frac{c-ax}{b}.\n\\end{cases}$$\n\n## Algorithmic solution\n\nTo find one solution of the Diophantine equation with 2 unknowns, you can use the [Extended Euclidean algorithm](extended-euclid-algorithm.md). First, assume that $a$ and $b$ are non-negative. When we apply Extended Euclidean algorithm for $a$ and $b$, we can find their greatest common divisor $g$ and 2 numbers $x_g$ and $y_g$ such that:\n\n$$a x_g + b y_g = g$$\n\nIf $c$ is divisible by $g = \\gcd(a, b)$, then the given Diophantine equation has a solution, otherwise it does not have any solution. The proof is straight-forward: a linear combination of two numbers is divisible by their common divisor.\n\nNow supposed that $c$ is divisible by $g$, then we have:\n\n$$a \\cdot x_g \\cdot \\frac{c}{g} + b \\cdot y_g \\cdot \\frac{c}{g} = c$$\n\nTherefore one of the solutions of the Diophantine equation is:\n\n$$x_0 = x_g \\cdot \\frac{c}{g},$$\n\n$$y_0 = y_g \\cdot \\frac{c}{g}.$$\n\nThe above idea still works when $a$ or $b$ or both of them are negative. We only need to change the sign of $x_0$ and $y_0$ when necessary.\n\nFinally, we can implement this idea as follows (note that this code does not consider the case $a = b = 0$):\n\n```{.cpp file=linear_diophantine_any}\nint gcd(int a, int b, int& x, int& y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int x1, y1;\n    int d = gcd(b, a % b, x1, y1);\n    x = y1;\n    y = x1 - y1 * (a / b);\n    return d;\n}\n\nbool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {\n    g = gcd(abs(a), abs(b), x0, y0);\n    if (c % g) {\n        return false;\n    }\n\n    x0 *= c / g;\n    y0 *= c / g;\n    if (a < 0) x0 = -x0;\n    if (b < 0) y0 = -y0;\n    return true;\n}\n```\n\n## Getting all solutions\n\nFrom one solution $(x_0, y_0)$, we can obtain all the solutions of the given equation.\n\nLet $g = \\gcd(a, b)$ and let $x_0, y_0$ be integers which satisfy the following:\n\n$$a \\cdot x_0 + b \\cdot y_0 = c$$\n\nNow, we should see that adding $b / g$ to $x_0$, and, at the same time subtracting $a / g$ from $y_0$ will not break the equality:\n\n$$a \\cdot \\left(x_0 + \\frac{b}{g}\\right) + b \\cdot \\left(y_0 - \\frac{a}{g}\\right) = a \\cdot x_0 + b \\cdot y_0 + a \\cdot \\frac{b}{g} - b \\cdot \\frac{a}{g} = c$$\n\nObviously, this process can be repeated again, so all the numbers of the form:\n\n$$x = x_0 + k \\cdot \\frac{b}{g}$$\n\n$$y = y_0 - k \\cdot \\frac{a}{g}$$\n\nare solutions of the given Diophantine equation.\n\nMoreover, this is the set of all possible solutions of the given Diophantine equation.\n\n## Finding the number of solutions and the solutions in a given interval\n\nFrom previous section, it should be clear that if we don't impose any restrictions on the solutions, there would be infinite number of them. So in this section, we add some restrictions on the interval of $x$ and $y$, and we will try to count and enumerate all the solutions.\n\nLet there be two intervals: $[min_x; max_x]$ and $[min_y; max_y]$ and let's say we only want to find the solutions in these two intervals.\n\nNote that if $a$ or $b$ is $0$, then the problem only has one solution. We don't consider this case here.\n\nFirst, we can find a solution which have minimum value of $x$, such that $x \\ge min_x$. To do this, we first find any solution of the Diophantine equation. Then, we shift this solution to get $x \\ge min_x$ (using what we know about the set of all solutions in previous section). This can be done in $O(1)$.\nDenote this minimum value of $x$ by $l_{x1}$.\n\nSimilarly, we can find the maximum value of $x$ which satisfy $x \\le max_x$. Denote this maximum value of $x$ by $r_{x1}$.\n\nSimilarly, we can find the minimum value of $y$ $(y \\ge min_y)$ and maximum values of $y$ $(y \\le max_y)$. Denote the corresponding values of $x$ by $l_{x2}$ and $r_{x2}$.\n\nThe final solution is all solutions with x in intersection of $[l_{x1}, r_{x1}]$ and $[l_{x2}, r_{x2}]$. Let denote this intersection by $[l_x, r_x]$.\n\nFollowing is the code implementing this idea.\nNotice that we divide $a$ and $b$ at the beginning by $g$.\nSince the equation $a x + b y = c$ is equivalent to the equation $\\frac{a}{g} x + \\frac{b}{g} y = \\frac{c}{g}$, we can use this one instead and have $\\gcd(\\frac{a}{g}, \\frac{b}{g}) = 1$, which simplifies the formulas.\n\n```{.cpp file=linear_diophantine_all}\nvoid shift_solution(int & x, int & y, int a, int b, int cnt) {\n    x += cnt * b;\n    y -= cnt * a;\n}\n\nint find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {\n    int x, y, g;\n    if (!find_any_solution(a, b, c, x, y, g))\n        return 0;\n    a /= g;\n    b /= g;\n\n    int sign_a = a > 0 ? +1 : -1;\n    int sign_b = b > 0 ? +1 : -1;\n\n    shift_solution(x, y, a, b, (minx - x) / b);\n    if (x < minx)\n        shift_solution(x, y, a, b, sign_b);\n    if (x > maxx)\n        return 0;\n    int lx1 = x;\n\n    shift_solution(x, y, a, b, (maxx - x) / b);\n    if (x > maxx)\n        shift_solution(x, y, a, b, -sign_b);\n    int rx1 = x;\n\n    shift_solution(x, y, a, b, -(miny - y) / a);\n    if (y < miny)\n        shift_solution(x, y, a, b, -sign_a);\n    if (y > maxy)\n        return 0;\n    int lx2 = x;\n\n    shift_solution(x, y, a, b, -(maxy - y) / a);\n    if (y > maxy)\n        shift_solution(x, y, a, b, sign_a);\n    int rx2 = x;\n\n    if (lx2 > rx2)\n        swap(lx2, rx2);\n    int lx = max(lx1, lx2);\n    int rx = min(rx1, rx2);\n\n    if (lx > rx)\n        return 0;\n    return (rx - lx) / abs(b) + 1;\n}\n```\n\nOnce we have $l_x$ and $r_x$, it is also simple to enumerate through all the solutions. Just need to iterate through $x = l_x + k \\cdot \\frac{b}{g}$ for all $k \\ge 0$ until $x = r_x$, and find the corresponding $y$ values using the equation $a x + b y = c$.\n\n## Find the solution with minimum value of $x + y$ { data-toc-label='Find the solution with minimum value of <script type=\"math/tex\">x + y</script>' }\n\nHere, $x$ and $y$ also need to be given some restriction, otherwise, the answer may become negative infinity.\n\nThe idea is similar to previous section: We find any solution of the Diophantine equation, and then shift the solution to satisfy some conditions.\n\nFinally, use the knowledge of the set of all solutions to find the minimum:\n\n$$x' = x + k \\cdot \\frac{b}{g},$$\n\n$$y' = y - k \\cdot \\frac{a}{g}.$$\n\nNote that $x + y$ change as follows:\n\n$$x' + y' = x + y + k \\cdot \\left(\\frac{b}{g} - \\frac{a}{g}\\right) = x + y + k \\cdot \\frac{b-a}{g}$$\n\nIf $a < b$, we need to select smallest possible value of $k$. If $a > b$, we need to select the largest possible value of $k$. If $a = b$, all solution will have the same sum $x + y$.\n\n## Practice Problems\n\n* [Spoj - Crucial Equation](http://www.spoj.com/problems/CEQU/)\n* [SGU 106](http://codeforces.com/problemsets/acmsguru/problem/99999/106)\n* [Codeforces - Ebony and Ivory](http://codeforces.com/contest/633/problem/A)\n* [Codechef - Get AC in one go](https://www.codechef.com/problems/COPR16G)\n* [LightOj - Solutions to an equation](http://www.lightoj.com/volume_showproblem.php?problem=1306)\n", "problem_ids": ["633_A"], "title": "Linear Diophantine Equation"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: discrete_log\n---\n\n# Discrete Logarithm\n\nThe discrete logarithm is an integer $x$ satisfying the equation\n\n$$a^x \\equiv b \\pmod m$$\n\nfor given integers $a$, $b$ and $m$.\n\nThe discrete logarithm does not always exist, for instance there is no solution to $2^x \\equiv 3 \\pmod 7$. There is no simple condition to determine if the discrete logarithm exists.\n\nIn this article, we describe the **Baby-step giant-step** algorithm, an algorithm to compute the discrete logarithm proposed by Shanks in 1971, which has the time complexity $O(\\sqrt{m})$. This is a **meet-in-the-middle** algorithm because it uses the technique of separating tasks in half.\n\n## Algorithm\n\nConsider the equation:\n\n$$a^x \\equiv b \\pmod m,$$\n\nwhere $a$ and $m$ are relatively prime.\n\nLet $x = np - q$, where $n$ is some pre-selected constant (we will describe how to select $n$ later). $p$ is known as **giant step**, since increasing it by one increases $x$ by $n$. Similarly, $q$ is known as **baby step**.\n\nObviously, any number $x$ in the interval $[0; m)$ can be represented in this form, where $p \\in [1; \\lceil \\frac{m}{n} \\rceil ]$ and $q \\in [0; n]$.\n\nThen, the equation becomes:\n\n$$a^{np - q} \\equiv b \\pmod m.$$\n\nUsing the fact that $a$ and $m$ are relatively prime, we obtain:\n\n$$a^{np} \\equiv ba^q \\pmod m$$\n\nThis new equation can be rewritten in a simplified form:\n\n$$f_1(p) = f_2(q).$$\n\nThis problem can be solved using the meet-in-the-middle method as follows:\n\n* Calculate $f_1$ for all possible arguments $p$. Sort the array of value-argument pairs.\n* For all possible arguments $q$, calculate $f_2$ and look for the corresponding $p$ in the sorted array using binary search.\n\n## Complexity\n\nWe can calculate $f_1(p)$ in $O(\\log m)$ using the [binary exponentiation algorithm](binary-exp.md). Similarly for $f_2(q)$.\n\nIn the first step of the algorithm, we need to calculate $f_1$ for every possible argument $p$ and then sort the values. Thus, this step has complexity:\n\n$$O\\left(\\left\\lceil \\frac{m}{n} \\right\\rceil \\left(\\log m + \\log \\left\\lceil \\frac{m}{n} \\right\\rceil \\right)\\right) = O\\left( \\left\\lceil \\frac {m}{n} \\right\\rceil \\log m\\right)$$\n\nIn the second step of the algorithm, we need to calculate $f_2(q)$ for every possible argument $q$ and then do a binary search on the array of values of $f_1$, thus this step has complexity:\n\n$$O\\left(n \\left(\\log m + \\log \\frac{m}{n} \\right) \\right) = O\\left(n \\log m\\right).$$\n\nNow, when we add these two complexities, we get $\\log m$ multiplied by the sum of $n$ and $m/n$, which is minimal when $n = m/n$, which means, to achieve optimal performance, $n$ should be chosen such that:\n\n$$n = \\sqrt{m}.$$\n\nThen, the complexity of the algorithm becomes:\n\n$$O(\\sqrt {m} \\log m).$$\n\n## Implementation\n\n### The simplest implementation\n\nIn the following code, the function `powmod` calculates $a^b \\pmod m$ and the function `solve` produces a proper solution to the problem.\nIt returns $-1$ if there is no solution and returns one of the possible solutions otherwise.\n\n```cpp\nint powmod(int a, int b, int m) {\n    int res = 1;\n    while (b > 0) {\n        if (b & 1) {\n            res = (res * 1ll * a) % m;\n        }\n        a = (a * 1ll * a) % m;\n        b >>= 1;\n    }\n    return res;\n}\n\nint solve(int a, int b, int m) {\n    a %= m, b %= m;\n    int n = sqrt(m) + 1;\n    map<int, int> vals;\n    for (int p = 1; p <= n; ++p)\n        vals[powmod(a, p * n, m)] = p;\n    for (int q = 0; q <= n; ++q) {\n        int cur = (powmod(a, q, m) * 1ll * b) % m;\n        if (vals.count(cur)) {\n            int ans = vals[cur] * n - q;\n            return ans;\n        }\n    }\n    return -1;\n}\n```\n\nIn this code, we used `map` from the C++ standard library to store the values of $f_1$.\nInternally, `map` uses a red-black tree to store values.\nThus this code is a little bit slower than if we had used an array and binary searched, but is much easier to write.\n\nNotice that our code assumes $0^0 = 1$, i.e. the code will compute $0$ as solution for the equation $0^x \\equiv 1 \\pmod m$ and also as solution for $0^x \\equiv 0 \\pmod 1$.\nThis is an often used convention in algebra, but it's also not universally accepted in all areas.\nSometimes $0^0$ is simply undefined.\nIf you don't like our convention, then you need to handle the case $a=0$ separately:\n\n```cpp\n    if (a == 0)\n        return b == 0 ? 1 : -1;\n```\n\nAnother thing to note is that, if there are multiple arguments $p$ that map to the same value of $f_1$, we only store one such argument.\nThis works in this case because we only want to return one possible solution.\nIf we need to return all possible solutions, we need to change `map<int, int>` to, say, `map<int, vector<int>>`.\nWe also need to change the second step accordingly.\n\n## Improved implementation\n\nA possible improvement is to get rid of binary exponentiation.\nThis can be done by keeping a variable that is multiplied by $a$ each time we increase $q$ and a variable that is multiplied by $a^n$ each time we increase $p$.\nWith this change, the complexity of the algorithm is still the same, but now the $\\log$ factor is only for the `map`.\nInstead of a `map`, we can also use a hash table (`unordered_map` in C++) which has the average time complexity $O(1)$ for inserting and searching.\n\nProblems often ask for the minimum $x$ which satisfies the solution.  \nIt is possible to get all answers and take the minimum, or reduce the first found answer using [Euler's theorem](phi-function.md#toc-tgt-2), but we can be smart about the order in which we calculate values and ensure the first answer we find is the minimum.\n\n```{.cpp file=discrete_log}\n// Returns minimum x for which a ^ x % m = b % m, a and m are coprime.\nint solve(int a, int b, int m) {\n    a %= m, b %= m;\n    int n = sqrt(m) + 1;\n\n    int an = 1;\n    for (int i = 0; i < n; ++i)\n        an = (an * 1ll * a) % m;\n\n    unordered_map<int, int> vals;\n    for (int q = 0, cur = b; q <= n; ++q) {\n        vals[cur] = q;\n        cur = (cur * 1ll * a) % m;\n    }\n\n    for (int p = 1, cur = 1; p <= n; ++p) {\n        cur = (cur * 1ll * an) % m;\n        if (vals.count(cur)) {\n            int ans = n * p - vals[cur];\n            return ans;\n        }\n    }\n    return -1;\n}\n```\n\nThe complexity is $O(\\sqrt{m})$ using `unordered_map`.\n\n## When $a$ and $m$ are not coprime { data-toc-label='When a and m are not coprime' }\nLet $g = \\gcd(a, m)$, and $g > 1$. Clearly $a^x \\bmod m$ for every $x \\ge 1$ will be divisible by $g$.\n\nIf $g \\nmid b$, there is no solution for $x$.\n\nIf $g \\mid b$, let $a = g \\alpha, b = g \\beta, m = g \\nu$.\n\n$$\n\\begin{aligned}\na^x & \\equiv b \\mod m \\\\\\\n(g \\alpha) a^{x - 1} & \\equiv g \\beta \\mod g \\nu \\\\\\\n\\alpha a^{x-1} & \\equiv \\beta \\mod \\nu\n\\end{aligned}\n$$\n\nThe baby-step giant-step algorithm can be easily extended to solve $ka^{x} \\equiv b \\pmod m$ for $x$.\n\n```{.cpp file=discrete_log_extended}\n// Returns minimum x for which a ^ x % m = b % m.\nint solve(int a, int b, int m) {\n    a %= m, b %= m;\n    int k = 1, add = 0, g;\n    while ((g = gcd(a, m)) > 1) {\n        if (b == k)\n            return add;\n        if (b % g)\n            return -1;\n        b /= g, m /= g, ++add;\n        k = (k * 1ll * a / g) % m;\n    }\n\n    int n = sqrt(m) + 1;\n    int an = 1;\n    for (int i = 0; i < n; ++i)\n        an = (an * 1ll * a) % m;\n\n    unordered_map<int, int> vals;\n    for (int q = 0, cur = b; q <= n; ++q) {\n        vals[cur] = q;\n        cur = (cur * 1ll * a) % m;\n    }\n\n    for (int p = 1, cur = k; p <= n; ++p) {\n        cur = (cur * 1ll * an) % m;\n        if (vals.count(cur)) {\n            int ans = n * p - vals[cur] + add;\n            return ans;\n        }\n    }\n    return -1;\n}\n```\n\nThe time complexity remains $O(\\sqrt{m})$ as before since the initial reduction to coprime $a$ and $m$ is done in $O(\\log^2 m)$.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: discrete_log\n---\n\n# Discrete Logarithm\n\nThe discrete logarithm is an integer $x$ satisfying the equation\n\n$$a^x \\equiv b \\pmod m$$\n\nfor given integers $a$, $b$ and $m$.\n\nThe discrete logarithm does not always exist, for instance there is no solution to $2^x \\equiv 3 \\pmod 7$. There is no simple condition to determine if the discrete logarithm exists.\n\nIn this article, we describe the **Baby-step giant-step** algorithm, an algorithm to compute the discrete logarithm proposed by Shanks in 1971, which has the time complexity $O(\\sqrt{m})$. This is a **meet-in-the-middle** algorithm because it uses the technique of separating tasks in half.\n\n## Algorithm\n\nConsider the equation:\n\n$$a^x \\equiv b \\pmod m,$$\n\nwhere $a$ and $m$ are relatively prime.\n\nLet $x = np - q$, where $n$ is some pre-selected constant (we will describe how to select $n$ later). $p$ is known as **giant step**, since increasing it by one increases $x$ by $n$. Similarly, $q$ is known as **baby step**.\n\nObviously, any number $x$ in the interval $[0; m)$ can be represented in this form, where $p \\in [1; \\lceil \\frac{m}{n} \\rceil ]$ and $q \\in [0; n]$.\n\nThen, the equation becomes:\n\n$$a^{np - q} \\equiv b \\pmod m.$$\n\nUsing the fact that $a$ and $m$ are relatively prime, we obtain:\n\n$$a^{np} \\equiv ba^q \\pmod m$$\n\nThis new equation can be rewritten in a simplified form:\n\n$$f_1(p) = f_2(q).$$\n\nThis problem can be solved using the meet-in-the-middle method as follows:\n\n* Calculate $f_1$ for all possible arguments $p$. Sort the array of value-argument pairs.\n* For all possible arguments $q$, calculate $f_2$ and look for the corresponding $p$ in the sorted array using binary search.\n\n## Complexity\n\nWe can calculate $f_1(p)$ in $O(\\log m)$ using the [binary exponentiation algorithm](binary-exp.md). Similarly for $f_2(q)$.\n\nIn the first step of the algorithm, we need to calculate $f_1$ for every possible argument $p$ and then sort the values. Thus, this step has complexity:\n\n$$O\\left(\\left\\lceil \\frac{m}{n} \\right\\rceil \\left(\\log m + \\log \\left\\lceil \\frac{m}{n} \\right\\rceil \\right)\\right) = O\\left( \\left\\lceil \\frac {m}{n} \\right\\rceil \\log m\\right)$$\n\nIn the second step of the algorithm, we need to calculate $f_2(q)$ for every possible argument $q$ and then do a binary search on the array of values of $f_1$, thus this step has complexity:\n\n$$O\\left(n \\left(\\log m + \\log \\frac{m}{n} \\right) \\right) = O\\left(n \\log m\\right).$$\n\nNow, when we add these two complexities, we get $\\log m$ multiplied by the sum of $n$ and $m/n$, which is minimal when $n = m/n$, which means, to achieve optimal performance, $n$ should be chosen such that:\n\n$$n = \\sqrt{m}.$$\n\nThen, the complexity of the algorithm becomes:\n\n$$O(\\sqrt {m} \\log m).$$\n\n## Implementation\n\n### The simplest implementation\n\nIn the following code, the function `powmod` calculates $a^b \\pmod m$ and the function `solve` produces a proper solution to the problem.\nIt returns $-1$ if there is no solution and returns one of the possible solutions otherwise.\n\n```cpp\nint powmod(int a, int b, int m) {\n    int res = 1;\n    while (b > 0) {\n        if (b & 1) {\n            res = (res * 1ll * a) % m;\n        }\n        a = (a * 1ll * a) % m;\n        b >>= 1;\n    }\n    return res;\n}\n\nint solve(int a, int b, int m) {\n    a %= m, b %= m;\n    int n = sqrt(m) + 1;\n    map<int, int> vals;\n    for (int p = 1; p <= n; ++p)\n        vals[powmod(a, p * n, m)] = p;\n    for (int q = 0; q <= n; ++q) {\n        int cur = (powmod(a, q, m) * 1ll * b) % m;\n        if (vals.count(cur)) {\n            int ans = vals[cur] * n - q;\n            return ans;\n        }\n    }\n    return -1;\n}\n```\n\nIn this code, we used `map` from the C++ standard library to store the values of $f_1$.\nInternally, `map` uses a red-black tree to store values.\nThus this code is a little bit slower than if we had used an array and binary searched, but is much easier to write.\n\nNotice that our code assumes $0^0 = 1$, i.e. the code will compute $0$ as solution for the equation $0^x \\equiv 1 \\pmod m$ and also as solution for $0^x \\equiv 0 \\pmod 1$.\nThis is an often used convention in algebra, but it's also not universally accepted in all areas.\nSometimes $0^0$ is simply undefined.\nIf you don't like our convention, then you need to handle the case $a=0$ separately:\n\n```cpp\n    if (a == 0)\n        return b == 0 ? 1 : -1;\n```\n\nAnother thing to note is that, if there are multiple arguments $p$ that map to the same value of $f_1$, we only store one such argument.\nThis works in this case because we only want to return one possible solution.\nIf we need to return all possible solutions, we need to change `map<int, int>` to, say, `map<int, vector<int>>`.\nWe also need to change the second step accordingly.\n\n## Improved implementation\n\nA possible improvement is to get rid of binary exponentiation.\nThis can be done by keeping a variable that is multiplied by $a$ each time we increase $q$ and a variable that is multiplied by $a^n$ each time we increase $p$.\nWith this change, the complexity of the algorithm is still the same, but now the $\\log$ factor is only for the `map`.\nInstead of a `map`, we can also use a hash table (`unordered_map` in C++) which has the average time complexity $O(1)$ for inserting and searching.\n\nProblems often ask for the minimum $x$ which satisfies the solution.  \nIt is possible to get all answers and take the minimum, or reduce the first found answer using [Euler's theorem](phi-function.md#toc-tgt-2), but we can be smart about the order in which we calculate values and ensure the first answer we find is the minimum.\n\n```{.cpp file=discrete_log}\n// Returns minimum x for which a ^ x % m = b % m, a and m are coprime.\nint solve(int a, int b, int m) {\n    a %= m, b %= m;\n    int n = sqrt(m) + 1;\n\n    int an = 1;\n    for (int i = 0; i < n; ++i)\n        an = (an * 1ll * a) % m;\n\n    unordered_map<int, int> vals;\n    for (int q = 0, cur = b; q <= n; ++q) {\n        vals[cur] = q;\n        cur = (cur * 1ll * a) % m;\n    }\n\n    for (int p = 1, cur = 1; p <= n; ++p) {\n        cur = (cur * 1ll * an) % m;\n        if (vals.count(cur)) {\n            int ans = n * p - vals[cur];\n            return ans;\n        }\n    }\n    return -1;\n}\n```\n\nThe complexity is $O(\\sqrt{m})$ using `unordered_map`.\n\n## When $a$ and $m$ are not coprime { data-toc-label='When a and m are not coprime' }\nLet $g = \\gcd(a, m)$, and $g > 1$. Clearly $a^x \\bmod m$ for every $x \\ge 1$ will be divisible by $g$.\n\nIf $g \\nmid b$, there is no solution for $x$.\n\nIf $g \\mid b$, let $a = g \\alpha, b = g \\beta, m = g \\nu$.\n\n$$\n\\begin{aligned}\na^x & \\equiv b \\mod m \\\\\\\n(g \\alpha) a^{x - 1} & \\equiv g \\beta \\mod g \\nu \\\\\\\n\\alpha a^{x-1} & \\equiv \\beta \\mod \\nu\n\\end{aligned}\n$$\n\nThe baby-step giant-step algorithm can be easily extended to solve $ka^{x} \\equiv b \\pmod m$ for $x$.\n\n```{.cpp file=discrete_log_extended}\n// Returns minimum x for which a ^ x % m = b % m.\nint solve(int a, int b, int m) {\n    a %= m, b %= m;\n    int k = 1, add = 0, g;\n    while ((g = gcd(a, m)) > 1) {\n        if (b == k)\n            return add;\n        if (b % g)\n            return -1;\n        b /= g, m /= g, ++add;\n        k = (k * 1ll * a / g) % m;\n    }\n\n    int n = sqrt(m) + 1;\n    int an = 1;\n    for (int i = 0; i < n; ++i)\n        an = (an * 1ll * a) % m;\n\n    unordered_map<int, int> vals;\n    for (int q = 0, cur = b; q <= n; ++q) {\n        vals[cur] = q;\n        cur = (cur * 1ll * a) % m;\n    }\n\n    for (int p = 1, cur = k; p <= n; ++p) {\n        cur = (cur * 1ll * an) % m;\n        if (vals.count(cur)) {\n            int ans = n * p - vals[cur] + add;\n            return ans;\n        }\n    }\n    return -1;\n}\n```\n\nThe time complexity remains $O(\\sqrt{m})$ as before since the initial reduction to coprime $a$ and $m$ is done in $O(\\log^2 m)$.\n\n## Practice Problems\n* [Spoj - Power Modulo Inverted](http://www.spoj.com/problems/MOD/)\n* [Topcoder - SplittingFoxes3](https://community.topcoder.com/stat?c=problem_statement&pm=14386&rd=16801)\n* [CodeChef - Inverse of a Function](https://www.codechef.com/problems/INVXOR/)\n* [Hard Equation](https://codeforces.com/gym/101853/problem/G) (assume that $0^0$ is undefined)\n* [CodeChef - Chef and Modular Sequence](https://www.codechef.com/problems/CHEFMOD)\n\n## References\n* [Wikipedia - Baby-step giant-step](https://en.wikipedia.org/wiki/Baby-step_giant-step)\n* [Answer by Zander on Mathematics StackExchange](https://math.stackexchange.com/a/133054)\n", "problem_ids": [], "title": "Discrete Logarithm"}, {"article": "---\ntitle: Factorial modulo p\ntags:\n  - Translated\ne_maxx_link: modular_factorial\n---\n\n# Factorial modulo $p$\n\nIn some cases it is necessary to consider complex formulas modulo some prime $p$, containing factorials in both numerator and denominator, like such that you encounter in the formula for Binomial coefficients.\nWe consider the case when $p$ is relatively small.\nThis problem makes only sense when the factorials appear in both numerator and denominator of fractions.\nOtherwise $p!$ and subsequent terms will reduce to zero.\nBut in fractions the factors of $p$ can cancel, and the resulting expression will be non-zero modulo $p$.\n\nThus, formally the task is: You want to calculate $n! \\bmod p$, without taking all the multiple factors of $p$ into account that appear in the factorial.\nImaging you write down the prime factorization of $n!$, remove all factors $p$, and compute the product modulo $p$.\nWe will denote this *modified* factorial with $n!_{\\%p}$.\nFor instance $7!_{\\%p} \\equiv 1 \\cdot 2 \\cdot \\underbrace{1}_{3} \\cdot 4 \\cdot 5 \\underbrace{2}_{6} \\cdot 7 \\equiv 2 \\bmod 3$.\n\nLearning how to effectively calculate this modified factorial allows us to quickly calculate the value of the various combinatorial formulas (for example, [Binomial coefficients](../combinatorics/binomial-coefficients.md)).\n\n## Algorithm\nLet's write this modified factorial explicitly.\n\n$$\\begin{eqnarray}\nn!_{\\%p} &=& 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot \\underbrace{1}_{p} \\cdot (p+1) \\cdot (p+2) \\cdot \\ldots \\cdot (2p-1) \\cdot \\underbrace{2}_{2p} \\\\\\\n & &\\quad \\cdot (2p+1) \\cdot \\ldots \\cdot (p^2-1) \\cdot \\underbrace{1}_{p^2} \\cdot (p^2 +1) \\cdot \\ldots \\cdot n \\pmod{p} \\\\\\\\\n&=& 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot \\underbrace{1}_{p} \\cdot 1 \\cdot 2 \\cdot \\ldots \\cdot (p-1) \\cdot \\underbrace{2}_{2p} \\cdot 1 \\cdot 2 \\\\\\\n& &\\quad \\cdot \\ldots \\cdot (p-1) \\cdot \\underbrace{1}_{p^2} \\cdot 1 \\cdot 2 \\cdot \\ldots \\cdot (n \\bmod p) \\pmod{p}\n\\end{eqnarray}$$\n\nIt can be clearly seen that factorial is divided into several blocks of same length except for the last one.\n\n$$\\begin{eqnarray}\nn!_{\\%p}&=& \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 1}_{1\\text{st}} \\cdot \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 2}_{2\\text{nd}} \\cdot \\ldots \\\\\\\\\n& & \\cdot \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 1}_{p\\text{th}} \\cdot \\ldots \\cdot \\quad \\underbrace{1 \\cdot 2 \\cdot \\cdot \\ldots \\cdot (n \\bmod p)}_{\\text{tail}} \\pmod{p}.\n\\end{eqnarray}$$\n\nThe main part of the blocks it is easy to count \u2014 it's just $(p-1)!\\ \\mathrm{mod}\\ p$.\nWe can compute that programmatically or just apply Wilson theorem which states that $(p-1)! \\bmod p = -1$ for any prime $p$.\n\nWe have exactly $\\lfloor \\frac{n}{p} \\rfloor$ such blocks, therefore we need to raise $-1$ to the power of $\\lfloor \\frac{n}{p} \\rfloor$.\nThis can be done in logarithmic time using [Binary Exponentiation](binary-exp.md); however you can also notice that the result will switch between $-1$ and $1$, so we only need to look at the parity of the exponent and multiply by $-1$ if the parity is odd.\nAnd instead of a multiplication, we can also just subtract the current result from $p$.\n\nThe value of the last partial block can be calculated separately in $O(p)$.\n\n\nThis leaves only the last element of each block.\nIf we hide the already handled elements, we can see the following pattern:\n\n$$n!_{\\%p} = \\underbrace{ \\ldots \\cdot 1 } \\cdot \\underbrace{ \\ldots \\cdot 2} \\cdot \\ldots \\cdot \\underbrace{ \\ldots \\cdot (p-1)} \\cdot \\underbrace{ \\ldots \\cdot 1 } \\cdot \\underbrace{ \\ldots \\cdot 1} \\cdot \\underbrace{ \\ldots \\cdot 2} \\cdots$$\n\nThis again is a *modified* factorial, only with a much smaller dimension.\nIt's $\\lfloor n / p \\rfloor !_{\\%p}$.\n\nThus, during the calculation of the *modified* factorial $n\\!_{\\%p}$ we did $O(p)$ operations and are left with the calculation of $\\lfloor n / p \\rfloor !_{\\%p}$.\nWe have a recursive formula.\nThe recursion depth is $O(\\log_p n)$, and therefore the complete asymptotic behavior of the algorithm is $O(p \\log_p n)$.\n\nNotice, if you precompute the factorials $0!,~ 1!,~ 2!,~ \\dots,~ (p-1)!$ modulo $p$, then the complexity will just be $O(\\log_p n)$.\n\n\n## Implementation\n\nWe don't need recursion because this is a case of tail recursion and thus can be easily implemented using iteration.\nIn the following implementation we precompute the factorials $0!,~ 1!,~ \\dots,~ (p-1)!$, and thus have the runtime $O(p + \\log_p n)$.\nIf you need to call the function multiple times, then you can do the precomputation outside of the function and do the computation of $n!_{\\%p}$ in $O(\\log_p n)$ time.\n\n```cpp\nint factmod(int n, int p) {\n    vector<int> f(p);\n    f[0] = 1;\n    for (int i = 1; i < p; i++)\n        f[i] = f[i-1] * i % p;\n\n    int res = 1;\n    while (n > 1) {\n        if ((n/p) % 2)\n            res = p - res;\n        res = res * f[n%p] % p;\n        n /= p;\n    }\n    return res;\n}\n```\n\nAlternative, if you only have limit memory and can't afford storing all factorials, you can also just remember the factorials that you need, sort them, and then compute them in one sweep by computing the factorials $0!,~ 1!,~ 2!,~ \\dots,~ (p-1)!$ in a loop without storing them explicitly.\n\n## Multiplicity of $p$\n\nIf we want to compute a Binomial coefficient modulo $p$, then we additionally need the multiplicity of the $p$ in $n$, i.e. the number of times $p$ occurs in the prime factorization of $n$, or number of times we erased $p$ during the computation of the *modified* factorial.\n\n[Legendre's formula](https://en.wikipedia.org/wiki/Legendre%27s_formula) gives us a way to compute this in $O(\\log_p n)$ time.\nThe formula gives the multiplicity $\\nu_p$ as:\n\n$$\\nu_p(n!) = \\sum_{i=1}^{\\infty} \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor$$\n\nThus we get the implementation:\n\n```cpp\nint multiplicity_factorial(int n, int p) {\n    int count = 0;\n    do {\n        n /= p;\n        count += n;\n    } while (n);\n    return count;\n}\n```\n\nThis formula can be proven very easily using the same ideas that we did in the previous sections.\nRemove all elements that don't contain the factor $p$.\nThis leaves $\\lfloor n/p \\rfloor$ element remaining.\nIf we remove the factor $p$ from each of them, we get the product $1 \\cdot 2 \\cdots \\lfloor n/p \\rfloor = \\lfloor n/p \\rfloor !$, and again we have a recursion.\n", "full_article": "---\ntitle: Factorial modulo p\ntags:\n  - Translated\ne_maxx_link: modular_factorial\n---\n\n# Factorial modulo $p$\n\nIn some cases it is necessary to consider complex formulas modulo some prime $p$, containing factorials in both numerator and denominator, like such that you encounter in the formula for Binomial coefficients.\nWe consider the case when $p$ is relatively small.\nThis problem makes only sense when the factorials appear in both numerator and denominator of fractions.\nOtherwise $p!$ and subsequent terms will reduce to zero.\nBut in fractions the factors of $p$ can cancel, and the resulting expression will be non-zero modulo $p$.\n\nThus, formally the task is: You want to calculate $n! \\bmod p$, without taking all the multiple factors of $p$ into account that appear in the factorial.\nImaging you write down the prime factorization of $n!$, remove all factors $p$, and compute the product modulo $p$.\nWe will denote this *modified* factorial with $n!_{\\%p}$.\nFor instance $7!_{\\%p} \\equiv 1 \\cdot 2 \\cdot \\underbrace{1}_{3} \\cdot 4 \\cdot 5 \\underbrace{2}_{6} \\cdot 7 \\equiv 2 \\bmod 3$.\n\nLearning how to effectively calculate this modified factorial allows us to quickly calculate the value of the various combinatorial formulas (for example, [Binomial coefficients](../combinatorics/binomial-coefficients.md)).\n\n## Algorithm\nLet's write this modified factorial explicitly.\n\n$$\\begin{eqnarray}\nn!_{\\%p} &=& 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot \\underbrace{1}_{p} \\cdot (p+1) \\cdot (p+2) \\cdot \\ldots \\cdot (2p-1) \\cdot \\underbrace{2}_{2p} \\\\\\\n & &\\quad \\cdot (2p+1) \\cdot \\ldots \\cdot (p^2-1) \\cdot \\underbrace{1}_{p^2} \\cdot (p^2 +1) \\cdot \\ldots \\cdot n \\pmod{p} \\\\\\\\\n&=& 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot \\underbrace{1}_{p} \\cdot 1 \\cdot 2 \\cdot \\ldots \\cdot (p-1) \\cdot \\underbrace{2}_{2p} \\cdot 1 \\cdot 2 \\\\\\\n& &\\quad \\cdot \\ldots \\cdot (p-1) \\cdot \\underbrace{1}_{p^2} \\cdot 1 \\cdot 2 \\cdot \\ldots \\cdot (n \\bmod p) \\pmod{p}\n\\end{eqnarray}$$\n\nIt can be clearly seen that factorial is divided into several blocks of same length except for the last one.\n\n$$\\begin{eqnarray}\nn!_{\\%p}&=& \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 1}_{1\\text{st}} \\cdot \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 2}_{2\\text{nd}} \\cdot \\ldots \\\\\\\\\n& & \\cdot \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 1}_{p\\text{th}} \\cdot \\ldots \\cdot \\quad \\underbrace{1 \\cdot 2 \\cdot \\cdot \\ldots \\cdot (n \\bmod p)}_{\\text{tail}} \\pmod{p}.\n\\end{eqnarray}$$\n\nThe main part of the blocks it is easy to count \u2014 it's just $(p-1)!\\ \\mathrm{mod}\\ p$.\nWe can compute that programmatically or just apply Wilson theorem which states that $(p-1)! \\bmod p = -1$ for any prime $p$.\n\nWe have exactly $\\lfloor \\frac{n}{p} \\rfloor$ such blocks, therefore we need to raise $-1$ to the power of $\\lfloor \\frac{n}{p} \\rfloor$.\nThis can be done in logarithmic time using [Binary Exponentiation](binary-exp.md); however you can also notice that the result will switch between $-1$ and $1$, so we only need to look at the parity of the exponent and multiply by $-1$ if the parity is odd.\nAnd instead of a multiplication, we can also just subtract the current result from $p$.\n\nThe value of the last partial block can be calculated separately in $O(p)$.\n\n\nThis leaves only the last element of each block.\nIf we hide the already handled elements, we can see the following pattern:\n\n$$n!_{\\%p} = \\underbrace{ \\ldots \\cdot 1 } \\cdot \\underbrace{ \\ldots \\cdot 2} \\cdot \\ldots \\cdot \\underbrace{ \\ldots \\cdot (p-1)} \\cdot \\underbrace{ \\ldots \\cdot 1 } \\cdot \\underbrace{ \\ldots \\cdot 1} \\cdot \\underbrace{ \\ldots \\cdot 2} \\cdots$$\n\nThis again is a *modified* factorial, only with a much smaller dimension.\nIt's $\\lfloor n / p \\rfloor !_{\\%p}$.\n\nThus, during the calculation of the *modified* factorial $n\\!_{\\%p}$ we did $O(p)$ operations and are left with the calculation of $\\lfloor n / p \\rfloor !_{\\%p}$.\nWe have a recursive formula.\nThe recursion depth is $O(\\log_p n)$, and therefore the complete asymptotic behavior of the algorithm is $O(p \\log_p n)$.\n\nNotice, if you precompute the factorials $0!,~ 1!,~ 2!,~ \\dots,~ (p-1)!$ modulo $p$, then the complexity will just be $O(\\log_p n)$.\n\n\n## Implementation\n\nWe don't need recursion because this is a case of tail recursion and thus can be easily implemented using iteration.\nIn the following implementation we precompute the factorials $0!,~ 1!,~ \\dots,~ (p-1)!$, and thus have the runtime $O(p + \\log_p n)$.\nIf you need to call the function multiple times, then you can do the precomputation outside of the function and do the computation of $n!_{\\%p}$ in $O(\\log_p n)$ time.\n\n```cpp\nint factmod(int n, int p) {\n    vector<int> f(p);\n    f[0] = 1;\n    for (int i = 1; i < p; i++)\n        f[i] = f[i-1] * i % p;\n\n    int res = 1;\n    while (n > 1) {\n        if ((n/p) % 2)\n            res = p - res;\n        res = res * f[n%p] % p;\n        n /= p;\n    }\n    return res;\n}\n```\n\nAlternative, if you only have limit memory and can't afford storing all factorials, you can also just remember the factorials that you need, sort them, and then compute them in one sweep by computing the factorials $0!,~ 1!,~ 2!,~ \\dots,~ (p-1)!$ in a loop without storing them explicitly.\n\n## Multiplicity of $p$\n\nIf we want to compute a Binomial coefficient modulo $p$, then we additionally need the multiplicity of the $p$ in $n$, i.e. the number of times $p$ occurs in the prime factorization of $n$, or number of times we erased $p$ during the computation of the *modified* factorial.\n\n[Legendre's formula](https://en.wikipedia.org/wiki/Legendre%27s_formula) gives us a way to compute this in $O(\\log_p n)$ time.\nThe formula gives the multiplicity $\\nu_p$ as:\n\n$$\\nu_p(n!) = \\sum_{i=1}^{\\infty} \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor$$\n\nThus we get the implementation:\n\n```cpp\nint multiplicity_factorial(int n, int p) {\n    int count = 0;\n    do {\n        n /= p;\n        count += n;\n    } while (n);\n    return count;\n}\n```\n\nThis formula can be proven very easily using the same ideas that we did in the previous sections.\nRemove all elements that don't contain the factor $p$.\nThis leaves $\\lfloor n/p \\rfloor$ element remaining.\nIf we remove the factor $p$ from each of them, we get the product $1 \\cdot 2 \\cdots \\lfloor n/p \\rfloor = \\lfloor n/p \\rfloor !$, and again we have a recursion.\n", "problem_ids": [], "title": "Factorial modulo $p$"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: primitive_root\n---\n\n# Primitive Root\n\n## Definition\n\nIn modular arithmetic, a number $g$ is called a `primitive root modulo n` if every number coprime to $n$ is congruent to a power of $g$ modulo $n$. Mathematically, $g$ is a `primitive root modulo n` if and only if for any integer $a$ such that $\\gcd(a, n) = 1$, there exists an integer $k$ such that:\n\n$g^k \\equiv a \\pmod n$.\n\n$k$ is then called the `index` or `discrete logarithm` of $a$ to the base $g$ modulo $n$. $g$ is also called the `generator` of the multiplicative group of integers modulo $n$.\n\nIn particular, for the case where $n$ is a prime, the powers of primitive root runs through all numbers from $1$ to $n-1$.\n\n## Existence\n\nPrimitive root modulo $n$ exists if and only if:\n\n* $n$ is 1, 2, 4, or\n* $n$ is power of an odd prime number $(n = p^k)$, or\n* $n$ is twice power of an odd prime number $(n = 2 \\cdot p^k)$.\n\nThis theorem was proved by Gauss in 1801.\n\n## Relation with the Euler function\n\nLet $g$ be a primitive root modulo $n$. Then we can show that the smallest number $k$ for which $g^k \\equiv 1 \\pmod n$ is equal $\\phi (n)$. Moreover, the reverse is also true, and this fact will be used in this article to find a primitive root.\n\nFurthermore, the number of primitive roots modulo $n$, if there are any, is equal to $\\phi (\\phi (n) )$.\n\n## Algorithm for finding a primitive root\n\nA naive algorithm is to consider all numbers in range $[1, n-1]$. And then check if each one is a primitive root, by calculating all its power to see if they are all different. This algorithm has complexity $O(g \\cdot n)$, which would be too slow. In this section, we propose a faster algorithm using several well-known theorems.\n\nFrom previous section, we know that if the smallest number $k$ for which $g^k \\equiv 1 \\pmod n$ is $\\phi (n)$, then $g$ is a primitive root. Since for any number $a$ relative prime to $n$, we know from Euler's theorem that $a ^ { \\phi (n) } \\equiv 1 \\pmod n$, then to check if $g$ is primitive root, it is enough to check that for all $d$ less than $\\phi (n)$, $g^d \\not \\equiv 1 \\pmod n$. However, this algorithm is still too slow.\n\nFrom Lagrange's theorem, we know that the index of 1 of any number modulo $n$ must be a divisor of $\\phi (n)$. Thus, it is sufficient to verify for all proper divisor $d \\mid \\phi (n)$ that $g^d \\not \\equiv 1 \\pmod n$. This is already a much faster algorithm, but we can still do better.\n\nFactorize $\\phi (n) = p_1 ^ {a_1} \\cdots p_s ^ {a_s}$. We prove that in the previous algorithm, it is sufficient to consider only the values of $d$ which have the form $\\frac { \\phi (n) } {p_j}$. Indeed, let $d$ be any proper divisor of $\\phi (n)$. Then, obviously, there exists such $j$ that $d \\mid \\frac { \\phi (n) } {p_j}$, i.e. $d \\cdot k = \\frac { \\phi (n) } {p_j}$. However, if $g^d \\equiv 1 \\pmod n$, we would get:\n\n$g ^ { \\frac { \\phi (n)} {p_j} } \\equiv g ^ {d \\cdot k} \\equiv (g^d) ^k \\equiv 1^k \\equiv 1 \\pmod n$.\n\ni.e. among the numbers of the form $\\frac {\\phi (n)} {p_i}$, there would be at least one such that the conditions were not met.\n\nNow we have a complete algorithm for finding the primitive root:\n\n* First, find $\\phi (n)$ and factorize it.\n* Then iterate through all numbers $g \\in [1, n]$, and for each number, to check if it is primitive root, we do the following:\n\n    * Calculate all $g ^ { \\frac {\\phi (n)} {p_i}} \\pmod n$.\n    * If all the calculated values are different from $1$, then $g$ is a primitive root.\n\n    Running time of this algorithm is $O(Ans \\cdot \\log \\phi (n) \\cdot \\log n)$ (assume that $\\phi (n)$ has $\\log \\phi (n)$ divisors).\n\nShoup (1990, 1992) proved, assuming the [generalized Riemann hypothesis](http://en.wikipedia.org/wiki/Generalized_Riemann_hypothesis), that $g$ is $O(\\log^6 p)$.\n\n## Implementation\n\nThe following code assumes that the modulo `p` is a prime number. To make it works for any value of `p`, we must add calculation of $\\phi (p)$. \n\n```cpp\nint powmod (int a, int b, int p) {\n\tint res = 1;\n\twhile (b)\n\t\tif (b & 1)\n\t\t\tres = int (res * 1ll * a % p),  --b;\n\t\telse\n\t\t\ta = int (a * 1ll * a % p),  b >>= 1;\n\treturn res;\n}\n \nint generator (int p) {\n\tvector<int> fact;\n\tint phi = p-1,  n = phi;\n\tfor (int i=2; i*i<=n; ++i)\n\t\tif (n % i == 0) {\n\t\t\tfact.push_back (i);\n\t\t\twhile (n % i == 0)\n\t\t\t\tn /= i;\n\t\t}\n\tif (n > 1)\n\t\tfact.push_back (n);\n \n\tfor (int res=2; res<=p; ++res) {\n\t\tbool ok = true;\n\t\tfor (size_t i=0; i<fact.size() && ok; ++i)\n\t\t\tok &= powmod (res, phi / fact[i], p) != 1;\n\t\tif (ok)  return res;\n\t}\n\treturn -1;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: primitive_root\n---\n\n# Primitive Root\n\n## Definition\n\nIn modular arithmetic, a number $g$ is called a `primitive root modulo n` if every number coprime to $n$ is congruent to a power of $g$ modulo $n$. Mathematically, $g$ is a `primitive root modulo n` if and only if for any integer $a$ such that $\\gcd(a, n) = 1$, there exists an integer $k$ such that:\n\n$g^k \\equiv a \\pmod n$.\n\n$k$ is then called the `index` or `discrete logarithm` of $a$ to the base $g$ modulo $n$. $g$ is also called the `generator` of the multiplicative group of integers modulo $n$.\n\nIn particular, for the case where $n$ is a prime, the powers of primitive root runs through all numbers from $1$ to $n-1$.\n\n## Existence\n\nPrimitive root modulo $n$ exists if and only if:\n\n* $n$ is 1, 2, 4, or\n* $n$ is power of an odd prime number $(n = p^k)$, or\n* $n$ is twice power of an odd prime number $(n = 2 \\cdot p^k)$.\n\nThis theorem was proved by Gauss in 1801.\n\n## Relation with the Euler function\n\nLet $g$ be a primitive root modulo $n$. Then we can show that the smallest number $k$ for which $g^k \\equiv 1 \\pmod n$ is equal $\\phi (n)$. Moreover, the reverse is also true, and this fact will be used in this article to find a primitive root.\n\nFurthermore, the number of primitive roots modulo $n$, if there are any, is equal to $\\phi (\\phi (n) )$.\n\n## Algorithm for finding a primitive root\n\nA naive algorithm is to consider all numbers in range $[1, n-1]$. And then check if each one is a primitive root, by calculating all its power to see if they are all different. This algorithm has complexity $O(g \\cdot n)$, which would be too slow. In this section, we propose a faster algorithm using several well-known theorems.\n\nFrom previous section, we know that if the smallest number $k$ for which $g^k \\equiv 1 \\pmod n$ is $\\phi (n)$, then $g$ is a primitive root. Since for any number $a$ relative prime to $n$, we know from Euler's theorem that $a ^ { \\phi (n) } \\equiv 1 \\pmod n$, then to check if $g$ is primitive root, it is enough to check that for all $d$ less than $\\phi (n)$, $g^d \\not \\equiv 1 \\pmod n$. However, this algorithm is still too slow.\n\nFrom Lagrange's theorem, we know that the index of 1 of any number modulo $n$ must be a divisor of $\\phi (n)$. Thus, it is sufficient to verify for all proper divisor $d \\mid \\phi (n)$ that $g^d \\not \\equiv 1 \\pmod n$. This is already a much faster algorithm, but we can still do better.\n\nFactorize $\\phi (n) = p_1 ^ {a_1} \\cdots p_s ^ {a_s}$. We prove that in the previous algorithm, it is sufficient to consider only the values of $d$ which have the form $\\frac { \\phi (n) } {p_j}$. Indeed, let $d$ be any proper divisor of $\\phi (n)$. Then, obviously, there exists such $j$ that $d \\mid \\frac { \\phi (n) } {p_j}$, i.e. $d \\cdot k = \\frac { \\phi (n) } {p_j}$. However, if $g^d \\equiv 1 \\pmod n$, we would get:\n\n$g ^ { \\frac { \\phi (n)} {p_j} } \\equiv g ^ {d \\cdot k} \\equiv (g^d) ^k \\equiv 1^k \\equiv 1 \\pmod n$.\n\ni.e. among the numbers of the form $\\frac {\\phi (n)} {p_i}$, there would be at least one such that the conditions were not met.\n\nNow we have a complete algorithm for finding the primitive root:\n\n* First, find $\\phi (n)$ and factorize it.\n* Then iterate through all numbers $g \\in [1, n]$, and for each number, to check if it is primitive root, we do the following:\n\n    * Calculate all $g ^ { \\frac {\\phi (n)} {p_i}} \\pmod n$.\n    * If all the calculated values are different from $1$, then $g$ is a primitive root.\n\n    Running time of this algorithm is $O(Ans \\cdot \\log \\phi (n) \\cdot \\log n)$ (assume that $\\phi (n)$ has $\\log \\phi (n)$ divisors).\n\nShoup (1990, 1992) proved, assuming the [generalized Riemann hypothesis](http://en.wikipedia.org/wiki/Generalized_Riemann_hypothesis), that $g$ is $O(\\log^6 p)$.\n\n## Implementation\n\nThe following code assumes that the modulo `p` is a prime number. To make it works for any value of `p`, we must add calculation of $\\phi (p)$. \n\n```cpp\nint powmod (int a, int b, int p) {\n\tint res = 1;\n\twhile (b)\n\t\tif (b & 1)\n\t\t\tres = int (res * 1ll * a % p),  --b;\n\t\telse\n\t\t\ta = int (a * 1ll * a % p),  b >>= 1;\n\treturn res;\n}\n \nint generator (int p) {\n\tvector<int> fact;\n\tint phi = p-1,  n = phi;\n\tfor (int i=2; i*i<=n; ++i)\n\t\tif (n % i == 0) {\n\t\t\tfact.push_back (i);\n\t\t\twhile (n % i == 0)\n\t\t\t\tn /= i;\n\t\t}\n\tif (n > 1)\n\t\tfact.push_back (n);\n \n\tfor (int res=2; res<=p; ++res) {\n\t\tbool ok = true;\n\t\tfor (size_t i=0; i<fact.size() && ok; ++i)\n\t\t\tok &= powmod (res, phi / fact[i], p) != 1;\n\t\tif (ok)  return res;\n\t}\n\treturn -1;\n}\n```\n", "problem_ids": [], "title": "Primitive Root"}, {"article": "---\ntags:\n  - Original\n---\n\n# Binary Exponentiation by Factoring\n\nConsider a problem of computing $ax^y \\pmod{2^d}$, given integers $a$, $x$, $y$ and $d \\geq 3$, where $x$ is odd.\n\nThe algorithm below allows to solve this problem with $O(d)$ additions and binary operations and a single multiplication by $y$.\n\nDue to the structure of the multiplicative group modulo $2^d$, any number $x$ such that $x \\equiv 1 \\pmod 4$ can be represented as\n\n$$\nx \\equiv b^{L(x)} \\pmod{2^d},\n$$\n\nwhere $b \\equiv 5 \\pmod 8$. Without loss of generality we assume that $x \\equiv 1 \\pmod 4$, as we can reduce $x \\equiv 3 \\pmod 4$ to $x \\equiv 1 \\pmod 4$ by substituting $x \\mapsto -x$ and $a \\mapsto (-1)^{y} a$. In this notion, $ax^y$ is represented as\n\n$$\na x^y \\equiv a b^{yL(x)} \\pmod{2^d}.\n$$\n\nThe core idea of the algorithm is to simplify the computation of $L(x)$ and $b^{y L(x)}$ using the fact that we're working modulo $2^d$. For reasons that will be apparent later on, we'll be working with $4L(x)$ rather than $L(x)$, but taken modulo $2^d$ instead of $2^{d-2}$.\n\nIn this article, we will cover the implementation for $32$-bit integers. Let\n\n* `mbin_log_32(r, x)` be a function that computes $r+4L(x) \\pmod{2^d}$;\n* `mbin_exp_32(r, x)` be a function that computes $r b^{\\frac{x}{4}} \\pmod{2^d}$;\n* `mbin_power_odd_32(a, x, y)` be a function that computes $ax^y \\pmod{2^d}$.\n\nThen `mbin_power_odd_32` is implemented as follows:\n\n```cpp\nuint32_t mbin_power_odd_32(uint32_t rem, uint32_t base, uint32_t exp) {\n    if (base & 2) {\n        /* divider is considered negative */\n        base = -base;\n        /* check if result should be negative */\n        if (exp & 1) {\n            rem = -rem;\n        }\n    }\n    return (mbin_exp_32(rem, mbin_log_32(0, base) * exp));\n}\n```\n\n## Computing 4L(x) from x\n\nLet $x$ be an odd number such that $x \\equiv 1 \\pmod 4$. It can be represented as \n\n$$\nx \\equiv (2^{a_1}+1)\\dots(2^{a_k}+1) \\pmod{2^d},\n$$\n\nwhere $1 < a_1 < \\dots < a_k < d$. Here $L(\\cdot)$ is well-defined for each multiplier, as they're equal to $1$ modulo $4$. Hence,\n\n$$\n4L(x) \\equiv 4L(2^{a_1}+1)+\\dots+4L(2^{a_k}+1) \\pmod{2^{d}}.\n$$\n\nSo, if we precompute $t_k = 4L(2^n+1)$ for all $1 < k < d$, we will be able to compute $4L(x)$ for any number $x$.\n\nFor 32-bit integers, we can use the following table:\n\n```cpp\nconst uint32_t mbin_log_32_table[32] = {\n    0x00000000, 0x00000000, 0xd3cfd984, 0x9ee62e18,\n    0xe83d9070, 0xb59e81e0, 0xa17407c0, 0xce601f80,\n    0xf4807f00, 0xe701fe00, 0xbe07fc00, 0xfc1ff800,\n    0xf87ff000, 0xf1ffe000, 0xe7ffc000, 0xdfff8000,\n    0xffff0000, 0xfffe0000, 0xfffc0000, 0xfff80000,\n    0xfff00000, 0xffe00000, 0xffc00000, 0xff800000,\n    0xff000000, 0xfe000000, 0xfc000000, 0xf8000000,\n    0xf0000000, 0xe0000000, 0xc0000000, 0x80000000,\n};\n```\n\nOn practice, a slightly different approach is used than described above. Rather than finding the factorization for $x$, we will consequently multiply $x$ with $2^n+1$ until we turn it into $1$ modulo $2^d$. In this way, we will find the representation of $x^{-1}$, that is\n\n$$\nx (2^{a_1}+1)\\dots(2^{a_k}+1) \\equiv 1 \\pmod {2^d}.\n$$\n\nTo do this, we iterate over $n$ such that $1 < n < d$. If the current $x$ has $n$-th bit set, we multiply $x$ with $2^n+1$, which is conveniently done in C++ as `x = x + (x << n)`. This won't change bits lower than $n$, but will turn the $n$-th bit to zero, because $x$ is odd.\n\nWith all this in mind, the function `mbin_log_32(r, x)` is implemented as follows:\n\n```cpp\nuint32_t mbin_log_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n < 32; n++) {\n        if (x & (1 << n)) {\n            x = x + (x << n);\n            r -= mbin_log_32_table[n];\n        }\n    }\n\n    return r;\n}\n```\n\nNote that $4L(x) = -4L(x^{-1})$, so instead of adding $4L(2^n+1)$, we subtract it from $r$, which initially equates to $0$.\n\n## Computing x from 4L(x)\n\nNote that for $k \\geq 1$ it holds that\n\n$$\n(a 2^{k}+1)^2 = a^2 2^{2k} +a 2^{k+1}+1 = b2^{k+1}+1,\n$$\n\nfrom which (by repeated squaring) we can deduce that\n\n$$\n(2^a+1)^{2^b} \\equiv 1 \\pmod{2^{a+b}}.\n$$\n\nApplying this result to $a=2^n+1$ and $b=d-k$ we deduce that the multiplicative order of $2^n+1$ is a divisor of $2^{d-n}$.\n\nThis, in turn, means that $L(2^n+1)$ must be divisible by $2^{n}$, as the order of $b$ is $2^{d-2}$ and the order of $b^y$ is $2^{d-2-v}$, where $2^v$ is the highest power of $2$ that divides $y$, so we need\n\n$$\n2^{d-k} \\equiv 0 \\pmod{2^{d-2-v}},\n$$\n\nthus $v$ must be greater or equal than $k-2$. This is a bit ugly and to mitigate this we said in the beginning that we multiply $L(x)$ by $4$. Now if we know $4L(x)$, we can uniquely decomposing it into a sum of $4L(2^n+1)$ by consequentially checking bits in $4L(x)$. If the $n$-th bit is set to $1$, we will multiply the result with $2^n+1$ and reduce the current $4L(x)$ by $4L(2^n+1)$.\n\nThus, `mbin_exp_32` is implemented as follows:\n\n```cpp\nuint32_t mbin_exp_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n < 32; n++) {\n        if (x & (1 << n)) {\n            r = r + (r << n);\n            x -= mbin_log_32_table[n];\n        }\n    }\n\n    return r;\n}\n```\n\n## Further optimizations\n\nIt is possible to halve the number of iterations if you note that $4L(2^{d-1}+1)=2^{d-1}$ and that for $2k \\geq d$ it holds that\n\n$$\n(2^n+1)^2 \\equiv 2^{2n} + 2^{n+1}+1 \\equiv 2^{n+1}+1 \\pmod{2^d},\n$$\n\nwhich allows to deduce that $4L(2^n+1)=2^n$ for $2n \\geq d$. So, you could simplify the algorithm by only going up to $\\frac{d}{2}$ and then use the fact above to compute the remaining part with bitwise operations:\n\n```cpp\nuint32_t mbin_log_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n != 16; n++) {\n        if (x & (1 << n)) {\n            x = x + (x << n);\n            r -= mbin_log_32_table[n];\n        }\n    }\n\n    r -= (x & 0xFFFF0000);\n\n    return r;\n}\n\nuint32_t mbin_exp_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n != 16; n++) {\n        if (x & (1 << n)) {\n            r = r + (r << n);\n            x -= mbin_log_32_table[n];\n        }\n    }\n\n    r *= 1 - (x & 0xFFFF0000);\n\n    return r;\n}\n```\n\n## Computing logarithm table\n\nTo compute log-table, one could modify the [Pohlig\u2013Hellman algorithm](https://en.wikipedia.org/wiki/Pohlig\u2013Hellman_algorithm) for the case when modulo is a power of $2$.\n\nOur main task here is to compute $x$ such that $g^x \\equiv y \\pmod{2^d}$, where $g=5$ and $y$ is a number of kind $2^n+1$. \n\nSquaring both parts $k$ times we arrive to\n\n$$\ng^{2^k x} \\equiv y^{2^k} \\pmod{2^d}.\n$$\n\nNote that the order of $g$ is not greater than $2^{d}$ (in fact, than $2^{d-2}$, but we will stick to $2^d$ for convenience), hence using $k=d-1$ we will have either $g^1$ or $g^0$ on the left hand side which allows us to determine the smallest bit of $x$ by comparing $y^{2^k}$ to $g$. Now assume that $x=x_0 + 2^k x_1$, where $x_0$ is a known part and $x_1$ is not yet known. Then\n\n$$\ng^{x_0+2^k x_1} \\equiv y \\pmod{2^d}.\n$$\n\nMultiplying both parts with $g^{-x_0}$, we get\n\n$$\ng^{2^k x_1} \\equiv (g^{-x_0} y) \\pmod{2^d}.\n$$\n\nNow, squaring both sides $d-k-1$ times we can obtain the next bit of $x$, eventually recovering all its bits.\n\n## References\n\n* [M30, Hans Petter Selasky, 2009](https://ia601602.us.archive.org/29/items/B-001-001-251/B-001-001-251.pdf#page=640)\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Binary Exponentiation by Factoring\n\nConsider a problem of computing $ax^y \\pmod{2^d}$, given integers $a$, $x$, $y$ and $d \\geq 3$, where $x$ is odd.\n\nThe algorithm below allows to solve this problem with $O(d)$ additions and binary operations and a single multiplication by $y$.\n\nDue to the structure of the multiplicative group modulo $2^d$, any number $x$ such that $x \\equiv 1 \\pmod 4$ can be represented as\n\n$$\nx \\equiv b^{L(x)} \\pmod{2^d},\n$$\n\nwhere $b \\equiv 5 \\pmod 8$. Without loss of generality we assume that $x \\equiv 1 \\pmod 4$, as we can reduce $x \\equiv 3 \\pmod 4$ to $x \\equiv 1 \\pmod 4$ by substituting $x \\mapsto -x$ and $a \\mapsto (-1)^{y} a$. In this notion, $ax^y$ is represented as\n\n$$\na x^y \\equiv a b^{yL(x)} \\pmod{2^d}.\n$$\n\nThe core idea of the algorithm is to simplify the computation of $L(x)$ and $b^{y L(x)}$ using the fact that we're working modulo $2^d$. For reasons that will be apparent later on, we'll be working with $4L(x)$ rather than $L(x)$, but taken modulo $2^d$ instead of $2^{d-2}$.\n\nIn this article, we will cover the implementation for $32$-bit integers. Let\n\n* `mbin_log_32(r, x)` be a function that computes $r+4L(x) \\pmod{2^d}$;\n* `mbin_exp_32(r, x)` be a function that computes $r b^{\\frac{x}{4}} \\pmod{2^d}$;\n* `mbin_power_odd_32(a, x, y)` be a function that computes $ax^y \\pmod{2^d}$.\n\nThen `mbin_power_odd_32` is implemented as follows:\n\n```cpp\nuint32_t mbin_power_odd_32(uint32_t rem, uint32_t base, uint32_t exp) {\n    if (base & 2) {\n        /* divider is considered negative */\n        base = -base;\n        /* check if result should be negative */\n        if (exp & 1) {\n            rem = -rem;\n        }\n    }\n    return (mbin_exp_32(rem, mbin_log_32(0, base) * exp));\n}\n```\n\n## Computing 4L(x) from x\n\nLet $x$ be an odd number such that $x \\equiv 1 \\pmod 4$. It can be represented as \n\n$$\nx \\equiv (2^{a_1}+1)\\dots(2^{a_k}+1) \\pmod{2^d},\n$$\n\nwhere $1 < a_1 < \\dots < a_k < d$. Here $L(\\cdot)$ is well-defined for each multiplier, as they're equal to $1$ modulo $4$. Hence,\n\n$$\n4L(x) \\equiv 4L(2^{a_1}+1)+\\dots+4L(2^{a_k}+1) \\pmod{2^{d}}.\n$$\n\nSo, if we precompute $t_k = 4L(2^n+1)$ for all $1 < k < d$, we will be able to compute $4L(x)$ for any number $x$.\n\nFor 32-bit integers, we can use the following table:\n\n```cpp\nconst uint32_t mbin_log_32_table[32] = {\n    0x00000000, 0x00000000, 0xd3cfd984, 0x9ee62e18,\n    0xe83d9070, 0xb59e81e0, 0xa17407c0, 0xce601f80,\n    0xf4807f00, 0xe701fe00, 0xbe07fc00, 0xfc1ff800,\n    0xf87ff000, 0xf1ffe000, 0xe7ffc000, 0xdfff8000,\n    0xffff0000, 0xfffe0000, 0xfffc0000, 0xfff80000,\n    0xfff00000, 0xffe00000, 0xffc00000, 0xff800000,\n    0xff000000, 0xfe000000, 0xfc000000, 0xf8000000,\n    0xf0000000, 0xe0000000, 0xc0000000, 0x80000000,\n};\n```\n\nOn practice, a slightly different approach is used than described above. Rather than finding the factorization for $x$, we will consequently multiply $x$ with $2^n+1$ until we turn it into $1$ modulo $2^d$. In this way, we will find the representation of $x^{-1}$, that is\n\n$$\nx (2^{a_1}+1)\\dots(2^{a_k}+1) \\equiv 1 \\pmod {2^d}.\n$$\n\nTo do this, we iterate over $n$ such that $1 < n < d$. If the current $x$ has $n$-th bit set, we multiply $x$ with $2^n+1$, which is conveniently done in C++ as `x = x + (x << n)`. This won't change bits lower than $n$, but will turn the $n$-th bit to zero, because $x$ is odd.\n\nWith all this in mind, the function `mbin_log_32(r, x)` is implemented as follows:\n\n```cpp\nuint32_t mbin_log_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n < 32; n++) {\n        if (x & (1 << n)) {\n            x = x + (x << n);\n            r -= mbin_log_32_table[n];\n        }\n    }\n\n    return r;\n}\n```\n\nNote that $4L(x) = -4L(x^{-1})$, so instead of adding $4L(2^n+1)$, we subtract it from $r$, which initially equates to $0$.\n\n## Computing x from 4L(x)\n\nNote that for $k \\geq 1$ it holds that\n\n$$\n(a 2^{k}+1)^2 = a^2 2^{2k} +a 2^{k+1}+1 = b2^{k+1}+1,\n$$\n\nfrom which (by repeated squaring) we can deduce that\n\n$$\n(2^a+1)^{2^b} \\equiv 1 \\pmod{2^{a+b}}.\n$$\n\nApplying this result to $a=2^n+1$ and $b=d-k$ we deduce that the multiplicative order of $2^n+1$ is a divisor of $2^{d-n}$.\n\nThis, in turn, means that $L(2^n+1)$ must be divisible by $2^{n}$, as the order of $b$ is $2^{d-2}$ and the order of $b^y$ is $2^{d-2-v}$, where $2^v$ is the highest power of $2$ that divides $y$, so we need\n\n$$\n2^{d-k} \\equiv 0 \\pmod{2^{d-2-v}},\n$$\n\nthus $v$ must be greater or equal than $k-2$. This is a bit ugly and to mitigate this we said in the beginning that we multiply $L(x)$ by $4$. Now if we know $4L(x)$, we can uniquely decomposing it into a sum of $4L(2^n+1)$ by consequentially checking bits in $4L(x)$. If the $n$-th bit is set to $1$, we will multiply the result with $2^n+1$ and reduce the current $4L(x)$ by $4L(2^n+1)$.\n\nThus, `mbin_exp_32` is implemented as follows:\n\n```cpp\nuint32_t mbin_exp_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n < 32; n++) {\n        if (x & (1 << n)) {\n            r = r + (r << n);\n            x -= mbin_log_32_table[n];\n        }\n    }\n\n    return r;\n}\n```\n\n## Further optimizations\n\nIt is possible to halve the number of iterations if you note that $4L(2^{d-1}+1)=2^{d-1}$ and that for $2k \\geq d$ it holds that\n\n$$\n(2^n+1)^2 \\equiv 2^{2n} + 2^{n+1}+1 \\equiv 2^{n+1}+1 \\pmod{2^d},\n$$\n\nwhich allows to deduce that $4L(2^n+1)=2^n$ for $2n \\geq d$. So, you could simplify the algorithm by only going up to $\\frac{d}{2}$ and then use the fact above to compute the remaining part with bitwise operations:\n\n```cpp\nuint32_t mbin_log_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n != 16; n++) {\n        if (x & (1 << n)) {\n            x = x + (x << n);\n            r -= mbin_log_32_table[n];\n        }\n    }\n\n    r -= (x & 0xFFFF0000);\n\n    return r;\n}\n\nuint32_t mbin_exp_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n != 16; n++) {\n        if (x & (1 << n)) {\n            r = r + (r << n);\n            x -= mbin_log_32_table[n];\n        }\n    }\n\n    r *= 1 - (x & 0xFFFF0000);\n\n    return r;\n}\n```\n\n## Computing logarithm table\n\nTo compute log-table, one could modify the [Pohlig\u2013Hellman algorithm](https://en.wikipedia.org/wiki/Pohlig\u2013Hellman_algorithm) for the case when modulo is a power of $2$.\n\nOur main task here is to compute $x$ such that $g^x \\equiv y \\pmod{2^d}$, where $g=5$ and $y$ is a number of kind $2^n+1$. \n\nSquaring both parts $k$ times we arrive to\n\n$$\ng^{2^k x} \\equiv y^{2^k} \\pmod{2^d}.\n$$\n\nNote that the order of $g$ is not greater than $2^{d}$ (in fact, than $2^{d-2}$, but we will stick to $2^d$ for convenience), hence using $k=d-1$ we will have either $g^1$ or $g^0$ on the left hand side which allows us to determine the smallest bit of $x$ by comparing $y^{2^k}$ to $g$. Now assume that $x=x_0 + 2^k x_1$, where $x_0$ is a known part and $x_1$ is not yet known. Then\n\n$$\ng^{x_0+2^k x_1} \\equiv y \\pmod{2^d}.\n$$\n\nMultiplying both parts with $g^{-x_0}$, we get\n\n$$\ng^{2^k x_1} \\equiv (g^{-x_0} y) \\pmod{2^d}.\n$$\n\nNow, squaring both sides $d-k-1$ times we can obtain the next bit of $x$, eventually recovering all its bits.\n\n## References\n\n* [M30, Hans Petter Selasky, 2009](https://ia601602.us.archive.org/29/items/B-001-001-251/B-001-001-251.pdf#page=640)\n", "problem_ids": [], "title": "Binary Exponentiation by Factoring"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: reverse_element\n---\n\n# Modular Multiplicative Inverse\n\n## Definition\n\nA [modular multiplicative inverse](http://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of an integer $a$ is an integer $x$ such that $a \\cdot x$ is congruent to $1$ modular some modulus $m$.\nTo write it in a formal way: we want to find an integer $x$ so that \n\n$$a \\cdot x \\equiv 1 \\mod m.$$\n\nWe will also denote $x$ simply with $a^{-1}$.\n\nWe should note that the modular inverse does not always exist. For example, let $m = 4$, $a = 2$. \nBy checking all possible values modulo $m$, it should become clear that we cannot find $a^{-1}$ satisfying the above equation. \nIt can be proven that the modular inverse exists if and only if $a$ and $m$ are relatively prime (i.e. $\\gcd(a, m) = 1$).\n\nIn this article, we present two methods for finding the modular inverse in case it exists, and one method for finding the modular inverse for all numbers in linear time.\n\n## Finding the Modular Inverse using Extended Euclidean algorithm\n\nConsider the following equation (with unknown $x$ and $y$):\n\n$$a \\cdot x + m \\cdot y = 1$$\n\nThis is a [Linear Diophantine equation in two variables](linear-diophantine-equation.md).\nAs shown in the linked article, when $\\gcd(a, m) = 1$, the equation has a solution which can be found using the [extended Euclidean algorithm](extended-euclid-algorithm.md).\nNote that $\\gcd(a, m) = 1$ is also the condition for the modular inverse to exist.\n\nNow, if we take modulo $m$ of both sides, we can get rid of $m \\cdot y$, and the equation becomes:\n\n$$a \\cdot x \\equiv 1 \\mod m$$\n\nThus, the modular inverse of $a$ is $x$.\n\nThe implementation is as follows:\n\n```cpp\nint x, y;\nint g = extended_euclidean(a, m, x, y);\nif (g != 1) {\n    cout << \"No solution!\";\n}\nelse {\n    x = (x % m + m) % m;\n    cout << x << endl;\n}\n```\n\nNotice that the way we modify `x`.\nThe resulting `x` from the extended Euclidean algorithm may be negative, so `x % m` might also be negative, and we first have to add `m` to make it positive.\n\n<div id=\"fermat-euler\"></div>\n## Finding the Modular Inverse using Binary Exponentiation\n\nAnother method for finding modular inverse is to use Euler's theorem, which states that the following congruence is true if $a$ and $m$ are relatively prime:\n\n$$a^{\\phi (m)} \\equiv 1 \\mod m$$\n\n$\\phi$ is [Euler's Totient function](phi-function.md).\nAgain, note that $a$ and $m$ being relative prime was also the condition for the modular inverse to exist.\n\nIf $m$ is a prime number, this simplifies to [Fermat's little theorem](http://en.wikipedia.org/wiki/Fermat's_little_theorem):\n\n$$a^{m - 1} \\equiv 1 \\mod m$$\n\nMultiply both sides of the above equations by $a^{-1}$, and we get:\n\n* For an arbitrary (but coprime) modulus $m$: $a ^ {\\phi (m) - 1} \\equiv a ^{-1} \\mod m$\n* For a prime modulus $m$: $a ^ {m - 2} \\equiv a ^ {-1} \\mod m$\n\nFrom these results, we can easily find the modular inverse using the [binary exponentiation algorithm](binary-exp.md), which works in $O(\\log m)$ time.\n\nEven though this method is easier to understand than the method described in previous paragraph, in the case when $m$ is not a prime number, we need to calculate Euler phi function, which involves factorization of $m$, which might be very hard. If the prime factorization of $m$ is known, then the complexity of this method is $O(\\log m)$.\n\n<div id=\"finding-the-modular-inverse-using-euclidean-division\"></div>\n## Finding the modular inverse for prime moduli using Euclidean Division\n\nGiven a prime modulus $m > a$ (or we can apply modulo to make it smaller in 1 step), according to [Euclidean Division](https://en.wikipedia.org/wiki/Euclidean_division)\n\n$$m = k \\cdot a + r$$\n\nwhere $k = \\left\\lfloor \\frac{m}{a} \\right\\rfloor$ and $r = m \\bmod a$, then\n\n$$\n\\begin{align*}\n& \\implies & 0          & \\equiv k \\cdot a + r   & \\mod m \\\\\n& \\iff & r              & \\equiv -k \\cdot a      & \\mod m \\\\\n& \\iff & r \\cdot a^{-1} & \\equiv -k              & \\mod m \\\\\n& \\iff & a^{-1}         & \\equiv -k \\cdot r^{-1} & \\mod m\n\\end{align*}\n$$\n\nNote that this reasoning does not hold if $m$ is not prime, since the existence of $a^{-1}$ does not imply the existence of $r^{-1}$\nin the general case. To see this, lets try to calculate $5^{-1}$ modulo $12$ with the above formula. We would like to arrive at $5$,\nsince $5 \\cdot 5 \\equiv 1 \\bmod 12$. However, $12 = 2 \\cdot 5 + 2$, and we have $k=2$ and $r=2$, with $2$ being not invertible modulo $12$.\n\nIf the modulus is prime however, all $a$ with $0 < a < m$ are invertible modulo $m$, and we can have the following recursive function (in C++) for computing the modular inverse for number $a$ with respect to $m$\n\n```{.cpp file=modular_inverse_euclidean_division}\nint inv(int a) {\n  return a <= 1 ? a : m - (long long)(m/a) * inv(m % a) % m;\n}\n```\n\nThe exact time complexity of the this recursion is not known. It's is somewhere between $O(\\frac{\\log m}{\\log\\log m})$ and $O(m^{\\frac{1}{3} - \\frac{2}{177} + \\epsilon})$.\nSee [On the length of Pierce expansions](https://arxiv.org/abs/2211.08374).\nIn practice this implementation is fast, e.g. for the modulus $10^9 + 7$ it will always finish in less than 50 iterations.\n\n<div id=\"mod-inv-all-num\"></div>\nApplying this formula, we can also precompute the modular inverse for every number in the range $[1, m-1]$ in $O(m)$.\n\n```{.cpp file=modular_inverse_euclidean_division_all}\ninv[1] = 1;\nfor(int a = 2; a < m; ++a)\n    inv[a] = m - (long long)(m/a) * inv[m%a] % m;\n```\n\n## Finding the modular inverse for array of numbers modulo $m$\n\nSuppose we are given an array and we want to find modular inverse for all numbers in it (all of them are invertible).\nInstead of computing the inverse for every number, we can expand the fraction by the prefix product (excluding itself) and suffix product (excluding itself), and end up only computing a single inverse instead.\n\n$$\n\\begin{align}\nx_i^{-1} &= \\frac{1}{x_i} = \\frac{\\overbrace{x_1 \\cdot x_2 \\cdots x_{i-1}}^{\\text{prefix}_{i-1}} \\cdot ~1~ \\cdot \\overbrace{x_{i+1} \\cdot x_{i+2} \\cdots x_n}^{\\text{suffix}_{i+1}}}{x_1 \\cdot x_2 \\cdots x_{i-1} \\cdot x_i \\cdot x_{i+1} \\cdot x_{i+2} \\cdots x_n} \\\\\n&= \\text{prefix}_{i-1} \\cdot \\text{suffix}_{i+1} \\cdot \\left(x_1 \\cdot x_2 \\cdots x_n\\right)^{-1}\n\\end{align}\n$$\n\nIn the code we can just make a prefix product array (exclude itself, start from the identity element), compute the modular inverse for the product of all numbers and than multiply it by the prefix product and suffix product (exclude itself).\nThe suffix product is computed by iterating from the back to the front.\n\n```cpp\nstd::vector<int> invs(const std::vector<int> &a, int m) {\n    int n = a.size();\n    if (n == 0) return {};\n    std::vector<int> b(n);\n    int v = 1;\n    for (int i = 0; i != n; ++i) {\n        b[i] = v;\n        v = static_cast<long long>(v) * a[i] % m;\n    }\n    int x, y;\n    extended_euclidean(v, m, x, y);\n    x = (x % m + m) % m;\n    for (int i = n - 1; i >= 0; --i) {\n        b[i] = static_cast<long long>(x) * b[i] % m;\n        x = static_cast<long long>(x) * a[i] % m;\n    }\n    return b;\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: reverse_element\n---\n\n# Modular Multiplicative Inverse\n\n## Definition\n\nA [modular multiplicative inverse](http://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of an integer $a$ is an integer $x$ such that $a \\cdot x$ is congruent to $1$ modular some modulus $m$.\nTo write it in a formal way: we want to find an integer $x$ so that \n\n$$a \\cdot x \\equiv 1 \\mod m.$$\n\nWe will also denote $x$ simply with $a^{-1}$.\n\nWe should note that the modular inverse does not always exist. For example, let $m = 4$, $a = 2$. \nBy checking all possible values modulo $m$, it should become clear that we cannot find $a^{-1}$ satisfying the above equation. \nIt can be proven that the modular inverse exists if and only if $a$ and $m$ are relatively prime (i.e. $\\gcd(a, m) = 1$).\n\nIn this article, we present two methods for finding the modular inverse in case it exists, and one method for finding the modular inverse for all numbers in linear time.\n\n## Finding the Modular Inverse using Extended Euclidean algorithm\n\nConsider the following equation (with unknown $x$ and $y$):\n\n$$a \\cdot x + m \\cdot y = 1$$\n\nThis is a [Linear Diophantine equation in two variables](linear-diophantine-equation.md).\nAs shown in the linked article, when $\\gcd(a, m) = 1$, the equation has a solution which can be found using the [extended Euclidean algorithm](extended-euclid-algorithm.md).\nNote that $\\gcd(a, m) = 1$ is also the condition for the modular inverse to exist.\n\nNow, if we take modulo $m$ of both sides, we can get rid of $m \\cdot y$, and the equation becomes:\n\n$$a \\cdot x \\equiv 1 \\mod m$$\n\nThus, the modular inverse of $a$ is $x$.\n\nThe implementation is as follows:\n\n```cpp\nint x, y;\nint g = extended_euclidean(a, m, x, y);\nif (g != 1) {\n    cout << \"No solution!\";\n}\nelse {\n    x = (x % m + m) % m;\n    cout << x << endl;\n}\n```\n\nNotice that the way we modify `x`.\nThe resulting `x` from the extended Euclidean algorithm may be negative, so `x % m` might also be negative, and we first have to add `m` to make it positive.\n\n<div id=\"fermat-euler\"></div>\n## Finding the Modular Inverse using Binary Exponentiation\n\nAnother method for finding modular inverse is to use Euler's theorem, which states that the following congruence is true if $a$ and $m$ are relatively prime:\n\n$$a^{\\phi (m)} \\equiv 1 \\mod m$$\n\n$\\phi$ is [Euler's Totient function](phi-function.md).\nAgain, note that $a$ and $m$ being relative prime was also the condition for the modular inverse to exist.\n\nIf $m$ is a prime number, this simplifies to [Fermat's little theorem](http://en.wikipedia.org/wiki/Fermat's_little_theorem):\n\n$$a^{m - 1} \\equiv 1 \\mod m$$\n\nMultiply both sides of the above equations by $a^{-1}$, and we get:\n\n* For an arbitrary (but coprime) modulus $m$: $a ^ {\\phi (m) - 1} \\equiv a ^{-1} \\mod m$\n* For a prime modulus $m$: $a ^ {m - 2} \\equiv a ^ {-1} \\mod m$\n\nFrom these results, we can easily find the modular inverse using the [binary exponentiation algorithm](binary-exp.md), which works in $O(\\log m)$ time.\n\nEven though this method is easier to understand than the method described in previous paragraph, in the case when $m$ is not a prime number, we need to calculate Euler phi function, which involves factorization of $m$, which might be very hard. If the prime factorization of $m$ is known, then the complexity of this method is $O(\\log m)$.\n\n<div id=\"finding-the-modular-inverse-using-euclidean-division\"></div>\n## Finding the modular inverse for prime moduli using Euclidean Division\n\nGiven a prime modulus $m > a$ (or we can apply modulo to make it smaller in 1 step), according to [Euclidean Division](https://en.wikipedia.org/wiki/Euclidean_division)\n\n$$m = k \\cdot a + r$$\n\nwhere $k = \\left\\lfloor \\frac{m}{a} \\right\\rfloor$ and $r = m \\bmod a$, then\n\n$$\n\\begin{align*}\n& \\implies & 0          & \\equiv k \\cdot a + r   & \\mod m \\\\\n& \\iff & r              & \\equiv -k \\cdot a      & \\mod m \\\\\n& \\iff & r \\cdot a^{-1} & \\equiv -k              & \\mod m \\\\\n& \\iff & a^{-1}         & \\equiv -k \\cdot r^{-1} & \\mod m\n\\end{align*}\n$$\n\nNote that this reasoning does not hold if $m$ is not prime, since the existence of $a^{-1}$ does not imply the existence of $r^{-1}$\nin the general case. To see this, lets try to calculate $5^{-1}$ modulo $12$ with the above formula. We would like to arrive at $5$,\nsince $5 \\cdot 5 \\equiv 1 \\bmod 12$. However, $12 = 2 \\cdot 5 + 2$, and we have $k=2$ and $r=2$, with $2$ being not invertible modulo $12$.\n\nIf the modulus is prime however, all $a$ with $0 < a < m$ are invertible modulo $m$, and we can have the following recursive function (in C++) for computing the modular inverse for number $a$ with respect to $m$\n\n```{.cpp file=modular_inverse_euclidean_division}\nint inv(int a) {\n  return a <= 1 ? a : m - (long long)(m/a) * inv(m % a) % m;\n}\n```\n\nThe exact time complexity of the this recursion is not known. It's is somewhere between $O(\\frac{\\log m}{\\log\\log m})$ and $O(m^{\\frac{1}{3} - \\frac{2}{177} + \\epsilon})$.\nSee [On the length of Pierce expansions](https://arxiv.org/abs/2211.08374).\nIn practice this implementation is fast, e.g. for the modulus $10^9 + 7$ it will always finish in less than 50 iterations.\n\n<div id=\"mod-inv-all-num\"></div>\nApplying this formula, we can also precompute the modular inverse for every number in the range $[1, m-1]$ in $O(m)$.\n\n```{.cpp file=modular_inverse_euclidean_division_all}\ninv[1] = 1;\nfor(int a = 2; a < m; ++a)\n    inv[a] = m - (long long)(m/a) * inv[m%a] % m;\n```\n\n## Finding the modular inverse for array of numbers modulo $m$\n\nSuppose we are given an array and we want to find modular inverse for all numbers in it (all of them are invertible).\nInstead of computing the inverse for every number, we can expand the fraction by the prefix product (excluding itself) and suffix product (excluding itself), and end up only computing a single inverse instead.\n\n$$\n\\begin{align}\nx_i^{-1} &= \\frac{1}{x_i} = \\frac{\\overbrace{x_1 \\cdot x_2 \\cdots x_{i-1}}^{\\text{prefix}_{i-1}} \\cdot ~1~ \\cdot \\overbrace{x_{i+1} \\cdot x_{i+2} \\cdots x_n}^{\\text{suffix}_{i+1}}}{x_1 \\cdot x_2 \\cdots x_{i-1} \\cdot x_i \\cdot x_{i+1} \\cdot x_{i+2} \\cdots x_n} \\\\\n&= \\text{prefix}_{i-1} \\cdot \\text{suffix}_{i+1} \\cdot \\left(x_1 \\cdot x_2 \\cdots x_n\\right)^{-1}\n\\end{align}\n$$\n\nIn the code we can just make a prefix product array (exclude itself, start from the identity element), compute the modular inverse for the product of all numbers and than multiply it by the prefix product and suffix product (exclude itself).\nThe suffix product is computed by iterating from the back to the front.\n\n```cpp\nstd::vector<int> invs(const std::vector<int> &a, int m) {\n    int n = a.size();\n    if (n == 0) return {};\n    std::vector<int> b(n);\n    int v = 1;\n    for (int i = 0; i != n; ++i) {\n        b[i] = v;\n        v = static_cast<long long>(v) * a[i] % m;\n    }\n    int x, y;\n    extended_euclidean(v, m, x, y);\n    x = (x % m + m) % m;\n    for (int i = n - 1; i >= 0; --i) {\n        b[i] = static_cast<long long>(x) * b[i] % m;\n        x = static_cast<long long>(x) * a[i] % m;\n    }\n    return b;\n}\n```\n\n## Practice Problems\n\n* [UVa 11904 - One Unit Machine](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3055)\n* [Hackerrank - Longest Increasing Subsequence Arrays](https://www.hackerrank.com/contests/world-codesprint-5/challenges/longest-increasing-subsequence-arrays)\n* [Codeforces 300C - Beautiful Numbers](http://codeforces.com/problemset/problem/300/C)\n* [Codeforces 622F - The Sum of the k-th Powers](http://codeforces.com/problemset/problem/622/F)\n* [Codeforces 717A - Festival Organization](http://codeforces.com/problemset/problem/717/A)\n* [Codeforces 896D - Nephren Runs a Cinema](http://codeforces.com/problemset/problem/896/D)\n", "problem_ids": [], "title": "Modular Multiplicative Inverse"}, {"article": "---\ntags:\n  - Original\n---\n# Bit manipulation\n\n## Binary number\n\nA **binary number** is a number expressed in the base-2 numeral system or binary numeral system, it is a method of mathematical expression which uses only two symbols: typically \"0\" (zero) and \"1\" (one).\n\nWe say that a certain bit is **set**, if it is one, and **cleared** if it is zero.\n\nThe binary number $(a_k a_{k-1} \\dots a_1 a_0)_2$ represents the number:\n\n$$(a_k a_{k-1} \\dots a_1 a_0)_2 = a_k \\cdot 2^k + a_{k-1} \\cdot 2^{k-1} + \\dots + a_1 \\cdot 2^1 + a_0 \\cdot 2^0.$$\n\nFor instance the binary number $1101_2$ represents the number $13$:\n\n$$\\begin{align}\n1101_2 &= 1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 \\\\\n       &= 1\\cdot 8 + 1 \\cdot 4 + 0 \\cdot 2 + 1 \\cdot 1 = 13\n\\end{align}$$\n\nComputers represent integers as binary numbers.\nPositive integers (both signed and unsigned) are just represented with their binary digits, and negative signed numbers (which can be positive and negative) are usually represented with the [Two's complement](https://en.wikipedia.org/wiki/Two%27s_complement).\n\n```cpp\nunsigned int unsigned_number = 13;\nassert(unsigned_number == 0b1101);\n\nint positive_signed_number = 13;\nassert(positive_signed_number == 0b1101);\n\nint negative_signed_number = -13;\nassert(negative_signed_number == 0b1111'1111'1111'1111'1111'1111'1111'0011);\n```\n\nCPUs are very fast manipulating those bits with specific operations.\nFor some problems we can take these binary number representations to our advantage, and speed up the execution time.\nAnd for some problems (typically in combinatorics or dynamic programming) where we want to track which objects we already picked from a given set of objects, we can just use an large enough integer where each digit represents an object and depending on if we pick or drop the object we set or clear the digit.\n\n## Bit operators\n\nAll those introduced operators are instant (same speed as an addition) on a CPU for fixed-length integers.\n\n### Bitwise operators\n\n-   $\\&$ : The bitwise AND operator compares each bit of its first operand with the corresponding bit of its second operand. \n    If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.\n \t\n-   $|$ : The bitwise inclusive OR operator compares each bit of its first operand with the corresponding bit of its second operand.\n    If one of the two bits is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.\n\n-   $\\wedge$ : The bitwise exclusive OR (XOR) operator compares each bit of its first operand with the corresponding bit of its second operand.\n    If one bit is 0 and the other bit is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.\n\n-   $\\sim$ : The bitwise complement (NOT) operator flips each bit of a number, if a bit is set the operator will clear it, if it is cleared the operator sets it.\n\nExamples:\n\n```\nn         = 01011000\nn-1       = 01010111\n--------------------\nn & (n-1) = 01010000\n```\n\n```\nn         = 01011000\nn-1       = 01010111\n--------------------\nn | (n-1) = 01011111\n```\n\n```\nn         = 01011000\nn-1       = 01010111\n--------------------\nn ^ (n-1) = 00001111\n```\n\n```\nn         = 01011000\n--------------------\n~n        = 10100111\n```\n\n### Shift operators\n\nThere are two operators for shifting bits.\n\n-   $\\gg$ Shifts a number to the right by removing the last few binary digits of the number.\n    Each shift by one represents an integer division by 2, so a right shift by $k$ represents an integer division by $2^k$.\n\n    E.g. $5 \\gg 2 = 101_2 \\gg 2 = 1_2 = 1$ which is the same as $\\frac{5}{2^2} = \\frac{5}{4} = 1$.\n    For a computer though shifting some bits is a lot faster than doing divisions.\n\n-   $\\ll$ Shifts a number to left by appending zero digits.\n    In similar fashion to a right shift by $k$, a left shift by $k$ represents a multiplication by $2^k$.\n\n    E.g. $5 \\ll 3 = 101_2 \\ll 3 = 101000_2 = 40$ which is the same as $5 \\cdot 2^3 = 5 \\cdot 8 = 40$.\n\n    Notice however that for a fixed-length integer that means dropping the most left digits, and if you shift too much you end up with the number $0$.\n\n\n## Useful tricks\n\n### Set/flip/clear a bit\n\nUsing bitwise shifts and some basic bitwise operations we can easily set, flip or clear a bit.\n$1 \\ll x$ is a number with only the $x$-th bit set, while $\\sim(1 \\ll x)$ is a number with all bits set except the $x$-th bit.\n\n- $n ~|~ (1 \\ll x)$ sets the $x$-th bit in the number $n$\n- $n ~\\wedge~ (1 \\ll x)$ flips the $x$-th bit in the number $n$\n- $n ~\\&~ \\sim(1 \\ll x)$ clears the $x$-th bit in the number $n$\n\n### Check if a bit is set\n\nThe value of the $x$-th bit can be checked by shifting the number $x$ positions to the right, so that the $x$-th bit is at the unit place, after which we can extract it by performing a bitwise & with 1.\n\n``` cpp\nbool is_set(unsigned int number, int x) {\n    return (number >> x) & 1;\n}\n```\n\n### Check if an integer is a power of 2\n\nA power of two is a number that has only a single bit in it (e.g. $32 = 0010~0000_2$), while the predecessor of that number has that digit not set and all the digits after it set ($31 = 0001~1111_2$).\nSo the bitwise AND of a number with it's predecessor will always be 0, as they don't have any common digits set.\nYou can easily check that this only happens for the the power of twos and for the number $0$ which already has no digit set.\n\n``` cpp\nbool isPowerOfTwo(unsigned int n) {\n    return n && !(n & (n - 1));\n}\n```\n\n### Clear the most-right set bit\n\nThe expression $n ~\\&~ (n-1)$ can be used to turn off the rightmost set bit of a number $n$.\nThis works because the expression $n-1$ flips all bits after the rightmost set bit of $n$, including the rightmost set bit.\nSo all those digits are different from the original number, and by doing a bitwise AND they are all set to 0, giving you the original number $n$ with the rightmost set bit flipped.\n\nFor example, consider the number $52 = 0011~0100_2$:\n\n```\nn         = 00110100\nn-1       = 00110011\n--------------------\nn & (n-1) = 00110000\n```\n\n### Brian Kernighan's algorithm\n\nWe can count the number of bits set with the above expression.\n\nThe idea is to consider only the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the Next Rightmost bit.\n\n``` cpp\nint countSetBits(int n)\n{\n    int count = 0;\n    while (n)\n    {\n        n = n & (n - 1);\n        count++;\n    }\n    return count;\n}\n```\n\n### Additional tricks\n\n- $n ~\\&~ (n + 1)$ clears all trailing ones: $0011~0111_2 \\rightarrow 0011~0000_2$.\n- $n ~|~ (n + 1)$ sets the last cleared bit: $0011~0101_2 \\rightarrow 0011~0111_2$.\n- $n ~\\&~ -n$ extracts the last set bit: $0011~0100_2 \\rightarrow 0000~0100_2$.\n\nMany more can be found in the book [Hacker's Delight](https://en.wikipedia.org/wiki/Hacker%27s_Delight).\n\n### Language and compiler support\n\nC++ supports some of those operations since C++20 via the [bit](https://en.cppreference.com/w/cpp/header/bit) standard library:\n\n- `has_single_bit`: checks if the number is a power of two\n- `bit_ceil` / `bit_floor`: round up/down to the next power of two\n- `rotl` / `rotr`: rotate the bits in the number\n- `countl_zero` / `countr_zero` / `countl_one` / `countr_one`: count the leading/trailing zeros/ones\n- `popcount`: count the number of set bits\n\nAdditionally, there are also predefined functions in some compilers that help working with bits.\nE.g. GCC defines a list at [Built-in Functions Provided by GCC](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html) that also work in older versions of C++:\n\n- `__builtin_popcount(unsigned int)` returns the number of set bits (`__builtin_popcount(0b0001'0010'1100) == 4`)\n- `__builtin_ffs(int)` finds the index of the first (most right) set bit (`__builtin_ffs(0b0001'0010'1100) == 3`)\n- `__builtin_clz(unsigned int)` the count of leading zeros (`__builtin_clz(0b0001'0010'1100) == 23`)\n- `__builtin_ctz(unsigned int)` the count of trailing zeros (`__builtin_ctz(0b0001'0010'1100) == 2`)\n\n_Note that some of the operations (both the C++20 functions and the Compiler Built-in ones) might be quite slow in GCC if you don't enable a specific compiler target with `#pragma GCC target(\"popcnt\")`._\n\n", "full_article": "---\ntags:\n  - Original\n---\n# Bit manipulation\n\n## Binary number\n\nA **binary number** is a number expressed in the base-2 numeral system or binary numeral system, it is a method of mathematical expression which uses only two symbols: typically \"0\" (zero) and \"1\" (one).\n\nWe say that a certain bit is **set**, if it is one, and **cleared** if it is zero.\n\nThe binary number $(a_k a_{k-1} \\dots a_1 a_0)_2$ represents the number:\n\n$$(a_k a_{k-1} \\dots a_1 a_0)_2 = a_k \\cdot 2^k + a_{k-1} \\cdot 2^{k-1} + \\dots + a_1 \\cdot 2^1 + a_0 \\cdot 2^0.$$\n\nFor instance the binary number $1101_2$ represents the number $13$:\n\n$$\\begin{align}\n1101_2 &= 1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 \\\\\n       &= 1\\cdot 8 + 1 \\cdot 4 + 0 \\cdot 2 + 1 \\cdot 1 = 13\n\\end{align}$$\n\nComputers represent integers as binary numbers.\nPositive integers (both signed and unsigned) are just represented with their binary digits, and negative signed numbers (which can be positive and negative) are usually represented with the [Two's complement](https://en.wikipedia.org/wiki/Two%27s_complement).\n\n```cpp\nunsigned int unsigned_number = 13;\nassert(unsigned_number == 0b1101);\n\nint positive_signed_number = 13;\nassert(positive_signed_number == 0b1101);\n\nint negative_signed_number = -13;\nassert(negative_signed_number == 0b1111'1111'1111'1111'1111'1111'1111'0011);\n```\n\nCPUs are very fast manipulating those bits with specific operations.\nFor some problems we can take these binary number representations to our advantage, and speed up the execution time.\nAnd for some problems (typically in combinatorics or dynamic programming) where we want to track which objects we already picked from a given set of objects, we can just use an large enough integer where each digit represents an object and depending on if we pick or drop the object we set or clear the digit.\n\n## Bit operators\n\nAll those introduced operators are instant (same speed as an addition) on a CPU for fixed-length integers.\n\n### Bitwise operators\n\n-   $\\&$ : The bitwise AND operator compares each bit of its first operand with the corresponding bit of its second operand. \n    If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.\n \t\n-   $|$ : The bitwise inclusive OR operator compares each bit of its first operand with the corresponding bit of its second operand.\n    If one of the two bits is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.\n\n-   $\\wedge$ : The bitwise exclusive OR (XOR) operator compares each bit of its first operand with the corresponding bit of its second operand.\n    If one bit is 0 and the other bit is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.\n\n-   $\\sim$ : The bitwise complement (NOT) operator flips each bit of a number, if a bit is set the operator will clear it, if it is cleared the operator sets it.\n\nExamples:\n\n```\nn         = 01011000\nn-1       = 01010111\n--------------------\nn & (n-1) = 01010000\n```\n\n```\nn         = 01011000\nn-1       = 01010111\n--------------------\nn | (n-1) = 01011111\n```\n\n```\nn         = 01011000\nn-1       = 01010111\n--------------------\nn ^ (n-1) = 00001111\n```\n\n```\nn         = 01011000\n--------------------\n~n        = 10100111\n```\n\n### Shift operators\n\nThere are two operators for shifting bits.\n\n-   $\\gg$ Shifts a number to the right by removing the last few binary digits of the number.\n    Each shift by one represents an integer division by 2, so a right shift by $k$ represents an integer division by $2^k$.\n\n    E.g. $5 \\gg 2 = 101_2 \\gg 2 = 1_2 = 1$ which is the same as $\\frac{5}{2^2} = \\frac{5}{4} = 1$.\n    For a computer though shifting some bits is a lot faster than doing divisions.\n\n-   $\\ll$ Shifts a number to left by appending zero digits.\n    In similar fashion to a right shift by $k$, a left shift by $k$ represents a multiplication by $2^k$.\n\n    E.g. $5 \\ll 3 = 101_2 \\ll 3 = 101000_2 = 40$ which is the same as $5 \\cdot 2^3 = 5 \\cdot 8 = 40$.\n\n    Notice however that for a fixed-length integer that means dropping the most left digits, and if you shift too much you end up with the number $0$.\n\n\n## Useful tricks\n\n### Set/flip/clear a bit\n\nUsing bitwise shifts and some basic bitwise operations we can easily set, flip or clear a bit.\n$1 \\ll x$ is a number with only the $x$-th bit set, while $\\sim(1 \\ll x)$ is a number with all bits set except the $x$-th bit.\n\n- $n ~|~ (1 \\ll x)$ sets the $x$-th bit in the number $n$\n- $n ~\\wedge~ (1 \\ll x)$ flips the $x$-th bit in the number $n$\n- $n ~\\&~ \\sim(1 \\ll x)$ clears the $x$-th bit in the number $n$\n\n### Check if a bit is set\n\nThe value of the $x$-th bit can be checked by shifting the number $x$ positions to the right, so that the $x$-th bit is at the unit place, after which we can extract it by performing a bitwise & with 1.\n\n``` cpp\nbool is_set(unsigned int number, int x) {\n    return (number >> x) & 1;\n}\n```\n\n### Check if an integer is a power of 2\n\nA power of two is a number that has only a single bit in it (e.g. $32 = 0010~0000_2$), while the predecessor of that number has that digit not set and all the digits after it set ($31 = 0001~1111_2$).\nSo the bitwise AND of a number with it's predecessor will always be 0, as they don't have any common digits set.\nYou can easily check that this only happens for the the power of twos and for the number $0$ which already has no digit set.\n\n``` cpp\nbool isPowerOfTwo(unsigned int n) {\n    return n && !(n & (n - 1));\n}\n```\n\n### Clear the most-right set bit\n\nThe expression $n ~\\&~ (n-1)$ can be used to turn off the rightmost set bit of a number $n$.\nThis works because the expression $n-1$ flips all bits after the rightmost set bit of $n$, including the rightmost set bit.\nSo all those digits are different from the original number, and by doing a bitwise AND they are all set to 0, giving you the original number $n$ with the rightmost set bit flipped.\n\nFor example, consider the number $52 = 0011~0100_2$:\n\n```\nn         = 00110100\nn-1       = 00110011\n--------------------\nn & (n-1) = 00110000\n```\n\n### Brian Kernighan's algorithm\n\nWe can count the number of bits set with the above expression.\n\nThe idea is to consider only the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the Next Rightmost bit.\n\n``` cpp\nint countSetBits(int n)\n{\n    int count = 0;\n    while (n)\n    {\n        n = n & (n - 1);\n        count++;\n    }\n    return count;\n}\n```\n\n### Additional tricks\n\n- $n ~\\&~ (n + 1)$ clears all trailing ones: $0011~0111_2 \\rightarrow 0011~0000_2$.\n- $n ~|~ (n + 1)$ sets the last cleared bit: $0011~0101_2 \\rightarrow 0011~0111_2$.\n- $n ~\\&~ -n$ extracts the last set bit: $0011~0100_2 \\rightarrow 0000~0100_2$.\n\nMany more can be found in the book [Hacker's Delight](https://en.wikipedia.org/wiki/Hacker%27s_Delight).\n\n### Language and compiler support\n\nC++ supports some of those operations since C++20 via the [bit](https://en.cppreference.com/w/cpp/header/bit) standard library:\n\n- `has_single_bit`: checks if the number is a power of two\n- `bit_ceil` / `bit_floor`: round up/down to the next power of two\n- `rotl` / `rotr`: rotate the bits in the number\n- `countl_zero` / `countr_zero` / `countl_one` / `countr_one`: count the leading/trailing zeros/ones\n- `popcount`: count the number of set bits\n\nAdditionally, there are also predefined functions in some compilers that help working with bits.\nE.g. GCC defines a list at [Built-in Functions Provided by GCC](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html) that also work in older versions of C++:\n\n- `__builtin_popcount(unsigned int)` returns the number of set bits (`__builtin_popcount(0b0001'0010'1100) == 4`)\n- `__builtin_ffs(int)` finds the index of the first (most right) set bit (`__builtin_ffs(0b0001'0010'1100) == 3`)\n- `__builtin_clz(unsigned int)` the count of leading zeros (`__builtin_clz(0b0001'0010'1100) == 23`)\n- `__builtin_ctz(unsigned int)` the count of trailing zeros (`__builtin_ctz(0b0001'0010'1100) == 2`)\n\n_Note that some of the operations (both the C++20 functions and the Compiler Built-in ones) might be quite slow in GCC if you don't enable a specific compiler target with `#pragma GCC target(\"popcnt\")`._\n\n## Practice Problems\n\n* [Codeforces - Raising Bacteria](https://codeforces.com/problemset/problem/579/A)\n* [Codeforces - Fedor and New Game](https://codeforces.com/problemset/problem/467/B)\n* [Codeforces - And Then There Were K](https://codeforces.com/problemset/problem/1527/A)\n", "problem_ids": ["579_A", "467_B", "1527_A"], "title": "Bit manipulation"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: fibonacci_numbers\n---\n\n# Fibonacci Numbers\n\nThe Fibonacci sequence is defined as follows:\n\n$$F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}$$\n\nThe first elements of the sequence ([OEIS A000045](http://oeis.org/A000045)) are:\n\n$$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...$$\n\n## Properties\n\nFibonacci numbers possess a lot of interesting properties. Here are a few of them:\n\n* Cassini's identity:\n  \n$$F_{n-1} F_{n+1} - F_n^2 = (-1)^n$$\n\n* The \"addition\" rule:\n  \n$$F_{n+k} = F_k F_{n+1} + F_{k-1} F_n$$\n\n* Applying the previous identity to the case $k = n$, we get:\n  \n$$F_{2n} = F_n (F_{n+1} + F_{n-1})$$\n\n* From this we can prove by induction that for any positive integer $k$,  $F_{nk}$ is multiple of $F_n$.\n\n* The inverse is also true: if $F_m$ is multiple of $F_n$, then $m$ is multiple of $n$.\n\n* GCD identity:\n  \n$$GCD(F_m, F_n) = F_{GCD(m, n)}$$\n\n* Fibonacci numbers are the worst possible inputs for Euclidean algorithm (see Lame's theorem in [Euclidean algorithm](euclid-algorithm.md))\n\n## Fibonacci Coding\n\nWe can use the sequence to encode positive integers into binary code words. According to Zeckendorf's theorem, any natural number $n$ can be uniquely represented as a sum of Fibonacci numbers:\n\n$$N = F_{k_1} + F_{k_2} + \\ldots + F_{k_r}$$\n\nsuch that $k_1 \\ge k_2 + 2,\\ k_2 \\ge k_3 + 2,\\  \\ldots,\\  k_r \\ge 2$ (i.e.: the representation cannot use two consecutive Fibonacci numbers).\n\nIt follows that any number can be uniquely encoded in the Fibonacci coding.\nAnd we can describe this representation with binary codes $d_0 d_1 d_2 \\dots d_s 1$, where $d_i$ is $1$ if $F_{i+2}$ is used in the representation.\nThe code will be appended by a $1$ do indicate the end of the code word.\nNotice that this is the only occurrence where two consecutive 1-bits appear.\n\n$$\\begin{eqnarray}\n1 &=& 1 &=& F_2 &=& (11)_F \\\\\n2 &=& 2 &=& F_3 &=& (011)_F \\\\\n6 &=& 5 + 1 &=& F_5 + F_2 &=& (10011)_F \\\\\n8 &=& 8 &=& F_6 &=& (000011)_F \\\\\n9 &=& 8 + 1 &=& F_6 + F_2 &=& (100011)_F \\\\\n19 &=& 13 + 5 + 1 &=& F_7 + F_5 + F_2 &=& (1001011)_F\n\\end{eqnarray}$$\n\nThe encoding of an integer $n$ can be done with a simple greedy algorithm:\n\n1. Iterate through the Fibonacci numbers from the largest to the smallest until you find one less than or equal to $n$.\n\n2. Suppose this number was $F_i$. Subtract $F_i$ from $n$ and put a $1$ in the $i-2$ position of the code word (indexing from 0 from the leftmost to the rightmost bit).\n\n3. Repeat until there is no remainder.\n\n4. Add a final $1$ to the codeword to indicate its end.\n\nTo decode a code word, first remove the final $1$. Then, if the $i$-th bit is set (indexing from 0 from the leftmost to the rightmost bit), sum $F_{i+2}$ to the number.\n\n\n## Formulas for the $n^{\\text{th}}$ Fibonacci number { data-toc-label=\"Formulas for the <script type='math/tex'>n</script>-th Fibonacci number\" }\n\n### Closed-form expression\n\nThere is a formula known as \"Binet's formula\", even though it was already known by Moivre:\n\n$$F_n = \\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}$$\n\nThis formula is easy to prove by induction, but it can be deduced with the help of the concept of generating functions or by solving a functional equation.\n\nYou can immediately notice that the second term's absolute value is always less than $1$, and it also decreases very rapidly (exponentially). Hence the value of the first term alone is \"almost\" $F_n$. This can be written strictly as: \n\n$$F_n = \\left[\\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}\\right]$$\n\nwhere the square brackets denote rounding to the nearest integer.\n\nAs these two formulas would require very high accuracy when working with fractional numbers, they are of little use in practical calculations.\n\n### Fibonacci in linear time\n\nThe $n$-th Fibonacci number can be easily found in $O(n)$ by computing the numbers one by one up to $n$. However, there are also faster ways, as we will see.\n\nWe can start from an iterative approach, to take advantage of the use of the formula $F_n = F_{n-1} + F_{n-2}$, therefore, we will simply precalculate those values in an array. Taking into account the base cases for $F_0$ and $F_1$.\n\n```{.cpp file=fibonacci_linear}\nint fib(int n) {\n    int a = 0;\n    int b = 1;\n    for (int i = 0; i < n; i++) {\n        int tmp = a + b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n```\n\nIn this way, we obtain a linear solution, $O(n)$ time, saving all the values prior to $n$ in the sequence.\n\n### Matrix form\n\nIt is easy to prove the following relation:\n\n$$\\begin{pmatrix} 1 & 1 \\cr 1 & 0 \\cr\\end{pmatrix} ^ n = \\begin{pmatrix} F_{n+1} & F_{n} \\cr F_{n} & F_{n-1} \\cr\\end{pmatrix}$$\n\nThus, in order to find $F_n$ in $O(log  n)$ time, we must raise the matrix to n. (See [Binary exponentiation](binary-exp.md))\n\n```{.cpp file=fibonacci_matrix}\nstruct matrix {\n    long long mat[2][2];\n    matrix friend operator *(const matrix &a, const matrix &b){\n        matrix c;\n        for (int i = 0; i < 2; i++) {\n          for (int j = 0; j < 2; j++) {\n              c.mat[i][j] = 0;\n              for (int k = 0; k < 2; k++) {\n                  c.mat[i][j] += a.mat[i][k] * b.mat[k][j];\n              }\n          }\n        }\n        return c;\n    }\n};\n\nmatrix matpow(matrix base, long long n) {\n    matrix ans{ {\n      {1, 0},\n      {0, 1}\n    } };\n    while (n) {\n        if(n&1)\n            ans = ans*base;\n        base = base*base;\n        n >>= 1;\n    }\n    return ans;\n}\n\nlong long fib(int n) {\n    matrix base{ {\n      {1, 1},\n      {1, 0}\n    } };\n    return matpow(base, n).mat[0][1];\n}\n```\n\n### Fast Doubling Method\n\nUsing expanding the above matrix expression for $n = 2\\cdot k$\n\n$$\n\\begin{pmatrix}\nF_{2k+1} & F_{2k}\\\\\nF_{2k} & F_{2k-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 & 1\\\\\n1 & 0\n\\end{pmatrix}^{2k}\n=\n\\begin{pmatrix}\nF_{k+1} & F_{k}\\\\\nF_{k} & F_{k-1}\n\\end{pmatrix}\n^2\n$$\n\nwe can find these simpler equations:\n\n$$ \\begin{align}\nF_{2k+1} &= F_{k+1}^2 + F_{k}^2 \\\\\nF_{2k} &= F_k(F_{k+1}+F_{k-1}) = F_k (2F_{k+1} - F_{k})\\\\\n\\end{align}.$$\n\nThus using above two equations Fibonacci numbers can be calculated easily by the following code:\n\n```{.cpp file=fibonacci_doubling}\npair<int, int> fib (int n) {\n    if (n == 0)\n        return {0, 1};\n\n    auto p = fib(n >> 1);\n    int c = p.first * (2 * p.second - p.first);\n    int d = p.first * p.first + p.second * p.second;\n    if (n & 1)\n        return {d, c + d};\n    else\n        return {c, d};\n}\n```\nThe above code returns $F_n$ and $F_{n+1}$ as a pair.\n\n## Periodicity modulo p\n\nConsider the Fibonacci sequence modulo $p$. We will prove the sequence is periodic.\n\nLet us prove this by contradiction. Consider the first $p^2 + 1$ pairs of Fibonacci numbers taken modulo $p$:\n\n$$(F_0,\\ F_1),\\ (F_1,\\ F_2),\\ \\ldots,\\ (F_{p^2},\\ F_{p^2 + 1})$$\n\nThere can only be $p$ different remainders modulo $p$, and at most $p^2$ different pairs of remainders, so there are at least two identical pairs among them. This is sufficient to prove the sequence is periodic, as a Fibonacci number is only determined by it's two predecessors. Hence if two pairs of consecutive numbers repeat, that would also mean the numbers after the pair will repeat in the same fashion.\n\nWe now choose two pairs of identical remainders with the smallest indices in the sequence. Let the pairs be $(F_a,\\ F_{a + 1})$ and $(F_b,\\ F_{b + 1})$. We will prove that $a = 0$. If this was false, there would be two previous pairs $(F_{a-1},\\ F_a)$ and $(F_{b-1},\\ F_b)$, which, by the property of Fibonacci numbers, would also be equal. However, this contradicts the fact that we had chosen pairs with the smallest indices, completing our proof that there is no pre-period (i.e the numbers are periodic starting from $F_0$).\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: fibonacci_numbers\n---\n\n# Fibonacci Numbers\n\nThe Fibonacci sequence is defined as follows:\n\n$$F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}$$\n\nThe first elements of the sequence ([OEIS A000045](http://oeis.org/A000045)) are:\n\n$$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...$$\n\n## Properties\n\nFibonacci numbers possess a lot of interesting properties. Here are a few of them:\n\n* Cassini's identity:\n  \n$$F_{n-1} F_{n+1} - F_n^2 = (-1)^n$$\n\n* The \"addition\" rule:\n  \n$$F_{n+k} = F_k F_{n+1} + F_{k-1} F_n$$\n\n* Applying the previous identity to the case $k = n$, we get:\n  \n$$F_{2n} = F_n (F_{n+1} + F_{n-1})$$\n\n* From this we can prove by induction that for any positive integer $k$,  $F_{nk}$ is multiple of $F_n$.\n\n* The inverse is also true: if $F_m$ is multiple of $F_n$, then $m$ is multiple of $n$.\n\n* GCD identity:\n  \n$$GCD(F_m, F_n) = F_{GCD(m, n)}$$\n\n* Fibonacci numbers are the worst possible inputs for Euclidean algorithm (see Lame's theorem in [Euclidean algorithm](euclid-algorithm.md))\n\n## Fibonacci Coding\n\nWe can use the sequence to encode positive integers into binary code words. According to Zeckendorf's theorem, any natural number $n$ can be uniquely represented as a sum of Fibonacci numbers:\n\n$$N = F_{k_1} + F_{k_2} + \\ldots + F_{k_r}$$\n\nsuch that $k_1 \\ge k_2 + 2,\\ k_2 \\ge k_3 + 2,\\  \\ldots,\\  k_r \\ge 2$ (i.e.: the representation cannot use two consecutive Fibonacci numbers).\n\nIt follows that any number can be uniquely encoded in the Fibonacci coding.\nAnd we can describe this representation with binary codes $d_0 d_1 d_2 \\dots d_s 1$, where $d_i$ is $1$ if $F_{i+2}$ is used in the representation.\nThe code will be appended by a $1$ do indicate the end of the code word.\nNotice that this is the only occurrence where two consecutive 1-bits appear.\n\n$$\\begin{eqnarray}\n1 &=& 1 &=& F_2 &=& (11)_F \\\\\n2 &=& 2 &=& F_3 &=& (011)_F \\\\\n6 &=& 5 + 1 &=& F_5 + F_2 &=& (10011)_F \\\\\n8 &=& 8 &=& F_6 &=& (000011)_F \\\\\n9 &=& 8 + 1 &=& F_6 + F_2 &=& (100011)_F \\\\\n19 &=& 13 + 5 + 1 &=& F_7 + F_5 + F_2 &=& (1001011)_F\n\\end{eqnarray}$$\n\nThe encoding of an integer $n$ can be done with a simple greedy algorithm:\n\n1. Iterate through the Fibonacci numbers from the largest to the smallest until you find one less than or equal to $n$.\n\n2. Suppose this number was $F_i$. Subtract $F_i$ from $n$ and put a $1$ in the $i-2$ position of the code word (indexing from 0 from the leftmost to the rightmost bit).\n\n3. Repeat until there is no remainder.\n\n4. Add a final $1$ to the codeword to indicate its end.\n\nTo decode a code word, first remove the final $1$. Then, if the $i$-th bit is set (indexing from 0 from the leftmost to the rightmost bit), sum $F_{i+2}$ to the number.\n\n\n## Formulas for the $n^{\\text{th}}$ Fibonacci number { data-toc-label=\"Formulas for the <script type='math/tex'>n</script>-th Fibonacci number\" }\n\n### Closed-form expression\n\nThere is a formula known as \"Binet's formula\", even though it was already known by Moivre:\n\n$$F_n = \\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}$$\n\nThis formula is easy to prove by induction, but it can be deduced with the help of the concept of generating functions or by solving a functional equation.\n\nYou can immediately notice that the second term's absolute value is always less than $1$, and it also decreases very rapidly (exponentially). Hence the value of the first term alone is \"almost\" $F_n$. This can be written strictly as: \n\n$$F_n = \\left[\\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}\\right]$$\n\nwhere the square brackets denote rounding to the nearest integer.\n\nAs these two formulas would require very high accuracy when working with fractional numbers, they are of little use in practical calculations.\n\n### Fibonacci in linear time\n\nThe $n$-th Fibonacci number can be easily found in $O(n)$ by computing the numbers one by one up to $n$. However, there are also faster ways, as we will see.\n\nWe can start from an iterative approach, to take advantage of the use of the formula $F_n = F_{n-1} + F_{n-2}$, therefore, we will simply precalculate those values in an array. Taking into account the base cases for $F_0$ and $F_1$.\n\n```{.cpp file=fibonacci_linear}\nint fib(int n) {\n    int a = 0;\n    int b = 1;\n    for (int i = 0; i < n; i++) {\n        int tmp = a + b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n```\n\nIn this way, we obtain a linear solution, $O(n)$ time, saving all the values prior to $n$ in the sequence.\n\n### Matrix form\n\nIt is easy to prove the following relation:\n\n$$\\begin{pmatrix} 1 & 1 \\cr 1 & 0 \\cr\\end{pmatrix} ^ n = \\begin{pmatrix} F_{n+1} & F_{n} \\cr F_{n} & F_{n-1} \\cr\\end{pmatrix}$$\n\nThus, in order to find $F_n$ in $O(log  n)$ time, we must raise the matrix to n. (See [Binary exponentiation](binary-exp.md))\n\n```{.cpp file=fibonacci_matrix}\nstruct matrix {\n    long long mat[2][2];\n    matrix friend operator *(const matrix &a, const matrix &b){\n        matrix c;\n        for (int i = 0; i < 2; i++) {\n          for (int j = 0; j < 2; j++) {\n              c.mat[i][j] = 0;\n              for (int k = 0; k < 2; k++) {\n                  c.mat[i][j] += a.mat[i][k] * b.mat[k][j];\n              }\n          }\n        }\n        return c;\n    }\n};\n\nmatrix matpow(matrix base, long long n) {\n    matrix ans{ {\n      {1, 0},\n      {0, 1}\n    } };\n    while (n) {\n        if(n&1)\n            ans = ans*base;\n        base = base*base;\n        n >>= 1;\n    }\n    return ans;\n}\n\nlong long fib(int n) {\n    matrix base{ {\n      {1, 1},\n      {1, 0}\n    } };\n    return matpow(base, n).mat[0][1];\n}\n```\n\n### Fast Doubling Method\n\nUsing expanding the above matrix expression for $n = 2\\cdot k$\n\n$$\n\\begin{pmatrix}\nF_{2k+1} & F_{2k}\\\\\nF_{2k} & F_{2k-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 & 1\\\\\n1 & 0\n\\end{pmatrix}^{2k}\n=\n\\begin{pmatrix}\nF_{k+1} & F_{k}\\\\\nF_{k} & F_{k-1}\n\\end{pmatrix}\n^2\n$$\n\nwe can find these simpler equations:\n\n$$ \\begin{align}\nF_{2k+1} &= F_{k+1}^2 + F_{k}^2 \\\\\nF_{2k} &= F_k(F_{k+1}+F_{k-1}) = F_k (2F_{k+1} - F_{k})\\\\\n\\end{align}.$$\n\nThus using above two equations Fibonacci numbers can be calculated easily by the following code:\n\n```{.cpp file=fibonacci_doubling}\npair<int, int> fib (int n) {\n    if (n == 0)\n        return {0, 1};\n\n    auto p = fib(n >> 1);\n    int c = p.first * (2 * p.second - p.first);\n    int d = p.first * p.first + p.second * p.second;\n    if (n & 1)\n        return {d, c + d};\n    else\n        return {c, d};\n}\n```\nThe above code returns $F_n$ and $F_{n+1}$ as a pair.\n\n## Periodicity modulo p\n\nConsider the Fibonacci sequence modulo $p$. We will prove the sequence is periodic.\n\nLet us prove this by contradiction. Consider the first $p^2 + 1$ pairs of Fibonacci numbers taken modulo $p$:\n\n$$(F_0,\\ F_1),\\ (F_1,\\ F_2),\\ \\ldots,\\ (F_{p^2},\\ F_{p^2 + 1})$$\n\nThere can only be $p$ different remainders modulo $p$, and at most $p^2$ different pairs of remainders, so there are at least two identical pairs among them. This is sufficient to prove the sequence is periodic, as a Fibonacci number is only determined by it's two predecessors. Hence if two pairs of consecutive numbers repeat, that would also mean the numbers after the pair will repeat in the same fashion.\n\nWe now choose two pairs of identical remainders with the smallest indices in the sequence. Let the pairs be $(F_a,\\ F_{a + 1})$ and $(F_b,\\ F_{b + 1})$. We will prove that $a = 0$. If this was false, there would be two previous pairs $(F_{a-1},\\ F_a)$ and $(F_{b-1},\\ F_b)$, which, by the property of Fibonacci numbers, would also be equal. However, this contradicts the fact that we had chosen pairs with the smallest indices, completing our proof that there is no pre-period (i.e the numbers are periodic starting from $F_0$).\n\n## Practice Problems\n\n* [SPOJ - Euclid Algorithm Revisited](http://www.spoj.com/problems/MAIN74/)\n* [SPOJ - Fibonacci Sum](http://www.spoj.com/problems/FIBOSUM/)\n* [HackerRank - Is Fibo](https://www.hackerrank.com/challenges/is-fibo/problem)\n* [Project Euler - Even Fibonacci numbers](https://www.hackerrank.com/contests/projecteuler/challenges/euler002/problem)\n* [DMOJ - Fibonacci Sequence](https://dmoj.ca/problem/fibonacci)\n* [DMOJ - Fibonacci Sequence (Harder)](https://dmoj.ca/problem/fibonacci2)\n* [DMOJ UCLV - Numbered sequence of pencils](https://dmoj.uclv.edu.cu/problem/secnum)\n* [DMOJ UCLV - Fibonacci 2D](https://dmoj.uclv.edu.cu/problem/fibonacci)\n* [DMOJ UCLV - fibonacci calculation](https://dmoj.uclv.edu.cu/problem/fibonaccicalculatio)\n* [LightOJ -  Number Sequence](https://lightoj.com/problem/number-sequence)\n* [Codeforces - C. Fibonacci](https://codeforces.com/problemset/gymProblem/102644/C)\n* [Codeforces - A. Hexadecimal's theorem](https://codeforces.com/problemset/problem/199/A)\n* [Codeforces - B. Blackboard Fibonacci](https://codeforces.com/problemset/problem/217/B)\n* [Codeforces - E. Fibonacci Number](https://codeforces.com/problemset/problem/193/E)\n", "problem_ids": [], "title": "Fibonacci Numbers"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: euler_function\n---\n\n# Euler's totient function\n\nEuler's totient function, also known as **phi-function** $\\phi (n)$, counts the number of integers between 1 and $n$ inclusive, which are coprime to $n$. Two numbers are coprime if their greatest common divisor equals $1$ ($1$ is considered to be coprime to any number).\n\nHere are values of $\\phi(n)$ for the first few positive integers:\n\n$$\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\n\\hline\nn & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\\\\\\ \\hline\n\\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\\\\\\\ \\hline\n\\end{array}$$\n\n## Properties\n\nThe following properties of Euler totient function are sufficient to calculate it for any number:\n\n  - If $p$ is a prime number, then $\\gcd(p, q) = 1$ for all $1 \\le q < p$. Therefore we have:\n  \n$$\\phi (p) = p - 1.$$\n\n  - If $p$ is a prime number and $k \\ge 1$, then there are exactly $p^k / p$ numbers between $1$ and $p^k$ that are divisible by $p$.\n    Which gives us:\n    \n$$\\phi(p^k) = p^k - p^{k-1}.$$\n\n  - If $a$ and $b$ are relatively prime, then:\n    \n    \\[\\phi(a b) = \\phi(a) \\cdot \\phi(b).\\]\n    \n    This relation is not trivial to see. It follows from the [Chinese remainder theorem](chinese-remainder-theorem.md). The Chinese remainder theorem guarantees, that for each $0 \\le x < a$ and each $0 \\le y < b$, there exists a unique $0 \\le z < a b$ with $z \\equiv x \\pmod{a}$ and $z \\equiv y \\pmod{b}$. It's not hard to show that $z$ is coprime to $a b$ if and only if $x$ is coprime to $a$ and $y$ is coprime to $b$. Therefore the amount of integers coprime to $a b$ is equal to product of the amounts of $a$ and $b$.\n\n  - In general, for not coprime $a$ and $b$, the equation\n\n    \\[\\phi(ab) = \\phi(a) \\cdot \\phi(b) \\cdot \\dfrac{d}{\\phi(d)}\\]\n\n    with $d = \\gcd(a, b)$ holds.\n\nThus, using the first three properties, we can compute $\\phi(n)$ through the factorization of $n$ (decomposition of $n$ into a product of its prime factors).\nIf $n = {p_1}^{a_1} \\cdot {p_2}^{a_2} \\cdots {p_k}^{a_k}$, where $p_i$ are prime factors of $n$,\n\n$$\\begin{align}\n\\phi (n) &= \\phi ({p_1}^{a_1}) \\cdot \\phi ({p_2}^{a_2}) \\cdots  \\phi ({p_k}^{a_k}) \\\\\\\\\n&= \\left({p_1}^{a_1} - {p_1}^{a_1 - 1}\\right) \\cdot \\left({p_2}^{a_2} - {p_2}^{a_2 - 1}\\right) \\cdots \\left({p_k}^{a_k} - {p_k}^{a_k - 1}\\right) \\\\\\\\\n&= p_1^{a_1} \\cdot \\left(1 - \\frac{1}{p_1}\\right) \\cdot p_2^{a_2} \\cdot \\left(1 - \\frac{1}{p_2}\\right) \\cdots p_k^{a_k} \\cdot \\left(1 - \\frac{1}{p_k}\\right) \\\\\\\\\n&= n \\cdot \\left(1 - \\frac{1}{p_1}\\right) \\cdot \\left(1 - \\frac{1}{p_2}\\right) \\cdots \\left(1 - \\frac{1}{p_k}\\right)\n\\end{align}$$\n\n## Implementation\n\nHere is an implementation using factorization in $O(\\sqrt{n})$:\n\n```cpp\nint phi(int n) {\n    int result = n;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            while (n % i == 0)\n                n /= i;\n            result -= result / i;\n        }\n    }\n    if (n > 1)\n        result -= result / n;\n    return result;\n}\n```\n\n## Euler totient function from $1$ to $n$ in $O(n \\log\\log{n})$ { #etf_1_to_n data-toc-label=\"Euler totient function from 1 to n in <script type=\\\"math/tex\\\">O(n log log n)</script>\" }\n\nIf we need all all the totient of all numbers between $1$ and $n$, then factorizing all $n$ numbers is not efficient.\nWe can use the same idea as the [Sieve of Eratosthenes](sieve-of-eratosthenes.md).\nIt is still based on the property shown above, but instead of updating the temporary result for each prime factor for each number, we find all prime numbers and for each one update the temporary results of all numbers that are divisible by that prime number.\n\nSince this approach is basically identical to the Sieve of Eratosthenes, the complexity will also be the same: $O(n \\log \\log n)$\n\n```cpp\nvoid phi_1_to_n(int n) {\n    vector<int> phi(n + 1);\n    for (int i = 0; i <= n; i++)\n        phi[i] = i;\n    \n    for (int i = 2; i <= n; i++) {\n        if (phi[i] == i) {\n            for (int j = i; j <= n; j += i)\n                phi[j] -= phi[j] / i;\n        }\n    }\n}\n```\n\n\n## Divisor sum property { #divsum}\n\nThis interesting property was established by Gauss:\n\n$$ \\sum_{d|n} \\phi{(d)} = n$$\n\nHere the sum is over all positive divisors $d$ of $n$.\n\nFor instance the divisors of 10 are 1, 2, 5 and 10.\nHence $\\phi{(1)} + \\phi{(2)} + \\phi{(5)} + \\phi{(10)} = 1 + 1 + 4 + 4 = 10$.\n\n### Finding the totient from 1 to $n$ using the divisor sum property { data-toc-label=\"Finding the totient from 1 to n using the divisor sum property\" }\n\nThe divisor sum property also allows us to compute the totient of all numbers between 1 and $n$.\nThis implementation is a little simpler than the previous implementation based on the Sieve of Eratosthenes, however also has a slightly worse complexity: $O(n \\log n)$\n\n```cpp\nvoid phi_1_to_n(int n) {\n    vector<int> phi(n + 1);\n    phi[0] = 0;\n    phi[1] = 1;\n    for (int i = 2; i <= n; i++)\n        phi[i] = i - 1;\n    \n    for (int i = 2; i <= n; i++)\n        for (int j = 2 * i; j <= n; j += i)\n              phi[j] -= phi[i];\n}\n```\n\n## Application in Euler's theorem { #application }\n\nThe most famous and important property of Euler's totient function is expressed in **Euler's theorem**: \n\n$$a^{\\phi(m)} \\equiv 1 \\pmod m \\quad \\text{if } a \\text{ and } m \\text{ are relatively prime.}$$\n\nIn the particular case when $m$ is prime, Euler's theorem turns into **Fermat's little theorem**:\n\n$$a^{m - 1} \\equiv 1 \\pmod m$$\n\nEuler's theorem and Euler's totient function occur quite often in practical applications, for example both are used to compute the [modular multiplicative inverse](module-inverse.md).\n\nAs immediate consequence we also get the equivalence:\n\n$$a^n \\equiv a^{n \\bmod \\phi(m)} \\pmod m$$\n\nThis allows computing $x^n \\bmod m$ for very big $n$, especially if $n$ is the result of another computation, as it allows to compute $n$ under a modulo.\n\n## Generalization\n\nThere is a less known version of the last equivalence, that allows computing $x^n \\bmod m$ efficiently for not coprime $x$ and $m$.\nFor arbitrary $x, m$ and $n \\geq \\log_2 m$:\n\n$$x^{n}\\equiv x^{\\phi(m)+[n \\bmod \\phi(m)]} \\mod m$$\n\nProof:\n\nLet $p_1, \\dots, p_t$ be common prime divisors of $x$ and $m$, and $k_i$ their exponents in $m$.\nWith those we define $a = p_1^{k_1} \\dots p_t^{k_t}$, which makes $\\frac{m}{a}$ coprime to $x$.\nAnd let $k$ be the smallest number such that $a$ divides $x^k$.\nAssuming $n \\ge k$, we can write:\n\n$$\\begin{align}x^n \\bmod m &= \\frac{x^k}{a}ax^{n-k}\\bmod m \\\\\n&= \\frac{x^k}{a}\\left(ax^{n-k}\\bmod m\\right) \\bmod m \\\\\n&= \\frac{x^k}{a}\\left(ax^{n-k}\\bmod a \\frac{m}{a}\\right) \\bmod m \\\\\n&=\\frac{x^k}{a} a \\left(x^{n-k} \\bmod \\frac{m}{a}\\right)\\bmod m \\\\\n&= x^k\\left(x^{n-k} \\bmod \\frac{m}{a}\\right)\\bmod m\n\\end{align}$$\n\nThe equivalence between the third and forth line follows from the fact that $ab \\bmod ac = a(b \\bmod c)$.\nIndeed if $b = cd + r$ with $r < c$, then $ab = acd + ar$ with $ar < ac$.\n\nSince $x$ and $\\frac{m}{a}$ are coprime, we can apply Euler's theorem and get the efficient (since $k$ is very small; in fact $k \\le \\log_2 m$) formula:\n\n$$x^n \\bmod m = x^k\\left(x^{n-k \\bmod \\phi(\\frac{m}{a})} \\bmod \\frac{m}{a}\\right)\\bmod m.$$\n\nThis formula is difficult to apply, but we can use it to analyze the behavior of $x^n \\bmod m$. We can see that the sequence of powers $(x^1 \\bmod m, x^2 \\bmod m, x^3 \\bmod m, \\dots)$ enters a cycle of length $\\phi\\left(\\frac{m}{a}\\right)$ after the first $k$ (or less) elements. \n$\\phi\\left(\\frac{m}{a}\\right)$ divides $\\phi(m)$ (because $a$ and $\\frac{m}{a}$ are coprime we have $\\phi(a) \\cdot \\phi\\left(\\frac{m}{a}\\right) = \\phi(m)$), therefore we can also say that the period has length $\\phi(m)$.\nAnd since $\\phi(m) \\ge \\log_2 m \\ge k$, we can conclude the desired, much simpler, formula:\n\n$$ x^n \\equiv x^{\\phi(m)} x^{(n - \\phi(m)) \\bmod \\phi(m)} \\bmod m \\equiv x^{\\phi(m)+[n \\bmod \\phi(m)]} \\mod m.$$\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: euler_function\n---\n\n# Euler's totient function\n\nEuler's totient function, also known as **phi-function** $\\phi (n)$, counts the number of integers between 1 and $n$ inclusive, which are coprime to $n$. Two numbers are coprime if their greatest common divisor equals $1$ ($1$ is considered to be coprime to any number).\n\nHere are values of $\\phi(n)$ for the first few positive integers:\n\n$$\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\n\\hline\nn & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\\\\\\ \\hline\n\\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\\\\\\\ \\hline\n\\end{array}$$\n\n## Properties\n\nThe following properties of Euler totient function are sufficient to calculate it for any number:\n\n  - If $p$ is a prime number, then $\\gcd(p, q) = 1$ for all $1 \\le q < p$. Therefore we have:\n  \n$$\\phi (p) = p - 1.$$\n\n  - If $p$ is a prime number and $k \\ge 1$, then there are exactly $p^k / p$ numbers between $1$ and $p^k$ that are divisible by $p$.\n    Which gives us:\n    \n$$\\phi(p^k) = p^k - p^{k-1}.$$\n\n  - If $a$ and $b$ are relatively prime, then:\n    \n    \\[\\phi(a b) = \\phi(a) \\cdot \\phi(b).\\]\n    \n    This relation is not trivial to see. It follows from the [Chinese remainder theorem](chinese-remainder-theorem.md). The Chinese remainder theorem guarantees, that for each $0 \\le x < a$ and each $0 \\le y < b$, there exists a unique $0 \\le z < a b$ with $z \\equiv x \\pmod{a}$ and $z \\equiv y \\pmod{b}$. It's not hard to show that $z$ is coprime to $a b$ if and only if $x$ is coprime to $a$ and $y$ is coprime to $b$. Therefore the amount of integers coprime to $a b$ is equal to product of the amounts of $a$ and $b$.\n\n  - In general, for not coprime $a$ and $b$, the equation\n\n    \\[\\phi(ab) = \\phi(a) \\cdot \\phi(b) \\cdot \\dfrac{d}{\\phi(d)}\\]\n\n    with $d = \\gcd(a, b)$ holds.\n\nThus, using the first three properties, we can compute $\\phi(n)$ through the factorization of $n$ (decomposition of $n$ into a product of its prime factors).\nIf $n = {p_1}^{a_1} \\cdot {p_2}^{a_2} \\cdots {p_k}^{a_k}$, where $p_i$ are prime factors of $n$,\n\n$$\\begin{align}\n\\phi (n) &= \\phi ({p_1}^{a_1}) \\cdot \\phi ({p_2}^{a_2}) \\cdots  \\phi ({p_k}^{a_k}) \\\\\\\\\n&= \\left({p_1}^{a_1} - {p_1}^{a_1 - 1}\\right) \\cdot \\left({p_2}^{a_2} - {p_2}^{a_2 - 1}\\right) \\cdots \\left({p_k}^{a_k} - {p_k}^{a_k - 1}\\right) \\\\\\\\\n&= p_1^{a_1} \\cdot \\left(1 - \\frac{1}{p_1}\\right) \\cdot p_2^{a_2} \\cdot \\left(1 - \\frac{1}{p_2}\\right) \\cdots p_k^{a_k} \\cdot \\left(1 - \\frac{1}{p_k}\\right) \\\\\\\\\n&= n \\cdot \\left(1 - \\frac{1}{p_1}\\right) \\cdot \\left(1 - \\frac{1}{p_2}\\right) \\cdots \\left(1 - \\frac{1}{p_k}\\right)\n\\end{align}$$\n\n## Implementation\n\nHere is an implementation using factorization in $O(\\sqrt{n})$:\n\n```cpp\nint phi(int n) {\n    int result = n;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            while (n % i == 0)\n                n /= i;\n            result -= result / i;\n        }\n    }\n    if (n > 1)\n        result -= result / n;\n    return result;\n}\n```\n\n## Euler totient function from $1$ to $n$ in $O(n \\log\\log{n})$ { #etf_1_to_n data-toc-label=\"Euler totient function from 1 to n in <script type=\\\"math/tex\\\">O(n log log n)</script>\" }\n\nIf we need all all the totient of all numbers between $1$ and $n$, then factorizing all $n$ numbers is not efficient.\nWe can use the same idea as the [Sieve of Eratosthenes](sieve-of-eratosthenes.md).\nIt is still based on the property shown above, but instead of updating the temporary result for each prime factor for each number, we find all prime numbers and for each one update the temporary results of all numbers that are divisible by that prime number.\n\nSince this approach is basically identical to the Sieve of Eratosthenes, the complexity will also be the same: $O(n \\log \\log n)$\n\n```cpp\nvoid phi_1_to_n(int n) {\n    vector<int> phi(n + 1);\n    for (int i = 0; i <= n; i++)\n        phi[i] = i;\n    \n    for (int i = 2; i <= n; i++) {\n        if (phi[i] == i) {\n            for (int j = i; j <= n; j += i)\n                phi[j] -= phi[j] / i;\n        }\n    }\n}\n```\n\n\n## Divisor sum property { #divsum}\n\nThis interesting property was established by Gauss:\n\n$$ \\sum_{d|n} \\phi{(d)} = n$$\n\nHere the sum is over all positive divisors $d$ of $n$.\n\nFor instance the divisors of 10 are 1, 2, 5 and 10.\nHence $\\phi{(1)} + \\phi{(2)} + \\phi{(5)} + \\phi{(10)} = 1 + 1 + 4 + 4 = 10$.\n\n### Finding the totient from 1 to $n$ using the divisor sum property { data-toc-label=\"Finding the totient from 1 to n using the divisor sum property\" }\n\nThe divisor sum property also allows us to compute the totient of all numbers between 1 and $n$.\nThis implementation is a little simpler than the previous implementation based on the Sieve of Eratosthenes, however also has a slightly worse complexity: $O(n \\log n)$\n\n```cpp\nvoid phi_1_to_n(int n) {\n    vector<int> phi(n + 1);\n    phi[0] = 0;\n    phi[1] = 1;\n    for (int i = 2; i <= n; i++)\n        phi[i] = i - 1;\n    \n    for (int i = 2; i <= n; i++)\n        for (int j = 2 * i; j <= n; j += i)\n              phi[j] -= phi[i];\n}\n```\n\n## Application in Euler's theorem { #application }\n\nThe most famous and important property of Euler's totient function is expressed in **Euler's theorem**: \n\n$$a^{\\phi(m)} \\equiv 1 \\pmod m \\quad \\text{if } a \\text{ and } m \\text{ are relatively prime.}$$\n\nIn the particular case when $m$ is prime, Euler's theorem turns into **Fermat's little theorem**:\n\n$$a^{m - 1} \\equiv 1 \\pmod m$$\n\nEuler's theorem and Euler's totient function occur quite often in practical applications, for example both are used to compute the [modular multiplicative inverse](module-inverse.md).\n\nAs immediate consequence we also get the equivalence:\n\n$$a^n \\equiv a^{n \\bmod \\phi(m)} \\pmod m$$\n\nThis allows computing $x^n \\bmod m$ for very big $n$, especially if $n$ is the result of another computation, as it allows to compute $n$ under a modulo.\n\n## Generalization\n\nThere is a less known version of the last equivalence, that allows computing $x^n \\bmod m$ efficiently for not coprime $x$ and $m$.\nFor arbitrary $x, m$ and $n \\geq \\log_2 m$:\n\n$$x^{n}\\equiv x^{\\phi(m)+[n \\bmod \\phi(m)]} \\mod m$$\n\nProof:\n\nLet $p_1, \\dots, p_t$ be common prime divisors of $x$ and $m$, and $k_i$ their exponents in $m$.\nWith those we define $a = p_1^{k_1} \\dots p_t^{k_t}$, which makes $\\frac{m}{a}$ coprime to $x$.\nAnd let $k$ be the smallest number such that $a$ divides $x^k$.\nAssuming $n \\ge k$, we can write:\n\n$$\\begin{align}x^n \\bmod m &= \\frac{x^k}{a}ax^{n-k}\\bmod m \\\\\n&= \\frac{x^k}{a}\\left(ax^{n-k}\\bmod m\\right) \\bmod m \\\\\n&= \\frac{x^k}{a}\\left(ax^{n-k}\\bmod a \\frac{m}{a}\\right) \\bmod m \\\\\n&=\\frac{x^k}{a} a \\left(x^{n-k} \\bmod \\frac{m}{a}\\right)\\bmod m \\\\\n&= x^k\\left(x^{n-k} \\bmod \\frac{m}{a}\\right)\\bmod m\n\\end{align}$$\n\nThe equivalence between the third and forth line follows from the fact that $ab \\bmod ac = a(b \\bmod c)$.\nIndeed if $b = cd + r$ with $r < c$, then $ab = acd + ar$ with $ar < ac$.\n\nSince $x$ and $\\frac{m}{a}$ are coprime, we can apply Euler's theorem and get the efficient (since $k$ is very small; in fact $k \\le \\log_2 m$) formula:\n\n$$x^n \\bmod m = x^k\\left(x^{n-k \\bmod \\phi(\\frac{m}{a})} \\bmod \\frac{m}{a}\\right)\\bmod m.$$\n\nThis formula is difficult to apply, but we can use it to analyze the behavior of $x^n \\bmod m$. We can see that the sequence of powers $(x^1 \\bmod m, x^2 \\bmod m, x^3 \\bmod m, \\dots)$ enters a cycle of length $\\phi\\left(\\frac{m}{a}\\right)$ after the first $k$ (or less) elements. \n$\\phi\\left(\\frac{m}{a}\\right)$ divides $\\phi(m)$ (because $a$ and $\\frac{m}{a}$ are coprime we have $\\phi(a) \\cdot \\phi\\left(\\frac{m}{a}\\right) = \\phi(m)$), therefore we can also say that the period has length $\\phi(m)$.\nAnd since $\\phi(m) \\ge \\log_2 m \\ge k$, we can conclude the desired, much simpler, formula:\n\n$$ x^n \\equiv x^{\\phi(m)} x^{(n - \\phi(m)) \\bmod \\phi(m)} \\bmod m \\equiv x^{\\phi(m)+[n \\bmod \\phi(m)]} \\mod m.$$\n\n## Practice Problems  \n\n* [SPOJ #4141 \"Euler Totient Function\" [Difficulty: CakeWalk]](http://www.spoj.com/problems/ETF/)\n* [UVA #10179 \"Irreducible Basic Fractions\" [Difficulty: Easy]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1120)\n* [UVA #10299 \"Relatives\" [Difficulty: Easy]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1240)\n* [UVA #11327 \"Enumerating Rational Numbers\" [Difficulty: Medium]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2302)\n* [TIMUS #1673 \"Admission to Exam\" [Difficulty: High]](http://acm.timus.ru/problem.aspx?space=1&num=1673)\n* [UVA 10990 - Another New Function](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1931)\n* [Codechef - Golu and Sweetness](https://www.codechef.com/problems/COZIE)\n* [SPOJ - LCM Sum](http://www.spoj.com/problems/LCMSUM/)\n* [GYM - Simple Calculations  (F)](http://codeforces.com/gym/100975)\n* [UVA 13132 - Laser Mirrors](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=5043)\n* [SPOJ - GCDEX](http://www.spoj.com/problems/GCDEX/)\n* [UVA 12995 - Farey Sequence](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4878)\n* [SPOJ - Totient in Permutation (easy)](http://www.spoj.com/problems/TIP1/)\n* [LOJ - Mathematically Hard](http://lightoj.com/volume_showproblem.php?problem=1007)\n* [SPOJ - Totient Extreme](http://www.spoj.com/problems/DCEPCA03/)\n* [SPOJ - Playing with GCD](http://www.spoj.com/problems/NAJPWG/)\n* [SPOJ - G Force](http://www.spoj.com/problems/DCEPC12G/)\n* [SPOJ - Smallest Inverse Euler Totient Function](http://www.spoj.com/problems/INVPHI/)\n* [Codeforces - Power Tower](http://codeforces.com/problemset/problem/906/D)\n* [Kattis - Exponial](https://open.kattis.com/problems/exponial)\n* [LeetCode - 372. Super Pow](https://leetcode.com/problems/super-pow/)\n* [Codeforces - The Holmes Children](http://codeforces.com/problemset/problem/776/E)\n", "problem_ids": ["906_D", "776_E"], "title": "Euler's totient function"}, {"article": "---\ntags:\n  - Original\n---\n\n# Number of divisors / sum of divisors\n\nIn this article we discuss how to compute the number of divisors $d(n)$ and the sum of divisors $\\sigma(n)$ of a given number $n$.\n\n## Number of divisors\n\nIt should be obvious that the prime factorization of a divisor $d$ has to be a subset of the prime factorization of $n$, e.g. $6 = 2 \\cdot 3$ is a divisor of $60 = 2^2 \\cdot 3 \\cdot 5$.\nSo we only need to find all different subsets of the prime factorization of $n$.\n\nUsually the number of subsets is $2^x$ for a set with $x$ elements.\nHowever this is no longer true, if there are repeated elements in the set. In our case some prime factors may appear multiple times in the prime factorization of $n$.\n\nIf a prime factor $p$ appears $e$ times in the prime factorization of $n$, then we can use the factor $p$ up to $e$ times in the subset.\nWhich means we have $e+1$ choices.\n\nTherefore if the prime factorization of $n$ is $p_1^{e_1} \\cdot p_2^{e_2} \\cdots p_k^{e_k}$, where $p_i$ are distinct prime numbers, then the number of divisors is:\n\n$$d(n) = (e_1 + 1) \\cdot (e_2 + 1) \\cdots (e_k + 1)$$\n\nA way of thinking about it is the following:\n\n* If there is only one distinct prime divisor $n = p_1^{e_1}$, then there are obviously $e_1 + 1$ divisors ($1, p_1, p_1^2, \\dots, p_1^{e_1}$).\n\n* If there are two distinct prime divisors $n = p_1^{e_1} \\cdot p_2^{e_2}$, then you can arrange all divisors in form of a tabular.\n\n$$\\begin{array}{c|ccccc}\n& 1 & p_2 & p_2^2 & \\dots & p_2^{e_2} \\\\\\\\\\hline\n1 & 1 & p_2 & p_2^2 & \\dots & p_2^{e_2} \\\\\\\\\np_1 & p_1 & p_1 \\cdot p_2 & p_1 \\cdot p_2^2 & \\dots & p_1 \\cdot p_2^{e_2} \\\\\\\\\np_1^2 & p_1^2 & p_1^2 \\cdot p_2 & p_1^2 \\cdot p_2^2 & \\dots & p_1^2 \\cdot p_2^{e_2} \\\\\\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\\\\\np_1^{e_1} & p_1^{e_1} & p_1^{e_1} \\cdot p_2 & p_1^{e_1} \\cdot p_2^2 & \\dots & p_1^{e_1} \\cdot p_2^{e_2} \\\\\\\\\n\\end{array}$$\n\nSo the number of divisors is trivially $(e_1 + 1) \\cdot (e_2 + 1)$.\n\n* A similar argument can be made if there are more then two distinct prime factors.\n\n\n```cpp\nlong long numberOfDivisors(long long num) {\n    long long total = 1;\n    for (int i = 2; (long long)i * i <= num; i++) {\n        if (num % i == 0) {\n            int e = 0;\n            do {\n                e++;\n                num /= i;\n            } while (num % i == 0);\n            total *= e + 1;\n        }\n    }\n    if (num > 1) {\n        total *= 2;\n    }\n    return total;\n}\n```\n\n## Sum of divisors\n\nWe can use the same argument of the previous section.\n\n* If there is only one distinct prime divisor $n = p_1^{e_1}$, then the sum is:\n\n$$1 + p_1 + p_1^2 + \\dots + p_1^{e_1} = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1}$$\n\n* If there are two distinct prime divisors $n = p_1^{e_1} \\cdot p_2^{e_2}$, then we can make the same table as before.\n  The only difference is that now we now want to compute the sum instead of counting the elements.\n  It is easy to see, that the sum of each combination can be expressed as:\n\n$$\\left(1 + p_1 + p_1^2 + \\dots + p_1^{e_1}\\right) \\cdot \\left(1 + p_2 + p_2^2 + \\dots + p_2^{e_2}\\right)$$\n\n$$ = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1} \\cdot \\frac{p_2^{e_2 + 1} - 1}{p_2 - 1}$$\n\n* In general, for $n = p_1^{e_1} \\cdot p_2^{e_2} \\cdots p_k^{e_k}$ we receive the formula:\n\n$$\\sigma(n) = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1} \\cdot \\frac{p_2^{e_2 + 1} - 1}{p_2 - 1} \\cdots \\frac{p_k^{e_k + 1} - 1}{p_k - 1}$$\n\n```cpp\nlong long SumOfDivisors(long long num) {\n    long long total = 1;\n\n    for (int i = 2; (long long)i * i <= num; i++) {\n        if (num % i == 0) {\n            int e = 0;\n            do {\n                e++;\n                num /= i;\n            } while (num % i == 0);\n\n            long long sum = 0, pow = 1;\n            do {\n                sum += pow;\n                pow *= i;\n            } while (e-- > 0);\n            total *= sum;\n        }\n    }\n    if (num > 1) {\n        total *= (1 + num);\n    }\n    return total;\n}\n```\n\n## Multiplicative functions\n\nA multiplicative function is a function $f(x)$ which satisfies\n\n$$f(a \\cdot b) = f(a) \\cdot f(b)$$\n\nif $a$ and $b$ are coprime.\n\nBoth $d(n)$ and $\\sigma(n)$ are multiplicative functions.\n\nMultiplicative functions have a huge variety of interesting properties, which can be very useful in number theory problems.\nFor instance the Dirichlet convolution of two multiplicative functions is also multiplicative.\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Number of divisors / sum of divisors\n\nIn this article we discuss how to compute the number of divisors $d(n)$ and the sum of divisors $\\sigma(n)$ of a given number $n$.\n\n## Number of divisors\n\nIt should be obvious that the prime factorization of a divisor $d$ has to be a subset of the prime factorization of $n$, e.g. $6 = 2 \\cdot 3$ is a divisor of $60 = 2^2 \\cdot 3 \\cdot 5$.\nSo we only need to find all different subsets of the prime factorization of $n$.\n\nUsually the number of subsets is $2^x$ for a set with $x$ elements.\nHowever this is no longer true, if there are repeated elements in the set. In our case some prime factors may appear multiple times in the prime factorization of $n$.\n\nIf a prime factor $p$ appears $e$ times in the prime factorization of $n$, then we can use the factor $p$ up to $e$ times in the subset.\nWhich means we have $e+1$ choices.\n\nTherefore if the prime factorization of $n$ is $p_1^{e_1} \\cdot p_2^{e_2} \\cdots p_k^{e_k}$, where $p_i$ are distinct prime numbers, then the number of divisors is:\n\n$$d(n) = (e_1 + 1) \\cdot (e_2 + 1) \\cdots (e_k + 1)$$\n\nA way of thinking about it is the following:\n\n* If there is only one distinct prime divisor $n = p_1^{e_1}$, then there are obviously $e_1 + 1$ divisors ($1, p_1, p_1^2, \\dots, p_1^{e_1}$).\n\n* If there are two distinct prime divisors $n = p_1^{e_1} \\cdot p_2^{e_2}$, then you can arrange all divisors in form of a tabular.\n\n$$\\begin{array}{c|ccccc}\n& 1 & p_2 & p_2^2 & \\dots & p_2^{e_2} \\\\\\\\\\hline\n1 & 1 & p_2 & p_2^2 & \\dots & p_2^{e_2} \\\\\\\\\np_1 & p_1 & p_1 \\cdot p_2 & p_1 \\cdot p_2^2 & \\dots & p_1 \\cdot p_2^{e_2} \\\\\\\\\np_1^2 & p_1^2 & p_1^2 \\cdot p_2 & p_1^2 \\cdot p_2^2 & \\dots & p_1^2 \\cdot p_2^{e_2} \\\\\\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\\\\\np_1^{e_1} & p_1^{e_1} & p_1^{e_1} \\cdot p_2 & p_1^{e_1} \\cdot p_2^2 & \\dots & p_1^{e_1} \\cdot p_2^{e_2} \\\\\\\\\n\\end{array}$$\n\nSo the number of divisors is trivially $(e_1 + 1) \\cdot (e_2 + 1)$.\n\n* A similar argument can be made if there are more then two distinct prime factors.\n\n\n```cpp\nlong long numberOfDivisors(long long num) {\n    long long total = 1;\n    for (int i = 2; (long long)i * i <= num; i++) {\n        if (num % i == 0) {\n            int e = 0;\n            do {\n                e++;\n                num /= i;\n            } while (num % i == 0);\n            total *= e + 1;\n        }\n    }\n    if (num > 1) {\n        total *= 2;\n    }\n    return total;\n}\n```\n\n## Sum of divisors\n\nWe can use the same argument of the previous section.\n\n* If there is only one distinct prime divisor $n = p_1^{e_1}$, then the sum is:\n\n$$1 + p_1 + p_1^2 + \\dots + p_1^{e_1} = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1}$$\n\n* If there are two distinct prime divisors $n = p_1^{e_1} \\cdot p_2^{e_2}$, then we can make the same table as before.\n  The only difference is that now we now want to compute the sum instead of counting the elements.\n  It is easy to see, that the sum of each combination can be expressed as:\n\n$$\\left(1 + p_1 + p_1^2 + \\dots + p_1^{e_1}\\right) \\cdot \\left(1 + p_2 + p_2^2 + \\dots + p_2^{e_2}\\right)$$\n\n$$ = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1} \\cdot \\frac{p_2^{e_2 + 1} - 1}{p_2 - 1}$$\n\n* In general, for $n = p_1^{e_1} \\cdot p_2^{e_2} \\cdots p_k^{e_k}$ we receive the formula:\n\n$$\\sigma(n) = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1} \\cdot \\frac{p_2^{e_2 + 1} - 1}{p_2 - 1} \\cdots \\frac{p_k^{e_k + 1} - 1}{p_k - 1}$$\n\n```cpp\nlong long SumOfDivisors(long long num) {\n    long long total = 1;\n\n    for (int i = 2; (long long)i * i <= num; i++) {\n        if (num % i == 0) {\n            int e = 0;\n            do {\n                e++;\n                num /= i;\n            } while (num % i == 0);\n\n            long long sum = 0, pow = 1;\n            do {\n                sum += pow;\n                pow *= i;\n            } while (e-- > 0);\n            total *= sum;\n        }\n    }\n    if (num > 1) {\n        total *= (1 + num);\n    }\n    return total;\n}\n```\n\n## Multiplicative functions\n\nA multiplicative function is a function $f(x)$ which satisfies\n\n$$f(a \\cdot b) = f(a) \\cdot f(b)$$\n\nif $a$ and $b$ are coprime.\n\nBoth $d(n)$ and $\\sigma(n)$ are multiplicative functions.\n\nMultiplicative functions have a huge variety of interesting properties, which can be very useful in number theory problems.\nFor instance the Dirichlet convolution of two multiplicative functions is also multiplicative.\n\n## Practice Problems\n\n  - [SPOJ - COMDIV](https://www.spoj.com/problems/COMDIV/)\n  - [SPOJ - DIVSUM](https://www.spoj.com/problems/DIVSUM/)\n  - [SPOJ - DIVSUM2](https://www.spoj.com/problems/DIVSUM2/)\n", "problem_ids": [], "title": "Number of divisors / sum of divisors"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: chinese_theorem\n---\n\n# Chinese Remainder Theorem\n\nThe Chinese Remainder Theorem (which will be referred to as CRT in the rest of this article) was discovered by Chinese mathematician Sun Zi.\n\n## Formulation\n\nLet $m = m_1 \\cdot m_2 \\cdots m_k$, where $m_i$ are pairwise coprime. In addition to $m_i$, we are also given a system of congruences\n\n$$\\left\\{\\begin{array}{rcl}\n    a & \\equiv & a_1 \\pmod{m_1} \\\\\n    a & \\equiv & a_2 \\pmod{m_2} \\\\\n      & \\vdots & \\\\\n    a & \\equiv & a_k \\pmod{m_k}\n\\end{array}\\right.$$\n\nwhere $a_i$ are some given constants. The original form of CRT then states that the given system of congruences always has *one and exactly one* solution modulo $m$.\n\nE.g. the system of congruences\n\n$$\\left\\{\\begin{array}{rcl}\n    a & \\equiv & 2 \\pmod{3} \\\\\n    a & \\equiv & 3 \\pmod{5} \\\\\n    a & \\equiv & 2 \\pmod{7}\n\\end{array}\\right.$$\n\nhas the solution $23$ modulo $105$, because $23 \\bmod{3} = 2$, $23 \\bmod{5} = 3$, and $23 \\bmod{7} = 2$.\nWe can write down every solution as $23 + 105\\cdot k$ for $k \\in \\mathbb{Z}$.\n\n\n### Corollary\n\nA consequence of the CRT is that the equation\n\n$$x \\equiv a \\pmod{m}$$\n\nis equivalent to the system of equations\n\n$$\\left\\{\\begin{array}{rcl}\n    x & \\equiv & a_1 \\pmod{m_1} \\\\\n      & \\vdots & \\\\\n    x & \\equiv & a_k \\pmod{m_k}\n\\end{array}\\right.$$\n\n(As above, assume that $m = m_1 m_2 \\cdots m_k$ and $m_i$ are pairwise coprime).\n\n## Solution for Two Moduli\n\nConsider a system of two equations for coprime $m_1, m_2$:\n\n$$\n\\left\\{\\begin{align}\n    a &\\equiv a_1 \\pmod{m_1} \\\\\n    a &\\equiv a_2 \\pmod{m_2} \\\\\n\\end{align}\\right.\n$$\n\nWe want to find a solution for $a \\pmod{m_1 m_2}$. Using the [Extended Euclidean Algorithm](extended-euclid-algorithm.md) we can find B\u00e9zout coefficients $n_1, n_2$ such that\n\n$$n_1 m_1 + n_2 m_2 = 1.$$\n\nIn fact $n_1$ and $n_2$ are just the [modular inverses](module-inverse.md) of $m_1$ and $m_2$ modulo $m_2$ and $m_1$.\nWe have $n_1 m_1 \\equiv 1 \\pmod{m_2}$ so $n_1 \\equiv m_1^{-1} \\pmod{m_2}$, and vice versa $n_2 \\equiv m_2^{-1} \\pmod{m_1}$. \n\nWith those two coefficients we can define a solution:\n\n$$a = a_1 n_2 m_2 + a_2 n_1 m_1 \\bmod{m_1 m_2}$$\n\nIt's easy to verify that this is indeed a solution by computing $a \\bmod{m_1}$ and $a \\bmod{m_2}$.\n\n$$\n\\begin{array}{rcll}\na & \\equiv & a_1 n_2 m_2 + a_2 n_1 m_1 & \\pmod{m_1}\\\\\n  & \\equiv & a_1 (1 - n_1 m_1) + a_2 n_1 m_1 & \\pmod{m_1}\\\\\n  & \\equiv & a_1 - a_1 n_1 m_1 + a_2 n_1 m_1 & \\pmod{m_1}\\\\\n  & \\equiv & a_1 & \\pmod{m_1}\n\\end{array}\n$$\n\nNotice, that the Chinese Remainder Theorem also guarantees, that only 1 solution exists modulo $m_1 m_2$.\nThis is also easy to prove.\n\nLets assume that you have two different solutions $x$ and $y$.\nBecause $x \\equiv a_i \\pmod{m_i}$ and $y \\equiv a_i \\pmod{m_i}$, it follows that $x \u2212 y \\equiv 0 \\pmod{m_i}$ and therefore $x \u2212 y \\equiv 0 \\pmod{m_1 m_2}$ or equivalently $x \\equiv y \\pmod{m_1 m_2}$.\nSo $x$ and $y$ are actually the same solution.\n\n## Solution for General Case\n\n### Inductive Solution\n\nAs $m_1 m_2$ is coprime to $m_3$, we can inductively repeatedly apply the solution for two moduli for any number of moduli.\nFirst you compute $b_2 := a \\pmod{m_1 m_2}$ using the first two congruences,\nthen you can compute $b_3 := a \\pmod{m_1 m_2 m_3}$ using the congruences $a \\equiv b_2 \\pmod{m_1 m_2}$ and $a \\equiv a_3 \\pmod {m_3}$, etc.\n\n### Direct Construction\n\nA direct construction similar to Lagrange interpolation is possible.\n\nLet $M_i := \\prod_{i \\neq j} m_j$, the product of all moduli but $m_i$, and $N_i$ the modular inverses $N_i := M_i^{-1} \\bmod{m_i}$.\nThen a solution to the system of congruences is:\n\n$$a \\equiv \\sum_{i=1}^k a_i M_i N_i \\pmod{m_1 m_2 \\cdots m_k}$$\n\nWe can check this is indeed a solution, by computing $a \\bmod{m_i}$ for all $i$.\nBecause $M_j$ is a multiple of $m_i$ for $i \\neq j$ we have\n\n$$\\begin{array}{rcll}\na & \\equiv & \\sum_{j=1}^k a_j M_j N_j & \\pmod{m_i} \\\\\n  & \\equiv & a_i M_i N_i              & \\pmod{m_i} \\\\\n  & \\equiv & a_i M_i M_i^{-1}         & \\pmod{m_i} \\\\\n  & \\equiv & a_i                      & \\pmod{m_i}\n\\end{array}$$\n\n### Implementation\n\n```{.cpp file=chinese_remainder_theorem}\nstruct Congruence {\n    long long a, m;\n};\n\nlong long chinese_remainder_theorem(vector<Congruence> const& congruences) {\n    long long M = 1;\n    for (auto const& congruence : congruences) {\n        M *= congruence.m;\n    }\n\n    long long solution = 0;\n    for (auto const& congruence : congruences) {\n        long long a_i = congruence.a;\n        long long M_i = M / congruence.m;\n        long long N_i = mod_inv(M_i, congruence.m);\n        solution = (solution + a_i * M_i % M * N_i) % M;\n    }\n    return solution;\n}\n```\n\n## Solution for not coprime moduli\n\nAs mentioned, the algorithm above only works for coprime moduli $m_1, m_2, \\dots m_k$.\n\nIn the not coprime case, a system of congruences has exactly one solution modulo $\\text{lcm}(m_1, m_2, \\dots, m_k)$, or has no solution at all.\n\nE.g. in the following system, the first congruence implies that the solution is odd, and the second congruence implies that the solution is even.\nIt's not possible that a number is both odd and even, therefore there is clearly no solution.\n\n$$\\left\\{\\begin{align}\n    a & \\equiv 1 \\pmod{4} \\\\\n    a & \\equiv 2 \\pmod{6}\n\\end{align}\\right.$$\n\nIt is pretty simple to determine is a system has a solution.\nAnd if it has one, we can use the original algorithm to solve a slightly modified system of congruences.\n\nA single congruence $a \\equiv a_i \\pmod{m_i}$ is equivalent to the system of congruences $a \\equiv a_i \\pmod{p_j^{n_j}}$ where $p_1^{n_1} p_2^{n_2}\\cdots p_k^{n_k}$ is the prime factorization of $m_i$.\n\nWith this fact, we can modify the system of congruences into a system, that only has prime powers as moduli.\nE.g. the above system of congruences is equivalent to:\n\n$$\\left\\{\\begin{array}{ll}\n    a \\equiv 1          & \\pmod{4} \\\\\n    a \\equiv 2 \\equiv 0 & \\pmod{2} \\\\\n    a \\equiv 2          & \\pmod{3}\n\\end{array}\\right.$$\n\nBecause originally some moduli had common factors, we will get some congruences moduli based on the same prime, however possibly with different prime powers.\n\nYou can observe, that the congruence with the highest prime power modulus will be the strongest congruence of all congruences based on the same prime number.\nEither it will give a contradiction with some other congruence, or it will imply already all other congruences.\n\nIn our case, the first congruence $a \\equiv 1 \\pmod{4}$ implies $a \\equiv 1 \\pmod{2}$, and therefore contradicts the second congruence $a \\equiv 0 \\pmod{2}$.\nTherefore this system of congruences has no solution.\n\nIf there are no contradictions, then the system of equation has a solution.\nWe can ignore all congruences except the ones with the highest prime power moduli.\nThese moduli are now coprime, and therefore we can solve this one with the algorithm discussed in the sections above.\n\nE.g. the following system has a solution modulo $\\text{lcm}(10, 12) = 60$.\n\n$$\\left\\{\\begin{align}\n    a & \\equiv 3 \\pmod{10} \\\\\n    a & \\equiv 5 \\pmod{12}\n\\end{align}\\right.$$\n\nThe system of congruence is equivalent to the system of congruences:\n\n$$\\left\\{\\begin{align}\n    a & \\equiv 3 \\equiv 1 \\pmod{2} \\\\\n    a & \\equiv 3 \\equiv 3 \\pmod{5} \\\\\n    a & \\equiv 5 \\equiv 1 \\pmod{4} \\\\\n    a & \\equiv 5 \\equiv 2 \\pmod{3}\n\\end{align}\\right.$$\n\nThe only congruence with same prime modulo are $a \\equiv 1 \\pmod{4}$ and $a \\equiv 1 \\pmod{2}$.\nThe first one already implies the second one, so we can ignore the second one, and solve the following system with coprime moduli instead:\n\n$$\\left\\{\\begin{align}\n    a & \\equiv 3 \\equiv 3 \\pmod{5} \\\\\n    a & \\equiv 5 \\equiv 1 \\pmod{4} \\\\\n    a & \\equiv 5 \\equiv 2 \\pmod{3}\n\\end{align}\\right.$$\n\nIt has the solution $53 \\pmod{60}$, and indeed $53 \\bmod{10} = 3$ and $53 \\bmod{12} = 5$.\n\n## Garner's Algorithm\n\nAnother consequence of the CRT is that we can represent big numbers using an array of small integers.\n\nInstead of doing a lot of computations with very large numbers numbers, which might be expensive (think of doing divisions with 1000-digit numbers), you can pick a couple of coprime moduli and represent the large number as a system of congruences, and perform all operations on the system of equations.\nAny number $a$ less than $m_1 m_2 \\cdots m_k$ can be represented as an array $a_1, \\ldots, a_k$, where $a \\equiv a_i \\pmod{m_i}$.\n\nBy using the above algorithm, you can again reconstruct the large number whenever you need it.\n\nAlternatively you can represent the number in the **mixed radix** representation:\n\n$$a = x_1 + x_2 m_1 + x_3 m_1 m_2 + \\ldots + x_k m_1 \\cdots m_{k-1} \\text{ with }x_i \\in [0, m_i)$$\n\nGarner's algorithm, which is discussed in the dedicated article [Garner's algorithm](garners-algorithm.md), computes the coefficients $x_i$.\nAnd with those coefficients you can restore the full number.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: chinese_theorem\n---\n\n# Chinese Remainder Theorem\n\nThe Chinese Remainder Theorem (which will be referred to as CRT in the rest of this article) was discovered by Chinese mathematician Sun Zi.\n\n## Formulation\n\nLet $m = m_1 \\cdot m_2 \\cdots m_k$, where $m_i$ are pairwise coprime. In addition to $m_i$, we are also given a system of congruences\n\n$$\\left\\{\\begin{array}{rcl}\n    a & \\equiv & a_1 \\pmod{m_1} \\\\\n    a & \\equiv & a_2 \\pmod{m_2} \\\\\n      & \\vdots & \\\\\n    a & \\equiv & a_k \\pmod{m_k}\n\\end{array}\\right.$$\n\nwhere $a_i$ are some given constants. The original form of CRT then states that the given system of congruences always has *one and exactly one* solution modulo $m$.\n\nE.g. the system of congruences\n\n$$\\left\\{\\begin{array}{rcl}\n    a & \\equiv & 2 \\pmod{3} \\\\\n    a & \\equiv & 3 \\pmod{5} \\\\\n    a & \\equiv & 2 \\pmod{7}\n\\end{array}\\right.$$\n\nhas the solution $23$ modulo $105$, because $23 \\bmod{3} = 2$, $23 \\bmod{5} = 3$, and $23 \\bmod{7} = 2$.\nWe can write down every solution as $23 + 105\\cdot k$ for $k \\in \\mathbb{Z}$.\n\n\n### Corollary\n\nA consequence of the CRT is that the equation\n\n$$x \\equiv a \\pmod{m}$$\n\nis equivalent to the system of equations\n\n$$\\left\\{\\begin{array}{rcl}\n    x & \\equiv & a_1 \\pmod{m_1} \\\\\n      & \\vdots & \\\\\n    x & \\equiv & a_k \\pmod{m_k}\n\\end{array}\\right.$$\n\n(As above, assume that $m = m_1 m_2 \\cdots m_k$ and $m_i$ are pairwise coprime).\n\n## Solution for Two Moduli\n\nConsider a system of two equations for coprime $m_1, m_2$:\n\n$$\n\\left\\{\\begin{align}\n    a &\\equiv a_1 \\pmod{m_1} \\\\\n    a &\\equiv a_2 \\pmod{m_2} \\\\\n\\end{align}\\right.\n$$\n\nWe want to find a solution for $a \\pmod{m_1 m_2}$. Using the [Extended Euclidean Algorithm](extended-euclid-algorithm.md) we can find B\u00e9zout coefficients $n_1, n_2$ such that\n\n$$n_1 m_1 + n_2 m_2 = 1.$$\n\nIn fact $n_1$ and $n_2$ are just the [modular inverses](module-inverse.md) of $m_1$ and $m_2$ modulo $m_2$ and $m_1$.\nWe have $n_1 m_1 \\equiv 1 \\pmod{m_2}$ so $n_1 \\equiv m_1^{-1} \\pmod{m_2}$, and vice versa $n_2 \\equiv m_2^{-1} \\pmod{m_1}$. \n\nWith those two coefficients we can define a solution:\n\n$$a = a_1 n_2 m_2 + a_2 n_1 m_1 \\bmod{m_1 m_2}$$\n\nIt's easy to verify that this is indeed a solution by computing $a \\bmod{m_1}$ and $a \\bmod{m_2}$.\n\n$$\n\\begin{array}{rcll}\na & \\equiv & a_1 n_2 m_2 + a_2 n_1 m_1 & \\pmod{m_1}\\\\\n  & \\equiv & a_1 (1 - n_1 m_1) + a_2 n_1 m_1 & \\pmod{m_1}\\\\\n  & \\equiv & a_1 - a_1 n_1 m_1 + a_2 n_1 m_1 & \\pmod{m_1}\\\\\n  & \\equiv & a_1 & \\pmod{m_1}\n\\end{array}\n$$\n\nNotice, that the Chinese Remainder Theorem also guarantees, that only 1 solution exists modulo $m_1 m_2$.\nThis is also easy to prove.\n\nLets assume that you have two different solutions $x$ and $y$.\nBecause $x \\equiv a_i \\pmod{m_i}$ and $y \\equiv a_i \\pmod{m_i}$, it follows that $x \u2212 y \\equiv 0 \\pmod{m_i}$ and therefore $x \u2212 y \\equiv 0 \\pmod{m_1 m_2}$ or equivalently $x \\equiv y \\pmod{m_1 m_2}$.\nSo $x$ and $y$ are actually the same solution.\n\n## Solution for General Case\n\n### Inductive Solution\n\nAs $m_1 m_2$ is coprime to $m_3$, we can inductively repeatedly apply the solution for two moduli for any number of moduli.\nFirst you compute $b_2 := a \\pmod{m_1 m_2}$ using the first two congruences,\nthen you can compute $b_3 := a \\pmod{m_1 m_2 m_3}$ using the congruences $a \\equiv b_2 \\pmod{m_1 m_2}$ and $a \\equiv a_3 \\pmod {m_3}$, etc.\n\n### Direct Construction\n\nA direct construction similar to Lagrange interpolation is possible.\n\nLet $M_i := \\prod_{i \\neq j} m_j$, the product of all moduli but $m_i$, and $N_i$ the modular inverses $N_i := M_i^{-1} \\bmod{m_i}$.\nThen a solution to the system of congruences is:\n\n$$a \\equiv \\sum_{i=1}^k a_i M_i N_i \\pmod{m_1 m_2 \\cdots m_k}$$\n\nWe can check this is indeed a solution, by computing $a \\bmod{m_i}$ for all $i$.\nBecause $M_j$ is a multiple of $m_i$ for $i \\neq j$ we have\n\n$$\\begin{array}{rcll}\na & \\equiv & \\sum_{j=1}^k a_j M_j N_j & \\pmod{m_i} \\\\\n  & \\equiv & a_i M_i N_i              & \\pmod{m_i} \\\\\n  & \\equiv & a_i M_i M_i^{-1}         & \\pmod{m_i} \\\\\n  & \\equiv & a_i                      & \\pmod{m_i}\n\\end{array}$$\n\n### Implementation\n\n```{.cpp file=chinese_remainder_theorem}\nstruct Congruence {\n    long long a, m;\n};\n\nlong long chinese_remainder_theorem(vector<Congruence> const& congruences) {\n    long long M = 1;\n    for (auto const& congruence : congruences) {\n        M *= congruence.m;\n    }\n\n    long long solution = 0;\n    for (auto const& congruence : congruences) {\n        long long a_i = congruence.a;\n        long long M_i = M / congruence.m;\n        long long N_i = mod_inv(M_i, congruence.m);\n        solution = (solution + a_i * M_i % M * N_i) % M;\n    }\n    return solution;\n}\n```\n\n## Solution for not coprime moduli\n\nAs mentioned, the algorithm above only works for coprime moduli $m_1, m_2, \\dots m_k$.\n\nIn the not coprime case, a system of congruences has exactly one solution modulo $\\text{lcm}(m_1, m_2, \\dots, m_k)$, or has no solution at all.\n\nE.g. in the following system, the first congruence implies that the solution is odd, and the second congruence implies that the solution is even.\nIt's not possible that a number is both odd and even, therefore there is clearly no solution.\n\n$$\\left\\{\\begin{align}\n    a & \\equiv 1 \\pmod{4} \\\\\n    a & \\equiv 2 \\pmod{6}\n\\end{align}\\right.$$\n\nIt is pretty simple to determine is a system has a solution.\nAnd if it has one, we can use the original algorithm to solve a slightly modified system of congruences.\n\nA single congruence $a \\equiv a_i \\pmod{m_i}$ is equivalent to the system of congruences $a \\equiv a_i \\pmod{p_j^{n_j}}$ where $p_1^{n_1} p_2^{n_2}\\cdots p_k^{n_k}$ is the prime factorization of $m_i$.\n\nWith this fact, we can modify the system of congruences into a system, that only has prime powers as moduli.\nE.g. the above system of congruences is equivalent to:\n\n$$\\left\\{\\begin{array}{ll}\n    a \\equiv 1          & \\pmod{4} \\\\\n    a \\equiv 2 \\equiv 0 & \\pmod{2} \\\\\n    a \\equiv 2          & \\pmod{3}\n\\end{array}\\right.$$\n\nBecause originally some moduli had common factors, we will get some congruences moduli based on the same prime, however possibly with different prime powers.\n\nYou can observe, that the congruence with the highest prime power modulus will be the strongest congruence of all congruences based on the same prime number.\nEither it will give a contradiction with some other congruence, or it will imply already all other congruences.\n\nIn our case, the first congruence $a \\equiv 1 \\pmod{4}$ implies $a \\equiv 1 \\pmod{2}$, and therefore contradicts the second congruence $a \\equiv 0 \\pmod{2}$.\nTherefore this system of congruences has no solution.\n\nIf there are no contradictions, then the system of equation has a solution.\nWe can ignore all congruences except the ones with the highest prime power moduli.\nThese moduli are now coprime, and therefore we can solve this one with the algorithm discussed in the sections above.\n\nE.g. the following system has a solution modulo $\\text{lcm}(10, 12) = 60$.\n\n$$\\left\\{\\begin{align}\n    a & \\equiv 3 \\pmod{10} \\\\\n    a & \\equiv 5 \\pmod{12}\n\\end{align}\\right.$$\n\nThe system of congruence is equivalent to the system of congruences:\n\n$$\\left\\{\\begin{align}\n    a & \\equiv 3 \\equiv 1 \\pmod{2} \\\\\n    a & \\equiv 3 \\equiv 3 \\pmod{5} \\\\\n    a & \\equiv 5 \\equiv 1 \\pmod{4} \\\\\n    a & \\equiv 5 \\equiv 2 \\pmod{3}\n\\end{align}\\right.$$\n\nThe only congruence with same prime modulo are $a \\equiv 1 \\pmod{4}$ and $a \\equiv 1 \\pmod{2}$.\nThe first one already implies the second one, so we can ignore the second one, and solve the following system with coprime moduli instead:\n\n$$\\left\\{\\begin{align}\n    a & \\equiv 3 \\equiv 3 \\pmod{5} \\\\\n    a & \\equiv 5 \\equiv 1 \\pmod{4} \\\\\n    a & \\equiv 5 \\equiv 2 \\pmod{3}\n\\end{align}\\right.$$\n\nIt has the solution $53 \\pmod{60}$, and indeed $53 \\bmod{10} = 3$ and $53 \\bmod{12} = 5$.\n\n## Garner's Algorithm\n\nAnother consequence of the CRT is that we can represent big numbers using an array of small integers.\n\nInstead of doing a lot of computations with very large numbers numbers, which might be expensive (think of doing divisions with 1000-digit numbers), you can pick a couple of coprime moduli and represent the large number as a system of congruences, and perform all operations on the system of equations.\nAny number $a$ less than $m_1 m_2 \\cdots m_k$ can be represented as an array $a_1, \\ldots, a_k$, where $a \\equiv a_i \\pmod{m_i}$.\n\nBy using the above algorithm, you can again reconstruct the large number whenever you need it.\n\nAlternatively you can represent the number in the **mixed radix** representation:\n\n$$a = x_1 + x_2 m_1 + x_3 m_1 m_2 + \\ldots + x_k m_1 \\cdots m_{k-1} \\text{ with }x_i \\in [0, m_i)$$\n\nGarner's algorithm, which is discussed in the dedicated article [Garner's algorithm](garners-algorithm.md), computes the coefficients $x_i$.\nAnd with those coefficients you can restore the full number.\n\n## Practice Problems:\n\n* [Google Code Jam - Golf Gophers](https://codingcompetitions.withgoogle.com/codejam/round/0000000000051635/0000000000104f1a#problem)\n* [Hackerrank - Number of sequences](https://www.hackerrank.com/contests/w22/challenges/number-of-sequences)\n* [Codeforces - Remainders Game](http://codeforces.com/problemset/problem/687/B)\n", "problem_ids": ["687_B"], "title": "Chinese Remainder Theorem"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: extended_euclid_algorithm\n---\n\n# Extended Euclidean Algorithm\n\nWhile the [Euclidean algorithm](euclid-algorithm.md) calculates only the greatest common divisor (GCD) of two integers $a$ and $b$, the extended version also finds a way to represent GCD in terms of $a$ and $b$, i.e. coefficients $x$ and $y$ for which:\n\n$$a \\cdot x + b \\cdot y = \\gcd(a, b)$$\n\nIt's important to note that by [B\u00e9zout's identity](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity) we can always find such a representation. For instance, $\\gcd(55, 80) = 5$, therefore we can represent $5$ as a linear combination with the terms $55$ and $80$: $55 \\cdot 3 + 80 \\cdot (-2) = 5$ \n\nA more general form of that problem is discussed in the article about [Linear Diophantine Equations](linear-diophantine-equation.md).\nIt will build upon this algorithm.\n\n## Algorithm\n\nWe will denote the GCD of $a$ and $b$ with $g$ in this section.\n\nThe changes to the original algorithm are very simple.\nIf we recall the algorithm, we can see that the algorithm ends with $b = 0$ and $a = g$.\nFor these parameters we can easily find coefficients, namely $g \\cdot 1 + 0 \\cdot 0 = g$.\n\nStarting from these coefficients $(x, y) = (1, 0)$, we can go backwards up the recursive calls.\nAll we need to do is to figure out how the coefficients $x$ and $y$ change during the transition from $(a, b)$ to $(b, a \\bmod b)$.\n\nLet us assume we found the coefficients $(x_1, y_1)$ for $(b, a \\bmod b)$:\n\n$$b \\cdot x_1 + (a \\bmod b) \\cdot y_1 = g$$\n\nand we want to find the pair $(x, y)$ for $(a, b)$:\n\n$$ a \\cdot x + b \\cdot y = g$$\n\nWe can represent $a \\bmod b$ as:\n\n$$ a \\bmod b = a - \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\cdot b$$\n\nSubstituting this expression in the coefficient equation of $(x_1, y_1)$ gives:\n\n$$ g = b \\cdot x_1 + (a \\bmod b) \\cdot y_1 = b \\cdot x_1 + \\left(a - \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\cdot b \\right) \\cdot y_1$$\n\nand after rearranging the terms:\n\n$$g = a \\cdot y_1 + b \\cdot \\left( x_1 - y_1 \\cdot \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\right)$$\n\nWe found the values of $x$ and $y$:\n\n$$\\begin{cases}\nx = y_1 \\\\\ny = x_1 - y_1 \\cdot \\left\\lfloor \\frac{a}{b} \\right\\rfloor\n\\end{cases} $$\n\n## Implementation\n\n```{.cpp file=extended_gcd}\nint gcd(int a, int b, int& x, int& y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int x1, y1;\n    int d = gcd(b, a % b, x1, y1);\n    x = y1;\n    y = x1 - y1 * (a / b);\n    return d;\n}\n```\n\nThe recursive function above returns the GCD and the values of coefficients to `x` and `y` (which are passed by reference to the function).\n\nThis implementation of extended Euclidean algorithm produces correct results for negative integers as well.\n\n## Iterative version\n\nIt's also possible to write the Extended Euclidean algorithm in an iterative way.\nBecause it avoids recursion, the code will run a little bit faster than the recursive one.\n\n```{.cpp file=extended_gcd_iter}\nint gcd(int a, int b, int& x, int& y) {\n    x = 1, y = 0;\n    int x1 = 0, y1 = 1, a1 = a, b1 = b;\n    while (b1) {\n        int q = a1 / b1;\n        tie(x, x1) = make_tuple(x1, x - q * x1);\n        tie(y, y1) = make_tuple(y1, y - q * y1);\n        tie(a1, b1) = make_tuple(b1, a1 - q * b1);\n    }\n    return a1;\n}\n```\n\nIf you look closely at the variable `a1` and `b1`, you can notice that they taking exactly the same values as in the iterative version of the normal [Euclidean algorithm](euclid-algorithm.md). So the algorithm will at least compute the correct GCD.\n\nTo see why the algorithm also computes the correct coefficients, you can check that the following invariants will hold at any time (before the while loop, and at the end of each iteration): $x \\cdot a + y \\cdot b = a_1$ and $x_1 \\cdot a + y_1 \\cdot b = b_1$.\nIt's trivial to see, that these two equations are satisfied at the beginning.\nAnd you can check that the update in the loop iteration will still keep those equalities valid.\n\nAt the end we know that $a_1$ contains the GCD, so $x \\cdot a + y \\cdot b = g$.\nWhich means that we have found the required coefficients.\n\nYou can even optimize the code more, and remove the variable $a_1$ and $b_1$ from the code, and just reuse $a$ and $b$.\nHowever if you do so, you lose the ability to argue about the invariants.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: extended_euclid_algorithm\n---\n\n# Extended Euclidean Algorithm\n\nWhile the [Euclidean algorithm](euclid-algorithm.md) calculates only the greatest common divisor (GCD) of two integers $a$ and $b$, the extended version also finds a way to represent GCD in terms of $a$ and $b$, i.e. coefficients $x$ and $y$ for which:\n\n$$a \\cdot x + b \\cdot y = \\gcd(a, b)$$\n\nIt's important to note that by [B\u00e9zout's identity](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity) we can always find such a representation. For instance, $\\gcd(55, 80) = 5$, therefore we can represent $5$ as a linear combination with the terms $55$ and $80$: $55 \\cdot 3 + 80 \\cdot (-2) = 5$ \n\nA more general form of that problem is discussed in the article about [Linear Diophantine Equations](linear-diophantine-equation.md).\nIt will build upon this algorithm.\n\n## Algorithm\n\nWe will denote the GCD of $a$ and $b$ with $g$ in this section.\n\nThe changes to the original algorithm are very simple.\nIf we recall the algorithm, we can see that the algorithm ends with $b = 0$ and $a = g$.\nFor these parameters we can easily find coefficients, namely $g \\cdot 1 + 0 \\cdot 0 = g$.\n\nStarting from these coefficients $(x, y) = (1, 0)$, we can go backwards up the recursive calls.\nAll we need to do is to figure out how the coefficients $x$ and $y$ change during the transition from $(a, b)$ to $(b, a \\bmod b)$.\n\nLet us assume we found the coefficients $(x_1, y_1)$ for $(b, a \\bmod b)$:\n\n$$b \\cdot x_1 + (a \\bmod b) \\cdot y_1 = g$$\n\nand we want to find the pair $(x, y)$ for $(a, b)$:\n\n$$ a \\cdot x + b \\cdot y = g$$\n\nWe can represent $a \\bmod b$ as:\n\n$$ a \\bmod b = a - \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\cdot b$$\n\nSubstituting this expression in the coefficient equation of $(x_1, y_1)$ gives:\n\n$$ g = b \\cdot x_1 + (a \\bmod b) \\cdot y_1 = b \\cdot x_1 + \\left(a - \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\cdot b \\right) \\cdot y_1$$\n\nand after rearranging the terms:\n\n$$g = a \\cdot y_1 + b \\cdot \\left( x_1 - y_1 \\cdot \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\right)$$\n\nWe found the values of $x$ and $y$:\n\n$$\\begin{cases}\nx = y_1 \\\\\ny = x_1 - y_1 \\cdot \\left\\lfloor \\frac{a}{b} \\right\\rfloor\n\\end{cases} $$\n\n## Implementation\n\n```{.cpp file=extended_gcd}\nint gcd(int a, int b, int& x, int& y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int x1, y1;\n    int d = gcd(b, a % b, x1, y1);\n    x = y1;\n    y = x1 - y1 * (a / b);\n    return d;\n}\n```\n\nThe recursive function above returns the GCD and the values of coefficients to `x` and `y` (which are passed by reference to the function).\n\nThis implementation of extended Euclidean algorithm produces correct results for negative integers as well.\n\n## Iterative version\n\nIt's also possible to write the Extended Euclidean algorithm in an iterative way.\nBecause it avoids recursion, the code will run a little bit faster than the recursive one.\n\n```{.cpp file=extended_gcd_iter}\nint gcd(int a, int b, int& x, int& y) {\n    x = 1, y = 0;\n    int x1 = 0, y1 = 1, a1 = a, b1 = b;\n    while (b1) {\n        int q = a1 / b1;\n        tie(x, x1) = make_tuple(x1, x - q * x1);\n        tie(y, y1) = make_tuple(y1, y - q * y1);\n        tie(a1, b1) = make_tuple(b1, a1 - q * b1);\n    }\n    return a1;\n}\n```\n\nIf you look closely at the variable `a1` and `b1`, you can notice that they taking exactly the same values as in the iterative version of the normal [Euclidean algorithm](euclid-algorithm.md). So the algorithm will at least compute the correct GCD.\n\nTo see why the algorithm also computes the correct coefficients, you can check that the following invariants will hold at any time (before the while loop, and at the end of each iteration): $x \\cdot a + y \\cdot b = a_1$ and $x_1 \\cdot a + y_1 \\cdot b = b_1$.\nIt's trivial to see, that these two equations are satisfied at the beginning.\nAnd you can check that the update in the loop iteration will still keep those equalities valid.\n\nAt the end we know that $a_1$ contains the GCD, so $x \\cdot a + y \\cdot b = g$.\nWhich means that we have found the required coefficients.\n\nYou can even optimize the code more, and remove the variable $a_1$ and $b_1$ from the code, and just reuse $a$ and $b$.\nHowever if you do so, you lose the ability to argue about the invariants.\n\n## Practice Problems\n\n* [10104 - Euclid Problem](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1045)\n* [GYM - (J) Once Upon A Time](http://codeforces.com/gym/100963)\n* [UVA - 12775 - Gift Dilemma](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4628)\n", "problem_ids": [], "title": "Extended Euclidean Algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: fft_multiply\n---\n\n# Fast Fourier transform\n\nIn this article we will discuss an algorithm that allows us to multiply two polynomials of length $n$ in $O(n \\log n)$ time, which is better than the trivial multiplication which takes $O(n^2)$ time.\nObviously also multiplying two long numbers can be reduced to multiplying polynomials, so also two long numbers can be multiplied in $O(n \\log n)$ time (where $n$ is the number of digits in the numbers).\n\nThe discovery of the **Fast Fourier transformation (FFT)** is attributed to Cooley and Tukey, who published an algorithm in 1965.\nBut in fact the FFT has been discovered repeatedly before, but the importance of it was not understood before the inventions of modern computers.\nSome researchers attribute the discovery of the FFT to Runge and K\u00f6nig in 1924.\nBut actually Gauss developed such a method already in 1805, but never published it.\n\nNotice, that the FFT algorithm presented here runs in $O(n \\log n)$ time, but it doesn't work for multiplying arbitrary big polynomials with arbitrary large coefficients or for multiplying arbitrary big integers.\nIt can easily handle polynomials of size $10^5$ with small coefficients, or multiplying two numbers of size $10^6$, but at some point the range and the precision of the used floating point numbers will not no longer be enough to give accurate results.\nThat is usually enough for solving competitive programming problems, but there are also more complex variations that can perform arbitrary large polynomial/integer multiplications.\nE.g. in 1971 Sch\u00f6nhage and Strasser developed a variation for multiplying arbitrary large numbers that applies the FFT recursively in rings structures running in $O(n \\log n \\log \\log n)$.\nAnd recently (in 2019) Harvey and van der Hoeven published an algorithm that runs in true $O(n \\log n)$.\n\n## Discrete Fourier transform\n\nLet there be a polynomial of degree $n - 1$:\n\n$$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}$$\n\nWithout loss of generality we assume that $n$ - the number of coefficients - is a power of $2$.\nIf $n$ is not a power of $2$, then we simply add the missing terms $a_i x^i$ and set the coefficients $a_i$ to $0$.\n\nThe theory of complex numbers tells us that the equation $x^n = 1$ has $n$ complex solutions (called the $n$-th roots of unity), and the solutions are of the form $w_{n, k} = e^{\\frac{2 k \\pi i}{n}}$ with $k = 0 \\dots n-1$.\nAdditionally these complex numbers have some very interesting properties:\ne.g. the principal $n$-th root $w_n = w_{n, 1} = e^{\\frac{2 \\pi i}{n}}$ can be used to describe all other $n$-th roots: $w_{n, k} = (w_n)^k$.\n\nThe **discrete Fourier transform (DFT)** of the polynomial $A(x)$ (or equivalently the vector of coefficients $(a_0, a_1, \\dots, a_{n-1})$ is defined as the values of the polynomial at the points $x = w_{n, k}$, i.e. it is the vector:\n\n$$\\begin{align}\n\\text{DFT}(a_0, a_1, \\dots, a_{n-1}) &= (y_0, y_1, \\dots, y_{n-1}) \\\\\n&= (A(w_{n, 0}), A(w_{n, 1}), \\dots, A(w_{n, n-1})) \\\\\n&= (A(w_n^0), A(w_n^1), \\dots, A(w_n^{n-1}))\n\\end{align}$$\n\nSimilarly the **inverse discrete Fourier transform** is defined:\nThe inverse DFT of values of the polynomial $(y_0, y_1, \\dots, y_{n-1})$ are the coefficients of the polynomial $(a_0, a_1, \\dots, a_{n-1})$.\n\n$$\\text{InverseDFT}(y_0, y_1, \\dots, y_{n-1}) = (a_0, a_1, \\dots, a_{n-1})$$\n\nThus, if a direct DFT computes the values of the polynomial at the points at the $n$-th roots, the inverse DFT can restore the coefficients of the polynomial using those values.\n\n### Application of the DFT: fast multiplication of polynomials\n\nLet there be two polynomials $A$ and $B$.\nWe compute the DFT for each of them: $\\text{DFT}(A)$ and $\\text{DFT}(B)$.\n\nWhat happens if we multiply these polynomials?\nObviously at each point the values are simply multiplied, i.e.\n\n$$(A \\cdot B)(x) = A(x) \\cdot B(x).$$\n\nThis means that if we multiply the vectors $\\text{DFT}(A)$ and $\\text{DFT}(B)$ - by multiplying each element of one vector by the corresponding element of the other vector - then we get nothing other than the DFT of the polynomial $\\text{DFT}(A \\cdot B)$:\n\n$$\\text{DFT}(A \\cdot B) = \\text{DFT}(A) \\cdot \\text{DFT}(B)$$\n\nFinally, applying the inverse DFT, we obtain:\n\n$$A \\cdot B = \\text{InverseDFT}(\\text{DFT}(A) \\cdot \\text{DFT}(B))$$\n\nOn the right the product of the two DFTs we mean the pairwise product of the vector elements.\nThis can be computed in $O(n)$ time.\nIf we can compute the DFT and the inverse DFT in $O(n \\log n)$, then we can compute the product of the two polynomials (and consequently also two long numbers) with the same time complexity.\n\nIt should be noted, that the two polynomials should have the same degree.\nOtherwise the two result vectors of the DFT have different length.\nWe can accomplish this by adding coefficients with the value $0$.\n\nAnd also, since the result of the product of two polynomials is a polynomial of degree $2 (n - 1)$, we have to double the degrees of each polynomial (again by padding $0$s).\nFrom a vector with $n$ values we cannot reconstruct the desired polynomial with $2n - 1$ coefficients.\n\n### Fast Fourier Transform\n\nThe **fast Fourier transform** is a method that allows computing the DFT in $O(n \\log n)$ time.\nThe basic idea of the FFT is to apply divide and conquer.\nWe divide the coefficient vector of the polynomial into two vectors, recursively compute the DFT for each of them, and combine the results to compute the DFT of the complete polynomial.\n\nSo let there be a polynomial $A(x)$ with degree $n - 1$, where $n$ is a power of $2$, and $n > 1$:\n\n$$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}$$\n\nWe divide it into two smaller polynomials, the one containing only the coefficients of the even positions, and the one containing the coefficients of the odd positions:\n\n$$\\begin{align}\nA_0(x) &= a_0 x^0 + a_2 x^1 + \\dots + a_{n-2} x^{\\frac{n}{2}-1} \\\\\nA_1(x) &= a_1 x^0 + a_3 x^1 + \\dots + a_{n-1} x^{\\frac{n}{2}-1}\n\\end{align}$$\n\nIt is easy to see that\n\n$$A(x) = A_0(x^2) + x A_1(x^2).$$\n\nThe polynomials $A_0$ and $A_1$ are only half as much coefficients as the polynomial $A$.\nIf we can compute the $\\text{DFT}(A)$ in linear time using $\\text{DFT}(A_0)$ and $\\text{DFT}(A_1)$, then we get the recurrence $T_{\\text{DFT}}(n) = 2 T_{\\text{DFT}}\\left(\\frac{n}{2}\\right) + O(n)$ for the time complexity, which results in $T_{\\text{DFT}}(n) = O(n \\log n)$ by the **master theorem**.\n\nLet's learn how we can accomplish that.\n\nSuppose we have computed the vectors $\\left(y_k^0\\right)_{k=0}^{n/2-1} = \\text{DFT}(A_0)$ and $\\left(y_k^1\\right)_{k=0}^{n/2-1} = \\text{DFT}(A_1)$.\nLet us find a expression for $\\left(y_k\\right)_{k=0}^{n-1} = \\text{DFT}(A)$.\n\nFor the first $\\frac{n}{2}$ values we can just use the previously noted equation $A(x) = A_0(x^2) + x A_1(x^2)$:\n\n$$y_k = y_k^0 + w_n^k y_k^1, \\quad k = 0 \\dots \\frac{n}{2} - 1.$$\n\nHowever for the second $\\frac{n}{2}$ values we need to find a slightly, different expression:\n\n$$\\begin{align}\ny_{k+n/2} &= A\\left(w_n^{k+n/2}\\right) \\\\\n&= A_0\\left(w_n^{2k+n}\\right) + w_n^{k + n/2} A_1\\left(w_n^{2k+n}\\right) \\\\\n&= A_0\\left(w_n^{2k} w_n^n\\right) + w_n^k w_n^{n/2} A_1\\left(w_n^{2k} w_n^n\\right) \\\\\n&= A_0\\left(w_n^{2k}\\right) - w_n^k A_1\\left(w_n^{2k}\\right) \\\\\n&= y_k^0 - w_n^k y_k^1\n\\end{align}$$\n\nHere we used again $A(x) = A_0(x^2) + x A_1(x^2)$ and the two identities $w_n^n = 1$ and $w_n^{n/2} = -1$.\n\nTherefore we get the desired formulas for computing the whole vector $(y_k)$:\n\n$$\\begin{align}\ny_k &= y_k^0 + w_n^k y_k^1, &\\quad k = 0 \\dots \\frac{n}{2} - 1, \\\\\ny_{k+n/2} &= y_k^0 - w_n^k y_k^1, &\\quad k = 0 \\dots \\frac{n}{2} - 1.\n\\end{align}$$\n\n(This pattern $a + b$ and $a - b$ is sometimes called a **butterfly**.)\n\nThus we learned how to compute the DFT in $O(n \\log n)$ time.\n\n### Inverse FFT\n\nLet the vector $(y_0, y_1, \\dots y_{n-1})$ - the values of polynomial $A$ of degree $n - 1$ in the points $x = w_n^k$ - be given.\nWe want to restore the coefficients $(a_0, a_1, \\dots, a_{n-1})$ of the polynomial.\nThis known problem is called **interpolation**, and there are general algorithms for solving it.\nBut in this special case (since we know the values of the points at the roots of unity), we can obtains a much simpler algorithm (that is practically the same as the direct FFT).\n\nWe can write the DFT, according to its definition, in the matrix form:\n\n$$\n\\begin{pmatrix}\nw_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\\nw_n^0 & w_n^1 & w_n^2 & w_n^3 & \\cdots & w_n^{n-1} \\\\\nw_n^0 & w_n^2 & w_n^4 & w_n^6 & \\cdots & w_n^{2(n-1)} \\\\\nw_n^0 & w_n^3 & w_n^6 & w_n^9 & \\cdots & w_n^{3(n-1)} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \\cdots & w_n^{(n-1)(n-1)}\n\\end{pmatrix} \\begin{pmatrix}\na_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1}\n\\end{pmatrix} = \\begin{pmatrix}\ny_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1}\n\\end{pmatrix}\n$$\n\nThis matrix is called the **Vandermonde matrix**.\n\nThus we can compute the vector $(a_0, a_1, \\dots, a_{n-1})$ by multiplying the vector $(y_0, y_1, \\dots y_{n-1})$ from the left with the inverse of the matrix:\n\n$$\n\\begin{pmatrix}\na_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1}\n\\end{pmatrix} = \\begin{pmatrix}\nw_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\\nw_n^0 & w_n^1 & w_n^2 & w_n^3 & \\cdots & w_n^{n-1} \\\\\nw_n^0 & w_n^2 & w_n^4 & w_n^6 & \\cdots & w_n^{2(n-1)} \\\\\nw_n^0 & w_n^3 & w_n^6 & w_n^9 & \\cdots & w_n^{3(n-1)} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \\cdots & w_n^{(n-1)(n-1)}\n\\end{pmatrix}^{-1} \\begin{pmatrix}\ny_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1}\n\\end{pmatrix}\n$$\n\nA quick check can verify that the inverse of the matrix has the following form:\n\n$$\n\\frac{1}{n}\n\\begin{pmatrix}\nw_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\\nw_n^0 & w_n^{-1} & w_n^{-2} & w_n^{-3} & \\cdots & w_n^{-(n-1)} \\\\\nw_n^0 & w_n^{-2} & w_n^{-4} & w_n^{-6} & \\cdots & w_n^{-2(n-1)} \\\\\nw_n^0 & w_n^{-3} & w_n^{-6} & w_n^{-9} & \\cdots & w_n^{-3(n-1)} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n^0 & w_n^{-(n-1)} & w_n^{-2(n-1)} & w_n^{-3(n-1)} & \\cdots & w_n^{-(n-1)(n-1)}\n\\end{pmatrix}\n$$\n\nThus we obtain the formula:\n\n$$a_k = \\frac{1}{n} \\sum_{j=0}^{n-1} y_j w_n^{-k j}$$\n\nComparing this to the formula for $y_k$\n\n$$y_k = \\sum_{j=0}^{n-1} a_j w_n^{k j},$$\n\nwe notice that these problems are almost the same, so the coefficients $a_k$ can be found by the same divide and conquer algorithm, as well as the direct FFT, only instead of $w_n^k$ we have to use $w_n^{-k}$, and at the end we need to divide the resulting coefficients by $n$.\n\nThus the computation of the inverse DFT is almost the same as the calculation of the direct DFT, and it also can be performed in $O(n \\log n)$ time.\n\n### Implementation\n\nHere we present a simple recursive **implementation of the FFT** and the inverse FFT, both in one function, since the difference between the forward and the inverse FFT are so minimal.\nTo store the complex numbers we use the complex type in the C++ STL.\n\n```{.cpp file=fft_recursive}\nusing cd = complex<double>;\nconst double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n    if (n == 1)\n        return;\n\n    vector<cd> a0(n / 2), a1(n / 2);\n    for (int i = 0; 2 * i < n; i++) {\n        a0[i] = a[2*i];\n        a1[i] = a[2*i+1];\n    }\n    fft(a0, invert);\n    fft(a1, invert);\n\n    double ang = 2 * PI / n * (invert ? -1 : 1);\n    cd w(1), wn(cos(ang), sin(ang));\n    for (int i = 0; 2 * i < n; i++) {\n        a[i] = a0[i] + w * a1[i];\n        a[i + n/2] = a0[i] - w * a1[i];\n        if (invert) {\n            a[i] /= 2;\n            a[i + n/2] /= 2;\n        }\n        w *= wn;\n    }\n}\n```\n\nThe function gets passed a vector of coefficients, and the function will compute the DFT or inverse DFT and store the result again in this vector.\nThe argument $\\text{invert}$ shows whether the direct or the inverse DFT should be computed.\nInside the function we first check if the length of the vector is equal to one, if this is the case then we don't have to do anything.\nOtherwise we divide the vector $a$ into two vectors $a0$ and $a1$ and compute the DFT for both recursively.\nThen we initialize the value $wn$ and a variable $w$, which will contain the current power of $wn$.\nThen the values of the resulting DFT are computed using the above formulas.\n\nIf the flag $\\text{invert}$ is set, then we replace $wn$ with $wn^{-1}$, and each of the values of the result is divided by $2$ (since this will be done in each level of the recursion, this will end up dividing the final values by $n$).\n\nUsing this function we can create a function for **multiplying two polynomials**:\n\n```{.cpp file=fft_multiply}\nvector<int> multiply(vector<int> const& a, vector<int> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size()) \n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<int> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\n```\n\nThis function works with polynomials with integer coefficients, however you can also adjust it to work with other types.\nSince there is some error when working with complex numbers, we need round the resulting coefficients at the end.\n\nFinally the function for **multiplying** two long numbers practically doesn't differ from the function for multiplying polynomials.\nThe only thing we have to do afterwards, is to normalize the number:\n\n```cpp\n    int carry = 0;\n    for (int i = 0; i < n; i++)\n        result[i] += carry;\n        carry = result[i] / 10;\n        result[i] %= 10;\n    }\n```\n\nSince the length of the product of two numbers never exceed the total length of both numbers, the size of the vector is enough to perform all carry operations.\n\n### Improved implementation: in-place computation\n\nTo increase the efficiency we will switch from the recursive implementation to an iterative one.\nIn the above recursive implementation we explicitly separated the vector $a$ into two vectors - the element on the even positions got assigned to one temporary vector, and the elements on odd positions to another.\nHowever if we reorder the elements in a certain way, we don't need to create these temporary vectors (i.e. all the calculations can be done \"in-place\", right in the vector $A$ itself).\n\nNote that at the first recursion level, the elements whose lowest bit of the position was zero got assigned to the vector $a_0$, and the ones with a one as the lowest bit of the position got assigned to $a_1$.\nIn the second recursion level the same thing happens, but with the second lowest bit instead, etc.\nTherefore if we reverse the bits of the position of each coefficient, and sort them by these reversed values, we get the desired order (it is called the bit-reversal permutation).\n\nFor example the desired order for $n = 8$ has the form:\n\n$$a = \\bigg\\{ \\Big[ (a_0, a_4), (a_2, a_6) \\Big], \\Big[ (a_1, a_5), (a_3, a_7) \\Big] \\bigg\\}$$\n\nIndeed in the first recursion level (surrounded by curly braces), the vector gets divided into two parts $[a_0, a_2, a_4, a_6]$ and $[a_1, a_3, a_5, a_7]$.\nAs we see, in the bit-reversal permutation this corresponds to simply dividing the vector into two halves: the first $\\frac{n}{2}$ elements and the last $\\frac{n}{2}$ elements.\nThen there is a recursive call for each halve.\nLet the resulting DFT for each of them be returned in place of the elements themselves (i.e. the first half and the second half of the vector $a$ respectively.\n\n$$a = \\bigg\\{ \\Big[y_0^0, y_1^0, y_2^0, y_3^0\\Big], \\Big[y_0^1, y_1^1, y_2^1, y_3^1 \\Big] \\bigg\\}$$\n\nNow we want to combine the two DFTs into one for the complete vector.\nThe order of the elements is ideal, and we can also perform the union directly in this vector.\nWe can take the elements $y_0^0$ and $y_0^1$ and perform the butterfly transform.\nThe place of the resulting two values is the same as the place of the two initial values, so we get:\n\n$$a = \\bigg\\{ \\Big[y_0^0 + w_n^0 y_0^1, y_1^0, y_2^0, y_3^0\\Big], \\Big[y_0^0 - w_n^0 y_0^1, y_1^1, y_2^1, y_3^1\\Big] \\bigg\\}$$\n\nSimilarly we can compute the butterfly transform of $y_1^0$ and $y_1^1$ and put the results in their place, and so on.\nAs a result we get:\n\n$$a = \\bigg\\{ \\Big[y_0^0 + w_n^0 y_0^1, y_1^0 + w_n^1 y_1^1, y_2^0 + w_n^2 y_2^1, y_3^0 + w_n^3 y_3^1\\Big], \\Big[y_0^0 - w_n^0 y_0^1, y_1^0 - w_n^1 y_1^1, y_2^0 - w_n^2 y_2^1, y_3^0 - w_n^3 y_3^1\\Big] \\bigg\\}$$\n\nThus we computed the required DFT from the vector $a$.\n\nHere we described the process of computing the DFT only at the first recursion level, but the same works obviously also for all other levels.\nThus, after applying the bit-reversal permutation, we can compute the DFT in-place, without any additional memory.\n\nThis additionally allows us to get rid of the recursion.\nWe just start at the lowest level, i.e. we divide the vector into pairs and apply the butterfly transform to them.\nThis results with the vector $a$ with the work of the last level applied.\nIn the next step we divide the vector into vectors of size $4$, and again apply the butterfly transform, which gives us the DFT for each block of size $4$.\nAnd so on.\nFinally in the last step we obtained the result of the DFTs of both halves of $a$, and by applying the butterfly transform we obtain the DFT for the complete vector $a$.\n\n```{.cpp file=fft_implementation_iterative}\nusing cd = complex<double>;\nconst double PI = acos(-1);\n\nint reverse(int num, int lg_n) {\n    int res = 0;\n    for (int i = 0; i < lg_n; i++) {\n        if (num & (1 << i))\n            res |= 1 << (lg_n - 1 - i);\n    }\n    return res;\n}\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n    int lg_n = 0;\n    while ((1 << lg_n) < n)\n        lg_n++;\n\n    for (int i = 0; i < n; i++) {\n        if (i < reverse(i, lg_n))\n            swap(a[i], a[reverse(i, lg_n)]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\n```\n\nAt first we apply the bit-reversal permutation by swapping the each element with the element of the reversed position.\nThen the $\\log n - 1$ states of the algorithm we compute the DFT for each block of the corresponding size $\\text{len}$.\nFor all those blocks we have the same root of unity $\\text{wlen}$.\nWe iterate all blocks and perform the butterfly transform on each of them.\n\nWe can further optimize the reversal of the bits.\nIn the previous implementation we iterated all bits of the index and created the bitwise reversed index.\nHowever we can reverse the bits in a different way.\n\nSuppose that $j$ already contains the reverse of $i$.\nThen by to go to $i + 1$, we have to increment $i$, and we also have to increment $j$, but in a \"reversed\" number system.\nAdding one in the conventional binary system is equivalent to flip all tailing ones into zeros and flipping the zero right before them into a one.\nEquivalently in the \"reversed\" number system, we flip all leading ones, and the also the next zero.\n\nThus we get the following implementation:\n\n```{.cpp file=fft_implementation_iterative_opt}\nusing cd = complex<double>;\nconst double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\n```\n\nAdditionally we can precompute the bit-reversal permutation beforehand.\nThis is especially useful when the size $n$ is the same for all calls.\nBut even when we only have three calls (which are necessary for multiplying two polynomials), the effect is noticeable.\nAlso we can precompute all roots of unity and their powers.\n\n## Number theoretic transform\n\nNow we switch the objective a little bit.\nWe still want to multiply two polynomials in $O(n \\log n)$ time, but this time we want to compute the coefficients modulo some prime number $p$.\nOf course for this task we can use the normal DFT and apply the modulo operator to the result.\nHowever, doing so might lead to rounding errors, especially when dealing with large numbers.\nThe **number theoretic transform (NTT)** has the advantage, that it only works with integer, and therefore the result are guaranteed to be correct.\n \nThe discrete Fourier transform is based on complex numbers, and the $n$-th roots of unity.\nTo efficiently compute it, we extensively use properties of the roots (e.g. that there is one root that generates all other roots by exponentiation).\n\nBut the same properties hold for the $n$-th roots of unity in modular arithmetic.\nA $n$-th root of unity under a primitive field is such a number $w_n$ that satisfies:\n\n$$\\begin{align}\n(w_n)^n &= 1 \\pmod{p}, \\\\\n(w_n)^k &\\ne 1 \\pmod{p}, \\quad 1 \\le k < n.\n\\end{align}$$\n\nThe other $n-1$ roots can be obtained as powers of the root $w_n$.\n\nTo apply it in the fast Fourier transform algorithm, we need a root to exist for some $n$, which is a power of $2$, and also for all smaller powers.\nWe can notice the following interesting property:\n\n$$\\begin{align}\n(w_n^2)^m = w_n^n &= 1 \\pmod{p}, \\quad \\text{with } m = \\frac{n}{2}\\\\\n(w_n^2)^k = w_n^{2k} &\\ne 1 \\pmod{p}, \\quad 1 \\le k < m.\n\\end{align}$$\n\nThus if $w_n$ is a $n$-th root of unity, then $w_n^2$ is a $\\frac{n}{2}$-th root of unity.\nAnd consequently for all smaller powers of two there exist roots of the required degree, and they can be computed using $w_n$.\n\nFor computing the inverse DFT, we need the inverse $w_n^{-1}$ of $w_n$.\nBut for a prime modulus the inverse always exists.\n\nThus all the properties that we need from the complex roots are also available in modular arithmetic, provided that we have a large enough module $p$ for which a $n$-th root of unity exists.\n\nFor example we can take the following values: module $p = 7340033$, $w_{2^{20}} = 5$.\nIf this module is not enough, we need to find a different pair.\nWe can use that fact that for modules of the form $p = c 2^k + 1$ (and $p$ is prime), there always exists the $2^k$-th root of unity.\nIt can be shown that $g^c$ is such a $2^k$-th root of unity, where $g$ is a [primitive root](primitive-root.md) of $p$.\n\n```{.cpp file=fft_implementation_modular_arithmetic}\nconst int mod = 7340033;\nconst int root = 5;\nconst int root_1 = 4404020;\nconst int root_pw = 1 << 20;\n\nvoid fft(vector<int> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        int wlen = invert ? root_1 : root;\n        for (int i = len; i < root_pw; i <<= 1)\n            wlen = (int)(1LL * wlen * wlen % mod);\n\n        for (int i = 0; i < n; i += len) {\n            int w = 1;\n            for (int j = 0; j < len / 2; j++) {\n                int u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);\n                a[i+j] = u + v < mod ? u + v : u + v - mod;\n                a[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;\n                w = (int)(1LL * w * wlen % mod);\n            }\n        }\n    }\n\n    if (invert) {\n        int n_1 = inverse(n, mod);\n        for (int & x : a)\n            x = (int)(1LL * x * n_1 % mod);\n    }\n}\n```\n\nHere the function `inverse` computes the modular inverse (see [Modular Multiplicative Inverse](module-inverse.md)).\nThe constants `mod`, `root`, `root_pw` determine the module and the root, and `root_1` is the inverse of `root` modulo `mod`.\n\nIn practice this implementation is slower than the implementation using complex numbers (due to the huge number of modulo operations), but it has some advantages such as less memory usage and no rounding errors.\n\n## Multiplication with arbitrary modulus\n\nHere we want to achieve the same goal as in previous section.\nMultiplying two polynomial $A(x)$ and $B(x)$, and computing the coefficients modulo some number $M$.\nThe number theoretic transform only works for certain prime numbers.\nWhat about the case when the modulus is not of the desired form?\n\nOne option would be to perform multiple number theoretic transforms with different prime numbers of the form $c 2^k + 1$, then apply the [Chinese Remainder Theorem](chinese-remainder-theorem.md) to compute the final coefficients.\n\nAnother options is to distribute the polynomials $A(x)$ and $B(x)$ into two smaller polynomials each\n\n$$\\begin{align}\nA(x) &= A_1(x) + A_2(x) \\cdot C \\\\\nB(x) &= B_1(x) + B_2(x) \\cdot C\n\\end{align}$$\n\nwith $C \\approx \\sqrt{M}$.\n\nThen the product of $A(x)$ and $B(x)$ can then be represented as:\n\n$$A(x) \\cdot B(x) = A_1(x) \\cdot B_1(x) + \\left(A_1(x) \\cdot B_2(x) + A_2(x) \\cdot B_1(x)\\right)\\cdot C + \\left(A_2(x) \\cdot B_2(x)\\right)\\cdot C^2$$\n\nThe polynomials $A_1(x)$, $A_2(x)$, $B_1(x)$ and $B_2(x)$ contain only coefficients smaller than $\\sqrt{M}$, therefore the coefficients of all the appearing products are smaller than $M \\cdot n$, which is usually small enough to handle with typical floating point types.\n\nThis approach therefore requires computing the products of polynomials with smaller coefficients (by using the normal FFT and inverse FFT), and then the original product can be restored using modular addition and multiplication in $O(n)$ time.\n\n## Applications\n\nDFT can be used in a huge variety of other problems, which at the first glance have nothing to do with multiplying polynomials.\n\n### All possible sums\n\nWe are given two arrays $a[]$ and $b[]$.\nWe have to find all possible sums $a[i] + b[j]$, and for each sum count how often it appears.\n\nFor example for $a = [1,~ 2,~ 3]$ and $b = [2,~ 4]$ we get:\nthen sum $3$ can be obtained in $1$ way, the sum $4$ also in $1$ way, $5$ in $2$, $6$ in $1$, $7$ in $1$.\n\nWe construct for the arrays $a$ and $b$ two polynomials $A$ and $B$.\nThe numbers of the array will act as the exponents in the polynomial ($a[i] \\Rightarrow x^{a[i]}$); and the coefficients of this term will be how often the number appears in the array.\n\nThen, by multiplying these two polynomials in $O(n \\log n)$ time, we get a polynomial $C$, where the exponents will tell us which sums can be obtained, and the coefficients tell us how often.\nTo demonstrate this on the example:\n\n$$(1 x^1 + 1 x^2 + 1 x^3) (1 x^2 + 1 x^4) = 1 x^3 + 1 x^4 + 2 x^5 + 1 x^6 + 1 x^7$$\n\n### All possible scalar products\n\nWe are given two arrays $a[]$ and $b[]$ of length $n$.\nWe have to compute the products of $a$ with every cyclic shift of $b$.\n\nWe generate two new arrays of size $2n$:\nWe reverse $a$ and append $n$ zeros to it.\nAnd we just append $b$ to itself.\nWhen we multiply these two arrays as polynomials, and look at the coefficients $c[n-1],~ c[n],~ \\dots,~ c[2n-2]$ of the product $c$, we get:\n\n$$c[k] = \\sum_{i+j=k} a[i] b[j]$$\n\nAnd since all the elements $a[i] = 0$ for $i \\ge n$:\n\n$$c[k] = \\sum_{i=0}^{n-1} a[i] b[k-i]$$\n\nIt is easy to see that this sum is just the scalar product of the vector $a$ with the $(k - (n - 1))$-th cyclic left shift of $b$.\nThus these coefficients are the answer to the problem, and we were still able to obtain it in $O(n \\log n)$ time.\nNote here that $c[2n-1]$ also gives us the $n$-th cyclic shift but that is the same as the $0$-th cyclic shift so we don't need to consider that separately into our answer.\n\n### Two stripes\n\nWe are given two Boolean stripes (cyclic arrays of values $0$ and $1$) $a$ and $b$.\nWe want to find all ways to attach the first stripe to the second one, such that at no position we have a $1$ of the first stripe next to a $1$ of the second stripe.\n\nThe problem doesn't actually differ much from the previous problem.\nAttaching two stripes just means that we perform a cyclic shift on the second array, and we can attach the two stripes, if scalar product of the two arrays is $0$.\n\n### String matching\n\nWe are given two strings, a text $T$ and a pattern $P$, consisting of lowercase letters.\nWe have to compute all the occurrences of the pattern in the text.\n\nWe create a polynomial for each string ($T[i]$ and $P[I]$ are numbers between $0$ and $25$ corresponding to the $26$ letters of the alphabet):\n\n$$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}, \\quad n = |T|$$\n\nwith\n\n$$a_i = \\cos(\\alpha_i) + i \\sin(\\alpha_i), \\quad \\alpha_i = \\frac{2 \\pi T[i]}{26}.$$\n\nAnd\n\n$$B(x) = b_0 x^0 + b_1 x^1 + \\dots + b_{m-1} x^{m-1}, \\quad m = |P|$$\n\nwith\n\n$$b_i = \\cos(\\beta_i) - i \\sin(\\beta_i), \\quad \\beta_i = \\frac{2 \\pi P[m-i-1]}{26}.$$\n\nNotice that with the expression $P[m-i-1]$ explicitly reverses the pattern.\n\nThe $(m-1+i)$th coefficients of the product of the two polynomials $C(x) = A(x) \\cdot B(x)$ will tell us, if the pattern appears in the text at position $i$.\n\n$$c_{m-1+i} = \\sum_{j = 0}^{m-1} a_{i+j} \\cdot b_{m-1-j} = \\sum_{j=0}^{m-1} \\left(\\cos(\\alpha_{i+j}) + i \\sin(\\alpha_{i+j})\\right) \\cdot \\left(\\cos(\\beta_j) - i \\sin(\\beta_j)\\right)$$\n\nwith $\\alpha_{i+j} = \\frac{2 \\pi T[i+j]}{26}$ and $\\beta_j = \\frac{2 \\pi P[j]}{26}$\n\nIf there is a match, than $T[i+j] = P[j]$, and therefore $\\alpha_{i+j} = \\beta_j$.\nThis gives (using the Pythagorean trigonometric identity):\n\n$$\\begin{align}\nc_{m-1+i} &= \\sum_{j = 0}^{m-1}  \\left(\\cos(\\alpha_{i+j}) + i \\sin(\\alpha_{i+j})\\right) \\cdot \\left(\\cos(\\alpha_{i+j}) - i \\sin(\\alpha_{i+j})\\right) \\\\\n&= \\sum_{j = 0}^{m-1} \\cos(\\alpha_{i+j})^2 + \\sin(\\alpha_{i+j})^2 = \\sum_{j = 0}^{m-1} 1 = m\n\\end{align}$$\n\nIf there isn't a match, then at least a character is different, which leads that one of the products $a_{i+1} \\cdot b_{m-1-j}$ is not equal to $1$, which leads to the coefficient $c_{m-1+i} \\ne m$.\n\n### String matching with wildcards\n\nThis is an extension of the previous problem.\nThis time we allow that the pattern contains the wildcard character $\\*$, which can match every possible letter.\nE.g. the pattern $a*c$ appears in the text $abccaacc$ at exactly three positions, at index $0$, index $4$ and index $5$.\n\nWe create the exact same polynomials, except that we set $b_i = 0$ if $P[m-i-1] = *$.\nIf $x$ is the number of wildcards in $P$, then we will have a match of $P$ in $T$ at index $i$ if $c_{m-1+i} = m - x$.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: fft_multiply\n---\n\n# Fast Fourier transform\n\nIn this article we will discuss an algorithm that allows us to multiply two polynomials of length $n$ in $O(n \\log n)$ time, which is better than the trivial multiplication which takes $O(n^2)$ time.\nObviously also multiplying two long numbers can be reduced to multiplying polynomials, so also two long numbers can be multiplied in $O(n \\log n)$ time (where $n$ is the number of digits in the numbers).\n\nThe discovery of the **Fast Fourier transformation (FFT)** is attributed to Cooley and Tukey, who published an algorithm in 1965.\nBut in fact the FFT has been discovered repeatedly before, but the importance of it was not understood before the inventions of modern computers.\nSome researchers attribute the discovery of the FFT to Runge and K\u00f6nig in 1924.\nBut actually Gauss developed such a method already in 1805, but never published it.\n\nNotice, that the FFT algorithm presented here runs in $O(n \\log n)$ time, but it doesn't work for multiplying arbitrary big polynomials with arbitrary large coefficients or for multiplying arbitrary big integers.\nIt can easily handle polynomials of size $10^5$ with small coefficients, or multiplying two numbers of size $10^6$, but at some point the range and the precision of the used floating point numbers will not no longer be enough to give accurate results.\nThat is usually enough for solving competitive programming problems, but there are also more complex variations that can perform arbitrary large polynomial/integer multiplications.\nE.g. in 1971 Sch\u00f6nhage and Strasser developed a variation for multiplying arbitrary large numbers that applies the FFT recursively in rings structures running in $O(n \\log n \\log \\log n)$.\nAnd recently (in 2019) Harvey and van der Hoeven published an algorithm that runs in true $O(n \\log n)$.\n\n## Discrete Fourier transform\n\nLet there be a polynomial of degree $n - 1$:\n\n$$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}$$\n\nWithout loss of generality we assume that $n$ - the number of coefficients - is a power of $2$.\nIf $n$ is not a power of $2$, then we simply add the missing terms $a_i x^i$ and set the coefficients $a_i$ to $0$.\n\nThe theory of complex numbers tells us that the equation $x^n = 1$ has $n$ complex solutions (called the $n$-th roots of unity), and the solutions are of the form $w_{n, k} = e^{\\frac{2 k \\pi i}{n}}$ with $k = 0 \\dots n-1$.\nAdditionally these complex numbers have some very interesting properties:\ne.g. the principal $n$-th root $w_n = w_{n, 1} = e^{\\frac{2 \\pi i}{n}}$ can be used to describe all other $n$-th roots: $w_{n, k} = (w_n)^k$.\n\nThe **discrete Fourier transform (DFT)** of the polynomial $A(x)$ (or equivalently the vector of coefficients $(a_0, a_1, \\dots, a_{n-1})$ is defined as the values of the polynomial at the points $x = w_{n, k}$, i.e. it is the vector:\n\n$$\\begin{align}\n\\text{DFT}(a_0, a_1, \\dots, a_{n-1}) &= (y_0, y_1, \\dots, y_{n-1}) \\\\\n&= (A(w_{n, 0}), A(w_{n, 1}), \\dots, A(w_{n, n-1})) \\\\\n&= (A(w_n^0), A(w_n^1), \\dots, A(w_n^{n-1}))\n\\end{align}$$\n\nSimilarly the **inverse discrete Fourier transform** is defined:\nThe inverse DFT of values of the polynomial $(y_0, y_1, \\dots, y_{n-1})$ are the coefficients of the polynomial $(a_0, a_1, \\dots, a_{n-1})$.\n\n$$\\text{InverseDFT}(y_0, y_1, \\dots, y_{n-1}) = (a_0, a_1, \\dots, a_{n-1})$$\n\nThus, if a direct DFT computes the values of the polynomial at the points at the $n$-th roots, the inverse DFT can restore the coefficients of the polynomial using those values.\n\n### Application of the DFT: fast multiplication of polynomials\n\nLet there be two polynomials $A$ and $B$.\nWe compute the DFT for each of them: $\\text{DFT}(A)$ and $\\text{DFT}(B)$.\n\nWhat happens if we multiply these polynomials?\nObviously at each point the values are simply multiplied, i.e.\n\n$$(A \\cdot B)(x) = A(x) \\cdot B(x).$$\n\nThis means that if we multiply the vectors $\\text{DFT}(A)$ and $\\text{DFT}(B)$ - by multiplying each element of one vector by the corresponding element of the other vector - then we get nothing other than the DFT of the polynomial $\\text{DFT}(A \\cdot B)$:\n\n$$\\text{DFT}(A \\cdot B) = \\text{DFT}(A) \\cdot \\text{DFT}(B)$$\n\nFinally, applying the inverse DFT, we obtain:\n\n$$A \\cdot B = \\text{InverseDFT}(\\text{DFT}(A) \\cdot \\text{DFT}(B))$$\n\nOn the right the product of the two DFTs we mean the pairwise product of the vector elements.\nThis can be computed in $O(n)$ time.\nIf we can compute the DFT and the inverse DFT in $O(n \\log n)$, then we can compute the product of the two polynomials (and consequently also two long numbers) with the same time complexity.\n\nIt should be noted, that the two polynomials should have the same degree.\nOtherwise the two result vectors of the DFT have different length.\nWe can accomplish this by adding coefficients with the value $0$.\n\nAnd also, since the result of the product of two polynomials is a polynomial of degree $2 (n - 1)$, we have to double the degrees of each polynomial (again by padding $0$s).\nFrom a vector with $n$ values we cannot reconstruct the desired polynomial with $2n - 1$ coefficients.\n\n### Fast Fourier Transform\n\nThe **fast Fourier transform** is a method that allows computing the DFT in $O(n \\log n)$ time.\nThe basic idea of the FFT is to apply divide and conquer.\nWe divide the coefficient vector of the polynomial into two vectors, recursively compute the DFT for each of them, and combine the results to compute the DFT of the complete polynomial.\n\nSo let there be a polynomial $A(x)$ with degree $n - 1$, where $n$ is a power of $2$, and $n > 1$:\n\n$$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}$$\n\nWe divide it into two smaller polynomials, the one containing only the coefficients of the even positions, and the one containing the coefficients of the odd positions:\n\n$$\\begin{align}\nA_0(x) &= a_0 x^0 + a_2 x^1 + \\dots + a_{n-2} x^{\\frac{n}{2}-1} \\\\\nA_1(x) &= a_1 x^0 + a_3 x^1 + \\dots + a_{n-1} x^{\\frac{n}{2}-1}\n\\end{align}$$\n\nIt is easy to see that\n\n$$A(x) = A_0(x^2) + x A_1(x^2).$$\n\nThe polynomials $A_0$ and $A_1$ are only half as much coefficients as the polynomial $A$.\nIf we can compute the $\\text{DFT}(A)$ in linear time using $\\text{DFT}(A_0)$ and $\\text{DFT}(A_1)$, then we get the recurrence $T_{\\text{DFT}}(n) = 2 T_{\\text{DFT}}\\left(\\frac{n}{2}\\right) + O(n)$ for the time complexity, which results in $T_{\\text{DFT}}(n) = O(n \\log n)$ by the **master theorem**.\n\nLet's learn how we can accomplish that.\n\nSuppose we have computed the vectors $\\left(y_k^0\\right)_{k=0}^{n/2-1} = \\text{DFT}(A_0)$ and $\\left(y_k^1\\right)_{k=0}^{n/2-1} = \\text{DFT}(A_1)$.\nLet us find a expression for $\\left(y_k\\right)_{k=0}^{n-1} = \\text{DFT}(A)$.\n\nFor the first $\\frac{n}{2}$ values we can just use the previously noted equation $A(x) = A_0(x^2) + x A_1(x^2)$:\n\n$$y_k = y_k^0 + w_n^k y_k^1, \\quad k = 0 \\dots \\frac{n}{2} - 1.$$\n\nHowever for the second $\\frac{n}{2}$ values we need to find a slightly, different expression:\n\n$$\\begin{align}\ny_{k+n/2} &= A\\left(w_n^{k+n/2}\\right) \\\\\n&= A_0\\left(w_n^{2k+n}\\right) + w_n^{k + n/2} A_1\\left(w_n^{2k+n}\\right) \\\\\n&= A_0\\left(w_n^{2k} w_n^n\\right) + w_n^k w_n^{n/2} A_1\\left(w_n^{2k} w_n^n\\right) \\\\\n&= A_0\\left(w_n^{2k}\\right) - w_n^k A_1\\left(w_n^{2k}\\right) \\\\\n&= y_k^0 - w_n^k y_k^1\n\\end{align}$$\n\nHere we used again $A(x) = A_0(x^2) + x A_1(x^2)$ and the two identities $w_n^n = 1$ and $w_n^{n/2} = -1$.\n\nTherefore we get the desired formulas for computing the whole vector $(y_k)$:\n\n$$\\begin{align}\ny_k &= y_k^0 + w_n^k y_k^1, &\\quad k = 0 \\dots \\frac{n}{2} - 1, \\\\\ny_{k+n/2} &= y_k^0 - w_n^k y_k^1, &\\quad k = 0 \\dots \\frac{n}{2} - 1.\n\\end{align}$$\n\n(This pattern $a + b$ and $a - b$ is sometimes called a **butterfly**.)\n\nThus we learned how to compute the DFT in $O(n \\log n)$ time.\n\n### Inverse FFT\n\nLet the vector $(y_0, y_1, \\dots y_{n-1})$ - the values of polynomial $A$ of degree $n - 1$ in the points $x = w_n^k$ - be given.\nWe want to restore the coefficients $(a_0, a_1, \\dots, a_{n-1})$ of the polynomial.\nThis known problem is called **interpolation**, and there are general algorithms for solving it.\nBut in this special case (since we know the values of the points at the roots of unity), we can obtains a much simpler algorithm (that is practically the same as the direct FFT).\n\nWe can write the DFT, according to its definition, in the matrix form:\n\n$$\n\\begin{pmatrix}\nw_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\\nw_n^0 & w_n^1 & w_n^2 & w_n^3 & \\cdots & w_n^{n-1} \\\\\nw_n^0 & w_n^2 & w_n^4 & w_n^6 & \\cdots & w_n^{2(n-1)} \\\\\nw_n^0 & w_n^3 & w_n^6 & w_n^9 & \\cdots & w_n^{3(n-1)} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \\cdots & w_n^{(n-1)(n-1)}\n\\end{pmatrix} \\begin{pmatrix}\na_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1}\n\\end{pmatrix} = \\begin{pmatrix}\ny_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1}\n\\end{pmatrix}\n$$\n\nThis matrix is called the **Vandermonde matrix**.\n\nThus we can compute the vector $(a_0, a_1, \\dots, a_{n-1})$ by multiplying the vector $(y_0, y_1, \\dots y_{n-1})$ from the left with the inverse of the matrix:\n\n$$\n\\begin{pmatrix}\na_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1}\n\\end{pmatrix} = \\begin{pmatrix}\nw_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\\nw_n^0 & w_n^1 & w_n^2 & w_n^3 & \\cdots & w_n^{n-1} \\\\\nw_n^0 & w_n^2 & w_n^4 & w_n^6 & \\cdots & w_n^{2(n-1)} \\\\\nw_n^0 & w_n^3 & w_n^6 & w_n^9 & \\cdots & w_n^{3(n-1)} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \\cdots & w_n^{(n-1)(n-1)}\n\\end{pmatrix}^{-1} \\begin{pmatrix}\ny_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1}\n\\end{pmatrix}\n$$\n\nA quick check can verify that the inverse of the matrix has the following form:\n\n$$\n\\frac{1}{n}\n\\begin{pmatrix}\nw_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\\nw_n^0 & w_n^{-1} & w_n^{-2} & w_n^{-3} & \\cdots & w_n^{-(n-1)} \\\\\nw_n^0 & w_n^{-2} & w_n^{-4} & w_n^{-6} & \\cdots & w_n^{-2(n-1)} \\\\\nw_n^0 & w_n^{-3} & w_n^{-6} & w_n^{-9} & \\cdots & w_n^{-3(n-1)} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n^0 & w_n^{-(n-1)} & w_n^{-2(n-1)} & w_n^{-3(n-1)} & \\cdots & w_n^{-(n-1)(n-1)}\n\\end{pmatrix}\n$$\n\nThus we obtain the formula:\n\n$$a_k = \\frac{1}{n} \\sum_{j=0}^{n-1} y_j w_n^{-k j}$$\n\nComparing this to the formula for $y_k$\n\n$$y_k = \\sum_{j=0}^{n-1} a_j w_n^{k j},$$\n\nwe notice that these problems are almost the same, so the coefficients $a_k$ can be found by the same divide and conquer algorithm, as well as the direct FFT, only instead of $w_n^k$ we have to use $w_n^{-k}$, and at the end we need to divide the resulting coefficients by $n$.\n\nThus the computation of the inverse DFT is almost the same as the calculation of the direct DFT, and it also can be performed in $O(n \\log n)$ time.\n\n### Implementation\n\nHere we present a simple recursive **implementation of the FFT** and the inverse FFT, both in one function, since the difference between the forward and the inverse FFT are so minimal.\nTo store the complex numbers we use the complex type in the C++ STL.\n\n```{.cpp file=fft_recursive}\nusing cd = complex<double>;\nconst double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n    if (n == 1)\n        return;\n\n    vector<cd> a0(n / 2), a1(n / 2);\n    for (int i = 0; 2 * i < n; i++) {\n        a0[i] = a[2*i];\n        a1[i] = a[2*i+1];\n    }\n    fft(a0, invert);\n    fft(a1, invert);\n\n    double ang = 2 * PI / n * (invert ? -1 : 1);\n    cd w(1), wn(cos(ang), sin(ang));\n    for (int i = 0; 2 * i < n; i++) {\n        a[i] = a0[i] + w * a1[i];\n        a[i + n/2] = a0[i] - w * a1[i];\n        if (invert) {\n            a[i] /= 2;\n            a[i + n/2] /= 2;\n        }\n        w *= wn;\n    }\n}\n```\n\nThe function gets passed a vector of coefficients, and the function will compute the DFT or inverse DFT and store the result again in this vector.\nThe argument $\\text{invert}$ shows whether the direct or the inverse DFT should be computed.\nInside the function we first check if the length of the vector is equal to one, if this is the case then we don't have to do anything.\nOtherwise we divide the vector $a$ into two vectors $a0$ and $a1$ and compute the DFT for both recursively.\nThen we initialize the value $wn$ and a variable $w$, which will contain the current power of $wn$.\nThen the values of the resulting DFT are computed using the above formulas.\n\nIf the flag $\\text{invert}$ is set, then we replace $wn$ with $wn^{-1}$, and each of the values of the result is divided by $2$ (since this will be done in each level of the recursion, this will end up dividing the final values by $n$).\n\nUsing this function we can create a function for **multiplying two polynomials**:\n\n```{.cpp file=fft_multiply}\nvector<int> multiply(vector<int> const& a, vector<int> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size()) \n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<int> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\n```\n\nThis function works with polynomials with integer coefficients, however you can also adjust it to work with other types.\nSince there is some error when working with complex numbers, we need round the resulting coefficients at the end.\n\nFinally the function for **multiplying** two long numbers practically doesn't differ from the function for multiplying polynomials.\nThe only thing we have to do afterwards, is to normalize the number:\n\n```cpp\n    int carry = 0;\n    for (int i = 0; i < n; i++)\n        result[i] += carry;\n        carry = result[i] / 10;\n        result[i] %= 10;\n    }\n```\n\nSince the length of the product of two numbers never exceed the total length of both numbers, the size of the vector is enough to perform all carry operations.\n\n### Improved implementation: in-place computation\n\nTo increase the efficiency we will switch from the recursive implementation to an iterative one.\nIn the above recursive implementation we explicitly separated the vector $a$ into two vectors - the element on the even positions got assigned to one temporary vector, and the elements on odd positions to another.\nHowever if we reorder the elements in a certain way, we don't need to create these temporary vectors (i.e. all the calculations can be done \"in-place\", right in the vector $A$ itself).\n\nNote that at the first recursion level, the elements whose lowest bit of the position was zero got assigned to the vector $a_0$, and the ones with a one as the lowest bit of the position got assigned to $a_1$.\nIn the second recursion level the same thing happens, but with the second lowest bit instead, etc.\nTherefore if we reverse the bits of the position of each coefficient, and sort them by these reversed values, we get the desired order (it is called the bit-reversal permutation).\n\nFor example the desired order for $n = 8$ has the form:\n\n$$a = \\bigg\\{ \\Big[ (a_0, a_4), (a_2, a_6) \\Big], \\Big[ (a_1, a_5), (a_3, a_7) \\Big] \\bigg\\}$$\n\nIndeed in the first recursion level (surrounded by curly braces), the vector gets divided into two parts $[a_0, a_2, a_4, a_6]$ and $[a_1, a_3, a_5, a_7]$.\nAs we see, in the bit-reversal permutation this corresponds to simply dividing the vector into two halves: the first $\\frac{n}{2}$ elements and the last $\\frac{n}{2}$ elements.\nThen there is a recursive call for each halve.\nLet the resulting DFT for each of them be returned in place of the elements themselves (i.e. the first half and the second half of the vector $a$ respectively.\n\n$$a = \\bigg\\{ \\Big[y_0^0, y_1^0, y_2^0, y_3^0\\Big], \\Big[y_0^1, y_1^1, y_2^1, y_3^1 \\Big] \\bigg\\}$$\n\nNow we want to combine the two DFTs into one for the complete vector.\nThe order of the elements is ideal, and we can also perform the union directly in this vector.\nWe can take the elements $y_0^0$ and $y_0^1$ and perform the butterfly transform.\nThe place of the resulting two values is the same as the place of the two initial values, so we get:\n\n$$a = \\bigg\\{ \\Big[y_0^0 + w_n^0 y_0^1, y_1^0, y_2^0, y_3^0\\Big], \\Big[y_0^0 - w_n^0 y_0^1, y_1^1, y_2^1, y_3^1\\Big] \\bigg\\}$$\n\nSimilarly we can compute the butterfly transform of $y_1^0$ and $y_1^1$ and put the results in their place, and so on.\nAs a result we get:\n\n$$a = \\bigg\\{ \\Big[y_0^0 + w_n^0 y_0^1, y_1^0 + w_n^1 y_1^1, y_2^0 + w_n^2 y_2^1, y_3^0 + w_n^3 y_3^1\\Big], \\Big[y_0^0 - w_n^0 y_0^1, y_1^0 - w_n^1 y_1^1, y_2^0 - w_n^2 y_2^1, y_3^0 - w_n^3 y_3^1\\Big] \\bigg\\}$$\n\nThus we computed the required DFT from the vector $a$.\n\nHere we described the process of computing the DFT only at the first recursion level, but the same works obviously also for all other levels.\nThus, after applying the bit-reversal permutation, we can compute the DFT in-place, without any additional memory.\n\nThis additionally allows us to get rid of the recursion.\nWe just start at the lowest level, i.e. we divide the vector into pairs and apply the butterfly transform to them.\nThis results with the vector $a$ with the work of the last level applied.\nIn the next step we divide the vector into vectors of size $4$, and again apply the butterfly transform, which gives us the DFT for each block of size $4$.\nAnd so on.\nFinally in the last step we obtained the result of the DFTs of both halves of $a$, and by applying the butterfly transform we obtain the DFT for the complete vector $a$.\n\n```{.cpp file=fft_implementation_iterative}\nusing cd = complex<double>;\nconst double PI = acos(-1);\n\nint reverse(int num, int lg_n) {\n    int res = 0;\n    for (int i = 0; i < lg_n; i++) {\n        if (num & (1 << i))\n            res |= 1 << (lg_n - 1 - i);\n    }\n    return res;\n}\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n    int lg_n = 0;\n    while ((1 << lg_n) < n)\n        lg_n++;\n\n    for (int i = 0; i < n; i++) {\n        if (i < reverse(i, lg_n))\n            swap(a[i], a[reverse(i, lg_n)]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\n```\n\nAt first we apply the bit-reversal permutation by swapping the each element with the element of the reversed position.\nThen the $\\log n - 1$ states of the algorithm we compute the DFT for each block of the corresponding size $\\text{len}$.\nFor all those blocks we have the same root of unity $\\text{wlen}$.\nWe iterate all blocks and perform the butterfly transform on each of them.\n\nWe can further optimize the reversal of the bits.\nIn the previous implementation we iterated all bits of the index and created the bitwise reversed index.\nHowever we can reverse the bits in a different way.\n\nSuppose that $j$ already contains the reverse of $i$.\nThen by to go to $i + 1$, we have to increment $i$, and we also have to increment $j$, but in a \"reversed\" number system.\nAdding one in the conventional binary system is equivalent to flip all tailing ones into zeros and flipping the zero right before them into a one.\nEquivalently in the \"reversed\" number system, we flip all leading ones, and the also the next zero.\n\nThus we get the following implementation:\n\n```{.cpp file=fft_implementation_iterative_opt}\nusing cd = complex<double>;\nconst double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\n```\n\nAdditionally we can precompute the bit-reversal permutation beforehand.\nThis is especially useful when the size $n$ is the same for all calls.\nBut even when we only have three calls (which are necessary for multiplying two polynomials), the effect is noticeable.\nAlso we can precompute all roots of unity and their powers.\n\n## Number theoretic transform\n\nNow we switch the objective a little bit.\nWe still want to multiply two polynomials in $O(n \\log n)$ time, but this time we want to compute the coefficients modulo some prime number $p$.\nOf course for this task we can use the normal DFT and apply the modulo operator to the result.\nHowever, doing so might lead to rounding errors, especially when dealing with large numbers.\nThe **number theoretic transform (NTT)** has the advantage, that it only works with integer, and therefore the result are guaranteed to be correct.\n \nThe discrete Fourier transform is based on complex numbers, and the $n$-th roots of unity.\nTo efficiently compute it, we extensively use properties of the roots (e.g. that there is one root that generates all other roots by exponentiation).\n\nBut the same properties hold for the $n$-th roots of unity in modular arithmetic.\nA $n$-th root of unity under a primitive field is such a number $w_n$ that satisfies:\n\n$$\\begin{align}\n(w_n)^n &= 1 \\pmod{p}, \\\\\n(w_n)^k &\\ne 1 \\pmod{p}, \\quad 1 \\le k < n.\n\\end{align}$$\n\nThe other $n-1$ roots can be obtained as powers of the root $w_n$.\n\nTo apply it in the fast Fourier transform algorithm, we need a root to exist for some $n$, which is a power of $2$, and also for all smaller powers.\nWe can notice the following interesting property:\n\n$$\\begin{align}\n(w_n^2)^m = w_n^n &= 1 \\pmod{p}, \\quad \\text{with } m = \\frac{n}{2}\\\\\n(w_n^2)^k = w_n^{2k} &\\ne 1 \\pmod{p}, \\quad 1 \\le k < m.\n\\end{align}$$\n\nThus if $w_n$ is a $n$-th root of unity, then $w_n^2$ is a $\\frac{n}{2}$-th root of unity.\nAnd consequently for all smaller powers of two there exist roots of the required degree, and they can be computed using $w_n$.\n\nFor computing the inverse DFT, we need the inverse $w_n^{-1}$ of $w_n$.\nBut for a prime modulus the inverse always exists.\n\nThus all the properties that we need from the complex roots are also available in modular arithmetic, provided that we have a large enough module $p$ for which a $n$-th root of unity exists.\n\nFor example we can take the following values: module $p = 7340033$, $w_{2^{20}} = 5$.\nIf this module is not enough, we need to find a different pair.\nWe can use that fact that for modules of the form $p = c 2^k + 1$ (and $p$ is prime), there always exists the $2^k$-th root of unity.\nIt can be shown that $g^c$ is such a $2^k$-th root of unity, where $g$ is a [primitive root](primitive-root.md) of $p$.\n\n```{.cpp file=fft_implementation_modular_arithmetic}\nconst int mod = 7340033;\nconst int root = 5;\nconst int root_1 = 4404020;\nconst int root_pw = 1 << 20;\n\nvoid fft(vector<int> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        int wlen = invert ? root_1 : root;\n        for (int i = len; i < root_pw; i <<= 1)\n            wlen = (int)(1LL * wlen * wlen % mod);\n\n        for (int i = 0; i < n; i += len) {\n            int w = 1;\n            for (int j = 0; j < len / 2; j++) {\n                int u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);\n                a[i+j] = u + v < mod ? u + v : u + v - mod;\n                a[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;\n                w = (int)(1LL * w * wlen % mod);\n            }\n        }\n    }\n\n    if (invert) {\n        int n_1 = inverse(n, mod);\n        for (int & x : a)\n            x = (int)(1LL * x * n_1 % mod);\n    }\n}\n```\n\nHere the function `inverse` computes the modular inverse (see [Modular Multiplicative Inverse](module-inverse.md)).\nThe constants `mod`, `root`, `root_pw` determine the module and the root, and `root_1` is the inverse of `root` modulo `mod`.\n\nIn practice this implementation is slower than the implementation using complex numbers (due to the huge number of modulo operations), but it has some advantages such as less memory usage and no rounding errors.\n\n## Multiplication with arbitrary modulus\n\nHere we want to achieve the same goal as in previous section.\nMultiplying two polynomial $A(x)$ and $B(x)$, and computing the coefficients modulo some number $M$.\nThe number theoretic transform only works for certain prime numbers.\nWhat about the case when the modulus is not of the desired form?\n\nOne option would be to perform multiple number theoretic transforms with different prime numbers of the form $c 2^k + 1$, then apply the [Chinese Remainder Theorem](chinese-remainder-theorem.md) to compute the final coefficients.\n\nAnother options is to distribute the polynomials $A(x)$ and $B(x)$ into two smaller polynomials each\n\n$$\\begin{align}\nA(x) &= A_1(x) + A_2(x) \\cdot C \\\\\nB(x) &= B_1(x) + B_2(x) \\cdot C\n\\end{align}$$\n\nwith $C \\approx \\sqrt{M}$.\n\nThen the product of $A(x)$ and $B(x)$ can then be represented as:\n\n$$A(x) \\cdot B(x) = A_1(x) \\cdot B_1(x) + \\left(A_1(x) \\cdot B_2(x) + A_2(x) \\cdot B_1(x)\\right)\\cdot C + \\left(A_2(x) \\cdot B_2(x)\\right)\\cdot C^2$$\n\nThe polynomials $A_1(x)$, $A_2(x)$, $B_1(x)$ and $B_2(x)$ contain only coefficients smaller than $\\sqrt{M}$, therefore the coefficients of all the appearing products are smaller than $M \\cdot n$, which is usually small enough to handle with typical floating point types.\n\nThis approach therefore requires computing the products of polynomials with smaller coefficients (by using the normal FFT and inverse FFT), and then the original product can be restored using modular addition and multiplication in $O(n)$ time.\n\n## Applications\n\nDFT can be used in a huge variety of other problems, which at the first glance have nothing to do with multiplying polynomials.\n\n### All possible sums\n\nWe are given two arrays $a[]$ and $b[]$.\nWe have to find all possible sums $a[i] + b[j]$, and for each sum count how often it appears.\n\nFor example for $a = [1,~ 2,~ 3]$ and $b = [2,~ 4]$ we get:\nthen sum $3$ can be obtained in $1$ way, the sum $4$ also in $1$ way, $5$ in $2$, $6$ in $1$, $7$ in $1$.\n\nWe construct for the arrays $a$ and $b$ two polynomials $A$ and $B$.\nThe numbers of the array will act as the exponents in the polynomial ($a[i] \\Rightarrow x^{a[i]}$); and the coefficients of this term will be how often the number appears in the array.\n\nThen, by multiplying these two polynomials in $O(n \\log n)$ time, we get a polynomial $C$, where the exponents will tell us which sums can be obtained, and the coefficients tell us how often.\nTo demonstrate this on the example:\n\n$$(1 x^1 + 1 x^2 + 1 x^3) (1 x^2 + 1 x^4) = 1 x^3 + 1 x^4 + 2 x^5 + 1 x^6 + 1 x^7$$\n\n### All possible scalar products\n\nWe are given two arrays $a[]$ and $b[]$ of length $n$.\nWe have to compute the products of $a$ with every cyclic shift of $b$.\n\nWe generate two new arrays of size $2n$:\nWe reverse $a$ and append $n$ zeros to it.\nAnd we just append $b$ to itself.\nWhen we multiply these two arrays as polynomials, and look at the coefficients $c[n-1],~ c[n],~ \\dots,~ c[2n-2]$ of the product $c$, we get:\n\n$$c[k] = \\sum_{i+j=k} a[i] b[j]$$\n\nAnd since all the elements $a[i] = 0$ for $i \\ge n$:\n\n$$c[k] = \\sum_{i=0}^{n-1} a[i] b[k-i]$$\n\nIt is easy to see that this sum is just the scalar product of the vector $a$ with the $(k - (n - 1))$-th cyclic left shift of $b$.\nThus these coefficients are the answer to the problem, and we were still able to obtain it in $O(n \\log n)$ time.\nNote here that $c[2n-1]$ also gives us the $n$-th cyclic shift but that is the same as the $0$-th cyclic shift so we don't need to consider that separately into our answer.\n\n### Two stripes\n\nWe are given two Boolean stripes (cyclic arrays of values $0$ and $1$) $a$ and $b$.\nWe want to find all ways to attach the first stripe to the second one, such that at no position we have a $1$ of the first stripe next to a $1$ of the second stripe.\n\nThe problem doesn't actually differ much from the previous problem.\nAttaching two stripes just means that we perform a cyclic shift on the second array, and we can attach the two stripes, if scalar product of the two arrays is $0$.\n\n### String matching\n\nWe are given two strings, a text $T$ and a pattern $P$, consisting of lowercase letters.\nWe have to compute all the occurrences of the pattern in the text.\n\nWe create a polynomial for each string ($T[i]$ and $P[I]$ are numbers between $0$ and $25$ corresponding to the $26$ letters of the alphabet):\n\n$$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}, \\quad n = |T|$$\n\nwith\n\n$$a_i = \\cos(\\alpha_i) + i \\sin(\\alpha_i), \\quad \\alpha_i = \\frac{2 \\pi T[i]}{26}.$$\n\nAnd\n\n$$B(x) = b_0 x^0 + b_1 x^1 + \\dots + b_{m-1} x^{m-1}, \\quad m = |P|$$\n\nwith\n\n$$b_i = \\cos(\\beta_i) - i \\sin(\\beta_i), \\quad \\beta_i = \\frac{2 \\pi P[m-i-1]}{26}.$$\n\nNotice that with the expression $P[m-i-1]$ explicitly reverses the pattern.\n\nThe $(m-1+i)$th coefficients of the product of the two polynomials $C(x) = A(x) \\cdot B(x)$ will tell us, if the pattern appears in the text at position $i$.\n\n$$c_{m-1+i} = \\sum_{j = 0}^{m-1} a_{i+j} \\cdot b_{m-1-j} = \\sum_{j=0}^{m-1} \\left(\\cos(\\alpha_{i+j}) + i \\sin(\\alpha_{i+j})\\right) \\cdot \\left(\\cos(\\beta_j) - i \\sin(\\beta_j)\\right)$$\n\nwith $\\alpha_{i+j} = \\frac{2 \\pi T[i+j]}{26}$ and $\\beta_j = \\frac{2 \\pi P[j]}{26}$\n\nIf there is a match, than $T[i+j] = P[j]$, and therefore $\\alpha_{i+j} = \\beta_j$.\nThis gives (using the Pythagorean trigonometric identity):\n\n$$\\begin{align}\nc_{m-1+i} &= \\sum_{j = 0}^{m-1}  \\left(\\cos(\\alpha_{i+j}) + i \\sin(\\alpha_{i+j})\\right) \\cdot \\left(\\cos(\\alpha_{i+j}) - i \\sin(\\alpha_{i+j})\\right) \\\\\n&= \\sum_{j = 0}^{m-1} \\cos(\\alpha_{i+j})^2 + \\sin(\\alpha_{i+j})^2 = \\sum_{j = 0}^{m-1} 1 = m\n\\end{align}$$\n\nIf there isn't a match, then at least a character is different, which leads that one of the products $a_{i+1} \\cdot b_{m-1-j}$ is not equal to $1$, which leads to the coefficient $c_{m-1+i} \\ne m$.\n\n### String matching with wildcards\n\nThis is an extension of the previous problem.\nThis time we allow that the pattern contains the wildcard character $\\*$, which can match every possible letter.\nE.g. the pattern $a*c$ appears in the text $abccaacc$ at exactly three positions, at index $0$, index $4$ and index $5$.\n\nWe create the exact same polynomials, except that we set $b_i = 0$ if $P[m-i-1] = *$.\nIf $x$ is the number of wildcards in $P$, then we will have a match of $P$ in $T$ at index $i$ if $c_{m-1+i} = m - x$.\n\n## Practice problems\n\n- [SPOJ - POLYMUL](http://www.spoj.com/problems/POLYMUL/)\n- [SPOJ - MAXMATCH](http://www.spoj.com/problems/MAXMATCH/)\n- [SPOJ - ADAMATCH](http://www.spoj.com/problems/ADAMATCH/)\n- [Codeforces - Yet Another String Matching Problem](http://codeforces.com/problemset/problem/954/I)\n- [Codeforces - Lightsabers (hard)](http://codeforces.com/problemset/problem/958/F3)\n- [Codeforces - Running Competition](https://codeforces.com/contest/1398/problem/G)\n- [Kattis - A+B Problem](https://open.kattis.com/problems/aplusb)\n- [Kattis - K-Inversions](https://open.kattis.com/problems/kinversions)\n- [Codeforces - Dasha and cyclic table](http://codeforces.com/contest/754/problem/E)\n- [CodeChef - Expected Number of Customers](https://www.codechef.com/COOK112A/problems/MMNN01)\n- [CodeChef - Power Sum](https://www.codechef.com/SEPT19A/problems/PSUM)\n- [Codeforces - Centroid Probabilities](https://codeforces.com/problemset/problem/1667/E)\n", "problem_ids": ["954_I", "958_F3", "1398_G", "754_E"], "title": "Fast Fourier transform"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: diofant_1_equation\n---\n\n# Linear Congruence Equation\n\nThis equation is of the form:\n\n$$a \\cdot x \\equiv b \\pmod n,$$\n\nwhere $a$, $b$ and $n$ are given integers and $x$ is an unknown integer.\n\nIt is required to find the value $x$ from the interval $[0, n-1]$ (clearly, on the entire number line there can be infinitely many solutions that will differ from each other in $n \\cdot k$ , where $k$ is any integer). If the solution is not unique, then we will consider how to get all the solutions.\n\n## Solution by finding the inverse element\n\nLet us first consider a simpler case where $a$ and $n$ are **coprime** ($\\gcd(a, n) = 1$).\nThen one can find the [inverse](module-inverse.md) of $a$, and multiplying both sides of the equation with the inverse, and we can get a **unique** solution.\n\n$$x \\equiv b \\cdot a ^ {- 1} \\pmod n$$\n\nNow consider the case where $a$ and $n$ are **not coprime** ($\\gcd(a, n) \\ne 1$).\nThen the solution will not always exist (for example $2 \\cdot x \\equiv 1 \\pmod 4$ has no solution).\n\nLet $g = \\gcd(a, n)$, i.e. the [greatest common divisor](euclid-algorithm.md) of $a$ and $n$ (which in this case is greater than one).\n\nThen, if $b$ is not divisible by $g$, there is no solution. In fact, for any $x$ the left side of the equation $a \\cdot x \\pmod n$ , is always divisible by $g$, while the right-hand side is not divisible by it, hence it follows that there are no solutions.\n\nIf $g$ divides $b$, then by dividing both sides of the equation by $g$ (i.e. dividing $a$, $b$ and $n$ by $g$), we receive a new equation:\n\n$$a^\\prime \\cdot x \\equiv b^\\prime \\pmod{n^\\prime}$$\n\nin which $a^\\prime$ and $n^\\prime$ are already relatively prime, and we have already learned how to handle such an equation.\nWe get $x^\\prime$ as solution for $x$.\n\nIt is clear that this $x^\\prime$ will also be a solution of the original equation.\nHowever it will **not be the only solution**.\nIt can be shown that the original equation has exactly $g$ solutions, and they will look like this:\n\n$$x_i \\equiv (x^\\prime + i\\cdot n^\\prime) \\pmod n \\quad \\text{for } i = 0 \\ldots g-1$$\n\nSummarizing, we can say that the **number of solutions** of the linear congruence equation is equal to either $g = \\gcd(a, n)$ or to zero.\n\n## Solution with the Extended Euclidean Algorithm\n\nWe can rewrite the linear congruence to the following Diophantine equation:\n\n$$a \\cdot x + n \\cdot k = b,$$\n\nwhere $x$ and $k$ are unknown integers.\n\nThe method of solving this equation is described in the corresponding article [Linear Diophantine equations](linear-diophantine-equation.md) and it consists of applying the [Extended Euclidean Algorithm](extended-euclid-algorithm.md).\n\nIt also describes the method of obtaining all solutions of this equation from one found solution, and incidentally this method, when carefully considered, is absolutely equivalent to the method described in the previous section.\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: diofant_1_equation\n---\n\n# Linear Congruence Equation\n\nThis equation is of the form:\n\n$$a \\cdot x \\equiv b \\pmod n,$$\n\nwhere $a$, $b$ and $n$ are given integers and $x$ is an unknown integer.\n\nIt is required to find the value $x$ from the interval $[0, n-1]$ (clearly, on the entire number line there can be infinitely many solutions that will differ from each other in $n \\cdot k$ , where $k$ is any integer). If the solution is not unique, then we will consider how to get all the solutions.\n\n## Solution by finding the inverse element\n\nLet us first consider a simpler case where $a$ and $n$ are **coprime** ($\\gcd(a, n) = 1$).\nThen one can find the [inverse](module-inverse.md) of $a$, and multiplying both sides of the equation with the inverse, and we can get a **unique** solution.\n\n$$x \\equiv b \\cdot a ^ {- 1} \\pmod n$$\n\nNow consider the case where $a$ and $n$ are **not coprime** ($\\gcd(a, n) \\ne 1$).\nThen the solution will not always exist (for example $2 \\cdot x \\equiv 1 \\pmod 4$ has no solution).\n\nLet $g = \\gcd(a, n)$, i.e. the [greatest common divisor](euclid-algorithm.md) of $a$ and $n$ (which in this case is greater than one).\n\nThen, if $b$ is not divisible by $g$, there is no solution. In fact, for any $x$ the left side of the equation $a \\cdot x \\pmod n$ , is always divisible by $g$, while the right-hand side is not divisible by it, hence it follows that there are no solutions.\n\nIf $g$ divides $b$, then by dividing both sides of the equation by $g$ (i.e. dividing $a$, $b$ and $n$ by $g$), we receive a new equation:\n\n$$a^\\prime \\cdot x \\equiv b^\\prime \\pmod{n^\\prime}$$\n\nin which $a^\\prime$ and $n^\\prime$ are already relatively prime, and we have already learned how to handle such an equation.\nWe get $x^\\prime$ as solution for $x$.\n\nIt is clear that this $x^\\prime$ will also be a solution of the original equation.\nHowever it will **not be the only solution**.\nIt can be shown that the original equation has exactly $g$ solutions, and they will look like this:\n\n$$x_i \\equiv (x^\\prime + i\\cdot n^\\prime) \\pmod n \\quad \\text{for } i = 0 \\ldots g-1$$\n\nSummarizing, we can say that the **number of solutions** of the linear congruence equation is equal to either $g = \\gcd(a, n)$ or to zero.\n\n## Solution with the Extended Euclidean Algorithm\n\nWe can rewrite the linear congruence to the following Diophantine equation:\n\n$$a \\cdot x + n \\cdot k = b,$$\n\nwhere $x$ and $k$ are unknown integers.\n\nThe method of solving this equation is described in the corresponding article [Linear Diophantine equations](linear-diophantine-equation.md) and it consists of applying the [Extended Euclidean Algorithm](extended-euclid-algorithm.md).\n\nIt also describes the method of obtaining all solutions of this equation from one found solution, and incidentally this method, when carefully considered, is absolutely equivalent to the method described in the previous section.\n", "problem_ids": [], "title": "Linear Congruence Equation"}, {"article": "---\ntags:\n  - Original\n---\n\n# Montgomery Multiplication\n\nMany algorithms in number theory, like [prime testing](primality_tests.md) or [integer factorization](factorization.md), and in cryptography, like RSA, require lots of operations modulo a large number.\nA multiplications like $x y \\bmod{n}$ is quite slow to compute with the typical algorithms, since it requires a division to know how many times $n$ has to be subtracted from the product.\nAnd division is a really expensive operation, especially with big numbers.\n\nThe **Montgomery (modular) multiplication** is a method that allows computing such multiplications faster.\nInstead of dividing the product and subtracting $n$ multiple times, it adds multiples of $n$ to cancel out the lower bits and then just discards the lower bits.\n\n## Montgomery representation\n\nHowever the Montgomery multiplication doesn't come for free.\nThe algorithm works only in the **Montgomery space**.\nAnd we need to transform our numbers into that space, before we can start multiplying.\n\nFor the space we need a positive integer $r \\ge n$ coprime to $n$, i.e. $\\gcd(n, r) = 1$.\nIn practice we always choose $r$ to be $2^m$ for a positive integer $m$, since multiplications, divisions and modulo $r$ operations can then be efficiently implemented using shifts and other bit operations.\n$n$ will be an odd number in pretty much all applications, since it is not hard to factorize an even number.\nSo every power of $2$ will be coprime to $n$.\n\nThe representative $\\bar{x}$ of a number $x$ in the Montgomery space is defined as: \n\n$$\\bar{x} := x \\cdot r \\bmod n$$\n\nNotice, the transformation is actually such a multiplication that we want to optimize.\nSo this is still an expensive operation.\nHowever you only need to transform a number once into the space.\nAs soon as you are in the Montgomery space, you can perform as many operations as you want efficiently.\nAnd at the end you transform the final result back.\nSo as long as you are doing lots of operations modulo $n$, this will be no problem.\n\nInside the Montgomery space you can still perform most operations as usual.\nYou can add two elements ($x \\cdot r + y \\cdot r \\equiv (x + y) \\cdot r \\bmod n$), subtract, check for equality, and even compute the greatest common divisor of a number with $n$ (since $\\gcd(n, r) = 1$).\nAll with the usual algorithms.\n\nHowever this is not the case for multiplication.\n\nWe expect the result to be:\n\n$$\\bar{x} * \\bar{y} = \\overline{x \\cdot y} = (x \\cdot y) \\cdot r \\bmod n.$$\n\nBut the normal multiplication will give us:\n\n$$\\bar{x} \\cdot \\bar{y} = (x \\cdot y) \\cdot r \\cdot r \\bmod n.$$\n\nTherefore the multiplication in the Montgomery space is defined as:\n\n$$\\bar{x} * \\bar{y} := \\bar{x} \\cdot \\bar{y} \\cdot r^{-1} \\bmod n.$$\n\n## Montgomery reduction\n\nThe multiplication of two numbers in the Montgomery space requires an efficient computation of $x \\cdot r^{-1} \\bmod n$.\nThis operation is called the **Montgomery reduction**, and is also known as the algorithm **REDC**.\n\nBecause $\\gcd(n, r) = 1$, we know that there are two numbers $r^{-1}$ and $n^{\\prime}$ with $0 < r^{-1}, n^{\\prime} < n$ with\n\n$$r \\cdot r^{-1} + n \\cdot n^{\\prime} = 1.$$\n\nBoth $r^{-1}$ and $n^{\\prime}$ can be computed using the [Extended Euclidean algorithm](extended-euclid-algorithm.md).\n\nUsing this identity we can write $x \\cdot r^{-1}$ as:\n\n$$\\begin{aligned}\nx \\cdot r^{-1} &= x \\cdot r \\cdot r^{-1} / r = x \\cdot (-n \\cdot n^{\\prime} + 1) / r \\\\\n&= (-x \\cdot n \\cdot n^{\\prime} + x) / r \\equiv (-x \\cdot n \\cdot n^{\\prime} + l \\cdot r \\cdot n + x) / r \\bmod n\\\\\n&\\equiv ((-x \\cdot n^{\\prime} + l \\cdot r) \\cdot n + x) / r \\bmod n\n\\end{aligned}$$\n\nThe equivalences hold for any arbitrary integer $l$.\nThis means, that we can add or subtract an arbitrary multiple of $r$ to $x \\cdot n^{\\prime}$, or in other words, we can compute $q := x \\cdot n^{\\prime}$ modulo $r$.\n\nThis gives us the following algorithm to compute $x \\cdot r^{-1} \\bmod n$:\n\n```text\nfunction reduce(x):\n    q = (x mod r) * n' mod r\n    a = (x - q * n) / r\n    if a < 0:\n        a += n\n    return a\n```\n\nSince $x < n \\cdot n < r \\cdot n$ (even if $x$ is the product of a multiplication) and $q \\cdot n < r \\cdot n$ we know that $-n < (x - q \\cdot n) / r < n$.\nTherefore the final modulo operation is implemented using a single check and one addition.\n\nAs we see, we can perform the Montgomery reduction without any heavy modulo operations.\nIf we choose $r$ as a power of $2$, the modulo operations and divisions in the algorithm can be computed using bitmasking and shifting.\n\nA second application of the Montgomery reduction is to transfer a number back from the Montgomery space into the normal space.\n\n## Fast inverse trick\n\nFor computing the inverse $n^{\\prime} := n^{-1} \\bmod r$ efficiently, we can use the following trick (which is inspired from the Newton's method):\n\n$$a \\cdot x \\equiv 1 \\bmod 2^k \\Longrightarrow a \\cdot x \\cdot (2 - a \\cdot x) \\equiv 1 \\bmod 2^{2k}$$\n\nThis can easily be proven.\nIf we have $a \\cdot x = 1 + m \\cdot 2^k$, then we have:\n\n$$\\begin{aligned}\na \\cdot x \\cdot (2 - a \\cdot x) &= 2 \\cdot a \\cdot x - (a \\cdot x)^2 \\\\\n&= 2 \\cdot (1 + m \\cdot 2^k) - (1 + m \\cdot 2^k)^2 \\\\\n&= 2 + 2 \\cdot m \\cdot 2^k - 1 - 2 \\cdot m \\cdot 2^k - m^2 \\cdot 2^{2k} \\\\\n&= 1 - m^2 \\cdot 2^{2k} \\\\\n&\\equiv 1 \\bmod 2^{2k}.\n\\end{aligned}$$\n\nThis means we can start with $x = 1$ as the inverse of $a$ modulo $2^1$, apply the trick a few times and in each iteration we double the number of correct bits of $x$.\n\n## Implementation\n\nUsing the GCC compiler we can compute $x \\cdot y \\bmod n$ still efficiently, when all three numbers are 64 bit integer, since the compiler supports 128 bit integer with the types `__int128` and `__uint128`.\n\n```cpp\nlong long result = (__int128)x * y % n;\n```\n\nHowever there is no type for 256 bit integer.\nTherefore we will here show an implementation for a 128 bit multiplication.\n\n```cpp\nusing u64 = uint64_t;\nusing u128 = __uint128_t;\nusing i128 = __int128_t;\n\nstruct u256 {\n    u128 high, low;\n\n    static u256 mult(u128 x, u128 y) {\n        u64 a = x >> 64, b = x;\n        u64 c = y >> 64, d = y;\n        // (a*2^64 + b) * (c*2^64 + d) =\n        // (a*c) * 2^128 + (a*d + b*c)*2^64 + (b*d)\n        u128 ac = (u128)a * c;\n        u128 ad = (u128)a * d;\n        u128 bc = (u128)b * c;\n        u128 bd = (u128)b * d;\n        u128 carry = (u128)(u64)ad + (u128)(u64)bc + (bd >> 64u);\n        u128 high = ac + (ad >> 64u) + (bc >> 64u) + (carry >> 64u);\n        u128 low = (ad << 64u) + (bc << 64u) + bd;\n        return {high, low};\n    }\n};\n\nstruct Montgomery {\n    Montgomery(u128 n) : mod(n), inv(1) {\n        for (int i = 0; i < 7; i++)\n            inv *= 2 - n * inv;\n    }\n\n    u128 init(u128 x) {\n        x %= mod;\n        for (int i = 0; i < 128; i++) {\n            x <<= 1;\n            if (x >= mod)\n                x -= mod;\n        }\n        return x;\n    }\n\n    u128 reduce(u256 x) {\n        u128 q = x.low * inv;\n        i128 a = x.high - u256::mult(q, mod).high;\n        if (a < 0)\n            a += mod;\n        return a;\n    }\n\n    u128 mult(u128 a, u128 b) {\n        return reduce(u256::mult(a, b));\n    }\n\n    u128 mod, inv;\n};\n```\n\n## Fast transformation\n\nThe current method of transforming a number into Montgomery space is pretty slow.\nThere are faster ways.\n\nYou can notice the following relation:\n\n$$\\bar{x} := x \\cdot r \\bmod n = x \\cdot r^2 / r = x * r^2$$\n\nTransforming a number into the space is just a multiplication inside the space of the number with $r^2$.\nTherefore we can precompute $r^2 \\bmod n$ and just perform a multiplication instead of shifting the number 128 times.\n\nIn the following code we initialize `r2` with `-n % n`, which is equivalent to $r - n \\equiv r \\bmod n$, shift it 4 times to get $r \\cdot 2^4 \\bmod n$.\nThis number can be interpreted as $2^4$ in Montgomery space.\nIf we square it $5$ times, we get $(2^4)^{2^5} = (2^4)^{32} = 2^{128} = r$ in Montgomery space, which is exactly $r^2 \\bmod n$.\n\n```\nstruct Montgomery {\n    Montgomery(u128 n) : mod(n), inv(1), r2(-n % n) {\n        for (int i = 0; i < 7; i++)\n            inv *= 2 - n * inv;\n\n        for (int i = 0; i < 4; i++) {\n            r2 <<= 1;\n            if (r2 >= mod)\n                r2 -= mod;\n        }\n        for (int i = 0; i < 5; i++)\n            r2 = mul(r2, r2);\n    }\n\n    u128 init(u128 x) {\n        return mult(x, r2);\n    }\n\n    u128 mod, inv, r2;\n};\n```\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Montgomery Multiplication\n\nMany algorithms in number theory, like [prime testing](primality_tests.md) or [integer factorization](factorization.md), and in cryptography, like RSA, require lots of operations modulo a large number.\nA multiplications like $x y \\bmod{n}$ is quite slow to compute with the typical algorithms, since it requires a division to know how many times $n$ has to be subtracted from the product.\nAnd division is a really expensive operation, especially with big numbers.\n\nThe **Montgomery (modular) multiplication** is a method that allows computing such multiplications faster.\nInstead of dividing the product and subtracting $n$ multiple times, it adds multiples of $n$ to cancel out the lower bits and then just discards the lower bits.\n\n## Montgomery representation\n\nHowever the Montgomery multiplication doesn't come for free.\nThe algorithm works only in the **Montgomery space**.\nAnd we need to transform our numbers into that space, before we can start multiplying.\n\nFor the space we need a positive integer $r \\ge n$ coprime to $n$, i.e. $\\gcd(n, r) = 1$.\nIn practice we always choose $r$ to be $2^m$ for a positive integer $m$, since multiplications, divisions and modulo $r$ operations can then be efficiently implemented using shifts and other bit operations.\n$n$ will be an odd number in pretty much all applications, since it is not hard to factorize an even number.\nSo every power of $2$ will be coprime to $n$.\n\nThe representative $\\bar{x}$ of a number $x$ in the Montgomery space is defined as: \n\n$$\\bar{x} := x \\cdot r \\bmod n$$\n\nNotice, the transformation is actually such a multiplication that we want to optimize.\nSo this is still an expensive operation.\nHowever you only need to transform a number once into the space.\nAs soon as you are in the Montgomery space, you can perform as many operations as you want efficiently.\nAnd at the end you transform the final result back.\nSo as long as you are doing lots of operations modulo $n$, this will be no problem.\n\nInside the Montgomery space you can still perform most operations as usual.\nYou can add two elements ($x \\cdot r + y \\cdot r \\equiv (x + y) \\cdot r \\bmod n$), subtract, check for equality, and even compute the greatest common divisor of a number with $n$ (since $\\gcd(n, r) = 1$).\nAll with the usual algorithms.\n\nHowever this is not the case for multiplication.\n\nWe expect the result to be:\n\n$$\\bar{x} * \\bar{y} = \\overline{x \\cdot y} = (x \\cdot y) \\cdot r \\bmod n.$$\n\nBut the normal multiplication will give us:\n\n$$\\bar{x} \\cdot \\bar{y} = (x \\cdot y) \\cdot r \\cdot r \\bmod n.$$\n\nTherefore the multiplication in the Montgomery space is defined as:\n\n$$\\bar{x} * \\bar{y} := \\bar{x} \\cdot \\bar{y} \\cdot r^{-1} \\bmod n.$$\n\n## Montgomery reduction\n\nThe multiplication of two numbers in the Montgomery space requires an efficient computation of $x \\cdot r^{-1} \\bmod n$.\nThis operation is called the **Montgomery reduction**, and is also known as the algorithm **REDC**.\n\nBecause $\\gcd(n, r) = 1$, we know that there are two numbers $r^{-1}$ and $n^{\\prime}$ with $0 < r^{-1}, n^{\\prime} < n$ with\n\n$$r \\cdot r^{-1} + n \\cdot n^{\\prime} = 1.$$\n\nBoth $r^{-1}$ and $n^{\\prime}$ can be computed using the [Extended Euclidean algorithm](extended-euclid-algorithm.md).\n\nUsing this identity we can write $x \\cdot r^{-1}$ as:\n\n$$\\begin{aligned}\nx \\cdot r^{-1} &= x \\cdot r \\cdot r^{-1} / r = x \\cdot (-n \\cdot n^{\\prime} + 1) / r \\\\\n&= (-x \\cdot n \\cdot n^{\\prime} + x) / r \\equiv (-x \\cdot n \\cdot n^{\\prime} + l \\cdot r \\cdot n + x) / r \\bmod n\\\\\n&\\equiv ((-x \\cdot n^{\\prime} + l \\cdot r) \\cdot n + x) / r \\bmod n\n\\end{aligned}$$\n\nThe equivalences hold for any arbitrary integer $l$.\nThis means, that we can add or subtract an arbitrary multiple of $r$ to $x \\cdot n^{\\prime}$, or in other words, we can compute $q := x \\cdot n^{\\prime}$ modulo $r$.\n\nThis gives us the following algorithm to compute $x \\cdot r^{-1} \\bmod n$:\n\n```text\nfunction reduce(x):\n    q = (x mod r) * n' mod r\n    a = (x - q * n) / r\n    if a < 0:\n        a += n\n    return a\n```\n\nSince $x < n \\cdot n < r \\cdot n$ (even if $x$ is the product of a multiplication) and $q \\cdot n < r \\cdot n$ we know that $-n < (x - q \\cdot n) / r < n$.\nTherefore the final modulo operation is implemented using a single check and one addition.\n\nAs we see, we can perform the Montgomery reduction without any heavy modulo operations.\nIf we choose $r$ as a power of $2$, the modulo operations and divisions in the algorithm can be computed using bitmasking and shifting.\n\nA second application of the Montgomery reduction is to transfer a number back from the Montgomery space into the normal space.\n\n## Fast inverse trick\n\nFor computing the inverse $n^{\\prime} := n^{-1} \\bmod r$ efficiently, we can use the following trick (which is inspired from the Newton's method):\n\n$$a \\cdot x \\equiv 1 \\bmod 2^k \\Longrightarrow a \\cdot x \\cdot (2 - a \\cdot x) \\equiv 1 \\bmod 2^{2k}$$\n\nThis can easily be proven.\nIf we have $a \\cdot x = 1 + m \\cdot 2^k$, then we have:\n\n$$\\begin{aligned}\na \\cdot x \\cdot (2 - a \\cdot x) &= 2 \\cdot a \\cdot x - (a \\cdot x)^2 \\\\\n&= 2 \\cdot (1 + m \\cdot 2^k) - (1 + m \\cdot 2^k)^2 \\\\\n&= 2 + 2 \\cdot m \\cdot 2^k - 1 - 2 \\cdot m \\cdot 2^k - m^2 \\cdot 2^{2k} \\\\\n&= 1 - m^2 \\cdot 2^{2k} \\\\\n&\\equiv 1 \\bmod 2^{2k}.\n\\end{aligned}$$\n\nThis means we can start with $x = 1$ as the inverse of $a$ modulo $2^1$, apply the trick a few times and in each iteration we double the number of correct bits of $x$.\n\n## Implementation\n\nUsing the GCC compiler we can compute $x \\cdot y \\bmod n$ still efficiently, when all three numbers are 64 bit integer, since the compiler supports 128 bit integer with the types `__int128` and `__uint128`.\n\n```cpp\nlong long result = (__int128)x * y % n;\n```\n\nHowever there is no type for 256 bit integer.\nTherefore we will here show an implementation for a 128 bit multiplication.\n\n```cpp\nusing u64 = uint64_t;\nusing u128 = __uint128_t;\nusing i128 = __int128_t;\n\nstruct u256 {\n    u128 high, low;\n\n    static u256 mult(u128 x, u128 y) {\n        u64 a = x >> 64, b = x;\n        u64 c = y >> 64, d = y;\n        // (a*2^64 + b) * (c*2^64 + d) =\n        // (a*c) * 2^128 + (a*d + b*c)*2^64 + (b*d)\n        u128 ac = (u128)a * c;\n        u128 ad = (u128)a * d;\n        u128 bc = (u128)b * c;\n        u128 bd = (u128)b * d;\n        u128 carry = (u128)(u64)ad + (u128)(u64)bc + (bd >> 64u);\n        u128 high = ac + (ad >> 64u) + (bc >> 64u) + (carry >> 64u);\n        u128 low = (ad << 64u) + (bc << 64u) + bd;\n        return {high, low};\n    }\n};\n\nstruct Montgomery {\n    Montgomery(u128 n) : mod(n), inv(1) {\n        for (int i = 0; i < 7; i++)\n            inv *= 2 - n * inv;\n    }\n\n    u128 init(u128 x) {\n        x %= mod;\n        for (int i = 0; i < 128; i++) {\n            x <<= 1;\n            if (x >= mod)\n                x -= mod;\n        }\n        return x;\n    }\n\n    u128 reduce(u256 x) {\n        u128 q = x.low * inv;\n        i128 a = x.high - u256::mult(q, mod).high;\n        if (a < 0)\n            a += mod;\n        return a;\n    }\n\n    u128 mult(u128 a, u128 b) {\n        return reduce(u256::mult(a, b));\n    }\n\n    u128 mod, inv;\n};\n```\n\n## Fast transformation\n\nThe current method of transforming a number into Montgomery space is pretty slow.\nThere are faster ways.\n\nYou can notice the following relation:\n\n$$\\bar{x} := x \\cdot r \\bmod n = x \\cdot r^2 / r = x * r^2$$\n\nTransforming a number into the space is just a multiplication inside the space of the number with $r^2$.\nTherefore we can precompute $r^2 \\bmod n$ and just perform a multiplication instead of shifting the number 128 times.\n\nIn the following code we initialize `r2` with `-n % n`, which is equivalent to $r - n \\equiv r \\bmod n$, shift it 4 times to get $r \\cdot 2^4 \\bmod n$.\nThis number can be interpreted as $2^4$ in Montgomery space.\nIf we square it $5$ times, we get $(2^4)^{2^5} = (2^4)^{32} = 2^{128} = r$ in Montgomery space, which is exactly $r^2 \\bmod n$.\n\n```\nstruct Montgomery {\n    Montgomery(u128 n) : mod(n), inv(1), r2(-n % n) {\n        for (int i = 0; i < 7; i++)\n            inv *= 2 - n * inv;\n\n        for (int i = 0; i < 4; i++) {\n            r2 <<= 1;\n            if (r2 >= mod)\n                r2 -= mod;\n        }\n        for (int i = 0; i < 5; i++)\n            r2 = mul(r2, r2);\n    }\n\n    u128 init(u128 x) {\n        return mult(x, r2);\n    }\n\n    u128 mod, inv, r2;\n};\n```\n", "problem_ids": [], "title": "Montgomery Multiplication"}, {"article": "---\ntags:\n    - Original\n---\n\n# Primality tests\n\nThis article describes multiple algorithms to determine if a number is prime or not.\n\n## Trial division\n\nBy definition a prime number doesn't have any divisors other than $1$ and itself.\nA composite number has at least one additional divisor, let's call it $d$.\nNaturally $\\frac{n}{d}$ is also a divisor of $n$.\nIt's easy to see, that either $d \\le \\sqrt{n}$ or $\\frac{n}{d} \\le \\sqrt{n}$, therefore one of the divisors $d$ and $\\frac{n}{d}$ is $\\le \\sqrt{n}$.\nWe can use this information to check for primality.\n\nWe try to find a non-trivial divisor, by checking if any of the numbers between $2$ and $\\sqrt{n}$ is a divisor of $n$.\nIf it is a divisor, than $n$ is definitely not prime, otherwise it is.\n\n```cpp\nbool isPrime(int x) {\n    for (int d = 2; d * d <= x; d++) {\n        if (x % d == 0)\n            return false;\n    }\n    return x >= 2;\n}\n```\n\nThis is the simplest form of a prime check.\nYou can optimize this function quite a bit, for instance by only checking all odd numbers in the loop, since the only even prime number is 2.\nMultiple such optimizations are described in the article about [integer factorization](factorization.md).\n\n## Fermat primality test\n\nThis is a probabilistic test.\n\nFermat's little theorem (see also [Euler's totient function](phi-function.md)) states, that for a prime number $p$ and a coprime integer $a$ the following equation holds:\n\n$$a^{p-1} \\equiv 1 \\bmod p$$\n\nIn general this theorem doesn't hold for composite numbers.\n\nThis can be used to create a primality test.\nWe pick an integer $2 \\le a \\le p - 2$, and check if the equation holds or not.\nIf it doesn't hold, e.g. $a^{p-1} \\not\\equiv 1 \\bmod p$, we know that $p$ cannot be a prime number.\nIn this case we call the base $a$ a *Fermat witness* for the compositeness of $p$.\n\nHowever it is also possible, that the equation holds for a composite number.\nSo if the equation holds, we don't have a proof for primality.\nWe only can say that $p$ is *probably prime*.\nIf it turns out that the number is actually composite, we call the base $a$ a *Fermat liar*.\n\nBy running the test for all possible bases $a$, we can actually prove that a number is prime.\nHowever this is not done in practice, since this is a lot more effort that just doing *trial division*.\nInstead the test will be repeated multiple times with random choices for $a$.\nIf we find no witness for the compositeness, it is very likely that the number is in fact prime.\n\n```cpp\nbool probablyPrimeFermat(int n, int iter=5) {\n    if (n < 4)\n        return n == 2 || n == 3;\n\n    for (int i = 0; i < iter; i++) {\n        int a = 2 + rand() % (n - 3);\n        if (binpower(a, n - 1, n) != 1)\n            return false;\n    }\n    return true;\n}\n```\n\nWe use [Binary Exponentiation](binary-exp.md) to efficiently compute the power $a^{p-1}$.\n\nThere is one bad news though:\nthere exist some composite numbers where $a^{n-1} \\equiv 1 \\bmod n$ holds for all $a$ coprime to $n$, for instance for the number $561 = 3 \\cdot 11 \\cdot 17$.\nSuch numbers are called *Carmichael numbers*.\nThe Fermat primality test can identify these numbers only, if we have immense luck and choose a base $a$ with $\\gcd(a, n) \\ne 1$.\n\nThe Fermat test is still be used in practice, as it is very fast and Carmichael numbers are very rare.\nE.g. there only exist 646 such numbers below $10^9$.\n\n## Miller-Rabin primality test\n\nThe Miller-Rabin test extends the ideas from the Fermat test.\n\nFor an odd number $n$, $n-1$ is even and we can factor out all powers of 2.\nWe can write:\n\n$$n - 1 = 2^s \\cdot d,~\\text{with}~d~\\text{odd}.$$\n\nThis allows us to factorize the equation of Fermat's little theorem:\n\n$$\\begin{array}{rl}\na^{n-1} \\equiv 1 \\bmod n &\\Longleftrightarrow a^{2^s d} - 1 \\equiv 0 \\bmod n \\\\\\\\\n&\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-1} d} - 1) \\equiv 0 \\bmod n \\\\\\\\\n&\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) (a^{2^{s-2} d} - 1) \\equiv 0 \\bmod n \\\\\\\\\n&\\quad\\vdots \\\\\\\\\n&\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) \\cdots (a^{d} + 1) (a^{d} - 1) \\equiv 0 \\bmod n \\\\\\\\\n\\end{array}$$\n\nIf $n$ is prime, then $n$ has to divide one of these factors.\nAnd in the Miller-Rabin primality test we check exactly that statement, which is a more stricter version of the statement of the Fermat test.\nFor a base $2 \\le a \\le n-2$ we check if either\n\n$$a^d \\equiv 1 \\bmod n$$\n\nholds or\n\n$$a^{2^r d} \\equiv -1 \\bmod n$$\n\nholds for some $0 \\le r \\le s - 1$.\n\nIf we found a base $a$ which doesn't satisfy any of the above equalities, than we found a *witness* for the compositeness of $n$.\nIn this case we have proven that $n$ is not a prime number.\n\nSimilar to the Fermat test, it is also possible that the set of equations is satisfied for a composite number.\nIn that case the base $a$ is called a *strong liar*.\nIf a base $a$ satisfies the equations (one of them), $n$ is only *strong probable prime*.\nHowever, there are no numbers like the Carmichael numbers, where all non-trivial bases lie.\nIn fact it is possible to show, that at most $\\frac{1}{4}$ of the bases can be strong liars.\nIf $n$ is composite, we have a probability of $\\ge 75\\%$ that a random base will tell us that it is composite.\nBy doing multiple iterations, choosing different random bases, we can tell with very high probability if the number is truly prime or if it is composite.\n\nHere is an implementation for 64 bit integer.\n\n```cpp\nusing u64 = uint64_t;\nusing u128 = __uint128_t;\n\nu64 binpower(u64 base, u64 e, u64 mod) {\n    u64 result = 1;\n    base %= mod;\n    while (e) {\n        if (e & 1)\n            result = (u128)result * base % mod;\n        base = (u128)base * base % mod;\n        e >>= 1;\n    }\n    return result;\n}\n\nbool check_composite(u64 n, u64 a, u64 d, int s) {\n    u64 x = binpower(a, d, n);\n    if (x == 1 || x == n - 1)\n        return false;\n    for (int r = 1; r < s; r++) {\n        x = (u128)x * x % n;\n        if (x == n - 1)\n            return false;\n    }\n    return true;\n};\n\nbool MillerRabin(u64 n, int iter=5) { // returns true if n is probably prime, else returns false.\n    if (n < 4)\n        return n == 2 || n == 3;\n\n    int s = 0;\n    u64 d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n\n    for (int i = 0; i < iter; i++) {\n        int a = 2 + rand() % (n - 3);\n        if (check_composite(n, a, d, s))\n            return false;\n    }\n    return true;\n}\n```\n\nBefore the Miller-Rabin test you can test additionally if one of the first few prime numbers is a divisor.\nThis can speed up the test by a lot, since most composite numbers have very small prime divisors.\nE.g. $88\\%$ of all numbers have a prime factors smaller than $100$.\n\n### Deterministic version\n\nMiller showed that it is possible to make the algorithm deterministic by only checking all bases $\\le O((\\ln n)^2)$.\nBach later gave a concrete bound, it is only necessary to test all bases $a \\le 2 \\ln(n)^2$.\n\nThis is still a pretty large number of bases.\nSo people have invested quite a lot of computation power into finding lower bounds.\nIt turns out, for testing a 32 bit integer it is only necessary to check the first 4 prime bases: 2, 3, 5 and 7.\nThe smallest composite number that fails this test is $3,215,031,751 = 151 \\cdot 751 \\cdot 28351$.\nAnd for testing 64 bit integer it is enough to check the first 12 prime bases: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37.\n\nThis results in the following deterministic implementation:\n\n```cpp\nbool MillerRabin(u64 n) { // returns true if n is prime, else returns false.\n    if (n < 2)\n        return false;\n\n    int r = 0;\n    u64 d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        r++;\n    }\n\n    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\n        if (n == a)\n            return true;\n        if (check_composite(n, a, d, r))\n            return false;\n    }\n    return true;\n}\n```\n\nIt's also possible to do the check with only 7 bases: 2, 325, 9375, 28178, 450775, 9780504 and 1795265022.\nHowever, since these numbers (except 2) are not prime, you need to check additionally if the number you are checking is equal to any prime divisor of those bases: 2, 3, 5, 13, 19, 73, 193, 407521, 299210837.\n\n", "full_article": "---\ntags:\n    - Original\n---\n\n# Primality tests\n\nThis article describes multiple algorithms to determine if a number is prime or not.\n\n## Trial division\n\nBy definition a prime number doesn't have any divisors other than $1$ and itself.\nA composite number has at least one additional divisor, let's call it $d$.\nNaturally $\\frac{n}{d}$ is also a divisor of $n$.\nIt's easy to see, that either $d \\le \\sqrt{n}$ or $\\frac{n}{d} \\le \\sqrt{n}$, therefore one of the divisors $d$ and $\\frac{n}{d}$ is $\\le \\sqrt{n}$.\nWe can use this information to check for primality.\n\nWe try to find a non-trivial divisor, by checking if any of the numbers between $2$ and $\\sqrt{n}$ is a divisor of $n$.\nIf it is a divisor, than $n$ is definitely not prime, otherwise it is.\n\n```cpp\nbool isPrime(int x) {\n    for (int d = 2; d * d <= x; d++) {\n        if (x % d == 0)\n            return false;\n    }\n    return x >= 2;\n}\n```\n\nThis is the simplest form of a prime check.\nYou can optimize this function quite a bit, for instance by only checking all odd numbers in the loop, since the only even prime number is 2.\nMultiple such optimizations are described in the article about [integer factorization](factorization.md).\n\n## Fermat primality test\n\nThis is a probabilistic test.\n\nFermat's little theorem (see also [Euler's totient function](phi-function.md)) states, that for a prime number $p$ and a coprime integer $a$ the following equation holds:\n\n$$a^{p-1} \\equiv 1 \\bmod p$$\n\nIn general this theorem doesn't hold for composite numbers.\n\nThis can be used to create a primality test.\nWe pick an integer $2 \\le a \\le p - 2$, and check if the equation holds or not.\nIf it doesn't hold, e.g. $a^{p-1} \\not\\equiv 1 \\bmod p$, we know that $p$ cannot be a prime number.\nIn this case we call the base $a$ a *Fermat witness* for the compositeness of $p$.\n\nHowever it is also possible, that the equation holds for a composite number.\nSo if the equation holds, we don't have a proof for primality.\nWe only can say that $p$ is *probably prime*.\nIf it turns out that the number is actually composite, we call the base $a$ a *Fermat liar*.\n\nBy running the test for all possible bases $a$, we can actually prove that a number is prime.\nHowever this is not done in practice, since this is a lot more effort that just doing *trial division*.\nInstead the test will be repeated multiple times with random choices for $a$.\nIf we find no witness for the compositeness, it is very likely that the number is in fact prime.\n\n```cpp\nbool probablyPrimeFermat(int n, int iter=5) {\n    if (n < 4)\n        return n == 2 || n == 3;\n\n    for (int i = 0; i < iter; i++) {\n        int a = 2 + rand() % (n - 3);\n        if (binpower(a, n - 1, n) != 1)\n            return false;\n    }\n    return true;\n}\n```\n\nWe use [Binary Exponentiation](binary-exp.md) to efficiently compute the power $a^{p-1}$.\n\nThere is one bad news though:\nthere exist some composite numbers where $a^{n-1} \\equiv 1 \\bmod n$ holds for all $a$ coprime to $n$, for instance for the number $561 = 3 \\cdot 11 \\cdot 17$.\nSuch numbers are called *Carmichael numbers*.\nThe Fermat primality test can identify these numbers only, if we have immense luck and choose a base $a$ with $\\gcd(a, n) \\ne 1$.\n\nThe Fermat test is still be used in practice, as it is very fast and Carmichael numbers are very rare.\nE.g. there only exist 646 such numbers below $10^9$.\n\n## Miller-Rabin primality test\n\nThe Miller-Rabin test extends the ideas from the Fermat test.\n\nFor an odd number $n$, $n-1$ is even and we can factor out all powers of 2.\nWe can write:\n\n$$n - 1 = 2^s \\cdot d,~\\text{with}~d~\\text{odd}.$$\n\nThis allows us to factorize the equation of Fermat's little theorem:\n\n$$\\begin{array}{rl}\na^{n-1} \\equiv 1 \\bmod n &\\Longleftrightarrow a^{2^s d} - 1 \\equiv 0 \\bmod n \\\\\\\\\n&\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-1} d} - 1) \\equiv 0 \\bmod n \\\\\\\\\n&\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) (a^{2^{s-2} d} - 1) \\equiv 0 \\bmod n \\\\\\\\\n&\\quad\\vdots \\\\\\\\\n&\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) \\cdots (a^{d} + 1) (a^{d} - 1) \\equiv 0 \\bmod n \\\\\\\\\n\\end{array}$$\n\nIf $n$ is prime, then $n$ has to divide one of these factors.\nAnd in the Miller-Rabin primality test we check exactly that statement, which is a more stricter version of the statement of the Fermat test.\nFor a base $2 \\le a \\le n-2$ we check if either\n\n$$a^d \\equiv 1 \\bmod n$$\n\nholds or\n\n$$a^{2^r d} \\equiv -1 \\bmod n$$\n\nholds for some $0 \\le r \\le s - 1$.\n\nIf we found a base $a$ which doesn't satisfy any of the above equalities, than we found a *witness* for the compositeness of $n$.\nIn this case we have proven that $n$ is not a prime number.\n\nSimilar to the Fermat test, it is also possible that the set of equations is satisfied for a composite number.\nIn that case the base $a$ is called a *strong liar*.\nIf a base $a$ satisfies the equations (one of them), $n$ is only *strong probable prime*.\nHowever, there are no numbers like the Carmichael numbers, where all non-trivial bases lie.\nIn fact it is possible to show, that at most $\\frac{1}{4}$ of the bases can be strong liars.\nIf $n$ is composite, we have a probability of $\\ge 75\\%$ that a random base will tell us that it is composite.\nBy doing multiple iterations, choosing different random bases, we can tell with very high probability if the number is truly prime or if it is composite.\n\nHere is an implementation for 64 bit integer.\n\n```cpp\nusing u64 = uint64_t;\nusing u128 = __uint128_t;\n\nu64 binpower(u64 base, u64 e, u64 mod) {\n    u64 result = 1;\n    base %= mod;\n    while (e) {\n        if (e & 1)\n            result = (u128)result * base % mod;\n        base = (u128)base * base % mod;\n        e >>= 1;\n    }\n    return result;\n}\n\nbool check_composite(u64 n, u64 a, u64 d, int s) {\n    u64 x = binpower(a, d, n);\n    if (x == 1 || x == n - 1)\n        return false;\n    for (int r = 1; r < s; r++) {\n        x = (u128)x * x % n;\n        if (x == n - 1)\n            return false;\n    }\n    return true;\n};\n\nbool MillerRabin(u64 n, int iter=5) { // returns true if n is probably prime, else returns false.\n    if (n < 4)\n        return n == 2 || n == 3;\n\n    int s = 0;\n    u64 d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n\n    for (int i = 0; i < iter; i++) {\n        int a = 2 + rand() % (n - 3);\n        if (check_composite(n, a, d, s))\n            return false;\n    }\n    return true;\n}\n```\n\nBefore the Miller-Rabin test you can test additionally if one of the first few prime numbers is a divisor.\nThis can speed up the test by a lot, since most composite numbers have very small prime divisors.\nE.g. $88\\%$ of all numbers have a prime factors smaller than $100$.\n\n### Deterministic version\n\nMiller showed that it is possible to make the algorithm deterministic by only checking all bases $\\le O((\\ln n)^2)$.\nBach later gave a concrete bound, it is only necessary to test all bases $a \\le 2 \\ln(n)^2$.\n\nThis is still a pretty large number of bases.\nSo people have invested quite a lot of computation power into finding lower bounds.\nIt turns out, for testing a 32 bit integer it is only necessary to check the first 4 prime bases: 2, 3, 5 and 7.\nThe smallest composite number that fails this test is $3,215,031,751 = 151 \\cdot 751 \\cdot 28351$.\nAnd for testing 64 bit integer it is enough to check the first 12 prime bases: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37.\n\nThis results in the following deterministic implementation:\n\n```cpp\nbool MillerRabin(u64 n) { // returns true if n is prime, else returns false.\n    if (n < 2)\n        return false;\n\n    int r = 0;\n    u64 d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        r++;\n    }\n\n    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\n        if (n == a)\n            return true;\n        if (check_composite(n, a, d, r))\n            return false;\n    }\n    return true;\n}\n```\n\nIt's also possible to do the check with only 7 bases: 2, 325, 9375, 28178, 450775, 9780504 and 1795265022.\nHowever, since these numbers (except 2) are not prime, you need to check additionally if the number you are checking is equal to any prime divisor of those bases: 2, 3, 5, 13, 19, 73, 193, 407521, 299210837.\n\n## Practice Problems\n\n- [SPOJ - Prime or Not](https://www.spoj.com/problems/PON/)", "problem_ids": [], "title": "Primality tests"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: euclid_algorithm\n---\n\n# Euclidean algorithm for computing the greatest common divisor\n\nGiven two non-negative integers $a$ and $b$, we have to find their **GCD** (greatest common divisor), i.e. the largest number which is a divisor of both $a$ and $b$.\nIt's commonly denoted by $\\gcd(a, b)$. Mathematically it is defined as:\n\n$$\\gcd(a, b) = \\max \\{k > 0 : (k \\mid a) \\text{ and } (k \\mid b) \\}$$\n\n(here the symbol \"$\\mid$\" denotes divisibility, i.e. \"$k \\mid a$\" means \"$k$ divides $a$\")\n\nWhen one of the numbers is zero, while the other is non-zero, their greatest common divisor, by definition, is the second number. When both numbers are zero, their greatest common divisor is undefined (it can be any arbitrarily large number), but it is convenient to define it as zero as well to preserve the associativity of $\\gcd$. Which gives us a simple rule: if one of the numbers is zero, the greatest common divisor is the other number.\n\nThe Euclidean algorithm, discussed below, allows to find the greatest common divisor of two numbers $a$ and $b$ in $O(\\log \\min(a, b))$.\n\nThe algorithm was first described in Euclid's \"Elements\" (circa 300 BC), but it is possible that the algorithm has even earlier origins.\n\n## Algorithm\n\nOriginally, the Euclidean algorithm was formulated as follows: subtract the smaller number from the larger one until one of the numbers is zero. Indeed, if $g$ divides $a$ and $b$, it also divides $a-b$. On the other hand, if $g$ divides $a-b$ and $b$, then it also divides $a = b + (a-b)$, which means that the sets of the common divisors of $\\{a, b\\}$ and $\\{b,a-b\\}$ coincide.\n\nNote that $a$ remains the larger number until $b$ is subtracted from it at least $\\left\\lfloor\\frac{a}{b}\\right\\rfloor$ times. Therefore, to speed things up, $a-b$ is substituted with $a-\\left\\lfloor\\frac{a}{b}\\right\\rfloor b = a \\bmod b$. Then the algorithm is formulated in an extremely simple way:\n\n$$\\gcd(a, b) = \\begin{cases}a,&\\text{if }b = 0 \\\\ \\gcd(b, a \\bmod b),&\\text{otherwise.}\\end{cases}$$\n\n## Implementation\n\n```cpp\nint gcd (int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd (b, a % b);\n}\n```\n\nUsing the ternary operator in C++, we can write it as a one-liner.\n\n```cpp\nint gcd (int a, int b) {\n    return b ? gcd (b, a % b) : a;\n}\n```\n\nAnd finally, here is a non-recursive implementation:\n\n```cpp\nint gcd (int a, int b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n```\n\nNote that since C++17, `gcd` is implemented as a [standard function](https://en.cppreference.com/w/cpp/numeric/gcd) in C++.\n\n## Time Complexity\n\nThe running time of the algorithm is estimated by Lam\u00e9's theorem, which establishes a surprising connection between the Euclidean algorithm and the Fibonacci sequence:\n\nIf $a > b \\geq 1$ and $b < F_n$ for some $n$, the Euclidean algorithm performs at most $n-2$ recursive calls.\n\nMoreover, it is possible to show that the upper bound of this theorem is optimal. When $a = F_n$ and $b = F_{n-1}$, $gcd(a, b)$ will perform exactly $n-2$ recursive calls. In other words, consecutive Fibonacci numbers are the worst case input for Euclid's algorithm.\n\nGiven that Fibonacci numbers grow exponentially, we get that the Euclidean algorithm works in $O(\\log \\min(a, b))$.\n\nAnother way to estimate the complexity is to notice that $a \\bmod b$ for the case $a \\geq b$ is at least $2$ times smaller than $a$, so the larger number is reduced at least in half on each iteration of the algorithm.\n\n## Least common multiple\n\nCalculating the least common multiple (commonly denoted **LCM**) can be reduced to calculating the GCD with the following simple formula:\n\n$$\\text{lcm}(a, b) = \\frac{a \\cdot b}{\\gcd(a, b)}$$\n\nThus, LCM can be calculated using the Euclidean algorithm with the same time complexity:\n\nA possible implementation, that cleverly avoids integer overflows by first dividing $a$ with the GCD, is given here:\n\n```cpp\nint lcm (int a, int b) {\n    return a / gcd(a, b) * b;\n}\n```\n\n## Binary GCD\n\nThe Binary GCD algorithm is an optimization to the normal Euclidean algorithm.\n\nThe slow part of the normal algorithm are the modulo operations. Modulo operations, although we see them as $O(1)$, are a lot slower than simpler operations like addition, subtraction or bitwise operations.\nSo it would be better to avoid those.\n\nIt turns out, that you can design a fast GCD algorithm that avoids modulo operations.\nIt's based on a few properties:\n\n  - If both numbers are even, then we can factor out a two of both and compute the GCD of the remaining numbers: $\\gcd(2a, 2b) = 2 \\gcd(a, b)$.\n  - If one of the numbers is even and the other one is odd, then we can remove the factor 2 from the even one: $\\gcd(2a, b) = \\gcd(a, b)$ if $b$ is odd.\n  - If both numbers are odd, then subtracting one number of the other one will not change the GCD: $\\gcd(a, b) = \\gcd(b, a-b)$\n\nUsing only these properties, and some fast bitwise functions from GCC, we can implement a fast version:\n\n```cpp\nint gcd(int a, int b) {\n    if (!a || !b)\n        return a | b;\n    unsigned shift = __builtin_ctz(a | b);\n    a >>= __builtin_ctz(a);\n    do {\n        b >>= __builtin_ctz(b);\n        if (a > b)\n            swap(a, b);\n        b -= a;\n    } while (b);\n    return a << shift;\n}\n```\n\nNotice, that such an optimization is usually not necessary, and most programming languages already have a GCD function in their standard libraries.\nE.g. C++17 has such a function `std::gcd` in the `numeric` header.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: euclid_algorithm\n---\n\n# Euclidean algorithm for computing the greatest common divisor\n\nGiven two non-negative integers $a$ and $b$, we have to find their **GCD** (greatest common divisor), i.e. the largest number which is a divisor of both $a$ and $b$.\nIt's commonly denoted by $\\gcd(a, b)$. Mathematically it is defined as:\n\n$$\\gcd(a, b) = \\max \\{k > 0 : (k \\mid a) \\text{ and } (k \\mid b) \\}$$\n\n(here the symbol \"$\\mid$\" denotes divisibility, i.e. \"$k \\mid a$\" means \"$k$ divides $a$\")\n\nWhen one of the numbers is zero, while the other is non-zero, their greatest common divisor, by definition, is the second number. When both numbers are zero, their greatest common divisor is undefined (it can be any arbitrarily large number), but it is convenient to define it as zero as well to preserve the associativity of $\\gcd$. Which gives us a simple rule: if one of the numbers is zero, the greatest common divisor is the other number.\n\nThe Euclidean algorithm, discussed below, allows to find the greatest common divisor of two numbers $a$ and $b$ in $O(\\log \\min(a, b))$.\n\nThe algorithm was first described in Euclid's \"Elements\" (circa 300 BC), but it is possible that the algorithm has even earlier origins.\n\n## Algorithm\n\nOriginally, the Euclidean algorithm was formulated as follows: subtract the smaller number from the larger one until one of the numbers is zero. Indeed, if $g$ divides $a$ and $b$, it also divides $a-b$. On the other hand, if $g$ divides $a-b$ and $b$, then it also divides $a = b + (a-b)$, which means that the sets of the common divisors of $\\{a, b\\}$ and $\\{b,a-b\\}$ coincide.\n\nNote that $a$ remains the larger number until $b$ is subtracted from it at least $\\left\\lfloor\\frac{a}{b}\\right\\rfloor$ times. Therefore, to speed things up, $a-b$ is substituted with $a-\\left\\lfloor\\frac{a}{b}\\right\\rfloor b = a \\bmod b$. Then the algorithm is formulated in an extremely simple way:\n\n$$\\gcd(a, b) = \\begin{cases}a,&\\text{if }b = 0 \\\\ \\gcd(b, a \\bmod b),&\\text{otherwise.}\\end{cases}$$\n\n## Implementation\n\n```cpp\nint gcd (int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd (b, a % b);\n}\n```\n\nUsing the ternary operator in C++, we can write it as a one-liner.\n\n```cpp\nint gcd (int a, int b) {\n    return b ? gcd (b, a % b) : a;\n}\n```\n\nAnd finally, here is a non-recursive implementation:\n\n```cpp\nint gcd (int a, int b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n```\n\nNote that since C++17, `gcd` is implemented as a [standard function](https://en.cppreference.com/w/cpp/numeric/gcd) in C++.\n\n## Time Complexity\n\nThe running time of the algorithm is estimated by Lam\u00e9's theorem, which establishes a surprising connection between the Euclidean algorithm and the Fibonacci sequence:\n\nIf $a > b \\geq 1$ and $b < F_n$ for some $n$, the Euclidean algorithm performs at most $n-2$ recursive calls.\n\nMoreover, it is possible to show that the upper bound of this theorem is optimal. When $a = F_n$ and $b = F_{n-1}$, $gcd(a, b)$ will perform exactly $n-2$ recursive calls. In other words, consecutive Fibonacci numbers are the worst case input for Euclid's algorithm.\n\nGiven that Fibonacci numbers grow exponentially, we get that the Euclidean algorithm works in $O(\\log \\min(a, b))$.\n\nAnother way to estimate the complexity is to notice that $a \\bmod b$ for the case $a \\geq b$ is at least $2$ times smaller than $a$, so the larger number is reduced at least in half on each iteration of the algorithm.\n\n## Least common multiple\n\nCalculating the least common multiple (commonly denoted **LCM**) can be reduced to calculating the GCD with the following simple formula:\n\n$$\\text{lcm}(a, b) = \\frac{a \\cdot b}{\\gcd(a, b)}$$\n\nThus, LCM can be calculated using the Euclidean algorithm with the same time complexity:\n\nA possible implementation, that cleverly avoids integer overflows by first dividing $a$ with the GCD, is given here:\n\n```cpp\nint lcm (int a, int b) {\n    return a / gcd(a, b) * b;\n}\n```\n\n## Binary GCD\n\nThe Binary GCD algorithm is an optimization to the normal Euclidean algorithm.\n\nThe slow part of the normal algorithm are the modulo operations. Modulo operations, although we see them as $O(1)$, are a lot slower than simpler operations like addition, subtraction or bitwise operations.\nSo it would be better to avoid those.\n\nIt turns out, that you can design a fast GCD algorithm that avoids modulo operations.\nIt's based on a few properties:\n\n  - If both numbers are even, then we can factor out a two of both and compute the GCD of the remaining numbers: $\\gcd(2a, 2b) = 2 \\gcd(a, b)$.\n  - If one of the numbers is even and the other one is odd, then we can remove the factor 2 from the even one: $\\gcd(2a, b) = \\gcd(a, b)$ if $b$ is odd.\n  - If both numbers are odd, then subtracting one number of the other one will not change the GCD: $\\gcd(a, b) = \\gcd(b, a-b)$\n\nUsing only these properties, and some fast bitwise functions from GCC, we can implement a fast version:\n\n```cpp\nint gcd(int a, int b) {\n    if (!a || !b)\n        return a | b;\n    unsigned shift = __builtin_ctz(a | b);\n    a >>= __builtin_ctz(a);\n    do {\n        b >>= __builtin_ctz(b);\n        if (a > b)\n            swap(a, b);\n        b -= a;\n    } while (b);\n    return a << shift;\n}\n```\n\nNotice, that such an optimization is usually not necessary, and most programming languages already have a GCD function in their standard libraries.\nE.g. C++17 has such a function `std::gcd` in the `numeric` header.\n\n## Practice Problems\n\n- [Codechef - GCD and LCM](https://www.codechef.com/problems/FLOW016)\n", "problem_ids": [], "title": "Euclidean algorithm for computing the greatest common divisor"}, {"article": "---\ntitle: K-th order statistic in O(N)\ntags:\n  - Translated\ne_maxx_link: kth_order_statistics\n---\n# $K$th order statistic in $O(N)$\n\nGiven an array $A$ of size $N$ and a number $K$. The problem is to find $K$-th largest number in the array, i.e., $K$-th order statistic.\n\nThe basic idea - to use the idea of quick sort algorithm. Actually, the algorithm is simple, it is more difficult to prove that it runs in an average of $O(N)$, in contrast to the quick sort.\n\n## Implementation (not recursive)\n\n```cpp\ntemplate <class T>\nT order_statistics (std::vector<T> a, unsigned n, unsigned k)\n{\n    using std::swap;\n    for (unsigned l=1, r=n; ; )\n    {\n        if (r <= l+1)\n        {\n            // the current part size is either 1 or 2, so it is easy to find the answer\n            if (r == l+1 && a[r] < a[l])\n                swap (a[l], a[r]);\n            return a[k];\n        }\n\n        // ordering a[l], a[l+1], a[r]\n        unsigned mid = (l + r) >> 1;\n        swap (a[mid], a[l+1]);\n        if (a[l] > a[r])\n            swap (a[l], a[r]);\n        if (a[l+1] > a[r])\n            swap (a[l+1], a[r]);\n        if (a[l] > a[l+1])\n            swap (a[l], a[l+1]);\n\n        // performing division\n        // barrier is a[l + 1], i.e. median among a[l], a[l + 1], a[r]\n        unsigned\n            i = l+1,\n            j = r;\n        const T\n            cur = a[l+1];\n        for (;;)\n        {\n            while (a[++i] < cur) ;\n            while (a[--j] > cur) ;\n            if (i > j)\n                break;\n            swap (a[i], a[j]);\n        }\n\n        // inserting the barrier\n        a[l+1] = a[j];\n        a[j] = cur;\n        \n        // we continue to work in that part, which must contain the required element\n        if (j >= k)\n            r = j-1;\n        if (j <= k)\n            l = i;\n    }\n}\n```\n\n## Notes\n* The randomized algorithm above is named [quickselect](https://en.wikipedia.org/wiki/Quickselect). You should do random shuffle on $A$ before calling it or use a random element as a barrier for it to run properly. There are also deterministic algorithms that solve the specified problem in linear time, such as [median of medians](https://en.wikipedia.org/wiki/Median_of_medians).\n* A deterministic linear solution is implemented in C++ standard library as [std::nth_element](https://en.cppreference.com/w/cpp/algorithm/nth_element).\n* Finding $K$ smallest elements can be reduced to finding $K$-th element with a linear overhead, as they're exactly the elements that are smaller than $K$-th.\n\n", "full_article": "---\ntitle: K-th order statistic in O(N)\ntags:\n  - Translated\ne_maxx_link: kth_order_statistics\n---\n# $K$th order statistic in $O(N)$\n\nGiven an array $A$ of size $N$ and a number $K$. The problem is to find $K$-th largest number in the array, i.e., $K$-th order statistic.\n\nThe basic idea - to use the idea of quick sort algorithm. Actually, the algorithm is simple, it is more difficult to prove that it runs in an average of $O(N)$, in contrast to the quick sort.\n\n## Implementation (not recursive)\n\n```cpp\ntemplate <class T>\nT order_statistics (std::vector<T> a, unsigned n, unsigned k)\n{\n    using std::swap;\n    for (unsigned l=1, r=n; ; )\n    {\n        if (r <= l+1)\n        {\n            // the current part size is either 1 or 2, so it is easy to find the answer\n            if (r == l+1 && a[r] < a[l])\n                swap (a[l], a[r]);\n            return a[k];\n        }\n\n        // ordering a[l], a[l+1], a[r]\n        unsigned mid = (l + r) >> 1;\n        swap (a[mid], a[l+1]);\n        if (a[l] > a[r])\n            swap (a[l], a[r]);\n        if (a[l+1] > a[r])\n            swap (a[l+1], a[r]);\n        if (a[l] > a[l+1])\n            swap (a[l], a[l+1]);\n\n        // performing division\n        // barrier is a[l + 1], i.e. median among a[l], a[l + 1], a[r]\n        unsigned\n            i = l+1,\n            j = r;\n        const T\n            cur = a[l+1];\n        for (;;)\n        {\n            while (a[++i] < cur) ;\n            while (a[--j] > cur) ;\n            if (i > j)\n                break;\n            swap (a[i], a[j]);\n        }\n\n        // inserting the barrier\n        a[l+1] = a[j];\n        a[j] = cur;\n        \n        // we continue to work in that part, which must contain the required element\n        if (j >= k)\n            r = j-1;\n        if (j <= k)\n            l = i;\n    }\n}\n```\n\n## Notes\n* The randomized algorithm above is named [quickselect](https://en.wikipedia.org/wiki/Quickselect). You should do random shuffle on $A$ before calling it or use a random element as a barrier for it to run properly. There are also deterministic algorithms that solve the specified problem in linear time, such as [median of medians](https://en.wikipedia.org/wiki/Median_of_medians).\n* A deterministic linear solution is implemented in C++ standard library as [std::nth_element](https://en.cppreference.com/w/cpp/algorithm/nth_element).\n* Finding $K$ smallest elements can be reduced to finding $K$-th element with a linear overhead, as they're exactly the elements that are smaller than $K$-th.\n\n## Practice Problems\n\n- [CODECHEF: Median](https://www.codechef.com/problems/CD1IT1)\n", "problem_ids": [], "title": "$K$th order statistic in $O(N)$"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: longest_increasing_subseq_log\n---\n\n# Longest increasing subsequence\n\nWe are given an array with $n$ numbers: $a[0 \\dots n-1]$.\nThe task is to find the longest, strictly increasing, subsequence in $a$.\n\nFormally we look for the longest sequence of indices $i_1, \\dots i_k$ such that\n\n$$i_1 < i_2 < \\dots < i_k,\\quad\na[i_1] < a[i_2] < \\dots < a[i_k]$$\n\nIn this article we discuss multiple algorithms for solving this task.\nAlso we will discuss some other problems, that can be reduced to this problem.\n\n## Solution in $O(n^2)$ with dynamic programming {data-toc-label=\"Solution in O(n^2) with dynamic programming\"}\n\nDynamic programming is a very general technique that allows to solve a huge class of problems.\nHere we apply the technique for our specific task.\n\nFirst we will search only for the **length** of the longest increasing subsequence, and only later learn how to restore the subsequence itself.\n\n### Finding the length\n\nTo accomplish this task, we define an array $d[0 \\dots n-1]$, where $d[i]$ is the length of the longest increasing subsequence that ends in the element at index $i$.\n\n!!! example\n\n    $$\\begin{array}{ll}\n    a &= \\{8, 3, 4, 6, 5, 2, 0, 7, 9, 1\\} \\\\\n    d &= \\{1, 1, 2, 3, 3, 1, 1, 4, 5, 2\\}\n    \\end{array}$$\n\n    The longest increasing subsequence that ends at index 4 is $\\{3, 4, 5\\}$ with a length of 3, the longest ending at index 8 is either $\\{3, 4, 5, 7, 9\\}$ or $\\{3, 4, 6, 7, 9\\}$, both having length 5, and the longest ending at index 9 is $\\{0, 1\\}$ having length 2.\n\nWe will compute this array gradually: first $d[0]$, then $d[1]$, and so on.\nAfter this array is computed, the answer to the problem will be the maximum value in the array $d[]$.\n\nSo let the current index be $i$.\nI.e. we want to compute the value $d[i]$ and all previous values $d[0], \\dots, d[i-1]$ are already known.\nThen there are two options:\n\n-   $d[i] = 1$: the required subsequence consists only of the element $a[i]$.\n\n-   $d[i] > 1$: The subsequence will end it $a[i]$, and right before it will be some number $a[j]$ with $j < i$ and $a[j] < a[i]$.\n\n    It's easy to see, that the subsequence ending in $a[j]$ will itself be one of the longest increasing subsequences that ends in $a[j]$.\n    The number $a[i]$ just extends that longest increasing subsequence by one number.\n\n    Therefore, we can just iterate over all $j < i$ with $a[j] < a[i]$, and take the longest sequence that we get by appending $a[i]$ to the longest increasing subsequence ending in $a[j]$.\n    The longest increasing subsequence ending in $a[j]$ has length $d[j]$, extending it by one gives the length $d[j] + 1$.\n  \n    $$d[i] = \\max_{\\substack{j < i \\\\\\\\ a[j] < a[i]}} \\left(d[j] + 1\\right)$$\n\nIf we combine these two cases we get the final answer for $d[i]$:\n\n$$d[i] = \\max\\left(1, \\max_{\\substack{j < i \\\\\\\\ a[j] < a[i]}} \\left(d[j] + 1\\right)\\right)$$\n\n### Implementation\n\nHere is an implementation of the algorithm described above, which computes the length of the longest increasing subsequence.\n\n```{.cpp file=lis_n2}\nint lis(vector<int> const& a) {\n    int n = a.size();\n    vector<int> d(n, 1);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (a[j] < a[i])\n                d[i] = max(d[i], d[j] + 1);\n        }\n    }\n\n    int ans = d[0];\n    for (int i = 1; i < n; i++) {\n        ans = max(ans, d[i]);\n    }\n    return ans;\n}\n```\n\n### Restoring the subsequence\n\nSo far we only learned how to find the length of the subsequence, but not how to find the subsequence itself.\n\nTo be able to restore the subsequence we generate an additional auxiliary array $p[0 \\dots n-1]$ that we will compute alongside the array $d[]$.\n$p[i]$ will be the index $j$ of the second last element in the longest increasing subsequence ending in $i$.\nIn other words the index $p[i]$ is the same index $j$ at which the highest value $d[i]$ was obtained.\nThis auxiliary array $p[]$ points in some sense to the ancestors.\n\nThen to derive the subsequence, we just start at the index $i$ with the maximal $d[i]$, and follow the ancestors until we deduced the entire subsequence, i.e. until we reach the element with $d[i] = 1$.\n\n### Implementation of restoring\n\nWe will change the code from the previous sections a little bit.\nWe will compute the array $p[]$ alongside $d[]$, and afterwards compute the subsequence.\n\nFor convenience we originally assign the ancestors with $p[i] = -1$.\nFor elements with $d[i] = 1$, the ancestors value will remain $-1$, which will be slightly more convenient for restoring the subsequence.\n\n```{.cpp file=lis_n2_restore}\nvector<int> lis(vector<int> const& a) {\n    int n = a.size();\n    vector<int> d(n, 1), p(n, -1);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (a[j] < a[i] && d[i] < d[j] + 1) {\n                d[i] = d[j] + 1;\n                p[i] = j;\n            }\n        }\n    }\n\n    int ans = d[0], pos = 0;\n    for (int i = 1; i < n; i++) {\n        if (d[i] > ans) {\n            ans = d[i];\n            pos = i;\n        }\n    }\n\n    vector<int> subseq;\n    while (pos != -1) {\n        subseq.push_back(a[pos]);\n        pos = p[pos];\n    }\n    reverse(subseq.begin(), subseq.end());\n    return subseq;\n}\n```\n\n### Alternative way of restoring the subsequence\n\nIt is also possible to restore the subsequence without the auxiliary array $p[]$.\nWe can simply recalculate the current value of $d[i]$ and also see how the maximum was reached.\n\nThis method leads to a slightly longer code, but in return we save some memory.\n\n## Solution in $O(n \\log n)$ with dynamic programming and binary search {data-toc-label=\"Solution in O(n log n) with dynamic programming and binary search\"}\n\nIn order to obtain a faster solution for the problem, we construct a different dynamic programming solution that runs in $O(n^2)$, and then later improve it to $O(n \\log n)$.\n\nWe will use the dynamic programming array $d[0 \\dots n]$.\nThis time $d[l]$ doesn't corresponds to the element $a[i]$ or to an prefix of the array. \n$d[l]$ will be the smallest element at which an increasing subsequence of length $l$ ends.\n\nInitially we assume $d[0] = -\\infty$ and for all other lengths $d[l] = \\infty$.\n\nWe will again gradually process the numbers, first $a[0]$, then $a[1]$, etc, and in each step maintain the array $d[]$ so that it is up to date.\n\n!!! example\n\n    Given the array $a = \\{8, 3, 4, 6, 5, 2, 0, 7, 9, 1\\}$, here are all their prefixes and their dynamic programming array.\n    Notice, that the values of the array don't always change at the end.\n\n    $$\n    \\begin{array}{ll}\n    \\text{prefix} = \\{\\} &\\quad d = \\{-\\infty, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8\\} &\\quad d = \\{-\\infty, 8, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8, 3\\} &\\quad d = \\{-\\infty, 3, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8, 3, 4\\} &\\quad d = \\{-\\infty, 3, 4, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6\\} &\\quad d = \\{-\\infty, 3, 4, 6, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5\\} &\\quad d = \\{-\\infty, 3, 4, 5, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5, 2\\} &\\quad d = \\{-\\infty, 2, 4, 5, \\infty, \\dots \\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0\\} &\\quad d = \\{-\\infty, 0, 4, 5, \\infty, \\dots \\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0, 7\\} &\\quad d = \\{-\\infty, 0, 4, 5, 7, \\infty, \\dots \\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0, 7, 9\\} &\\quad d = \\{-\\infty, 0, 4, 5, 7, 9, \\infty, \\dots \\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0, 7, 9, 1\\} &\\quad d = \\{-\\infty, 0, 1, 5, 7, 9, \\infty, \\dots \\}\\\\\n    \\end{array}\n    $$\n\nWhen we process $a[i]$, we can ask ourselves.\nWhat have the conditions to be, that we write the current number $a[i]$ into the $d[0 \\dots n]$ array?\n\nWe set $d[l] = a[i]$, if there is a longest increasing sequence of length $l$ that ends in $a[i]$, and there is no longest increasing sequence of length $l$ that ends in a smaller number.\nSimilar to the previous approach, if we remove the number $a[i]$ from the longest increasing sequence of length $l$, we get another longest increasing sequence of length $l -1$.\nSo we want to extend a longest increasing sequence of length $l - 1$ by the number $a[i]$, and obviously the longest increasing sequence of length $l - 1$ that ends with the smallest element will work the best, in other words the sequence of length $l-1$ that ends in element $d[l-1]$.\n\nThere is a longest increasing sequence of length $l - 1$ that we can extend with the number $a[i]$, exactly if $d[l-1] < a[i]$.\nSo we can just iterate over each length $l$, and check if we can extend a longest increasing sequence of length $l - 1$ by checking the criteria.\n\nAdditionally we also need to check, if we maybe have already found a longest increasing sequence of length $l$ with a smaller number at the end.\nSo we only update if $a[i] < d[l]$.\n\nAfter processing all the elements of $a[]$ the length of the desired subsequence is the largest $l$ with $d[l] < \\infty$.\n\n```{.cpp file=lis_method2_n2}\nint lis(vector<int> const& a) {\n    int n = a.size();\n    const int INF = 1e9;\n    vector<int> d(n+1, INF);\n    d[0] = -INF;\n\n    for (int i = 0; i < n; i++) {\n        for (int l = 1; l <= n; l++) {\n            if (d[l-1] < a[i] && a[i] < d[l])\n                d[l] = a[i];\n        }\n    }\n\n    int ans = 0;\n    for (int l = 0; l <= n; l++) {\n        if (d[l] < INF)\n            ans = l;\n    }\n    return ans;\n}\n```\n\nWe now make two important observations.\n\n1.  The array $d$ will always be sorted: \n    $d[l-1] < d[l]$ for all $i = 1 \\dots n$.\n\n    This is trivial, as you can just remove the last element from the increasing subsequence of length $l$, and you get a increasing subsequence of length $l-1$ with a smalller ending number.\n\n2.  The element $a[i]$ will only update at most one value $d[l]$.\n\n    This follows immediately from the above implementation.\n    There can only be one place in the array with $d[l-1] < a[i] < d[l]$.\n\nThus we can find this element in the array $d[]$ using [binary search](../num_methods/binary_search.md) in $O(\\log n)$.\nIn fact we can simply look in the array $d[]$ for the first number that is strictly greater than $a[i]$, and we try to update this element in the same way as the above implementation.\n\n### Implementation\n\nThis gives us the improved $O(n \\log n)$ implementation:\n\n```{.cpp file=lis_method2_nlogn}\nint lis(vector<int> const& a) {\n    int n = a.size();\n    const int INF = 1e9;\n    vector<int> d(n+1, INF);\n    d[0] = -INF;\n\n    for (int i = 0; i < n; i++) {\n        int l = upper_bound(d.begin(), d.end(), a[i]) - d.begin();\n        if (d[l-1] < a[i] && a[i] < d[l])\n            d[l] = a[i];\n    }\n\n    int ans = 0;\n    for (int l = 0; l <= n; l++) {\n        if (d[l] < INF)\n            ans = l;\n    }\n    return ans;\n}\n```\n\n### Restoring the subsequence\n\nIt is also possible to restore the subsequence using this approach.\nThis time we have to maintain two auxiliary arrays.\nOne that tells us the index of the elements in $d[]$.\nAnd again we have to create an array of \"ancestors\" $p[i]$.\n$p[i]$ will be the index of the previous element for the optimal subsequence ending in element $i$.\n\nIt's easy to maintain these two arrays in the course of iteration over the array $a[]$ alongside the computations of $d[]$.\nAnd at the end it is not difficult to restore the desired subsequence using these arrays.\n\n## Solution in $O(n \\log n)$ with data structures {data-toc-label=\"Solution in O(n log n) with data structures\"}\n\nInstead of the above method for computing the longest increasing subsequence in $O(n \\log n)$ we can also solve the problem in a different way: using some simple data structures.\n\nLet's go back to the first method.\nRemember that $d[i]$ is the value $d[j] + 1$ with $j < i$ and $a[j] < a[i]$.\n\nThus if we define an additional array $t[]$ such that\n\n$$t[a[i]] = d[i],$$\n\nthen the problem of computing the value $d[i]$ is equivalent to finding the **maximum value in a prefix** of the array $t[]$:\n\n$$d[i] = \\max\\left(t[0 \\dots a[i] - 1] + 1\\right)$$\n\nThe problem of finding the maximum of a prefix of an array (which changes) is a standard problem that can be solved by many different data structures. \nFor instance we can use a [Segment tree](../data_structures/segment_tree.md) or a [Fenwick tree](../data_structures/fenwick.md).\n\nThis method has obviously some **shortcomings**:\nin terms of length and complexity of the implementation this approach will be worse than the method using binary search.\nIn addition if the input numbers $a[i]$ are especially large, then we would have to use some tricks, like compressing the numbers (i.e. renumber them from $0$ to $n-1$), or use a dynamic segment tree (only generate the branches of the tree that are important).\nOtherwise the memory consumption will be too high.\n\nOn the other hand this method has also some **advantages**:\nwith this method you don't have to think about any tricky properties in the dynamic programming solution.\nAnd this approach allows us to generalize the problem very easily (see below).\n\n## Related tasks\n\nHere are several problems that are closely related to the problem of finding the longest increasing subsequence.\n\n### Longest non-decreasing subsequence\n\nThis is in fact nearly the same problem.\nOnly now it is allowed to use identical numbers in the subsequence.\n\nThe solution is essentially also nearly the same.\nWe just have to change the inequality signs, and make a slightly modification to the binary search.\n\n### Number of longest increasing subsequences\n\nWe can use the first discussed method, either the $O(n^2)$ version or the version using data structures.\nWe only have to additionally store in how many ways we can obtain longest increasing subsequences ending in the values $d[i]$.\n\nThe number of ways to form a longest increasing subsequences ending in $a[i]$ is the sum of all ways for all longest increasing subsequences ending in $j$ where $d[j]$ is maximal.\nThere can be multiple such $j$, so we need to sum all of them.\n\nUsing a Segment tree this approach can also be implemented in $O(n \\log n)$.\n\nIt is not possible to use the binary search approach for this task.\n\n### Smallest number of non-increasing subsequences covering a sequence\n\nFor a given array with $n$ numbers $a[0 \\dots n - 1]$ we have to colorize the numbers in the smallest number of colors, so that each color forms a non-increasing subsequence.\n\nTo solve this, we notice that the minimum number of required colors is equal to the length of the longest increasing subsequence.\n\n**Proof**:\nWe need to prove the **duality** of these two problems.\n\nLet's denote by $x$ the length of the longest increasing subsequence and by $y$ the least number of non-increasing subsequences that form a cover.\nWe need to prove that $x = y$.\n\nIt is clear that $y < x$ is not possible, because if we have $x$ strictly increasing elements, than no two can be part of the same non-increasing subsequence.\nTherefore we have $y \\ge x$.\n\nWe now show that $y > x$ is not possible by contradiction.\nSuppose that $y > x$.\nThen we consider any optimal set of $y$ non-increasing subsequences.\nWe transform this in set in the following way:\nas long as there are two such subsequences such that the first begins before the second subsequence, and the first sequence start with a number greater than or equal to the second, then we unhook this starting number and attach it to the beginning of second.\nAfter a finite number of steps we have $y$ subsequences, and their starting numbers will form an increasing subsequence of length $y$.\nSince we assumed that $y > x$ we reached a contradiction.\n\nThus it follows that $y = x$.\n\n**Restoring the sequences**:\nThe desired partition of the sequence into subsequences can be done greedily.\nI.e. go from left to right and assign the current number or that subsequence ending with the minimal number which is greater than or equal to the current one.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: longest_increasing_subseq_log\n---\n\n# Longest increasing subsequence\n\nWe are given an array with $n$ numbers: $a[0 \\dots n-1]$.\nThe task is to find the longest, strictly increasing, subsequence in $a$.\n\nFormally we look for the longest sequence of indices $i_1, \\dots i_k$ such that\n\n$$i_1 < i_2 < \\dots < i_k,\\quad\na[i_1] < a[i_2] < \\dots < a[i_k]$$\n\nIn this article we discuss multiple algorithms for solving this task.\nAlso we will discuss some other problems, that can be reduced to this problem.\n\n## Solution in $O(n^2)$ with dynamic programming {data-toc-label=\"Solution in O(n^2) with dynamic programming\"}\n\nDynamic programming is a very general technique that allows to solve a huge class of problems.\nHere we apply the technique for our specific task.\n\nFirst we will search only for the **length** of the longest increasing subsequence, and only later learn how to restore the subsequence itself.\n\n### Finding the length\n\nTo accomplish this task, we define an array $d[0 \\dots n-1]$, where $d[i]$ is the length of the longest increasing subsequence that ends in the element at index $i$.\n\n!!! example\n\n    $$\\begin{array}{ll}\n    a &= \\{8, 3, 4, 6, 5, 2, 0, 7, 9, 1\\} \\\\\n    d &= \\{1, 1, 2, 3, 3, 1, 1, 4, 5, 2\\}\n    \\end{array}$$\n\n    The longest increasing subsequence that ends at index 4 is $\\{3, 4, 5\\}$ with a length of 3, the longest ending at index 8 is either $\\{3, 4, 5, 7, 9\\}$ or $\\{3, 4, 6, 7, 9\\}$, both having length 5, and the longest ending at index 9 is $\\{0, 1\\}$ having length 2.\n\nWe will compute this array gradually: first $d[0]$, then $d[1]$, and so on.\nAfter this array is computed, the answer to the problem will be the maximum value in the array $d[]$.\n\nSo let the current index be $i$.\nI.e. we want to compute the value $d[i]$ and all previous values $d[0], \\dots, d[i-1]$ are already known.\nThen there are two options:\n\n-   $d[i] = 1$: the required subsequence consists only of the element $a[i]$.\n\n-   $d[i] > 1$: The subsequence will end it $a[i]$, and right before it will be some number $a[j]$ with $j < i$ and $a[j] < a[i]$.\n\n    It's easy to see, that the subsequence ending in $a[j]$ will itself be one of the longest increasing subsequences that ends in $a[j]$.\n    The number $a[i]$ just extends that longest increasing subsequence by one number.\n\n    Therefore, we can just iterate over all $j < i$ with $a[j] < a[i]$, and take the longest sequence that we get by appending $a[i]$ to the longest increasing subsequence ending in $a[j]$.\n    The longest increasing subsequence ending in $a[j]$ has length $d[j]$, extending it by one gives the length $d[j] + 1$.\n  \n    $$d[i] = \\max_{\\substack{j < i \\\\\\\\ a[j] < a[i]}} \\left(d[j] + 1\\right)$$\n\nIf we combine these two cases we get the final answer for $d[i]$:\n\n$$d[i] = \\max\\left(1, \\max_{\\substack{j < i \\\\\\\\ a[j] < a[i]}} \\left(d[j] + 1\\right)\\right)$$\n\n### Implementation\n\nHere is an implementation of the algorithm described above, which computes the length of the longest increasing subsequence.\n\n```{.cpp file=lis_n2}\nint lis(vector<int> const& a) {\n    int n = a.size();\n    vector<int> d(n, 1);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (a[j] < a[i])\n                d[i] = max(d[i], d[j] + 1);\n        }\n    }\n\n    int ans = d[0];\n    for (int i = 1; i < n; i++) {\n        ans = max(ans, d[i]);\n    }\n    return ans;\n}\n```\n\n### Restoring the subsequence\n\nSo far we only learned how to find the length of the subsequence, but not how to find the subsequence itself.\n\nTo be able to restore the subsequence we generate an additional auxiliary array $p[0 \\dots n-1]$ that we will compute alongside the array $d[]$.\n$p[i]$ will be the index $j$ of the second last element in the longest increasing subsequence ending in $i$.\nIn other words the index $p[i]$ is the same index $j$ at which the highest value $d[i]$ was obtained.\nThis auxiliary array $p[]$ points in some sense to the ancestors.\n\nThen to derive the subsequence, we just start at the index $i$ with the maximal $d[i]$, and follow the ancestors until we deduced the entire subsequence, i.e. until we reach the element with $d[i] = 1$.\n\n### Implementation of restoring\n\nWe will change the code from the previous sections a little bit.\nWe will compute the array $p[]$ alongside $d[]$, and afterwards compute the subsequence.\n\nFor convenience we originally assign the ancestors with $p[i] = -1$.\nFor elements with $d[i] = 1$, the ancestors value will remain $-1$, which will be slightly more convenient for restoring the subsequence.\n\n```{.cpp file=lis_n2_restore}\nvector<int> lis(vector<int> const& a) {\n    int n = a.size();\n    vector<int> d(n, 1), p(n, -1);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (a[j] < a[i] && d[i] < d[j] + 1) {\n                d[i] = d[j] + 1;\n                p[i] = j;\n            }\n        }\n    }\n\n    int ans = d[0], pos = 0;\n    for (int i = 1; i < n; i++) {\n        if (d[i] > ans) {\n            ans = d[i];\n            pos = i;\n        }\n    }\n\n    vector<int> subseq;\n    while (pos != -1) {\n        subseq.push_back(a[pos]);\n        pos = p[pos];\n    }\n    reverse(subseq.begin(), subseq.end());\n    return subseq;\n}\n```\n\n### Alternative way of restoring the subsequence\n\nIt is also possible to restore the subsequence without the auxiliary array $p[]$.\nWe can simply recalculate the current value of $d[i]$ and also see how the maximum was reached.\n\nThis method leads to a slightly longer code, but in return we save some memory.\n\n## Solution in $O(n \\log n)$ with dynamic programming and binary search {data-toc-label=\"Solution in O(n log n) with dynamic programming and binary search\"}\n\nIn order to obtain a faster solution for the problem, we construct a different dynamic programming solution that runs in $O(n^2)$, and then later improve it to $O(n \\log n)$.\n\nWe will use the dynamic programming array $d[0 \\dots n]$.\nThis time $d[l]$ doesn't corresponds to the element $a[i]$ or to an prefix of the array. \n$d[l]$ will be the smallest element at which an increasing subsequence of length $l$ ends.\n\nInitially we assume $d[0] = -\\infty$ and for all other lengths $d[l] = \\infty$.\n\nWe will again gradually process the numbers, first $a[0]$, then $a[1]$, etc, and in each step maintain the array $d[]$ so that it is up to date.\n\n!!! example\n\n    Given the array $a = \\{8, 3, 4, 6, 5, 2, 0, 7, 9, 1\\}$, here are all their prefixes and their dynamic programming array.\n    Notice, that the values of the array don't always change at the end.\n\n    $$\n    \\begin{array}{ll}\n    \\text{prefix} = \\{\\} &\\quad d = \\{-\\infty, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8\\} &\\quad d = \\{-\\infty, 8, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8, 3\\} &\\quad d = \\{-\\infty, 3, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8, 3, 4\\} &\\quad d = \\{-\\infty, 3, 4, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6\\} &\\quad d = \\{-\\infty, 3, 4, 6, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5\\} &\\quad d = \\{-\\infty, 3, 4, 5, \\infty, \\dots\\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5, 2\\} &\\quad d = \\{-\\infty, 2, 4, 5, \\infty, \\dots \\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0\\} &\\quad d = \\{-\\infty, 0, 4, 5, \\infty, \\dots \\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0, 7\\} &\\quad d = \\{-\\infty, 0, 4, 5, 7, \\infty, \\dots \\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0, 7, 9\\} &\\quad d = \\{-\\infty, 0, 4, 5, 7, 9, \\infty, \\dots \\}\\\\\n    \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0, 7, 9, 1\\} &\\quad d = \\{-\\infty, 0, 1, 5, 7, 9, \\infty, \\dots \\}\\\\\n    \\end{array}\n    $$\n\nWhen we process $a[i]$, we can ask ourselves.\nWhat have the conditions to be, that we write the current number $a[i]$ into the $d[0 \\dots n]$ array?\n\nWe set $d[l] = a[i]$, if there is a longest increasing sequence of length $l$ that ends in $a[i]$, and there is no longest increasing sequence of length $l$ that ends in a smaller number.\nSimilar to the previous approach, if we remove the number $a[i]$ from the longest increasing sequence of length $l$, we get another longest increasing sequence of length $l -1$.\nSo we want to extend a longest increasing sequence of length $l - 1$ by the number $a[i]$, and obviously the longest increasing sequence of length $l - 1$ that ends with the smallest element will work the best, in other words the sequence of length $l-1$ that ends in element $d[l-1]$.\n\nThere is a longest increasing sequence of length $l - 1$ that we can extend with the number $a[i]$, exactly if $d[l-1] < a[i]$.\nSo we can just iterate over each length $l$, and check if we can extend a longest increasing sequence of length $l - 1$ by checking the criteria.\n\nAdditionally we also need to check, if we maybe have already found a longest increasing sequence of length $l$ with a smaller number at the end.\nSo we only update if $a[i] < d[l]$.\n\nAfter processing all the elements of $a[]$ the length of the desired subsequence is the largest $l$ with $d[l] < \\infty$.\n\n```{.cpp file=lis_method2_n2}\nint lis(vector<int> const& a) {\n    int n = a.size();\n    const int INF = 1e9;\n    vector<int> d(n+1, INF);\n    d[0] = -INF;\n\n    for (int i = 0; i < n; i++) {\n        for (int l = 1; l <= n; l++) {\n            if (d[l-1] < a[i] && a[i] < d[l])\n                d[l] = a[i];\n        }\n    }\n\n    int ans = 0;\n    for (int l = 0; l <= n; l++) {\n        if (d[l] < INF)\n            ans = l;\n    }\n    return ans;\n}\n```\n\nWe now make two important observations.\n\n1.  The array $d$ will always be sorted: \n    $d[l-1] < d[l]$ for all $i = 1 \\dots n$.\n\n    This is trivial, as you can just remove the last element from the increasing subsequence of length $l$, and you get a increasing subsequence of length $l-1$ with a smalller ending number.\n\n2.  The element $a[i]$ will only update at most one value $d[l]$.\n\n    This follows immediately from the above implementation.\n    There can only be one place in the array with $d[l-1] < a[i] < d[l]$.\n\nThus we can find this element in the array $d[]$ using [binary search](../num_methods/binary_search.md) in $O(\\log n)$.\nIn fact we can simply look in the array $d[]$ for the first number that is strictly greater than $a[i]$, and we try to update this element in the same way as the above implementation.\n\n### Implementation\n\nThis gives us the improved $O(n \\log n)$ implementation:\n\n```{.cpp file=lis_method2_nlogn}\nint lis(vector<int> const& a) {\n    int n = a.size();\n    const int INF = 1e9;\n    vector<int> d(n+1, INF);\n    d[0] = -INF;\n\n    for (int i = 0; i < n; i++) {\n        int l = upper_bound(d.begin(), d.end(), a[i]) - d.begin();\n        if (d[l-1] < a[i] && a[i] < d[l])\n            d[l] = a[i];\n    }\n\n    int ans = 0;\n    for (int l = 0; l <= n; l++) {\n        if (d[l] < INF)\n            ans = l;\n    }\n    return ans;\n}\n```\n\n### Restoring the subsequence\n\nIt is also possible to restore the subsequence using this approach.\nThis time we have to maintain two auxiliary arrays.\nOne that tells us the index of the elements in $d[]$.\nAnd again we have to create an array of \"ancestors\" $p[i]$.\n$p[i]$ will be the index of the previous element for the optimal subsequence ending in element $i$.\n\nIt's easy to maintain these two arrays in the course of iteration over the array $a[]$ alongside the computations of $d[]$.\nAnd at the end it is not difficult to restore the desired subsequence using these arrays.\n\n## Solution in $O(n \\log n)$ with data structures {data-toc-label=\"Solution in O(n log n) with data structures\"}\n\nInstead of the above method for computing the longest increasing subsequence in $O(n \\log n)$ we can also solve the problem in a different way: using some simple data structures.\n\nLet's go back to the first method.\nRemember that $d[i]$ is the value $d[j] + 1$ with $j < i$ and $a[j] < a[i]$.\n\nThus if we define an additional array $t[]$ such that\n\n$$t[a[i]] = d[i],$$\n\nthen the problem of computing the value $d[i]$ is equivalent to finding the **maximum value in a prefix** of the array $t[]$:\n\n$$d[i] = \\max\\left(t[0 \\dots a[i] - 1] + 1\\right)$$\n\nThe problem of finding the maximum of a prefix of an array (which changes) is a standard problem that can be solved by many different data structures. \nFor instance we can use a [Segment tree](../data_structures/segment_tree.md) or a [Fenwick tree](../data_structures/fenwick.md).\n\nThis method has obviously some **shortcomings**:\nin terms of length and complexity of the implementation this approach will be worse than the method using binary search.\nIn addition if the input numbers $a[i]$ are especially large, then we would have to use some tricks, like compressing the numbers (i.e. renumber them from $0$ to $n-1$), or use a dynamic segment tree (only generate the branches of the tree that are important).\nOtherwise the memory consumption will be too high.\n\nOn the other hand this method has also some **advantages**:\nwith this method you don't have to think about any tricky properties in the dynamic programming solution.\nAnd this approach allows us to generalize the problem very easily (see below).\n\n## Related tasks\n\nHere are several problems that are closely related to the problem of finding the longest increasing subsequence.\n\n### Longest non-decreasing subsequence\n\nThis is in fact nearly the same problem.\nOnly now it is allowed to use identical numbers in the subsequence.\n\nThe solution is essentially also nearly the same.\nWe just have to change the inequality signs, and make a slightly modification to the binary search.\n\n### Number of longest increasing subsequences\n\nWe can use the first discussed method, either the $O(n^2)$ version or the version using data structures.\nWe only have to additionally store in how many ways we can obtain longest increasing subsequences ending in the values $d[i]$.\n\nThe number of ways to form a longest increasing subsequences ending in $a[i]$ is the sum of all ways for all longest increasing subsequences ending in $j$ where $d[j]$ is maximal.\nThere can be multiple such $j$, so we need to sum all of them.\n\nUsing a Segment tree this approach can also be implemented in $O(n \\log n)$.\n\nIt is not possible to use the binary search approach for this task.\n\n### Smallest number of non-increasing subsequences covering a sequence\n\nFor a given array with $n$ numbers $a[0 \\dots n - 1]$ we have to colorize the numbers in the smallest number of colors, so that each color forms a non-increasing subsequence.\n\nTo solve this, we notice that the minimum number of required colors is equal to the length of the longest increasing subsequence.\n\n**Proof**:\nWe need to prove the **duality** of these two problems.\n\nLet's denote by $x$ the length of the longest increasing subsequence and by $y$ the least number of non-increasing subsequences that form a cover.\nWe need to prove that $x = y$.\n\nIt is clear that $y < x$ is not possible, because if we have $x$ strictly increasing elements, than no two can be part of the same non-increasing subsequence.\nTherefore we have $y \\ge x$.\n\nWe now show that $y > x$ is not possible by contradiction.\nSuppose that $y > x$.\nThen we consider any optimal set of $y$ non-increasing subsequences.\nWe transform this in set in the following way:\nas long as there are two such subsequences such that the first begins before the second subsequence, and the first sequence start with a number greater than or equal to the second, then we unhook this starting number and attach it to the beginning of second.\nAfter a finite number of steps we have $y$ subsequences, and their starting numbers will form an increasing subsequence of length $y$.\nSince we assumed that $y > x$ we reached a contradiction.\n\nThus it follows that $y = x$.\n\n**Restoring the sequences**:\nThe desired partition of the sequence into subsequences can be done greedily.\nI.e. go from left to right and assign the current number or that subsequence ending with the minimal number which is greater than or equal to the current one.\n\n## Practice Problems\n\n- [ACMSGURU - \"North-East\"](http://codeforces.com/problemsets/acmsguru/problem/99999/521)\n- [Codeforces - LCIS](http://codeforces.com/problemset/problem/10/D)\n- [Codeforces - Tourist](http://codeforces.com/contest/76/problem/F)\n- [SPOJ - DOSA](https://www.spoj.com/problems/DOSA/)\n- [SPOJ - HMLIS](https://www.spoj.com/problems/HMLIS/)\n- [SPOJ - ONEXLIS](https://www.spoj.com/problems/ONEXLIS/)\n- [SPOJ - SUPPER](http://www.spoj.com/problems/SUPPER/)\n- [Topcoder - AutoMarket](https://community.topcoder.com/stat?c=problem_statement&pm=3937&rd=6532)\n- [Topcoder - BridgeArrangement](https://community.topcoder.com/stat?c=problem_statement&pm=2967&rd=5881)\n- [Topcoder - IntegerSequence](https://community.topcoder.com/stat?c=problem_statement&pm=5922&rd=8075)\n- [UVA - Back To Edit Distance](https://onlinejudge.org/external/127/12747.pdf)\n- [UVA - Happy Birthday](https://onlinejudge.org/external/120/12002.pdf)\n- [UVA - Tiling Up Blocks](https://onlinejudge.org/external/11/1196.pdf)\n", "problem_ids": ["10_D", "76_F"], "title": "Longest increasing subsequence"}, {"article": "---\ntags:\n    - Original\ntitle: MEX (minimal excluded) of a sequence\n---\n# MEX (minimal excluded) of a sequence\n\nGiven an array $A$ of size $N$. You have to find the minimal non-negative element that is not present in the array. That number is commonly called the **MEX** (minimal excluded).\n\n$$\n\\begin{align}\n\\text{mex}(\\{0, 1, 2, 4, 5\\}) &= 3 \\\\\n\\text{mex}(\\{0, 1, 2, 3, 4\\}) &= 5 \\\\\n\\text{mex}(\\{1, 2, 3, 4, 5\\}) &= 0 \\\\\n\\end{align}\n$$\n\nNotice, that the MEX of an array of size $N$ can never be bigger than $N$ itself.\n\nThe easiest approach is to create a set of all elements in the array $A$, so that we can quickly check if a number is part of the array or not.\nThen we can check all numbers from $0$ to $N$, if the current number is not present in the set, return it.\n\n## Implementation\n\nThe following algorithm runs in $O(N \\log N)$ time.\n\n```{.cpp file=mex_simple}\nint mex(vector<int> const& A) {\n    set<int> b(A.begin(), A.end());\n\n    int result = 0;\n    while (b.count(result))\n        ++result;\n    return result;\n}\n```\n\nIf an algorithm requires a $O(N)$ MEX computation, it is possible by using a boolean vector instead of a set.\nNotice, that the array needs to be as big as the biggest possible array size.\n\n\n```{.cpp file=mex_linear}\nint mex(vector<int> const& A) {\n    static bool used[MAX_N+1] = { 0 };\n\n    // mark the given numbers\n    for (int x : A) {\n        if (x <= MAX_N)\n            used[x] = true;\n    }\n\n    // find the mex\n    int result = 0;\n    while (used[result])\n        ++result;\n \n    // clear the array again\n    for (int x : A) {\n        if (x <= MAX_N)\n            used[x] = false;\n    }\n\n    return result;\n}\n```\n\nThis approach is fast, but only works well if you have to compute the MEX once.\nIf you need to compute the MEX over and over, e.g. because your array keeps changing, then it is not effective.\nFor that, we need something better.\n\n## MEX with array updates\n\nIn the problem you need to change individual numbers in the array, and compute the new MEX of the array after each such update.\n\nThere is a need for a better data structure that handles such queries efficiently.\n\nOne approach would be take the frequency of each number from $0$ to $N$, and build a tree-like data structure over it.\nE.g. a segment tree or a treap.\nEach node represents a range of numbers, and together to total frequency in the range, you additionally store the amount of distinct numbers in that range.\nIt's possible to update this data structure in $O(\\log N)$ time, and also find the MEX in $O(\\log N)$ time, by doing a binary search for the MEX.\nIf the node representing the range $[0, \\lfloor N/2 \\rfloor)$ doesn't contain $\\lfloor N/2 \\rfloor$ many distinct numbers, then one is missing and the MEX is smaller than $\\lfloor N/2 \\rfloor$, and you can recurse in the left branch of the tree. Otherwise it is at least $\\lfloor N/2 \\rfloor$, and you can recurse in the right branch of the tree.\n\nIt's also possible to use the standard library data structures `map` and `set` (based on an approach explained [here](https://codeforces.com/blog/entry/81287?#comment-677837)).\nWith a `map` we will remember the frequency of each number, and with the `set` we represent the numbers that are currently missing from the array.\nSince a `set` is ordered, `*set.begin()` will be the MEX.\nIn total we need $O(N \\log N)$ precomputation, and afterwards the MEX can be computed in $O(1)$ and an update can be performed in $O(\\log N)$.\n\n```{.cpp file=mex_updates}\nclass Mex {\nprivate:\n    map<int, int> frequency;\n    set<int> missing_numbers;\n    vector<int> A;\n\npublic:\n    Mex(vector<int> const& A) : A(A) {\n        for (int i = 0; i <= A.size(); i++)\n            missing_numbers.insert(i);\n\n        for (int x : A) {\n            ++frequency[x];\n            missing_numbers.erase(x);\n        }\n    }\n\n    int mex() {\n        return *missing_numbers.begin();\n    }\n\n    void update(int idx, int new_value) {\n        if (--frequency[A[idx]] == 0)\n            missing_numbers.insert(A[idx]);\n        A[idx] = new_value;\n        ++frequency[new_value];\n        missing_numbers.erase(new_value);\n    }\n};\n```\n\n", "full_article": "---\ntags:\n    - Original\ntitle: MEX (minimal excluded) of a sequence\n---\n# MEX (minimal excluded) of a sequence\n\nGiven an array $A$ of size $N$. You have to find the minimal non-negative element that is not present in the array. That number is commonly called the **MEX** (minimal excluded).\n\n$$\n\\begin{align}\n\\text{mex}(\\{0, 1, 2, 4, 5\\}) &= 3 \\\\\n\\text{mex}(\\{0, 1, 2, 3, 4\\}) &= 5 \\\\\n\\text{mex}(\\{1, 2, 3, 4, 5\\}) &= 0 \\\\\n\\end{align}\n$$\n\nNotice, that the MEX of an array of size $N$ can never be bigger than $N$ itself.\n\nThe easiest approach is to create a set of all elements in the array $A$, so that we can quickly check if a number is part of the array or not.\nThen we can check all numbers from $0$ to $N$, if the current number is not present in the set, return it.\n\n## Implementation\n\nThe following algorithm runs in $O(N \\log N)$ time.\n\n```{.cpp file=mex_simple}\nint mex(vector<int> const& A) {\n    set<int> b(A.begin(), A.end());\n\n    int result = 0;\n    while (b.count(result))\n        ++result;\n    return result;\n}\n```\n\nIf an algorithm requires a $O(N)$ MEX computation, it is possible by using a boolean vector instead of a set.\nNotice, that the array needs to be as big as the biggest possible array size.\n\n\n```{.cpp file=mex_linear}\nint mex(vector<int> const& A) {\n    static bool used[MAX_N+1] = { 0 };\n\n    // mark the given numbers\n    for (int x : A) {\n        if (x <= MAX_N)\n            used[x] = true;\n    }\n\n    // find the mex\n    int result = 0;\n    while (used[result])\n        ++result;\n \n    // clear the array again\n    for (int x : A) {\n        if (x <= MAX_N)\n            used[x] = false;\n    }\n\n    return result;\n}\n```\n\nThis approach is fast, but only works well if you have to compute the MEX once.\nIf you need to compute the MEX over and over, e.g. because your array keeps changing, then it is not effective.\nFor that, we need something better.\n\n## MEX with array updates\n\nIn the problem you need to change individual numbers in the array, and compute the new MEX of the array after each such update.\n\nThere is a need for a better data structure that handles such queries efficiently.\n\nOne approach would be take the frequency of each number from $0$ to $N$, and build a tree-like data structure over it.\nE.g. a segment tree or a treap.\nEach node represents a range of numbers, and together to total frequency in the range, you additionally store the amount of distinct numbers in that range.\nIt's possible to update this data structure in $O(\\log N)$ time, and also find the MEX in $O(\\log N)$ time, by doing a binary search for the MEX.\nIf the node representing the range $[0, \\lfloor N/2 \\rfloor)$ doesn't contain $\\lfloor N/2 \\rfloor$ many distinct numbers, then one is missing and the MEX is smaller than $\\lfloor N/2 \\rfloor$, and you can recurse in the left branch of the tree. Otherwise it is at least $\\lfloor N/2 \\rfloor$, and you can recurse in the right branch of the tree.\n\nIt's also possible to use the standard library data structures `map` and `set` (based on an approach explained [here](https://codeforces.com/blog/entry/81287?#comment-677837)).\nWith a `map` we will remember the frequency of each number, and with the `set` we represent the numbers that are currently missing from the array.\nSince a `set` is ordered, `*set.begin()` will be the MEX.\nIn total we need $O(N \\log N)$ precomputation, and afterwards the MEX can be computed in $O(1)$ and an update can be performed in $O(\\log N)$.\n\n```{.cpp file=mex_updates}\nclass Mex {\nprivate:\n    map<int, int> frequency;\n    set<int> missing_numbers;\n    vector<int> A;\n\npublic:\n    Mex(vector<int> const& A) : A(A) {\n        for (int i = 0; i <= A.size(); i++)\n            missing_numbers.insert(i);\n\n        for (int x : A) {\n            ++frequency[x];\n            missing_numbers.erase(x);\n        }\n    }\n\n    int mex() {\n        return *missing_numbers.begin();\n    }\n\n    void update(int idx, int new_value) {\n        if (--frequency[A[idx]] == 0)\n            missing_numbers.insert(A[idx]);\n        A[idx] = new_value;\n        ++frequency[new_value];\n        missing_numbers.erase(new_value);\n    }\n};\n```\n\n## Practice Problems\n\n- [AtCoder: Neq Min](https://atcoder.jp/contests/hhkb2020/tasks/hhkb2020_c)\n- [Codeforces: Replace by MEX](https://codeforces.com/contest/1375/problem/D)\n- [Codeforces: Vitya and Strange Lesson](https://codeforces.com/problemset/problem/842/D)\n- [Codeforces: MEX Queries](https://codeforces.com/contest/817/problem/F)\n", "problem_ids": [], "title": "MEX (minimal excluded) of a sequence"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: rmq\n---\n\n# Range Minimum Query\n\nYou are given an array $A[1..N]$.\nYou have to answer incoming queries of the form $(L, R)$, which ask to find the minimum element in array $A$ between positions $L$ and $R$ inclusive.\n\nRMQ can appear in problems directly or can be applied in some other tasks, e.g. the [Lowest Common Ancestor](../graph/lca.md) problem.\n\n## Solution\n\nThere are lots of possible approaches and data structures that you can use to solve the RMQ task.\n\nThe ones that are explained on this site are listed below.\n\nFirst the approaches that allow modifications to the array between answering queries.\n\n- [Sqrt-decomposition](../data_structures/sqrt_decomposition.md) - answers each query in $O(\\sqrt{N})$, preprocessing done in $O(N)$.\n  Pros: a very simple data structure. Cons: worse complexity.\n- [Segment tree](../data_structures/segment_tree.md) - answers each query in $O(\\log N)$, preprocessing done in $O(N)$.\n  Pros: good time complexity. Cons: larger amount of code compared to the other data structures.\n- [Fenwick tree](../data_structures/fenwick.md) - answers each query in $O(\\log N)$, preprocessing done in $O(N \\log N)$.\n  Pros: the shortest code, good time complexity. Cons: Fenwick tree can only be used for queries with $L = 1$, so it is not applicable to many problems.\n\nAnd here are the approaches that only work on static arrays, i.e. it is not possible to change a value in the array without recomputing the complete data structure.\n\n- [Sparse Table](../data_structures/sparse-table.md) - answers each query in $O(1)$, preprocessing done in $O(N \\log N)$.\n  Pros: simple data structure, excellent time complexity.\n- [Sqrt Tree](../data_structures/sqrt-tree.md) - answers queries in $O(1)$, preprocessing done in $O(N \\log \\log N)$. Pros: fast. Cons: Complicated to implement.\n- [Disjoint Set Union / Arpa's Trick](../data_structures/disjoint_set_union.md#arpa) - answers queries in $O(1)$, preprocessing in $O(n)$. Pros: short, fast. Cons: only works if all queries are known in advance, i.e. only supports off-line processing of the queries.\n- [Cartesian Tree](../graph/rmq_linear.md) and [Farach-Colton and Bender algorithm](../graph/lca_farachcoltonbender.md) - answers queries in $O(1)$, preprocessing in $O(n)$. Pros: optimal complexity. Cons: large amount of code.\n\nNote: Preprocessing is the preliminary processing of the given array by building the corresponding data structure for it.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: rmq\n---\n\n# Range Minimum Query\n\nYou are given an array $A[1..N]$.\nYou have to answer incoming queries of the form $(L, R)$, which ask to find the minimum element in array $A$ between positions $L$ and $R$ inclusive.\n\nRMQ can appear in problems directly or can be applied in some other tasks, e.g. the [Lowest Common Ancestor](../graph/lca.md) problem.\n\n## Solution\n\nThere are lots of possible approaches and data structures that you can use to solve the RMQ task.\n\nThe ones that are explained on this site are listed below.\n\nFirst the approaches that allow modifications to the array between answering queries.\n\n- [Sqrt-decomposition](../data_structures/sqrt_decomposition.md) - answers each query in $O(\\sqrt{N})$, preprocessing done in $O(N)$.\n  Pros: a very simple data structure. Cons: worse complexity.\n- [Segment tree](../data_structures/segment_tree.md) - answers each query in $O(\\log N)$, preprocessing done in $O(N)$.\n  Pros: good time complexity. Cons: larger amount of code compared to the other data structures.\n- [Fenwick tree](../data_structures/fenwick.md) - answers each query in $O(\\log N)$, preprocessing done in $O(N \\log N)$.\n  Pros: the shortest code, good time complexity. Cons: Fenwick tree can only be used for queries with $L = 1$, so it is not applicable to many problems.\n\nAnd here are the approaches that only work on static arrays, i.e. it is not possible to change a value in the array without recomputing the complete data structure.\n\n- [Sparse Table](../data_structures/sparse-table.md) - answers each query in $O(1)$, preprocessing done in $O(N \\log N)$.\n  Pros: simple data structure, excellent time complexity.\n- [Sqrt Tree](../data_structures/sqrt-tree.md) - answers queries in $O(1)$, preprocessing done in $O(N \\log \\log N)$. Pros: fast. Cons: Complicated to implement.\n- [Disjoint Set Union / Arpa's Trick](../data_structures/disjoint_set_union.md#arpa) - answers queries in $O(1)$, preprocessing in $O(n)$. Pros: short, fast. Cons: only works if all queries are known in advance, i.e. only supports off-line processing of the queries.\n- [Cartesian Tree](../graph/rmq_linear.md) and [Farach-Colton and Bender algorithm](../graph/lca_farachcoltonbender.md) - answers queries in $O(1)$, preprocessing in $O(n)$. Pros: optimal complexity. Cons: large amount of code.\n\nNote: Preprocessing is the preliminary processing of the given array by building the corresponding data structure for it.\n\n## Practice Problems\n- [SPOJ: Range Minimum Query](http://www.spoj.com/problems/RMQSQ/)\n- [CODECHEF: Chef And Array](https://www.codechef.com/problems/FRMQ)\n- [Codeforces:  Array Partition](https://codeforces.com/contest/1454/problem/F)\n", "problem_ids": [], "title": "Range Minimum Query"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: randomized_heap\n---\n\n# Randomized Heap\n\nA randomized heap is a heap that, through using randomization, allows to perform all operations in expected logarithmic time.\n\nA **min heap** is a binary tree in which the value of each vertex is less than or equal to the values of its children.\nThus the minimum of the tree is always in the root vertex.\n\nA max heap can be defined in a similar way: by replacing less with greater.\n\nThe default operations of a heap are:\n\n- Adding a value\n- Extracting the minimum\n- Removing the minimum\n- Merging two heaps (without deleting duplicates)\n- Removing an arbitrary element (if its position in the tree is known)\n\nA randomized heap can perform all these operations in expected $O(\\log n)$ time with a very simple implementation.\n\n## Data structure\n\nWe can immediately describe the structure of the binary heap:\n\n```{.cpp file=randomized_heap_structure}\nstruct Tree {\n    int value;\n    Tree * l = nullptr;\n    Tree * r = nullptr;\n};\n```\n\nIn the vertex we store a value.\nIn addition we have pointers to the left and right children, which are point to null if the corresponding child doesn't exist.\n\n## Operations\n\nIt is not difficult to see, that all operations can be reduced to a single one: **merging** two heaps into one.\nIndeed, adding a new value to the heap is equivalent to merging the heap with a heap consisting of a single vertex with that value. \nFinding a minimum doesn't require any operation at all - the minimum is simply the value at the root.\nRemoving the minimum is equivalent to the result of merging the left and right children of the root vertex.\nAnd removing an arbitrary element is similar.\nWe merge the children of the vertex and replace the vertex with the result of the merge.\n\nSo we actually only need to implement the operation of merging two heaps.\nAll other operations are trivially reduced to this operation.\n\nLet two heaps $T_1$ and $T_2$ be given.\nIt is clear that the root of each of these heaps contains its minimum.\nSo the root of the resulting heap will be the minimum of these two values.\nSo we compare both values, and use the smaller one as the new root.\nNow we have to combine the children of the selected vertex with the remaining heap.\nFor this we select one of the children, and merge it with the remaining heap.\nThus we again have the operation of merging two heaps.\nSooner of later this process will end (the number of such steps is limited by the sum of the heights of the two heaps)\n\nTo achieve logarithmic complexity on average, we need to specify a method for choosing one of the two children so that the average path length is logarithmic.\nIt is not difficult to guess, that we will make this decision **randomly**.\nThus the implementation of the merging operation is as follows:\n\n```{.cpp file=randomized_heap_merge}\nTree* merge(Tree* t1, Tree* t2) {\n    if (!t1 || !t2)\n        return t1 ? t1 : t2;\n    if (t2->value < t1->value)\n        swap(t1, t2);\n    if (rand() & 1)\n        swap(t1->l, t1->r);\n    t1->l = merge(t1->l, t2);\n    return t1;\n}\n```\n\nHere first we check if one of the heaps is empty, then we don't need to perform any merge action at all.\nOtherwise we make the heap `t1` the one with the smaller value (by swapping `t1` and `t2` if necessary).\nWe want to merge the left child of `t1` with `t2`, therefore we randomly swap the children of `t1`, and then perform the merge.\n\n## Complexity\n\nWe introduce the random variable $h(T)$ which will denote the **length of the random path** from the root to the leaf (the length in the number of edges).\nIt is clear that the algorithm `merge` performs $O(h(T_1) + h(T_2))$ steps.\nTherefore to understand the complexity of the operations, we must look into the random variable $h(T)$.\n\n### Expected value\n\nWe assume that the expectation $h(T)$ can be estimated from above by the logarithm of the number of vertices in the heap:\n\n$$\\mathbf{E} h(T) \\le \\log(n+1)$$\n\nThis can be easily proven by induction.\nLet $L$ and $R$ be the left and the right subtrees of the root $T$, and $n_L$ and $n_R$ the number of vertices in them ($n = n_L + n_R + 1$).\n\nThe following shows the induction step:\n\n$$\\begin{align}\n\\mathbf{E} h(T) &= 1 + \\frac{\\mathbf{E} h(L) + \\mathbf{E} h(R)}{2} \n\\le 1 + \\frac{\\log(n_L + 1) \\log(n_R + 1)}{2} \\\\\\\\\n&= 1 + \\log\\sqrt{(n_L + 1)(n_R + 1)} = \\log 2\\sqrt{(n_L + 1)(n_R + 1)} \\\\\\\\\n&\\le \\log \\frac{2\\left((n_L + 1) + (n_R + 1)\\right)}{2} = \\log(n_L + n_R + 2) = \\log(n+1)\n\\end{align}$$\n\n### Exceeding the expected value\n\nOf course we are still not happy.\nThe expected value of $h(T)$ doesn't say anything about the worst case.\nIt is still possible that the paths from the root to the vertices is on average much greater than $\\log(n + 1)$ for a specific tree.\n\nLet us prove that exceeding the expected value is indeed very small:\n\n$$P\\{h(T) > (c+1) \\log n\\} < \\frac{1}{n^c}$$\n\nfor any positive constant $c$.\n\nHere we denote by $P$ the set of paths from the root of the heap to the leaves where the length exceeds $(c+1) \\log n$.\nNote that for any path $p$ of length $|p|$ the probability that it will be chosen as random path is $2^{-|p|}$.\nTherefore we get:\n\n$$P\\{h(T) > (c+1) \\log n\\} = \\sum_{p \\in P} 2^{-|p|} < \\sum_{p \\in P} 2^{-(c+1) \\log n} = |P| n^{-(c+1)} \\le n^{-c}$$\n\n### Complexity of the algorithm\n\nThus the algorithm `merge`, and hence all other operations expressed with it, can be performed in $O(\\log n)$ on average.\n\nMoreover for any positive constant $\\epsilon$ there is a positive constant $c$, such that the probability that the operation will require more than $c \\log n$ steps is less than $n^{-\\epsilon}$ (in some sense this describes the worst case behavior of the algorithm).\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: randomized_heap\n---\n\n# Randomized Heap\n\nA randomized heap is a heap that, through using randomization, allows to perform all operations in expected logarithmic time.\n\nA **min heap** is a binary tree in which the value of each vertex is less than or equal to the values of its children.\nThus the minimum of the tree is always in the root vertex.\n\nA max heap can be defined in a similar way: by replacing less with greater.\n\nThe default operations of a heap are:\n\n- Adding a value\n- Extracting the minimum\n- Removing the minimum\n- Merging two heaps (without deleting duplicates)\n- Removing an arbitrary element (if its position in the tree is known)\n\nA randomized heap can perform all these operations in expected $O(\\log n)$ time with a very simple implementation.\n\n## Data structure\n\nWe can immediately describe the structure of the binary heap:\n\n```{.cpp file=randomized_heap_structure}\nstruct Tree {\n    int value;\n    Tree * l = nullptr;\n    Tree * r = nullptr;\n};\n```\n\nIn the vertex we store a value.\nIn addition we have pointers to the left and right children, which are point to null if the corresponding child doesn't exist.\n\n## Operations\n\nIt is not difficult to see, that all operations can be reduced to a single one: **merging** two heaps into one.\nIndeed, adding a new value to the heap is equivalent to merging the heap with a heap consisting of a single vertex with that value. \nFinding a minimum doesn't require any operation at all - the minimum is simply the value at the root.\nRemoving the minimum is equivalent to the result of merging the left and right children of the root vertex.\nAnd removing an arbitrary element is similar.\nWe merge the children of the vertex and replace the vertex with the result of the merge.\n\nSo we actually only need to implement the operation of merging two heaps.\nAll other operations are trivially reduced to this operation.\n\nLet two heaps $T_1$ and $T_2$ be given.\nIt is clear that the root of each of these heaps contains its minimum.\nSo the root of the resulting heap will be the minimum of these two values.\nSo we compare both values, and use the smaller one as the new root.\nNow we have to combine the children of the selected vertex with the remaining heap.\nFor this we select one of the children, and merge it with the remaining heap.\nThus we again have the operation of merging two heaps.\nSooner of later this process will end (the number of such steps is limited by the sum of the heights of the two heaps)\n\nTo achieve logarithmic complexity on average, we need to specify a method for choosing one of the two children so that the average path length is logarithmic.\nIt is not difficult to guess, that we will make this decision **randomly**.\nThus the implementation of the merging operation is as follows:\n\n```{.cpp file=randomized_heap_merge}\nTree* merge(Tree* t1, Tree* t2) {\n    if (!t1 || !t2)\n        return t1 ? t1 : t2;\n    if (t2->value < t1->value)\n        swap(t1, t2);\n    if (rand() & 1)\n        swap(t1->l, t1->r);\n    t1->l = merge(t1->l, t2);\n    return t1;\n}\n```\n\nHere first we check if one of the heaps is empty, then we don't need to perform any merge action at all.\nOtherwise we make the heap `t1` the one with the smaller value (by swapping `t1` and `t2` if necessary).\nWe want to merge the left child of `t1` with `t2`, therefore we randomly swap the children of `t1`, and then perform the merge.\n\n## Complexity\n\nWe introduce the random variable $h(T)$ which will denote the **length of the random path** from the root to the leaf (the length in the number of edges).\nIt is clear that the algorithm `merge` performs $O(h(T_1) + h(T_2))$ steps.\nTherefore to understand the complexity of the operations, we must look into the random variable $h(T)$.\n\n### Expected value\n\nWe assume that the expectation $h(T)$ can be estimated from above by the logarithm of the number of vertices in the heap:\n\n$$\\mathbf{E} h(T) \\le \\log(n+1)$$\n\nThis can be easily proven by induction.\nLet $L$ and $R$ be the left and the right subtrees of the root $T$, and $n_L$ and $n_R$ the number of vertices in them ($n = n_L + n_R + 1$).\n\nThe following shows the induction step:\n\n$$\\begin{align}\n\\mathbf{E} h(T) &= 1 + \\frac{\\mathbf{E} h(L) + \\mathbf{E} h(R)}{2} \n\\le 1 + \\frac{\\log(n_L + 1) \\log(n_R + 1)}{2} \\\\\\\\\n&= 1 + \\log\\sqrt{(n_L + 1)(n_R + 1)} = \\log 2\\sqrt{(n_L + 1)(n_R + 1)} \\\\\\\\\n&\\le \\log \\frac{2\\left((n_L + 1) + (n_R + 1)\\right)}{2} = \\log(n_L + n_R + 2) = \\log(n+1)\n\\end{align}$$\n\n### Exceeding the expected value\n\nOf course we are still not happy.\nThe expected value of $h(T)$ doesn't say anything about the worst case.\nIt is still possible that the paths from the root to the vertices is on average much greater than $\\log(n + 1)$ for a specific tree.\n\nLet us prove that exceeding the expected value is indeed very small:\n\n$$P\\{h(T) > (c+1) \\log n\\} < \\frac{1}{n^c}$$\n\nfor any positive constant $c$.\n\nHere we denote by $P$ the set of paths from the root of the heap to the leaves where the length exceeds $(c+1) \\log n$.\nNote that for any path $p$ of length $|p|$ the probability that it will be chosen as random path is $2^{-|p|}$.\nTherefore we get:\n\n$$P\\{h(T) > (c+1) \\log n\\} = \\sum_{p \\in P} 2^{-|p|} < \\sum_{p \\in P} 2^{-(c+1) \\log n} = |P| n^{-(c+1)} \\le n^{-c}$$\n\n### Complexity of the algorithm\n\nThus the algorithm `merge`, and hence all other operations expressed with it, can be performed in $O(\\log n)$ on average.\n\nMoreover for any positive constant $\\epsilon$ there is a positive constant $c$, such that the probability that the operation will require more than $c \\log n$ steps is less than $n^{-\\epsilon}$ (in some sense this describes the worst case behavior of the algorithm).\n", "problem_ids": [], "title": "Randomized Heap"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: fenwick_tree\n---\n\n# Fenwick Tree\n\nLet, $f$ be some group operation (binary associative function over a set with identity element and inverse elements) and $A$ be an array of integers of length $N$.\n\nFenwick tree is a data structure which:\n\n* calculates the value of function $f$ in the given range $[l, r]$ (i.e. $f(A_l, A_{l+1}, \\dots, A_r)$) in $O(\\log N)$ time;\n* updates the value of an element of $A$ in $O(\\log N)$ time;\n* requires $O(N)$ memory, or in other words, exactly the same memory required for $A$;\n* is easy to use and code, especially, in the case of multidimensional arrays.\n\nThe most common application of Fenwick tree is _calculating the sum of a range_ (i.e. using addition over the set of integers $\\mathbb{Z}$: $f(A_1, A_2, \\dots, A_k) = A_1 + A_2 + \\dots + A_k$).\n\nFenwick tree is also called **Binary Indexed Tree**, or just **BIT** abbreviated.\n\nFenwick tree was first described in a paper titled \"A new data structure for cumulative frequency tables\" (Peter M. Fenwick, 1994).\n\n## Description\n\n### Overview\n\nFor the sake of simplicity, we will assume that function $f$ is just a *sum function*.\n\nGiven an array of integers $A[0 \\dots N-1]$.\nA Fenwick tree is just an array $T[0 \\dots N-1]$, where each of its elements is equal to the sum of elements of $A$ in some range $[g(i), i]$:\n\n$$T_i = \\sum_{j = g(i)}^{i}{A_j},$$\n\nwhere $g$ is some function that satisfies $0 \\le g(i) \\le i$.\nWe will define the function in the next few paragraphs.\n\nThe data structure is called tree, because there is a nice representation of the data structure as tree, although we don't need to model an actual tree with nodes and edges.\nWe will only need to maintain the array $T$ to handle all queries.\n\n**Note:** The Fenwick tree presented here uses zero-based indexing.\nMany people will actually use a version of the Fenwick tree that uses one-based indexing.\nTherefore you will also find an alternative implementation using one-based indexing in the implementation section.\nBoth versions are equivalent in terms of time and memory complexity.\n\nNow we can write some pseudo-code for the two operations mentioned above - get the sum of elements of $A$ in the range $[0, r]$ and update (increase) some element $A_i$:\n\n```python\ndef sum(int r):\n    res = 0\n    while (r >= 0):\n        res += t[r]\n        r = g(r) - 1\n    return res\n\ndef increase(int i, int delta):\n    for all j with g(j) <= i <= j:\n        t[j] += delta\n```\n\nThe function `sum` works as follows:\n\n1. first, it adds the sum of the range $[g(r), r]$ (i.e. $T[r]$) to the `result`\n2. then, it \"jumps\" to the range $[g(g(r)-1), g(r)-1]$, and adds this range's sum to the `result`\n3. and so on, until it \"jumps\" from $[0, g(g( \\dots g(r)-1 \\dots -1)-1)]$ to $[g(-1), -1]$; that is where the `sum` function stops jumping.\n\nThe function `increase` works with the same analogy, but \"jumps\" in the direction of increasing indices:\n\n1. sums of the ranges $[g(j), j]$ that satisfy the condition $g(j) \\le i \\le j$ are increased by `delta` , that is `t[j] += delta`. Therefore we updated all elements in $T$ that correspond to ranges in which $A_i$ lies.\n\nIt is obvious that the complexity of both `sum` and `increase` depend on the function $g$.\nThere are lots of ways to choose the function $g$, as long as $0 \\le g(i) \\le i$ for all $i$.\nFor instance the function $g(i) = i$ works, which results just in $T = A$, and therefore summation queries are slow.\nWe can also take the function $g(i) = 0$.\nThis will correspond to prefix sum arrays, which means that finding the sum of the range $[0, i]$ will only take constant time, but updates are slow.\nThe clever part of the Fenwick algorithm is, that there it uses a special definition of the function $g$ that can handle both operations in $O(\\log N)$ time.\n\n### Definition of $g(i)$ { data-toc-label='Definition of <script type=\"math/tex\">g(i)</script>' }\n\nThe computation of $g(i)$ is defined using the following simple operation:\nwe replace all trailing $1$ bits in the binary representation of $i$ with $0$ bits.\n\nIn other words, if the least significant digit of $i$ in binary is $0$, then $g(i) = i$.\nAnd otherwise the least significant digit is a $1$, and we take this $1$ and all other trailing $1$s and flip them.\n\nFor instance we get\n\n$$\\begin{align}\ng(11) = g(1011_2) = 1000_2 &= 8 \\\\\\\\\ng(12) = g(1100_2) = 1100_2 &= 12 \\\\\\\\\ng(13) = g(1101_2) = 1100_2 &= 12 \\\\\\\\\ng(14) = g(1110_2) = 1110_2 &= 14 \\\\\\\\\ng(15) = g(1111_2) = 0000_2 &= 0 \\\\\\\\\n\\end{align}$$\n\nThere exists a simple implementation using bitwise operations for the non-trivial operation described above:\n\n$$g(i) = i ~\\&~ (i+1),$$\n\nwhere $\\&$ is the bitwise AND operator. It is not hard to convince yourself that this solution does the same thing as the operation described above.\n\nNow, we just need to find a way to iterate over all $j$'s, such that $g(j) \\le i \\le j$.\n\nIt is easy to see that we can find all such $j$'s by starting with $i$ and flipping the last unset bit.\nWe will call this operation $h(j)$.\nFor example, for $i = 10$ we have:\n\n$$\\begin{align}\n10 &= 0001010_2 \\\\\\\\\nh(10) = 11 &= 0001011_2 \\\\\\\\\nh(11) = 15 &= 0001111_2 \\\\\\\\\nh(15) = 31 &= 0011111_2 \\\\\\\\\nh(31) = 63 &= 0111111_2 \\\\\\\\\n\\vdots &\n\\end{align}$$\n\nUnsurprisingly, there also exists a simple way to perform $h$ using bitwise operations:\n\n$$h(j) = j ~\\|~ (j+1),$$\n\nwhere $\\|$ is the bitwise OR operator.\n\nThe following image shows a possible interpretation of the Fenwick tree as tree.\nThe nodes of the tree show the ranges they cover.\n\n<center>![Binary Indexed Tree](binary_indexed_tree.png)</center>\n\n## Implementation\n\n### Finding sum in one-dimensional array\n\nHere we present an implementation of the Fenwick tree for sum queries and single updates.\n\nThe normal Fenwick tree can only answer sum queries of the type $[0, r]$ using `sum(int r)`, however we can also answer other queries of the type $[l, r]$ by computing two sums $[0, r]$ and $[0, l-1]$ and subtract them.\nThis is handled in the `sum(int l, int r)` method.\n\nAlso this implementation supports two constructors.\nYou can create a Fenwick tree initialized with zeros, or you can convert an existing array into the Fenwick form.\n\n\n```{.cpp file=fenwick_sum}\nstruct FenwickTree {\n    vector<int> bit;  // binary indexed tree\n    int n;\n\n    FenwickTree(int n) {\n        this->n = n;\n        bit.assign(n, 0);\n    }\n\n    FenwickTree(vector<int> const &a) : FenwickTree(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int r) {\n        int ret = 0;\n        for (; r >= 0; r = (r & (r + 1)) - 1)\n            ret += bit[r];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (; idx < n; idx = idx | (idx + 1))\n            bit[idx] += delta;\n    }\n};\n```\n\n### Linear construction\n\nThe above implementation requires $O(N \\log N)$ time.\nIt's possible to improve that to $O(N)$ time.\n\nThe idea is, that the number $a[i]$ at index $i$ will contribute to the range stored in $bit[i]$, and to all ranges that the index $i | (i + 1)$ contributes to.\nSo by adding the numbers in order, you only have to push the current sum further to the next range, where it will then get pushed further to the next range, and so on.\n\n```cpp\nFenwickTree(vector<int> const &a) : FenwickTree(a.size()){\n    for (int i = 0; i < n; i++) {\n        bit[i] += a[i];\n        int r = i | (i + 1);\n        if (r < n) bit[r] += bit[i];\n    }\n}\n```\n\n### Finding minimum of $[0, r]$ in one-dimensional array { data-toc-label='Finding minimum of <script type=\"math/tex\">[0, r]</script> in one-dimensional array' }\n\nIt is obvious that there is no easy way of finding minimum of range $[l, r]$ using Fenwick tree, as Fenwick tree can only answer queries of type $[0, r]$.\nAdditionally, each time a value is `update`'d, the new value has to be smaller than the current value.\nBoth significant limitations are because the $min$ operation together with the set of integers doesn't form a group, as there are no inverse elements.\n\n```{.cpp file=fenwick_min}\nstruct FenwickTreeMin {\n    vector<int> bit;\n    int n;\n    const int INF = (int)1e9;\n\n    FenwickTreeMin(int n) {\n        this->n = n;\n        bit.assign(n, INF);\n    }\n\n    FenwickTreeMin(vector<int> a) : FenwickTreeMin(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            update(i, a[i]);\n    }\n\n    int getmin(int r) {\n        int ret = INF;\n        for (; r >= 0; r = (r & (r + 1)) - 1)\n            ret = min(ret, bit[r]);\n        return ret;\n    }\n\n    void update(int idx, int val) {\n        for (; idx < n; idx = idx | (idx + 1))\n            bit[idx] = min(bit[idx], val);\n    }\n};\n```\n\nNote: it is possible to implement a Fenwick tree that can handle arbitrary minimum range queries and arbitrary updates.\nThe paper [Efficient Range Minimum Queries using Binary Indexed Trees](http://ioinformatics.org/oi/pdf/v9_2015_39_44.pdf) describes such an approach.\nHowever with that approach you need to maintain a second binary indexed trees over the data, with a slightly different structure, since you one tree is not enough to store the values of all elements in the array.\nThe implementation is also a lot harder compared to the normal implementation for sums.\n\n### Finding sum in two-dimensional array\n\nAs claimed before, it is very easy to implement Fenwick Tree for multidimensional array.\n\n```cpp\nstruct FenwickTree2D {\n    vector<vector<int>> bit;\n    int n, m;\n\n    // init(...) { ... }\n\n    int sum(int x, int y) {\n        int ret = 0;\n        for (int i = x; i >= 0; i = (i & (i + 1)) - 1)\n            for (int j = y; j >= 0; j = (j & (j + 1)) - 1)\n                ret += bit[i][j];\n        return ret;\n    }\n\n    void add(int x, int y, int delta) {\n        for (int i = x; i < n; i = i | (i + 1))\n            for (int j = y; j < m; j = j | (j + 1))\n                bit[i][j] += delta;\n    }\n};\n```\n\n### One-based indexing approach\n\nFor this approach we change the requirements and definition for $T[]$ and $g()$ a little bit.\nWe want $T[i]$ to store the sum of $[g(i)+1; i]$.\nThis changes the implementation a little bit, and allows for a similar nice definition for $g(i)$:\n\n```python\ndef sum(int r):\n    res = 0\n    while (r > 0):\n        res += t[r]\n        r = g(r)\n    return res\n\ndef increase(int i, int delta):\n    for all j with g(j) < i <= j:\n        t[j] += delta\n```\n\nThe computation of $g(i)$ is defined as:\ntoggling of the last set $1$ bit in the binary representation of $i$.\n\n$$\\begin{align}\ng(7) = g(111_2) = 110_2 &= 6 \\\\\\\\\ng(6) = g(110_2) = 100_2 &= 4 \\\\\\\\\ng(4) = g(100_2) = 000_2 &= 0 \\\\\\\\\n\\end{align}$$\n\nThe last set bit can be extracted using $i ~\\&~ (-i)$, so the operation can be expressed as:\n\n$$g(i) = i - (i ~\\&~ (-i)).$$\n\nAnd it's not hard to see, that you need to change all values $T[j]$ in the sequence $i,~ h(i),~ h(h(i)),~ \\dots$ when you want to update $A[j]$, where $h(i)$ is defined as:\n\n$$h(i) = i + (i ~\\&~ (-i)).$$\n\nAs you can see, the main benefit of this approach is that the binary operations complement each other very nicely.\n\nThe following implementation can be used like the other implementations, however it uses one-based indexing internally.\n\n```{.cpp file=fenwick_sum_onebased}\nstruct FenwickTreeOneBasedIndexing {\n    vector<int> bit;  // binary indexed tree\n    int n;\n\n    FenwickTreeOneBasedIndexing(int n) {\n        this->n = n + 1;\n        bit.assign(n + 1, 0);\n    }\n\n    FenwickTreeOneBasedIndexing(vector<int> a)\n        : FenwickTreeOneBasedIndexing(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int idx) {\n        int ret = 0;\n        for (++idx; idx > 0; idx -= idx & -idx)\n            ret += bit[idx];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (++idx; idx < n; idx += idx & -idx)\n            bit[idx] += delta;\n    }\n};\n```\n\n## Range operations\n\nA Fenwick tree can support the following range operations:\n\n1. Point Update and Range Query\n2. Range Update and Point Query\n3. Range Update and Range Query\n\n### 1. Point Update and Range Query\n\nThis is just the ordinary Fenwick tree as explained above.\n\n### 2. Range Update and Point Query\n\nUsing simple tricks we can also do the reverse operations: increasing ranges and querying for single values.\n\nLet the Fenwick tree be initialized with zeros.\nSuppose that we want to increment the interval $[l, r]$ by $x$.\nWe make two point update operations on Fenwick tree which are `add(l, x)` and `add(r+1, -x)`.\n\nIf we want to get the value of $A[i]$, we just need to take the prefix sum using the ordinary range sum method.\nTo see why this is true, we can just focus on the previous increment operation again.\nIf $i < l$, then the two update operations have no effect on the query and we get the sum $0$.\nIf $i \\in [l, r]$, then we get the answer $x$ because of the first update operation.\nAnd if $i > r$, then the second update operation will cancel the effect of first one.\n\nThe following implementation uses one-based indexing.\n\n```cpp\nvoid add(int idx, int val) {\n    for (++idx; idx < n; idx += idx & -idx)\n        bit[idx] += val;\n}\n\nvoid range_add(int l, int r, int val) {\n    add(l, val);\n    add(r + 1, -val);\n}\n\nint point_query(int idx) {\n    int ret = 0;\n    for (++idx; idx > 0; idx -= idx & -idx)\n        ret += bit[idx];\n    return ret;\n}\n```\n\nNote: of course it is also possible to increase a single point $A[i]$ with `range_add(i, i, val)`.\n\n### 3. Range Updates and Range Queries\n\nTo support both range updates and range queries we will use two BITs namely $B_1[]$ and $B_2[]$, initialized with zeros.\n\nSuppose that we want to increment the interval $[l, r]$ by the value $x$.\nSimilarly as in the previous method, we perform two point updates on $B_1$: `add(B1, l, x)` and `add(B1, r+1, -x)`.\nAnd we also update $B_2$. The details will be explained later.\n\n```python\ndef range_add(l, r, x):\n    add(B1, l, x)\n    add(B1, r+1, -x)\n    add(B2, l, x*(l-1))\n    add(B2, r+1, -x*r))\n```\nAfter the range update $(l, r, x)$ the range sum query should return the following values:\n\n$$\nsum[0, i]=\n\\begin{cases}\n0 & i < l \\\\\\\\\nx \\cdot (i-(l-1)) & l \\le i \\le r \\\\\\\\\nx \\cdot (r-l+1) & i > r \\\\\\\\\n\\end{cases}\n$$\n\nWe can write the range sum as difference of two terms, where we use $B_1$ for first term and $B_2$ for second term.\nThe difference of the queries will give us prefix sum over $[0, i]$.\n\n$$\\begin{align}\nsum[0, i] &= sum(B_1, i) \\cdot i - sum(B_2, i) \\\\\\\\\n&= \\begin{cases}\n0 \\cdot i - 0 & i < l\\\\\\\\\nx \\cdot i - x \\cdot (l-1) & l \\le i \\le r \\\\\\\\\n0 \\cdot i - (x \\cdot (l-1) - x \\cdot r) & i > r \\\\\\\\\n\\end{cases}\n\\end{align}\n$$\n\nThe last expression is exactly equal to the required terms.\nThus we can use $B_2$ for shaving off extra terms when we multiply $B_1[i]\\times i$.\n\nWe can find arbitrary range sums by computing the prefix sums for $l-1$ and $r$ and taking the difference of them again.\n\n```python\ndef add(b, idx, x):\n    while idx <= N:\n        b[idx] += x\n        idx += idx & -idx\n\ndef range_add(l,r,x):\n    add(B1, l, x)\n    add(B1, r+1, -x)\n    add(B2, l, x*(l-1))\n    add(B2, r+1, -x*r)\n\ndef sum(b, idx):\n    total = 0\n    while idx > 0:\n        total += b[idx]\n        idx -= idx & -idx\n    return total\n\ndef prefix_sum(idx):\n    return sum(B1, idx)*idx -  sum(B2, idx)\n\ndef range_sum(l, r):\n    return prefix_sum(r) - prefix_sum(l-1)\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: fenwick_tree\n---\n\n# Fenwick Tree\n\nLet, $f$ be some group operation (binary associative function over a set with identity element and inverse elements) and $A$ be an array of integers of length $N$.\n\nFenwick tree is a data structure which:\n\n* calculates the value of function $f$ in the given range $[l, r]$ (i.e. $f(A_l, A_{l+1}, \\dots, A_r)$) in $O(\\log N)$ time;\n* updates the value of an element of $A$ in $O(\\log N)$ time;\n* requires $O(N)$ memory, or in other words, exactly the same memory required for $A$;\n* is easy to use and code, especially, in the case of multidimensional arrays.\n\nThe most common application of Fenwick tree is _calculating the sum of a range_ (i.e. using addition over the set of integers $\\mathbb{Z}$: $f(A_1, A_2, \\dots, A_k) = A_1 + A_2 + \\dots + A_k$).\n\nFenwick tree is also called **Binary Indexed Tree**, or just **BIT** abbreviated.\n\nFenwick tree was first described in a paper titled \"A new data structure for cumulative frequency tables\" (Peter M. Fenwick, 1994).\n\n## Description\n\n### Overview\n\nFor the sake of simplicity, we will assume that function $f$ is just a *sum function*.\n\nGiven an array of integers $A[0 \\dots N-1]$.\nA Fenwick tree is just an array $T[0 \\dots N-1]$, where each of its elements is equal to the sum of elements of $A$ in some range $[g(i), i]$:\n\n$$T_i = \\sum_{j = g(i)}^{i}{A_j},$$\n\nwhere $g$ is some function that satisfies $0 \\le g(i) \\le i$.\nWe will define the function in the next few paragraphs.\n\nThe data structure is called tree, because there is a nice representation of the data structure as tree, although we don't need to model an actual tree with nodes and edges.\nWe will only need to maintain the array $T$ to handle all queries.\n\n**Note:** The Fenwick tree presented here uses zero-based indexing.\nMany people will actually use a version of the Fenwick tree that uses one-based indexing.\nTherefore you will also find an alternative implementation using one-based indexing in the implementation section.\nBoth versions are equivalent in terms of time and memory complexity.\n\nNow we can write some pseudo-code for the two operations mentioned above - get the sum of elements of $A$ in the range $[0, r]$ and update (increase) some element $A_i$:\n\n```python\ndef sum(int r):\n    res = 0\n    while (r >= 0):\n        res += t[r]\n        r = g(r) - 1\n    return res\n\ndef increase(int i, int delta):\n    for all j with g(j) <= i <= j:\n        t[j] += delta\n```\n\nThe function `sum` works as follows:\n\n1. first, it adds the sum of the range $[g(r), r]$ (i.e. $T[r]$) to the `result`\n2. then, it \"jumps\" to the range $[g(g(r)-1), g(r)-1]$, and adds this range's sum to the `result`\n3. and so on, until it \"jumps\" from $[0, g(g( \\dots g(r)-1 \\dots -1)-1)]$ to $[g(-1), -1]$; that is where the `sum` function stops jumping.\n\nThe function `increase` works with the same analogy, but \"jumps\" in the direction of increasing indices:\n\n1. sums of the ranges $[g(j), j]$ that satisfy the condition $g(j) \\le i \\le j$ are increased by `delta` , that is `t[j] += delta`. Therefore we updated all elements in $T$ that correspond to ranges in which $A_i$ lies.\n\nIt is obvious that the complexity of both `sum` and `increase` depend on the function $g$.\nThere are lots of ways to choose the function $g$, as long as $0 \\le g(i) \\le i$ for all $i$.\nFor instance the function $g(i) = i$ works, which results just in $T = A$, and therefore summation queries are slow.\nWe can also take the function $g(i) = 0$.\nThis will correspond to prefix sum arrays, which means that finding the sum of the range $[0, i]$ will only take constant time, but updates are slow.\nThe clever part of the Fenwick algorithm is, that there it uses a special definition of the function $g$ that can handle both operations in $O(\\log N)$ time.\n\n### Definition of $g(i)$ { data-toc-label='Definition of <script type=\"math/tex\">g(i)</script>' }\n\nThe computation of $g(i)$ is defined using the following simple operation:\nwe replace all trailing $1$ bits in the binary representation of $i$ with $0$ bits.\n\nIn other words, if the least significant digit of $i$ in binary is $0$, then $g(i) = i$.\nAnd otherwise the least significant digit is a $1$, and we take this $1$ and all other trailing $1$s and flip them.\n\nFor instance we get\n\n$$\\begin{align}\ng(11) = g(1011_2) = 1000_2 &= 8 \\\\\\\\\ng(12) = g(1100_2) = 1100_2 &= 12 \\\\\\\\\ng(13) = g(1101_2) = 1100_2 &= 12 \\\\\\\\\ng(14) = g(1110_2) = 1110_2 &= 14 \\\\\\\\\ng(15) = g(1111_2) = 0000_2 &= 0 \\\\\\\\\n\\end{align}$$\n\nThere exists a simple implementation using bitwise operations for the non-trivial operation described above:\n\n$$g(i) = i ~\\&~ (i+1),$$\n\nwhere $\\&$ is the bitwise AND operator. It is not hard to convince yourself that this solution does the same thing as the operation described above.\n\nNow, we just need to find a way to iterate over all $j$'s, such that $g(j) \\le i \\le j$.\n\nIt is easy to see that we can find all such $j$'s by starting with $i$ and flipping the last unset bit.\nWe will call this operation $h(j)$.\nFor example, for $i = 10$ we have:\n\n$$\\begin{align}\n10 &= 0001010_2 \\\\\\\\\nh(10) = 11 &= 0001011_2 \\\\\\\\\nh(11) = 15 &= 0001111_2 \\\\\\\\\nh(15) = 31 &= 0011111_2 \\\\\\\\\nh(31) = 63 &= 0111111_2 \\\\\\\\\n\\vdots &\n\\end{align}$$\n\nUnsurprisingly, there also exists a simple way to perform $h$ using bitwise operations:\n\n$$h(j) = j ~\\|~ (j+1),$$\n\nwhere $\\|$ is the bitwise OR operator.\n\nThe following image shows a possible interpretation of the Fenwick tree as tree.\nThe nodes of the tree show the ranges they cover.\n\n<center>![Binary Indexed Tree](binary_indexed_tree.png)</center>\n\n## Implementation\n\n### Finding sum in one-dimensional array\n\nHere we present an implementation of the Fenwick tree for sum queries and single updates.\n\nThe normal Fenwick tree can only answer sum queries of the type $[0, r]$ using `sum(int r)`, however we can also answer other queries of the type $[l, r]$ by computing two sums $[0, r]$ and $[0, l-1]$ and subtract them.\nThis is handled in the `sum(int l, int r)` method.\n\nAlso this implementation supports two constructors.\nYou can create a Fenwick tree initialized with zeros, or you can convert an existing array into the Fenwick form.\n\n\n```{.cpp file=fenwick_sum}\nstruct FenwickTree {\n    vector<int> bit;  // binary indexed tree\n    int n;\n\n    FenwickTree(int n) {\n        this->n = n;\n        bit.assign(n, 0);\n    }\n\n    FenwickTree(vector<int> const &a) : FenwickTree(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int r) {\n        int ret = 0;\n        for (; r >= 0; r = (r & (r + 1)) - 1)\n            ret += bit[r];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (; idx < n; idx = idx | (idx + 1))\n            bit[idx] += delta;\n    }\n};\n```\n\n### Linear construction\n\nThe above implementation requires $O(N \\log N)$ time.\nIt's possible to improve that to $O(N)$ time.\n\nThe idea is, that the number $a[i]$ at index $i$ will contribute to the range stored in $bit[i]$, and to all ranges that the index $i | (i + 1)$ contributes to.\nSo by adding the numbers in order, you only have to push the current sum further to the next range, where it will then get pushed further to the next range, and so on.\n\n```cpp\nFenwickTree(vector<int> const &a) : FenwickTree(a.size()){\n    for (int i = 0; i < n; i++) {\n        bit[i] += a[i];\n        int r = i | (i + 1);\n        if (r < n) bit[r] += bit[i];\n    }\n}\n```\n\n### Finding minimum of $[0, r]$ in one-dimensional array { data-toc-label='Finding minimum of <script type=\"math/tex\">[0, r]</script> in one-dimensional array' }\n\nIt is obvious that there is no easy way of finding minimum of range $[l, r]$ using Fenwick tree, as Fenwick tree can only answer queries of type $[0, r]$.\nAdditionally, each time a value is `update`'d, the new value has to be smaller than the current value.\nBoth significant limitations are because the $min$ operation together with the set of integers doesn't form a group, as there are no inverse elements.\n\n```{.cpp file=fenwick_min}\nstruct FenwickTreeMin {\n    vector<int> bit;\n    int n;\n    const int INF = (int)1e9;\n\n    FenwickTreeMin(int n) {\n        this->n = n;\n        bit.assign(n, INF);\n    }\n\n    FenwickTreeMin(vector<int> a) : FenwickTreeMin(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            update(i, a[i]);\n    }\n\n    int getmin(int r) {\n        int ret = INF;\n        for (; r >= 0; r = (r & (r + 1)) - 1)\n            ret = min(ret, bit[r]);\n        return ret;\n    }\n\n    void update(int idx, int val) {\n        for (; idx < n; idx = idx | (idx + 1))\n            bit[idx] = min(bit[idx], val);\n    }\n};\n```\n\nNote: it is possible to implement a Fenwick tree that can handle arbitrary minimum range queries and arbitrary updates.\nThe paper [Efficient Range Minimum Queries using Binary Indexed Trees](http://ioinformatics.org/oi/pdf/v9_2015_39_44.pdf) describes such an approach.\nHowever with that approach you need to maintain a second binary indexed trees over the data, with a slightly different structure, since you one tree is not enough to store the values of all elements in the array.\nThe implementation is also a lot harder compared to the normal implementation for sums.\n\n### Finding sum in two-dimensional array\n\nAs claimed before, it is very easy to implement Fenwick Tree for multidimensional array.\n\n```cpp\nstruct FenwickTree2D {\n    vector<vector<int>> bit;\n    int n, m;\n\n    // init(...) { ... }\n\n    int sum(int x, int y) {\n        int ret = 0;\n        for (int i = x; i >= 0; i = (i & (i + 1)) - 1)\n            for (int j = y; j >= 0; j = (j & (j + 1)) - 1)\n                ret += bit[i][j];\n        return ret;\n    }\n\n    void add(int x, int y, int delta) {\n        for (int i = x; i < n; i = i | (i + 1))\n            for (int j = y; j < m; j = j | (j + 1))\n                bit[i][j] += delta;\n    }\n};\n```\n\n### One-based indexing approach\n\nFor this approach we change the requirements and definition for $T[]$ and $g()$ a little bit.\nWe want $T[i]$ to store the sum of $[g(i)+1; i]$.\nThis changes the implementation a little bit, and allows for a similar nice definition for $g(i)$:\n\n```python\ndef sum(int r):\n    res = 0\n    while (r > 0):\n        res += t[r]\n        r = g(r)\n    return res\n\ndef increase(int i, int delta):\n    for all j with g(j) < i <= j:\n        t[j] += delta\n```\n\nThe computation of $g(i)$ is defined as:\ntoggling of the last set $1$ bit in the binary representation of $i$.\n\n$$\\begin{align}\ng(7) = g(111_2) = 110_2 &= 6 \\\\\\\\\ng(6) = g(110_2) = 100_2 &= 4 \\\\\\\\\ng(4) = g(100_2) = 000_2 &= 0 \\\\\\\\\n\\end{align}$$\n\nThe last set bit can be extracted using $i ~\\&~ (-i)$, so the operation can be expressed as:\n\n$$g(i) = i - (i ~\\&~ (-i)).$$\n\nAnd it's not hard to see, that you need to change all values $T[j]$ in the sequence $i,~ h(i),~ h(h(i)),~ \\dots$ when you want to update $A[j]$, where $h(i)$ is defined as:\n\n$$h(i) = i + (i ~\\&~ (-i)).$$\n\nAs you can see, the main benefit of this approach is that the binary operations complement each other very nicely.\n\nThe following implementation can be used like the other implementations, however it uses one-based indexing internally.\n\n```{.cpp file=fenwick_sum_onebased}\nstruct FenwickTreeOneBasedIndexing {\n    vector<int> bit;  // binary indexed tree\n    int n;\n\n    FenwickTreeOneBasedIndexing(int n) {\n        this->n = n + 1;\n        bit.assign(n + 1, 0);\n    }\n\n    FenwickTreeOneBasedIndexing(vector<int> a)\n        : FenwickTreeOneBasedIndexing(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int idx) {\n        int ret = 0;\n        for (++idx; idx > 0; idx -= idx & -idx)\n            ret += bit[idx];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (++idx; idx < n; idx += idx & -idx)\n            bit[idx] += delta;\n    }\n};\n```\n\n## Range operations\n\nA Fenwick tree can support the following range operations:\n\n1. Point Update and Range Query\n2. Range Update and Point Query\n3. Range Update and Range Query\n\n### 1. Point Update and Range Query\n\nThis is just the ordinary Fenwick tree as explained above.\n\n### 2. Range Update and Point Query\n\nUsing simple tricks we can also do the reverse operations: increasing ranges and querying for single values.\n\nLet the Fenwick tree be initialized with zeros.\nSuppose that we want to increment the interval $[l, r]$ by $x$.\nWe make two point update operations on Fenwick tree which are `add(l, x)` and `add(r+1, -x)`.\n\nIf we want to get the value of $A[i]$, we just need to take the prefix sum using the ordinary range sum method.\nTo see why this is true, we can just focus on the previous increment operation again.\nIf $i < l$, then the two update operations have no effect on the query and we get the sum $0$.\nIf $i \\in [l, r]$, then we get the answer $x$ because of the first update operation.\nAnd if $i > r$, then the second update operation will cancel the effect of first one.\n\nThe following implementation uses one-based indexing.\n\n```cpp\nvoid add(int idx, int val) {\n    for (++idx; idx < n; idx += idx & -idx)\n        bit[idx] += val;\n}\n\nvoid range_add(int l, int r, int val) {\n    add(l, val);\n    add(r + 1, -val);\n}\n\nint point_query(int idx) {\n    int ret = 0;\n    for (++idx; idx > 0; idx -= idx & -idx)\n        ret += bit[idx];\n    return ret;\n}\n```\n\nNote: of course it is also possible to increase a single point $A[i]$ with `range_add(i, i, val)`.\n\n### 3. Range Updates and Range Queries\n\nTo support both range updates and range queries we will use two BITs namely $B_1[]$ and $B_2[]$, initialized with zeros.\n\nSuppose that we want to increment the interval $[l, r]$ by the value $x$.\nSimilarly as in the previous method, we perform two point updates on $B_1$: `add(B1, l, x)` and `add(B1, r+1, -x)`.\nAnd we also update $B_2$. The details will be explained later.\n\n```python\ndef range_add(l, r, x):\n    add(B1, l, x)\n    add(B1, r+1, -x)\n    add(B2, l, x*(l-1))\n    add(B2, r+1, -x*r))\n```\nAfter the range update $(l, r, x)$ the range sum query should return the following values:\n\n$$\nsum[0, i]=\n\\begin{cases}\n0 & i < l \\\\\\\\\nx \\cdot (i-(l-1)) & l \\le i \\le r \\\\\\\\\nx \\cdot (r-l+1) & i > r \\\\\\\\\n\\end{cases}\n$$\n\nWe can write the range sum as difference of two terms, where we use $B_1$ for first term and $B_2$ for second term.\nThe difference of the queries will give us prefix sum over $[0, i]$.\n\n$$\\begin{align}\nsum[0, i] &= sum(B_1, i) \\cdot i - sum(B_2, i) \\\\\\\\\n&= \\begin{cases}\n0 \\cdot i - 0 & i < l\\\\\\\\\nx \\cdot i - x \\cdot (l-1) & l \\le i \\le r \\\\\\\\\n0 \\cdot i - (x \\cdot (l-1) - x \\cdot r) & i > r \\\\\\\\\n\\end{cases}\n\\end{align}\n$$\n\nThe last expression is exactly equal to the required terms.\nThus we can use $B_2$ for shaving off extra terms when we multiply $B_1[i]\\times i$.\n\nWe can find arbitrary range sums by computing the prefix sums for $l-1$ and $r$ and taking the difference of them again.\n\n```python\ndef add(b, idx, x):\n    while idx <= N:\n        b[idx] += x\n        idx += idx & -idx\n\ndef range_add(l,r,x):\n    add(B1, l, x)\n    add(B1, r+1, -x)\n    add(B2, l, x*(l-1))\n    add(B2, r+1, -x*r)\n\ndef sum(b, idx):\n    total = 0\n    while idx > 0:\n        total += b[idx]\n        idx -= idx & -idx\n    return total\n\ndef prefix_sum(idx):\n    return sum(B1, idx)*idx -  sum(B2, idx)\n\ndef range_sum(l, r):\n    return prefix_sum(r) - prefix_sum(l-1)\n```\n\n## Practice Problems\n\n* [UVA 12086 - Potentiometers](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3238)\n* [LOJ 1112 - Curious Robin Hood](http://www.lightoj.com/volume_showproblem.php?problem=1112)\n* [LOJ 1266 - Points in Rectangle](http://www.lightoj.com/volume_showproblem.php?problem=1266 \"2D Fenwick Tree\")\n* [Codechef - SPREAD](http://www.codechef.com/problems/SPREAD)\n* [SPOJ - CTRICK](http://www.spoj.com/problems/CTRICK/)\n* [SPOJ - MATSUM](http://www.spoj.com/problems/MATSUM/)\n* [SPOJ - DQUERY](http://www.spoj.com/problems/DQUERY/)\n* [SPOJ - NKTEAM](http://www.spoj.com/problems/NKTEAM/)\n* [SPOJ - YODANESS](http://www.spoj.com/problems/YODANESS/)\n* [SRM 310 - FloatingMedian](https://community.topcoder.com/stat?c=problem_statement&pm=6551&rd=9990)\n* [SPOJ - Ada and Behives](http://www.spoj.com/problems/ADABEHIVE/)\n* [Hackerearth - Counting in Byteland](https://www.hackerearth.com/practice/data-structures/advanced-data-structures/fenwick-binary-indexed-trees/practice-problems/algorithm/counting-in-byteland/)\n* [DevSkill - Shan and String (archived)](http://web.archive.org/web/20210322010617/https://devskill.com/CodingProblems/ViewProblem/300)\n* [Codeforces - Little Artem and Time Machine](http://codeforces.com/contest/669/problem/E)\n* [Codeforces - Hanoi Factory](http://codeforces.com/contest/777/problem/E)\n* [SPOJ - Tulip and Numbers](http://www.spoj.com/problems/TULIPNUM/)\n* [SPOJ - SUMSUM](http://www.spoj.com/problems/SUMSUM/)\n* [SPOJ - Sabir and Gifts](http://www.spoj.com/problems/SGIFT/)\n* [SPOJ - The Permutation Game Again](http://www.spoj.com/problems/TPGA/)\n* [SPOJ - Zig when you Zag](http://www.spoj.com/problems/ZIGZAG2/)\n* [SPOJ - Cryon](http://www.spoj.com/problems/CRAYON/)\n* [SPOJ - Weird Points](http://www.spoj.com/problems/DCEPC705/)\n* [SPOJ - Its a Murder](http://www.spoj.com/problems/DCEPC206/)\n* [SPOJ - Bored of Suffixes and Prefixes](http://www.spoj.com/problems/KOPC12G/)\n* [SPOJ - Mega Inversions](http://www.spoj.com/problems/TRIPINV/)\n* [Codeforces - Subsequences](http://codeforces.com/contest/597/problem/C)\n* [Codeforces - Ball](http://codeforces.com/contest/12/problem/D)\n* [GYM - The Kamphaeng Phet's Chedis](http://codeforces.com/gym/101047/problem/J)\n* [Codeforces - Garlands](http://codeforces.com/contest/707/problem/E)\n* [Codeforces - Inversions after Shuffle](http://codeforces.com/contest/749/problem/E)\n* [GYM - Cairo Market](http://codeforces.com/problemset/gymProblem/101055/D)\n* [Codeforces - Goodbye Souvenir](http://codeforces.com/contest/849/problem/E)\n* [SPOJ - Ada and Species](http://www.spoj.com/problems/ADACABAA/)\n* [Codeforces - Thor](https://codeforces.com/problemset/problem/704/A)\n* [CSES - Forest Queries II](https://cses.fi/problemset/task/1739/)\n* [Latin American Regionals 2017 - Fundraising](http://matcomgrader.com/problem/9346/fundraising/)\n\n## Other sources\n\n* [Fenwick tree on Wikipedia](http://en.wikipedia.org/wiki/Fenwick_tree)\n* [Binary indexed trees tutorial on TopCoder](https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/)\n* [Range updates and queries ](https://programmingcontests.quora.com/Tutorial-Range-Updates-in-Fenwick-Tree)\n", "problem_ids": ["669_E", "777_E", "597_C", "12_D", "707_E", "849_E", "704_A"], "title": "Fenwick Tree"}, {"article": "---\ntags:\n  - Original\n---\n\n# Sparse Table\n\nSparse Table is a data structure, that allows answering range queries.\nIt can answer most range queries in $O(\\log n)$, but its true power is answering range minimum queries (or equivalent range maximum queries).\nFor those queries it can compute the answer in $O(1)$ time.\n\nThe only drawback of this data structure is, that it can only be used on _immutable_ arrays.\nThis means, that the array cannot be changed between two queries.\nIf any element in the array changes, the complete data structure has to be recomputed.\n\n## Intuition\n\nAny non-negative number can be uniquely represented as a sum of decreasing powers of two.\nThis is just a variant of the binary representation of a number.\nE.g. $13 = (1101)_2 = 8 + 4 + 1$.\nFor a number $x$ there can be at most $\\lceil \\log_2 x \\rceil$ summands.\n\nBy the same reasoning any interval can be uniquely represented as a union of intervals with lengths that are decreasing powers of two.\nE.g. $[2, 14] = [2, 9] \\cup [10, 13] \\cup [14, 14]$, where the complete interval has length 13, and the individual intervals have the lengths 8, 4 and 1 respectively.\nAnd also here the union consists of at most $\\lceil \\log_2(\\text{length of interval}) \\rceil$ many intervals.\n\nThe main idea behind Sparse Tables is to precompute all answers for range queries with power of two length.\nAfterwards a different range query can be answered by splitting the range into ranges with power of two lengths, looking up the precomputed answers, and combining them to receive a complete answer.\n\n## Precomputation\n\nWe will use a 2-dimensional array for storing the answers to the precomputed queries.\n$\\text{st}[i][j]$ will store the answer for the range $[j, j + 2^i - 1]$ of length $2^i$.\nThe size of the 2-dimensional array will be $(K + 1) \\times \\text{MAXN}$, where $\\text{MAXN}$ is the biggest possible array length.\n$\\text{K}$ has to satisfy $\\text{K} \\ge \\lfloor \\log_2 \\text{MAXN} \\rfloor$, because $2^{\\lfloor \\log_2 \\text{MAXN} \\rfloor}$ is the biggest power of two range, that we have to support.\nFor arrays with reasonable length ($\\le 10^7$ elements), $K = 25$ is a good value.\n\nThe $\\text{MAXN}$ dimension is second to allow (cache friendly) consecutive memory accesses.\n\n```{.cpp file=sparsetable_definition}\nint st[K + 1][MAXN];\n```\n\nBecause the range $[j, j + 2^i - 1]$ of length $2^i$ splits nicely into the ranges $[j, j + 2^{i - 1} - 1]$ and $[j + 2^{i - 1}, j + 2^i - 1]$, both of length $2^{i - 1}$, we can generate the table efficiently using dynamic programming:\n\n```{.cpp file=sparsetable_generation}\nstd::copy(array.begin(), array.end(), st[0]);\n\nfor (int i = 1; i <= K; i++)\n    for (int j = 0; j + (1 << i) <= N; j++)\n        st[i][j] = f(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n```\n\nThe function $f$ will depend on the type of query.\nFor range sum queries it will compute the sum, for range minimum queries it will compute the minimum.\n\nThe time complexity of the precomputation is $O(\\text{N} \\log \\text{N})$.\n\n## Range Sum Queries\n\nFor this type of queries, we want to find the sum of all values in a range.\nTherefore the natural definition of the function $f$ is $f(x, y) = x + y$.\nWe can construct the data structure with:\n\n```{.cpp file=sparsetable_sum_generation}\nlong long st[K + 1][MAXN];\n\nstd::copy(array.begin(), array.end(), st[0]);\n\nfor (int i = 1; i <= K; i++)\n    for (int j = 0; j + (1 << i) <= N; j++)\n        st[i][j] = st[i - 1][j] + st[i - 1][j + (1 << (i - 1))];\n```\n\nTo answer the sum query for the range $[L, R]$, we iterate over all powers of two, starting from the biggest one.\nAs soon as a power of two $2^i$ is smaller or equal to the length of the range ($= R - L + 1$), we process the first part of range $[L, L + 2^i - 1]$, and continue with the remaining range $[L + 2^i, R]$.\n\n```{.cpp file=sparsetable_sum_query}\nlong long sum = 0;\nfor (int i = K; i >= 0; i--) {\n    if ((1 << i) <= R - L + 1) {\n        sum += st[i][L];\n        L += 1 << i;\n    }\n}\n```\n\nTime complexity for a Range Sum Query is $O(K) = O(\\log \\text{MAXN})$.\n\n## Range Minimum Queries (RMQ)\n\nThese are the queries where the Sparse Table shines.\nWhen computing the minimum of a range, it doesn't matter if we process a value in the range once or twice.\nTherefore instead of splitting a range into multiple ranges, we can also split the range into only two overlapping ranges with power of two length.\nE.g. we can split the range $[1, 6]$ into the ranges $[1, 4]$ and $[3, 6]$.\nThe range minimum of $[1, 6]$ is clearly the same as the minimum of the range minimum of $[1, 4]$ and the range minimum of $[3, 6]$.\nSo we can compute the minimum of the range $[L, R]$ with:\n\n$$\\min(\\text{st}[i][L], \\text{st}[i][R - 2^i + 1]) \\quad \\text{ where } i = \\log_2(R - L + 1)$$\n\nThis requires that we are able to compute $\\log_2(R - L + 1)$ fast.\nYou can accomplish that by precomputing all logarithms:\n\n```{.cpp file=sparse_table_log_table}\nint lg[MAXN+1];\nlg[1] = 0;\nfor (int i = 2; i <= MAXN; i++)\n    lg[i] = lg[i/2] + 1;\n```\nAlternatively, log can be computed on the fly in constant space and time:\n```c++\n// C++20\n#include <bit>\nint log2_floor(unsigned long i) {\n    return std::bit_width(i) - 1;\n}\n\n// pre C++20\nint log2_floor(unsigned long long i) {\n    return i ? __builtin_clzll(1) - __builtin_clzll(i) : -1;\n}\n```\n[This benchmark](https://quick-bench.com/q/Zghbdj_TEkmw4XG2nqOpD3tsJ8U) shows that using `lg` array is slower because of cache misses.\n\nAfterwards we need to precompute the Sparse Table structure. This time we define $f$ with $f(x, y) = \\min(x, y)$.\n\n```{.cpp file=sparse_table_minimum_generation}\nint st[K + 1][MAXN];\n\nstd::copy(array.begin(), array.end(), st[0]);\n\nfor (int i = 1; i <= K; i++)\n    for (int j = 0; j + (1 << i) <= N; j++)\n        st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n```\n\nAnd the minimum of a range $[L, R]$ can be computed with:\n\n```{.cpp file=sparse_table_minimum_query}\nint i = lg[R - L + 1];\nint minimum = min(st[i][L], st[i][R - (1 << i) + 1]);\n```\n\nTime complexity for a Range Minimum Query is $O(1)$.\n\n## Similar data structures supporting more types of queries\n\nOne of the main weakness of the $O(1)$ approach discussed in the previous section is, that this approach only supports queries of [idempotent functions](https://en.wikipedia.org/wiki/Idempotence).\nI.e. it works great for range minimum queries, but it is not possible to answer range sum queries using this approach.\n\nThere are similar data structures that can handle any type of associative functions and answer range queries in $O(1)$.\nOne of them is called [Disjoint Sparse Table](https://discuss.codechef.com/questions/117696/tutorial-disjoint-sparse-table).\nAnother one would be the [Sqrt Tree](sqrt-tree.md).\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Sparse Table\n\nSparse Table is a data structure, that allows answering range queries.\nIt can answer most range queries in $O(\\log n)$, but its true power is answering range minimum queries (or equivalent range maximum queries).\nFor those queries it can compute the answer in $O(1)$ time.\n\nThe only drawback of this data structure is, that it can only be used on _immutable_ arrays.\nThis means, that the array cannot be changed between two queries.\nIf any element in the array changes, the complete data structure has to be recomputed.\n\n## Intuition\n\nAny non-negative number can be uniquely represented as a sum of decreasing powers of two.\nThis is just a variant of the binary representation of a number.\nE.g. $13 = (1101)_2 = 8 + 4 + 1$.\nFor a number $x$ there can be at most $\\lceil \\log_2 x \\rceil$ summands.\n\nBy the same reasoning any interval can be uniquely represented as a union of intervals with lengths that are decreasing powers of two.\nE.g. $[2, 14] = [2, 9] \\cup [10, 13] \\cup [14, 14]$, where the complete interval has length 13, and the individual intervals have the lengths 8, 4 and 1 respectively.\nAnd also here the union consists of at most $\\lceil \\log_2(\\text{length of interval}) \\rceil$ many intervals.\n\nThe main idea behind Sparse Tables is to precompute all answers for range queries with power of two length.\nAfterwards a different range query can be answered by splitting the range into ranges with power of two lengths, looking up the precomputed answers, and combining them to receive a complete answer.\n\n## Precomputation\n\nWe will use a 2-dimensional array for storing the answers to the precomputed queries.\n$\\text{st}[i][j]$ will store the answer for the range $[j, j + 2^i - 1]$ of length $2^i$.\nThe size of the 2-dimensional array will be $(K + 1) \\times \\text{MAXN}$, where $\\text{MAXN}$ is the biggest possible array length.\n$\\text{K}$ has to satisfy $\\text{K} \\ge \\lfloor \\log_2 \\text{MAXN} \\rfloor$, because $2^{\\lfloor \\log_2 \\text{MAXN} \\rfloor}$ is the biggest power of two range, that we have to support.\nFor arrays with reasonable length ($\\le 10^7$ elements), $K = 25$ is a good value.\n\nThe $\\text{MAXN}$ dimension is second to allow (cache friendly) consecutive memory accesses.\n\n```{.cpp file=sparsetable_definition}\nint st[K + 1][MAXN];\n```\n\nBecause the range $[j, j + 2^i - 1]$ of length $2^i$ splits nicely into the ranges $[j, j + 2^{i - 1} - 1]$ and $[j + 2^{i - 1}, j + 2^i - 1]$, both of length $2^{i - 1}$, we can generate the table efficiently using dynamic programming:\n\n```{.cpp file=sparsetable_generation}\nstd::copy(array.begin(), array.end(), st[0]);\n\nfor (int i = 1; i <= K; i++)\n    for (int j = 0; j + (1 << i) <= N; j++)\n        st[i][j] = f(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n```\n\nThe function $f$ will depend on the type of query.\nFor range sum queries it will compute the sum, for range minimum queries it will compute the minimum.\n\nThe time complexity of the precomputation is $O(\\text{N} \\log \\text{N})$.\n\n## Range Sum Queries\n\nFor this type of queries, we want to find the sum of all values in a range.\nTherefore the natural definition of the function $f$ is $f(x, y) = x + y$.\nWe can construct the data structure with:\n\n```{.cpp file=sparsetable_sum_generation}\nlong long st[K + 1][MAXN];\n\nstd::copy(array.begin(), array.end(), st[0]);\n\nfor (int i = 1; i <= K; i++)\n    for (int j = 0; j + (1 << i) <= N; j++)\n        st[i][j] = st[i - 1][j] + st[i - 1][j + (1 << (i - 1))];\n```\n\nTo answer the sum query for the range $[L, R]$, we iterate over all powers of two, starting from the biggest one.\nAs soon as a power of two $2^i$ is smaller or equal to the length of the range ($= R - L + 1$), we process the first part of range $[L, L + 2^i - 1]$, and continue with the remaining range $[L + 2^i, R]$.\n\n```{.cpp file=sparsetable_sum_query}\nlong long sum = 0;\nfor (int i = K; i >= 0; i--) {\n    if ((1 << i) <= R - L + 1) {\n        sum += st[i][L];\n        L += 1 << i;\n    }\n}\n```\n\nTime complexity for a Range Sum Query is $O(K) = O(\\log \\text{MAXN})$.\n\n## Range Minimum Queries (RMQ)\n\nThese are the queries where the Sparse Table shines.\nWhen computing the minimum of a range, it doesn't matter if we process a value in the range once or twice.\nTherefore instead of splitting a range into multiple ranges, we can also split the range into only two overlapping ranges with power of two length.\nE.g. we can split the range $[1, 6]$ into the ranges $[1, 4]$ and $[3, 6]$.\nThe range minimum of $[1, 6]$ is clearly the same as the minimum of the range minimum of $[1, 4]$ and the range minimum of $[3, 6]$.\nSo we can compute the minimum of the range $[L, R]$ with:\n\n$$\\min(\\text{st}[i][L], \\text{st}[i][R - 2^i + 1]) \\quad \\text{ where } i = \\log_2(R - L + 1)$$\n\nThis requires that we are able to compute $\\log_2(R - L + 1)$ fast.\nYou can accomplish that by precomputing all logarithms:\n\n```{.cpp file=sparse_table_log_table}\nint lg[MAXN+1];\nlg[1] = 0;\nfor (int i = 2; i <= MAXN; i++)\n    lg[i] = lg[i/2] + 1;\n```\nAlternatively, log can be computed on the fly in constant space and time:\n```c++\n// C++20\n#include <bit>\nint log2_floor(unsigned long i) {\n    return std::bit_width(i) - 1;\n}\n\n// pre C++20\nint log2_floor(unsigned long long i) {\n    return i ? __builtin_clzll(1) - __builtin_clzll(i) : -1;\n}\n```\n[This benchmark](https://quick-bench.com/q/Zghbdj_TEkmw4XG2nqOpD3tsJ8U) shows that using `lg` array is slower because of cache misses.\n\nAfterwards we need to precompute the Sparse Table structure. This time we define $f$ with $f(x, y) = \\min(x, y)$.\n\n```{.cpp file=sparse_table_minimum_generation}\nint st[K + 1][MAXN];\n\nstd::copy(array.begin(), array.end(), st[0]);\n\nfor (int i = 1; i <= K; i++)\n    for (int j = 0; j + (1 << i) <= N; j++)\n        st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n```\n\nAnd the minimum of a range $[L, R]$ can be computed with:\n\n```{.cpp file=sparse_table_minimum_query}\nint i = lg[R - L + 1];\nint minimum = min(st[i][L], st[i][R - (1 << i) + 1]);\n```\n\nTime complexity for a Range Minimum Query is $O(1)$.\n\n## Similar data structures supporting more types of queries\n\nOne of the main weakness of the $O(1)$ approach discussed in the previous section is, that this approach only supports queries of [idempotent functions](https://en.wikipedia.org/wiki/Idempotence).\nI.e. it works great for range minimum queries, but it is not possible to answer range sum queries using this approach.\n\nThere are similar data structures that can handle any type of associative functions and answer range queries in $O(1)$.\nOne of them is called [Disjoint Sparse Table](https://discuss.codechef.com/questions/117696/tutorial-disjoint-sparse-table).\nAnother one would be the [Sqrt Tree](sqrt-tree.md).\n\n## Practice Problems\n\n* [SPOJ - RMQSQ](http://www.spoj.com/problems/RMQSQ/)\n* [SPOJ - THRBL](http://www.spoj.com/problems/THRBL/)\n* [Codechef - MSTICK](https://www.codechef.com/problems/MSTICK)\n* [Codechef - SEAD](https://www.codechef.com/problems/SEAD)\n* [Codeforces - CGCDSSQ](http://codeforces.com/contest/475/problem/D)\n* [Codeforces - R2D2 and Droid Army](http://codeforces.com/problemset/problem/514/D)\n* [Codeforces - Maximum of Maximums of Minimums](http://codeforces.com/problemset/problem/872/B)\n* [SPOJ - Miraculous](http://www.spoj.com/problems/TNVFC1M/)\n* [DevSkill - Multiplication Interval (archived)](http://web.archive.org/web/20200922003506/https://devskill.com/CodingProblems/ViewProblem/19)\n* [Codeforces - Animals and Puzzles](http://codeforces.com/contest/713/problem/D)\n* [Codeforces - Trains and Statistics](http://codeforces.com/contest/675/problem/E)\n* [SPOJ - Postering](http://www.spoj.com/problems/POSTERIN/)\n* [SPOJ - Negative Score](http://www.spoj.com/problems/RPLN/)\n* [SPOJ - A Famous City](http://www.spoj.com/problems/CITY2/)\n* [SPOJ - Diferencija](http://www.spoj.com/problems/DIFERENC/)\n* [Codeforces - Turn off the TV](http://codeforces.com/contest/863/problem/E)\n* [Codeforces - Map](http://codeforces.com/contest/15/problem/D)\n* [Codeforces - Awards for Contestants](http://codeforces.com/contest/873/problem/E)\n* [Codeforces - Longest Regular Bracket Sequence](http://codeforces.com/contest/5/problem/C)\n* [Codeforces - Array Stabilization (GCD version)](http://codeforces.com/problemset/problem/1547/F)\n", "problem_ids": ["475_D", "514_D", "15_D", "5_C", "1547_F"], "title": "Sparse Table"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: treap\n---\n\n# Treap (Cartesian tree)\n\nA treap is a data structure which combines binary tree and binary heap (hence the name: tree + heap $\\Rightarrow$ Treap).\n\nMore specifically, treap is a data structure that stores pairs $(X, Y)$ in a binary tree in such a way that it is a binary search tree by $X$ and a binary heap by $Y$.\nIf some node of the tree contains values $(X_0, Y_0)$, all nodes in the left subtree have $X \\leq X_0$, all nodes in the right subtree have $X_0 \\leq X$, and all nodes in both left and right subtrees have $Y \\leq Y_0$.\n\nA treap is also often referred to as a \"cartesian tree\", as it is easy to embed it in a Cartesian plane:\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e4/Treap.svg\" width=\"350px\"/>\n</center>\n\nTreaps have been proposed by Raimund Siedel and Cecilia Aragon in 1989.\n\n## Advantages of such data organisation\n\nIn such implementation, $X$ values are the keys (and at same time the values stored in the treap), and $Y$ values are called **priorities**. Without priorities, the treap would be a regular binary search tree by $X$, and one set of $X$ values could correspond to a lot of different trees, some of them degenerate (for example, in the form of a linked list), and therefore extremely slow (the main operations would have $O(N)$ complexity).\n\nAt the same time, **priorities** (when they're unique) allow to **uniquely** specify the tree that will be constructed (of course, it does not depend on the order in which values are added), which can be proven using corresponding theorem. Obviously, if you **choose the priorities randomly**, you will get non-degenerate trees on average, which will ensure $O(\\log N)$ complexity for the main operations. Hence another name of this data structure - **randomized binary search tree**.\n\n## Operations\n\nA treap provides the following operations:\n\n- **Insert (X,Y)** in $O(\\log N)$.  \n  Adds a new node to the tree. One possible variant is to pass only $X$ and generate $Y$ randomly inside the operation.\n- **Search (X)** in $O(\\log N)$.  \n  Looks for a node with the specified key value $X$. The implementation is the same as for an ordinary binary search tree.\n- **Erase (X)** in $O(\\log N)$.  \n  Looks for a node with the specified key value $X$ and removes it from the tree.\n- **Build ($X_1$, ..., $X_N$)** in $O(N)$.  \n  Builds a tree from a list of values. This can be done in linear time (assuming that $X_1, ..., X_N$ are sorted).\n- **Union ($T_1$, $T_2$)** in $O(M \\log (N/M))$.  \n  Merges two trees, assuming that all the elements are different. It is possible to achieve the same complexity if duplicate elements should be removed during merge.\n- **Intersect ($T_1$, $T_2$)** in $O(M \\log (N/M))$.  \n  Finds the intersection of two trees (i.e. their common elements). We will not consider the implementation of this operation here.\n\nIn addition, due to the fact that a treap is a binary search tree, it can implement other operations, such as finding the $K$-th largest element or finding the index of an element.\n\n## Implementation Description\n\nIn terms of implementation, each node contains $X$, $Y$ and pointers to the left ($L$) and right ($R$) children.\n\nWe will implement all the required operations using just two auxiliary operations: Split and Merge.\n\n### Split\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/6/69/Treap_split.svg\" width=\"450px\"/>\n</center>\n\n**Split ($T$, $X$)** separates tree $T$ in 2 subtrees $L$ and $R$ trees (which are the return values of split) so that $L$ contains all elements with key $X_L \\le X$, and $R$ contains all elements with key $X_R > X$. This operation has $O (\\log N)$ complexity and is implemented using a clean recursion:\n\n1. If the value of the root node (R) is $\\le X$, then `L` would at least consist of `R->L` and `R`. We then call split on `R->R`, and note its split result as `L'` and `R'`. Finally, `L` would also contain `L'`, whereas `R = R'`.\n2. If the value of the root node (R) is $> X$, then `R` would at least consist of `R` and `R->R`. We then call split on `R->L`, and note its split result as `L'` and `R'`. Finally, `L=L'`, whereas `R` would also contain `R'`.\n\nThus, the split algorithm is:\n\n1. decide which subtree the root node would belong to (left or right)\n2. recursively call split on one of its children\n3. create the final result by reusing the recursive split call.\n\n### Merge\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/a/a8/Treap_merge.svg\" width=\"500px\"/>\n</center>\n\n**Merge ($T_1$, $T_2$)** combines two subtrees $T_1$ and $T_2$ and returns the new tree. This operation also has $O (\\log N)$ complexity. It works under the assumption that $T_1$ and $T_2$ are ordered (all keys $X$ in $T_1$ are smaller than keys in $T_2$). Thus, we need to combine these trees without violating the order of priorities $Y$. To do this, we choose as the root the tree which has higher priority $Y$ in the root node, and recursively call Merge for the other tree and the corresponding subtree of the selected root node.\n\n### Insert\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/3/35/Treap_insert.svg\" width=\"500px\"/>\n</center>\n\nNow implementation of **Insert ($X$, $Y$)** becomes obvious. First we descend in the tree (as in a regular binary search tree by X), and stop at the first node in which the priority value is less than $Y$. We have found the place where we will insert the new element. Next, we call **Split (T, X)** on the subtree starting at the found node, and use returned subtrees $L$ and $R$ as left and right children of the new node.\n\nAlternatively, insert can be done by splitting the initial treap on $X$ and doing $2$ merges with the new node (see the picture).\n\n\n### Erase\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/6/62/Treap_erase.svg\" width=\"500px\"/>\n</center>\n\nImplementation of **Erase ($X$)** is also clear. First we descend in the tree (as in a regular binary search tree by $X$), looking for the element we want to delete. Once the node is found, we call **Merge** on it children and put the return value of the operation in the place of the element we're deleting.\n\nAlternatively, we can factor out the subtree holding $X$ with $2$ split operations and merge the remaining treaps (see the picture).\n\n### Build\n\nWe implement **Build** operation with $O (N \\log N)$ complexity using $N$ **Insert** calls.\n\n### Union\n\n**Union ($T_1$, $T_2$)** has theoretical complexity $O (M \\log (N / M))$, but in practice it works very well, probably with a very small hidden constant. Let's assume without loss of generality that $T_1 \\rightarrow Y > T_2 \\rightarrow Y$, i. e. root of $T_1$ will be the root of the result. To get the result, we need to merge trees $T_1 \\rightarrow L$, $T_1 \\rightarrow R$ and $T_2$ in two trees which could be children of $T_1$ root. To do this, we call Split ($T_2$, $T_1\\rightarrow X$), thus splitting $T_2$ in two parts L and R, which we then recursively combine with children of $T_1$: Union ($T_1 \\rightarrow L$, $L$) and Union ($T_1 \\rightarrow R$, $R$), thus getting left and right subtrees of the result.\n\n## Implementation\n\n```cpp\nstruct item {\n\tint key, prior;\n\titem *l, *r;\n\titem () { }\n\titem (int key) : key(key), prior(rand()), l(NULL), r(NULL) { }\n\titem (int key, int prior) : key(key), prior(prior), l(NULL), r(NULL) { }\n};\ntypedef item* pitem;\n```\n\nThis is our item defintion. Note there are two child pointers, and an integer key (for the BST) and an integer priority (for the heap). The priority is assigned using a random number generator.\n\n```cpp\nvoid split (pitem t, int key, pitem & l, pitem & r) {\n\tif (!t)\n\t\tl = r = NULL;\n\telse if (t->key <= key)\n        split (t->r, key, t->r, r),  l = t;\n\telse\n        split (t->l, key, l, t->l),  r = t;\n}\n```\n\n`t` is the treap to split, and `key` is the BST value by which to split. Note that we do not `return` the result values anywhere, instead, we just use them like so:\n\n```cpp\npitem l = nullptr, r = nullptr;\nsplit(t, 5, l, r);\nif (l) cout << \"Left subtree size: \" << (l->size) << endl;\nif (r) cout << \"Right subtree size: \" << (r->size) << endl;\n```\n\nThis `split` function can be tricky to understand, as it has both pointers (`pitem`) as well as reference to those pointers (`pitem &l`). Let us understand in words what the function call `split(t, k, l, r)` intends: \"split treap `t` by value `k` into two treaps, and store the left treaps in `l` and right treap in `r`\". Great! Now, let us apply this definition to the two recursive calls, using the case work we analyzed in the previous section: (The first if condition is a trivial base case for an empty treap)\n\n1. When the root node value is $\\le$ key, we call `split (t->r, key, t->r, r)`, which means: \"split treap `t->r` (right subtree of `t`) by value `key` and store the left subtree in `t->r` and right subtree in `r`\". After that, we set `l = t`. Note now that the `l` result value contains `t->l`, `t` as well as `t->r` (which is the result of the recursive call we made) all already merged in the correct order! You should pause to ensure that this result of `l` and `r` corresponds exactly with what we discussed earlier in Implementation Description.\n2. When the root node value is greater than key, we call `split (t->l, key, l, t->l)`, which means: \"split treap `t->l` (left subtree of `t`) by value `key` and store the left subtree in `l` and right subtree in `t->l`\". After that, we set `r = t`. Note now that the `r` result value contains `t->l` (which is the result of the recursive call we made), `t` as well as `t->r`, all already merged in the correct order! You should pause to ensure that this result of `l` and `r` corresponds exactly with what we discussed earlier in Implementation Description.\n\nIf you're still having trouble understanding the implementation, you should look at it _inductively_, that is: do *not* try to break down the recursive calls over and over again. Assume the split implementation works correct on empty treap, then try to run it for a single node treap, then a two node treap, and so on, each time reusing your knowledge that split on smaller treaps works.\n\n```cpp\nvoid insert (pitem & t, pitem it) {\n\tif (!t)\n\t\tt = it;\n\telse if (it->prior > t->prior)\n\t\tsplit (t, it->key, it->l, it->r),  t = it;\n\telse\n\t\tinsert (t->key <= it->key ? t->r : t->l, it);\n}\n\nvoid merge (pitem & t, pitem l, pitem r) {\n\tif (!l || !r)\n\t\tt = l ? l : r;\n\telse if (l->prior > r->prior)\n\t\tmerge (l->r, l->r, r),  t = l;\n\telse\n\t\tmerge (r->l, l, r->l),  t = r;\n}\n\nvoid erase (pitem & t, int key) {\n\tif (t->key == key) {\n\t\tpitem th = t;\n\t\tmerge (t, t->l, t->r);\n\t\tdelete th;\n\t}\n\telse\n\t\terase (key < t->key ? t->l : t->r, key);\n}\n\npitem unite (pitem l, pitem r) {\n\tif (!l || !r)  return l ? l : r;\n\tif (l->prior < r->prior)  swap (l, r);\n\tpitem lt, rt;\n\tsplit (r, l->key, lt, rt);\n\tl->l = unite (l->l, lt);\n\tl->r = unite (l->r, rt);\n\treturn l;\n}\n```\n\n## Maintaining the sizes of subtrees\n\nTo extend the functionality of the treap, it is often necessary to store the number of nodes in subtree of each node - field `int cnt` in the `item` structure. For example, it can be used to find K-th largest element of tree in $O (\\log N)$, or to find the index of the element in the sorted list with the same complexity. The implementation of these operations will be the same as for the regular binary search tree.\n\nWhen a tree changes (nodes are added or removed etc.), `cnt` of some nodes should be updated accordingly. We'll create two functions: `cnt()` will return the current value of `cnt` or 0 if the node does not exist, and `upd_cnt()` will update the value of `cnt` for this node assuming that for its children L and R the values of `cnt` have already been updated. Evidently it's sufficient to add calls of `upd_cnt()` to the end of `insert`, `erase`, `split` and `merge` to keep `cnt` values up-to-date.\n\n```cpp\nint cnt (pitem t) {\n\treturn t ? t->cnt : 0;\n}\n\nvoid upd_cnt (pitem t) {\n\tif (t)\n\t\tt->cnt = 1 + cnt(t->l) + cnt (t->r);\n}\n```\n\n## Building a Treap in $O (N)$ in offline mode {data-toc-label=\"Building a Treap in O(N) in offline mode\"}\n\nGiven a sorted list of keys, it is possible to construct a treap faster than by inserting the keys one at a time which takes $O(N \\log N)$. Since the keys are sorted, a balanced binary search tree can be easily constructed in linear time. The heap values $Y$ are initialized randomly and then can be heapified independent of the keys $X$ to [build the heap](https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap) in $O(N)$.\n\n```cpp\nvoid heapify (pitem t) {\n\tif (!t) return;\n\tpitem max = t;\n\tif (t->l != NULL && t->l->prior > max->prior)\n\t\tmax = t->l;\n\tif (t->r != NULL && t->r->prior > max->prior)\n\t\tmax = t->r;\n\tif (max != t) {\n\t\tswap (t->prior, max->prior);\n\t\theapify (max);\n\t}\n}\n\npitem build (int * a, int n) {\n\t// Construct a treap on values {a[0], a[1], ..., a[n - 1]}\n\tif (n == 0) return NULL;\n\tint mid = n / 2;\n\tpitem t = new item (a[mid], rand ());\n\tt->l = build (a, mid);\n\tt->r = build (a + mid + 1, n - mid - 1);\n\theapify (t);\n\tupd_cnt(t)\n\treturn t;\n}\n```\n\nNote: calling `upd_cnt(t)` is only necessary if you need the subtree sizes.\n\nThe approach above always provides a perfectly balanced tree, which is generally good for practical purposes, but at the cost of not preserving the priorities that were initially assigned to each node. Thus, this approach is not feasible to solve the following problem:\n\n!!! example \"[acmsguru - Cartesian Tree](https://codeforces.com/problemsets/acmsguru/problem/99999/155)\"\n    Given a sequence of pairs $(x_i, y_i)$, construct a cartesian tree on them. All $x_i$ and all $y_i$ are unique.\n\nNote that in this problem priorities are not random, hence just inserting vertices one by one could provide a quadratic solution.\n\nOne of possible solutions here is to find for each element the closest elements to the left and to the right which have a smaller priority than this element. Among these two elements, the one with the larger priority must be the parent of the current element.\n\nThis problem is solvable with a [minimum stack](./stack_queue_modification.md) modification in linear time:\n\n```cpp\nvoid connect(auto from, auto to) {\n    vector<pitem> st;\n    for(auto it: ranges::subrange(from, to)) {\n        while(!st.empty() && st.back()->prior > it->prior) {\n            st.pop_back();\n        }\n        if(!st.empty()) {\n            if(!it->p || it->p->prior < st.back()->prior) {\n                it->p = st.back();\n            }\n        }\n        st.push_back(it);\n    }\n}\n\npitem build(int *x, int *y, int n) {\n    vector<pitem> nodes(n);\n    for(int i = 0; i < n; i++) {\n        nodes[i] = new item(x[i], y[i]);\n    }\n    connect(nodes.begin(), nodes.end());\n    connect(nodes.rbegin(), nodes.rend());\n    for(int i = 0; i < n; i++) {\n        if(nodes[i]->p) {\n            if(nodes[i]->p->key < nodes[i]->key) {\n                nodes[i]->p->r = nodes[i];\n            } else {\n                nodes[i]->p->l = nodes[i];\n            }\n        }\n    }\n    return nodes[min_element(y, y + n) - y];\n}\n```\n\n## Implicit Treaps\n\nImplicit treap is a simple modification of the regular treap which is a very powerful data structure. In fact, implicit treap can be considered as an array with the following procedures implemented (all in $O (\\log N)$ in the online mode):\n\n- Inserting an element in the array in any location\n- Removal of an arbitrary element\n- Finding sum, minimum / maximum element etc. on an arbitrary interval\n- Addition, painting on an arbitrary interval\n- Reversing elements on an arbitrary interval\n\nThe idea is that the keys should be null-based **indices** of the elements in the array. But we will not store these values explicitly (otherwise, for example, inserting an element would cause changes of the key in $O (N)$ nodes of the tree).\n\nNote that the key of a node is the number of nodes less than it (such nodes can be present not only in its left subtree but also in left subtrees of its ancestors). \nMore specifically, the **implicit key** for some node T is the number of vertices $cnt (T \\rightarrow L)$ in the left subtree of this node plus similar values $cnt (P \\rightarrow L) + 1$ for each ancestor P of the node T, if T is in the right subtree of P.\n\nNow it's clear how to calculate the implicit key of current node quickly. Since in all operations we arrive to any node by descending in the tree, we can just accumulate this sum and pass it to the function. If we go to the left subtree, the accumulated sum does not change, if we go to the right subtree it increases by $cnt (T \\rightarrow L) +1$.\n\nHere are the new implementations of **Split** and **Merge**:\n\n```cpp\nvoid merge (pitem & t, pitem l, pitem r) {\n\tif (!l || !r)\n\t\tt = l ? l : r;\n\telse if (l->prior > r->prior)\n\t\tmerge (l->r, l->r, r),  t = l;\n\telse\n\t\tmerge (r->l, l, r->l),  t = r;\n\tupd_cnt (t);\n}\n\nvoid split (pitem t, pitem & l, pitem & r, int key, int add = 0) {\n\tif (!t)\n\t\treturn void( l = r = 0 );\n\tint cur_key = add + cnt(t->l); //implicit key\n\tif (key <= cur_key)\n\t\tsplit (t->l, l, t->l, key, add),  r = t;\n\telse\n\t\tsplit (t->r, t->r, r, key, add + 1 + cnt(t->l)),  l = t;\n\tupd_cnt (t);\n}\n```\n\nIn the implementation above, after the call of $split(T, T_1, T_2, k)$, the tree $T_1$ will consist of first $k$ elements of $T$ (that is, of elements having their implicit key less than $k$) and $T_2$ will consist of all the rest.\n\nNow let's consider the implementation of various operations on implicit treaps:\n\n- **Insert element**.  \n  Suppose we need to insert an element at position $pos$. We divide the treap into two parts, which correspond to arrays $[0..pos-1]$ and $[pos..sz]$; to do this we call $split(T, T_1, T_2, pos)$. Then we can combine tree $T_1$ with the new vertex by calling $merge(T_1, T_1, \\text{new item})$ (it is easy to see that all preconditions are met). Finally, we combine trees $T_1$ and $T_2$ back into $T$ by calling $merge(T, T_1, T_2)$.\n- **Delete element**.  \n This operation is even easier: find the element to be deleted $T$, perform merge of its children $L$ and $R$, and replace the element $T$ with the result of merge. In fact, element deletion in the implicit treap is exactly the same as in the regular treap.\n- Find **sum / minimum**, etc. on the interval.  \n First, create an additional field $F$ in the `item` structure to store the value of the target function for this node's subtree. This field is easy to maintain similarly to maintaining sizes of subtrees: create a function which calculates this value for a node based on values for its children and add calls of this function in the end of all functions which modify the tree.  \n Second, we need to know how to process a query for an arbitrary interval $[A; B]$.  \n To get a part of tree which corresponds to the interval $[A; B]$, we need to call $split(T, T_2, T_3, B+1)$, and then $split(T_2, T_1, T_2, A)$: after this $T_2$ will consist of all the elements in the interval $[A; B]$, and only of them. Therefore, the response to the query will be stored in the field $F$ of the root of $T_2$. After the query is answered, the tree has to be restored by calling $merge(T, T_1, T_2)$ and $merge(T, T, T_3)$.\n- **Addition / painting** on the interval.  \n We act similarly to the previous paragraph, but instead of the field F we will store a field `add` which will contain the added value for the subtree (or the value to which the subtree is painted). Before performing any operation we have to \"push\" this value correctly - i.e. change $T \\rightarrow L \\rightarrow add$ and $T \\rightarrow R \\rightarrow add$, and to clean up `add` in the parent node. This way after any changes to the tree the information will not be lost.\n- **Reverse** on the interval.  \n This is again similar to the previous operation: we have to add boolean flag `rev` and set it to true when the subtree of the current node has to be reversed. \"Pushing\" this value is a bit complicated - we swap children of this node and set this flag to true for them.\n\nHere is an example implementation of the implicit treap with reverse on the interval. For each node we store field called `value` which is the actual value of the array element at current position. We also provide implementation of the function `output()`, which outputs an array that corresponds to the current state of the implicit treap.\n\n```cpp\ntypedef struct item * pitem;\nstruct item {\n\tint prior, value, cnt;\n\tbool rev;\n\tpitem l, r;\n};\n\nint cnt (pitem it) {\n\treturn it ? it->cnt : 0;\n}\n\nvoid upd_cnt (pitem it) {\n\tif (it)\n\t\tit->cnt = cnt(it->l) + cnt(it->r) + 1;\n}\n\nvoid push (pitem it) {\n\tif (it && it->rev) {\n\t\tit->rev = false;\n\t\tswap (it->l, it->r);\n\t\tif (it->l)  it->l->rev ^= true;\n\t\tif (it->r)  it->r->rev ^= true;\n\t}\n}\n\nvoid merge (pitem & t, pitem l, pitem r) {\n\tpush (l);\n\tpush (r);\n\tif (!l || !r)\n\t\tt = l ? l : r;\n\telse if (l->prior > r->prior)\n\t\tmerge (l->r, l->r, r),  t = l;\n\telse\n\t\tmerge (r->l, l, r->l),  t = r;\n\tupd_cnt (t);\n}\n\nvoid split (pitem t, pitem & l, pitem & r, int key, int add = 0) {\n\tif (!t)\n\t\treturn void( l = r = 0 );\n\tpush (t);\n\tint cur_key = add + cnt(t->l);\n\tif (key <= cur_key)\n\t\tsplit (t->l, l, t->l, key, add),  r = t;\n\telse\n\t\tsplit (t->r, t->r, r, key, add + 1 + cnt(t->l)),  l = t;\n\tupd_cnt (t);\n}\n\nvoid reverse (pitem t, int l, int r) {\n\tpitem t1, t2, t3;\n\tsplit (t, t1, t2, l);\n\tsplit (t2, t2, t3, r-l+1);\n\tt2->rev ^= true;\n\tmerge (t, t1, t2);\n\tmerge (t, t, t3);\n}\n\nvoid output (pitem t) {\n\tif (!t)  return;\n\tpush (t);\n\toutput (t->l);\n\tprintf (\"%d \", t->value);\n\toutput (t->r);\n}\n```\n\n## Literature\n\n* [Blelloch, Reid-Miller \"Fast Set Operations Using Treaps\"](https://www.cs.cmu.edu/~scandal/papers/treaps-spaa98.pdf)\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: treap\n---\n\n# Treap (Cartesian tree)\n\nA treap is a data structure which combines binary tree and binary heap (hence the name: tree + heap $\\Rightarrow$ Treap).\n\nMore specifically, treap is a data structure that stores pairs $(X, Y)$ in a binary tree in such a way that it is a binary search tree by $X$ and a binary heap by $Y$.\nIf some node of the tree contains values $(X_0, Y_0)$, all nodes in the left subtree have $X \\leq X_0$, all nodes in the right subtree have $X_0 \\leq X$, and all nodes in both left and right subtrees have $Y \\leq Y_0$.\n\nA treap is also often referred to as a \"cartesian tree\", as it is easy to embed it in a Cartesian plane:\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e4/Treap.svg\" width=\"350px\"/>\n</center>\n\nTreaps have been proposed by Raimund Siedel and Cecilia Aragon in 1989.\n\n## Advantages of such data organisation\n\nIn such implementation, $X$ values are the keys (and at same time the values stored in the treap), and $Y$ values are called **priorities**. Without priorities, the treap would be a regular binary search tree by $X$, and one set of $X$ values could correspond to a lot of different trees, some of them degenerate (for example, in the form of a linked list), and therefore extremely slow (the main operations would have $O(N)$ complexity).\n\nAt the same time, **priorities** (when they're unique) allow to **uniquely** specify the tree that will be constructed (of course, it does not depend on the order in which values are added), which can be proven using corresponding theorem. Obviously, if you **choose the priorities randomly**, you will get non-degenerate trees on average, which will ensure $O(\\log N)$ complexity for the main operations. Hence another name of this data structure - **randomized binary search tree**.\n\n## Operations\n\nA treap provides the following operations:\n\n- **Insert (X,Y)** in $O(\\log N)$.  \n  Adds a new node to the tree. One possible variant is to pass only $X$ and generate $Y$ randomly inside the operation.\n- **Search (X)** in $O(\\log N)$.  \n  Looks for a node with the specified key value $X$. The implementation is the same as for an ordinary binary search tree.\n- **Erase (X)** in $O(\\log N)$.  \n  Looks for a node with the specified key value $X$ and removes it from the tree.\n- **Build ($X_1$, ..., $X_N$)** in $O(N)$.  \n  Builds a tree from a list of values. This can be done in linear time (assuming that $X_1, ..., X_N$ are sorted).\n- **Union ($T_1$, $T_2$)** in $O(M \\log (N/M))$.  \n  Merges two trees, assuming that all the elements are different. It is possible to achieve the same complexity if duplicate elements should be removed during merge.\n- **Intersect ($T_1$, $T_2$)** in $O(M \\log (N/M))$.  \n  Finds the intersection of two trees (i.e. their common elements). We will not consider the implementation of this operation here.\n\nIn addition, due to the fact that a treap is a binary search tree, it can implement other operations, such as finding the $K$-th largest element or finding the index of an element.\n\n## Implementation Description\n\nIn terms of implementation, each node contains $X$, $Y$ and pointers to the left ($L$) and right ($R$) children.\n\nWe will implement all the required operations using just two auxiliary operations: Split and Merge.\n\n### Split\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/6/69/Treap_split.svg\" width=\"450px\"/>\n</center>\n\n**Split ($T$, $X$)** separates tree $T$ in 2 subtrees $L$ and $R$ trees (which are the return values of split) so that $L$ contains all elements with key $X_L \\le X$, and $R$ contains all elements with key $X_R > X$. This operation has $O (\\log N)$ complexity and is implemented using a clean recursion:\n\n1. If the value of the root node (R) is $\\le X$, then `L` would at least consist of `R->L` and `R`. We then call split on `R->R`, and note its split result as `L'` and `R'`. Finally, `L` would also contain `L'`, whereas `R = R'`.\n2. If the value of the root node (R) is $> X$, then `R` would at least consist of `R` and `R->R`. We then call split on `R->L`, and note its split result as `L'` and `R'`. Finally, `L=L'`, whereas `R` would also contain `R'`.\n\nThus, the split algorithm is:\n\n1. decide which subtree the root node would belong to (left or right)\n2. recursively call split on one of its children\n3. create the final result by reusing the recursive split call.\n\n### Merge\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/a/a8/Treap_merge.svg\" width=\"500px\"/>\n</center>\n\n**Merge ($T_1$, $T_2$)** combines two subtrees $T_1$ and $T_2$ and returns the new tree. This operation also has $O (\\log N)$ complexity. It works under the assumption that $T_1$ and $T_2$ are ordered (all keys $X$ in $T_1$ are smaller than keys in $T_2$). Thus, we need to combine these trees without violating the order of priorities $Y$. To do this, we choose as the root the tree which has higher priority $Y$ in the root node, and recursively call Merge for the other tree and the corresponding subtree of the selected root node.\n\n### Insert\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/3/35/Treap_insert.svg\" width=\"500px\"/>\n</center>\n\nNow implementation of **Insert ($X$, $Y$)** becomes obvious. First we descend in the tree (as in a regular binary search tree by X), and stop at the first node in which the priority value is less than $Y$. We have found the place where we will insert the new element. Next, we call **Split (T, X)** on the subtree starting at the found node, and use returned subtrees $L$ and $R$ as left and right children of the new node.\n\nAlternatively, insert can be done by splitting the initial treap on $X$ and doing $2$ merges with the new node (see the picture).\n\n\n### Erase\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/6/62/Treap_erase.svg\" width=\"500px\"/>\n</center>\n\nImplementation of **Erase ($X$)** is also clear. First we descend in the tree (as in a regular binary search tree by $X$), looking for the element we want to delete. Once the node is found, we call **Merge** on it children and put the return value of the operation in the place of the element we're deleting.\n\nAlternatively, we can factor out the subtree holding $X$ with $2$ split operations and merge the remaining treaps (see the picture).\n\n### Build\n\nWe implement **Build** operation with $O (N \\log N)$ complexity using $N$ **Insert** calls.\n\n### Union\n\n**Union ($T_1$, $T_2$)** has theoretical complexity $O (M \\log (N / M))$, but in practice it works very well, probably with a very small hidden constant. Let's assume without loss of generality that $T_1 \\rightarrow Y > T_2 \\rightarrow Y$, i. e. root of $T_1$ will be the root of the result. To get the result, we need to merge trees $T_1 \\rightarrow L$, $T_1 \\rightarrow R$ and $T_2$ in two trees which could be children of $T_1$ root. To do this, we call Split ($T_2$, $T_1\\rightarrow X$), thus splitting $T_2$ in two parts L and R, which we then recursively combine with children of $T_1$: Union ($T_1 \\rightarrow L$, $L$) and Union ($T_1 \\rightarrow R$, $R$), thus getting left and right subtrees of the result.\n\n## Implementation\n\n```cpp\nstruct item {\n\tint key, prior;\n\titem *l, *r;\n\titem () { }\n\titem (int key) : key(key), prior(rand()), l(NULL), r(NULL) { }\n\titem (int key, int prior) : key(key), prior(prior), l(NULL), r(NULL) { }\n};\ntypedef item* pitem;\n```\n\nThis is our item defintion. Note there are two child pointers, and an integer key (for the BST) and an integer priority (for the heap). The priority is assigned using a random number generator.\n\n```cpp\nvoid split (pitem t, int key, pitem & l, pitem & r) {\n\tif (!t)\n\t\tl = r = NULL;\n\telse if (t->key <= key)\n        split (t->r, key, t->r, r),  l = t;\n\telse\n        split (t->l, key, l, t->l),  r = t;\n}\n```\n\n`t` is the treap to split, and `key` is the BST value by which to split. Note that we do not `return` the result values anywhere, instead, we just use them like so:\n\n```cpp\npitem l = nullptr, r = nullptr;\nsplit(t, 5, l, r);\nif (l) cout << \"Left subtree size: \" << (l->size) << endl;\nif (r) cout << \"Right subtree size: \" << (r->size) << endl;\n```\n\nThis `split` function can be tricky to understand, as it has both pointers (`pitem`) as well as reference to those pointers (`pitem &l`). Let us understand in words what the function call `split(t, k, l, r)` intends: \"split treap `t` by value `k` into two treaps, and store the left treaps in `l` and right treap in `r`\". Great! Now, let us apply this definition to the two recursive calls, using the case work we analyzed in the previous section: (The first if condition is a trivial base case for an empty treap)\n\n1. When the root node value is $\\le$ key, we call `split (t->r, key, t->r, r)`, which means: \"split treap `t->r` (right subtree of `t`) by value `key` and store the left subtree in `t->r` and right subtree in `r`\". After that, we set `l = t`. Note now that the `l` result value contains `t->l`, `t` as well as `t->r` (which is the result of the recursive call we made) all already merged in the correct order! You should pause to ensure that this result of `l` and `r` corresponds exactly with what we discussed earlier in Implementation Description.\n2. When the root node value is greater than key, we call `split (t->l, key, l, t->l)`, which means: \"split treap `t->l` (left subtree of `t`) by value `key` and store the left subtree in `l` and right subtree in `t->l`\". After that, we set `r = t`. Note now that the `r` result value contains `t->l` (which is the result of the recursive call we made), `t` as well as `t->r`, all already merged in the correct order! You should pause to ensure that this result of `l` and `r` corresponds exactly with what we discussed earlier in Implementation Description.\n\nIf you're still having trouble understanding the implementation, you should look at it _inductively_, that is: do *not* try to break down the recursive calls over and over again. Assume the split implementation works correct on empty treap, then try to run it for a single node treap, then a two node treap, and so on, each time reusing your knowledge that split on smaller treaps works.\n\n```cpp\nvoid insert (pitem & t, pitem it) {\n\tif (!t)\n\t\tt = it;\n\telse if (it->prior > t->prior)\n\t\tsplit (t, it->key, it->l, it->r),  t = it;\n\telse\n\t\tinsert (t->key <= it->key ? t->r : t->l, it);\n}\n\nvoid merge (pitem & t, pitem l, pitem r) {\n\tif (!l || !r)\n\t\tt = l ? l : r;\n\telse if (l->prior > r->prior)\n\t\tmerge (l->r, l->r, r),  t = l;\n\telse\n\t\tmerge (r->l, l, r->l),  t = r;\n}\n\nvoid erase (pitem & t, int key) {\n\tif (t->key == key) {\n\t\tpitem th = t;\n\t\tmerge (t, t->l, t->r);\n\t\tdelete th;\n\t}\n\telse\n\t\terase (key < t->key ? t->l : t->r, key);\n}\n\npitem unite (pitem l, pitem r) {\n\tif (!l || !r)  return l ? l : r;\n\tif (l->prior < r->prior)  swap (l, r);\n\tpitem lt, rt;\n\tsplit (r, l->key, lt, rt);\n\tl->l = unite (l->l, lt);\n\tl->r = unite (l->r, rt);\n\treturn l;\n}\n```\n\n## Maintaining the sizes of subtrees\n\nTo extend the functionality of the treap, it is often necessary to store the number of nodes in subtree of each node - field `int cnt` in the `item` structure. For example, it can be used to find K-th largest element of tree in $O (\\log N)$, or to find the index of the element in the sorted list with the same complexity. The implementation of these operations will be the same as for the regular binary search tree.\n\nWhen a tree changes (nodes are added or removed etc.), `cnt` of some nodes should be updated accordingly. We'll create two functions: `cnt()` will return the current value of `cnt` or 0 if the node does not exist, and `upd_cnt()` will update the value of `cnt` for this node assuming that for its children L and R the values of `cnt` have already been updated. Evidently it's sufficient to add calls of `upd_cnt()` to the end of `insert`, `erase`, `split` and `merge` to keep `cnt` values up-to-date.\n\n```cpp\nint cnt (pitem t) {\n\treturn t ? t->cnt : 0;\n}\n\nvoid upd_cnt (pitem t) {\n\tif (t)\n\t\tt->cnt = 1 + cnt(t->l) + cnt (t->r);\n}\n```\n\n## Building a Treap in $O (N)$ in offline mode {data-toc-label=\"Building a Treap in O(N) in offline mode\"}\n\nGiven a sorted list of keys, it is possible to construct a treap faster than by inserting the keys one at a time which takes $O(N \\log N)$. Since the keys are sorted, a balanced binary search tree can be easily constructed in linear time. The heap values $Y$ are initialized randomly and then can be heapified independent of the keys $X$ to [build the heap](https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap) in $O(N)$.\n\n```cpp\nvoid heapify (pitem t) {\n\tif (!t) return;\n\tpitem max = t;\n\tif (t->l != NULL && t->l->prior > max->prior)\n\t\tmax = t->l;\n\tif (t->r != NULL && t->r->prior > max->prior)\n\t\tmax = t->r;\n\tif (max != t) {\n\t\tswap (t->prior, max->prior);\n\t\theapify (max);\n\t}\n}\n\npitem build (int * a, int n) {\n\t// Construct a treap on values {a[0], a[1], ..., a[n - 1]}\n\tif (n == 0) return NULL;\n\tint mid = n / 2;\n\tpitem t = new item (a[mid], rand ());\n\tt->l = build (a, mid);\n\tt->r = build (a + mid + 1, n - mid - 1);\n\theapify (t);\n\tupd_cnt(t)\n\treturn t;\n}\n```\n\nNote: calling `upd_cnt(t)` is only necessary if you need the subtree sizes.\n\nThe approach above always provides a perfectly balanced tree, which is generally good for practical purposes, but at the cost of not preserving the priorities that were initially assigned to each node. Thus, this approach is not feasible to solve the following problem:\n\n!!! example \"[acmsguru - Cartesian Tree](https://codeforces.com/problemsets/acmsguru/problem/99999/155)\"\n    Given a sequence of pairs $(x_i, y_i)$, construct a cartesian tree on them. All $x_i$ and all $y_i$ are unique.\n\nNote that in this problem priorities are not random, hence just inserting vertices one by one could provide a quadratic solution.\n\nOne of possible solutions here is to find for each element the closest elements to the left and to the right which have a smaller priority than this element. Among these two elements, the one with the larger priority must be the parent of the current element.\n\nThis problem is solvable with a [minimum stack](./stack_queue_modification.md) modification in linear time:\n\n```cpp\nvoid connect(auto from, auto to) {\n    vector<pitem> st;\n    for(auto it: ranges::subrange(from, to)) {\n        while(!st.empty() && st.back()->prior > it->prior) {\n            st.pop_back();\n        }\n        if(!st.empty()) {\n            if(!it->p || it->p->prior < st.back()->prior) {\n                it->p = st.back();\n            }\n        }\n        st.push_back(it);\n    }\n}\n\npitem build(int *x, int *y, int n) {\n    vector<pitem> nodes(n);\n    for(int i = 0; i < n; i++) {\n        nodes[i] = new item(x[i], y[i]);\n    }\n    connect(nodes.begin(), nodes.end());\n    connect(nodes.rbegin(), nodes.rend());\n    for(int i = 0; i < n; i++) {\n        if(nodes[i]->p) {\n            if(nodes[i]->p->key < nodes[i]->key) {\n                nodes[i]->p->r = nodes[i];\n            } else {\n                nodes[i]->p->l = nodes[i];\n            }\n        }\n    }\n    return nodes[min_element(y, y + n) - y];\n}\n```\n\n## Implicit Treaps\n\nImplicit treap is a simple modification of the regular treap which is a very powerful data structure. In fact, implicit treap can be considered as an array with the following procedures implemented (all in $O (\\log N)$ in the online mode):\n\n- Inserting an element in the array in any location\n- Removal of an arbitrary element\n- Finding sum, minimum / maximum element etc. on an arbitrary interval\n- Addition, painting on an arbitrary interval\n- Reversing elements on an arbitrary interval\n\nThe idea is that the keys should be null-based **indices** of the elements in the array. But we will not store these values explicitly (otherwise, for example, inserting an element would cause changes of the key in $O (N)$ nodes of the tree).\n\nNote that the key of a node is the number of nodes less than it (such nodes can be present not only in its left subtree but also in left subtrees of its ancestors). \nMore specifically, the **implicit key** for some node T is the number of vertices $cnt (T \\rightarrow L)$ in the left subtree of this node plus similar values $cnt (P \\rightarrow L) + 1$ for each ancestor P of the node T, if T is in the right subtree of P.\n\nNow it's clear how to calculate the implicit key of current node quickly. Since in all operations we arrive to any node by descending in the tree, we can just accumulate this sum and pass it to the function. If we go to the left subtree, the accumulated sum does not change, if we go to the right subtree it increases by $cnt (T \\rightarrow L) +1$.\n\nHere are the new implementations of **Split** and **Merge**:\n\n```cpp\nvoid merge (pitem & t, pitem l, pitem r) {\n\tif (!l || !r)\n\t\tt = l ? l : r;\n\telse if (l->prior > r->prior)\n\t\tmerge (l->r, l->r, r),  t = l;\n\telse\n\t\tmerge (r->l, l, r->l),  t = r;\n\tupd_cnt (t);\n}\n\nvoid split (pitem t, pitem & l, pitem & r, int key, int add = 0) {\n\tif (!t)\n\t\treturn void( l = r = 0 );\n\tint cur_key = add + cnt(t->l); //implicit key\n\tif (key <= cur_key)\n\t\tsplit (t->l, l, t->l, key, add),  r = t;\n\telse\n\t\tsplit (t->r, t->r, r, key, add + 1 + cnt(t->l)),  l = t;\n\tupd_cnt (t);\n}\n```\n\nIn the implementation above, after the call of $split(T, T_1, T_2, k)$, the tree $T_1$ will consist of first $k$ elements of $T$ (that is, of elements having their implicit key less than $k$) and $T_2$ will consist of all the rest.\n\nNow let's consider the implementation of various operations on implicit treaps:\n\n- **Insert element**.  \n  Suppose we need to insert an element at position $pos$. We divide the treap into two parts, which correspond to arrays $[0..pos-1]$ and $[pos..sz]$; to do this we call $split(T, T_1, T_2, pos)$. Then we can combine tree $T_1$ with the new vertex by calling $merge(T_1, T_1, \\text{new item})$ (it is easy to see that all preconditions are met). Finally, we combine trees $T_1$ and $T_2$ back into $T$ by calling $merge(T, T_1, T_2)$.\n- **Delete element**.  \n This operation is even easier: find the element to be deleted $T$, perform merge of its children $L$ and $R$, and replace the element $T$ with the result of merge. In fact, element deletion in the implicit treap is exactly the same as in the regular treap.\n- Find **sum / minimum**, etc. on the interval.  \n First, create an additional field $F$ in the `item` structure to store the value of the target function for this node's subtree. This field is easy to maintain similarly to maintaining sizes of subtrees: create a function which calculates this value for a node based on values for its children and add calls of this function in the end of all functions which modify the tree.  \n Second, we need to know how to process a query for an arbitrary interval $[A; B]$.  \n To get a part of tree which corresponds to the interval $[A; B]$, we need to call $split(T, T_2, T_3, B+1)$, and then $split(T_2, T_1, T_2, A)$: after this $T_2$ will consist of all the elements in the interval $[A; B]$, and only of them. Therefore, the response to the query will be stored in the field $F$ of the root of $T_2$. After the query is answered, the tree has to be restored by calling $merge(T, T_1, T_2)$ and $merge(T, T, T_3)$.\n- **Addition / painting** on the interval.  \n We act similarly to the previous paragraph, but instead of the field F we will store a field `add` which will contain the added value for the subtree (or the value to which the subtree is painted). Before performing any operation we have to \"push\" this value correctly - i.e. change $T \\rightarrow L \\rightarrow add$ and $T \\rightarrow R \\rightarrow add$, and to clean up `add` in the parent node. This way after any changes to the tree the information will not be lost.\n- **Reverse** on the interval.  \n This is again similar to the previous operation: we have to add boolean flag `rev` and set it to true when the subtree of the current node has to be reversed. \"Pushing\" this value is a bit complicated - we swap children of this node and set this flag to true for them.\n\nHere is an example implementation of the implicit treap with reverse on the interval. For each node we store field called `value` which is the actual value of the array element at current position. We also provide implementation of the function `output()`, which outputs an array that corresponds to the current state of the implicit treap.\n\n```cpp\ntypedef struct item * pitem;\nstruct item {\n\tint prior, value, cnt;\n\tbool rev;\n\tpitem l, r;\n};\n\nint cnt (pitem it) {\n\treturn it ? it->cnt : 0;\n}\n\nvoid upd_cnt (pitem it) {\n\tif (it)\n\t\tit->cnt = cnt(it->l) + cnt(it->r) + 1;\n}\n\nvoid push (pitem it) {\n\tif (it && it->rev) {\n\t\tit->rev = false;\n\t\tswap (it->l, it->r);\n\t\tif (it->l)  it->l->rev ^= true;\n\t\tif (it->r)  it->r->rev ^= true;\n\t}\n}\n\nvoid merge (pitem & t, pitem l, pitem r) {\n\tpush (l);\n\tpush (r);\n\tif (!l || !r)\n\t\tt = l ? l : r;\n\telse if (l->prior > r->prior)\n\t\tmerge (l->r, l->r, r),  t = l;\n\telse\n\t\tmerge (r->l, l, r->l),  t = r;\n\tupd_cnt (t);\n}\n\nvoid split (pitem t, pitem & l, pitem & r, int key, int add = 0) {\n\tif (!t)\n\t\treturn void( l = r = 0 );\n\tpush (t);\n\tint cur_key = add + cnt(t->l);\n\tif (key <= cur_key)\n\t\tsplit (t->l, l, t->l, key, add),  r = t;\n\telse\n\t\tsplit (t->r, t->r, r, key, add + 1 + cnt(t->l)),  l = t;\n\tupd_cnt (t);\n}\n\nvoid reverse (pitem t, int l, int r) {\n\tpitem t1, t2, t3;\n\tsplit (t, t1, t2, l);\n\tsplit (t2, t2, t3, r-l+1);\n\tt2->rev ^= true;\n\tmerge (t, t1, t2);\n\tmerge (t, t, t3);\n}\n\nvoid output (pitem t) {\n\tif (!t)  return;\n\tpush (t);\n\toutput (t->l);\n\tprintf (\"%d \", t->value);\n\toutput (t->r);\n}\n```\n\n## Literature\n\n* [Blelloch, Reid-Miller \"Fast Set Operations Using Treaps\"](https://www.cs.cmu.edu/~scandal/papers/treaps-spaa98.pdf)\n\n## Practice Problems\n\n* [SPOJ - Ada and Aphids](http://www.spoj.com/problems/ADAAPHID/)\n* [SPOJ - Ada and Harvest](http://www.spoj.com/problems/ADACROP/)\n* [Codeforces - Radio Stations](http://codeforces.com/contest/762/problem/E)\n* [SPOJ - Ghost Town](http://www.spoj.com/problems/COUNT1IT/)\n* [SPOJ - Arrangement Validity](http://www.spoj.com/problems/IITWPC4D/)\n* [SPOJ - All in One](http://www.spoj.com/problems/ALLIN1/)\n* [Codeforces - Dog Show](http://codeforces.com/contest/847/problem/D)\n* [Codeforces - Yet Another Array Queries Problem](http://codeforces.com/contest/863/problem/D)\n* [SPOJ - Mean of Array](http://www.spoj.com/problems/MEANARR/)\n* [SPOJ - TWIST](http://www.spoj.com/problems/TWIST/)\n* [SPOJ - KOILINE](http://www.spoj.com/problems/KOILINE/)\n* [CodeChef - The Prestige](https://www.codechef.com/problems/PRESTIGE)\n* [Codeforces - T-Shirts](https://codeforces.com/contest/702/problem/F)\n* [Codeforces - Wizards and Roads](https://codeforces.com/problemset/problem/167/D)\n* [Codeforces - Yaroslav and Points](https://codeforces.com/contest/295/problem/E)\n", "problem_ids": ["847_D", "863_D", "702_F", "167_D", "295_E"], "title": "Treap (Cartesian tree)"}, {"article": "---\ntitle: Deleting from a data structure in O(T(n) log n)\ntags:\n  - Original\n---\n# Deleting from a data structure in $O(T(n)\\log n)$\n\nSuppose you have a data structure which allows adding elements in **true** $O(T(n))$.\nThis article will describe a technique that allows deletion in $O(T(n)\\log n)$ offline.\n\n## Algorithm\n\nEach element lives in the data structure for some segments of time between additions and deletions.\nLet's build a segment tree over the queries.\nEach segment when some element is alive splits into $O(\\log n)$ nodes of the tree.\nLet's put each query when we want to know something about the structure into the corresponding leaf.\nNow to process all queries we will run a DFS on the segment tree.\nWhen entering the node we will add all the elements that are inside this node.\nThen we will go further to the children of this node or answer the queries (if the node is a leaf).\nWhen leaving the node, we must undo the additions.\nNote that if we change the structure in $O(T(n))$ we can roll back the changes in $O(T(n))$ by keeping a stack of changes.\nNote that rollbacks break amortized complexity.\n\n## Notes\n\nThe idea of creating a segment tree over segments when something is alive may be used not only for data structure problems.\nSee some problems below.\n\n## Implementation\n\nThis implementation is for the [dynamic connectivity](https://en.wikipedia.org/wiki/Dynamic_connectivity) problem.\nIt can add edges, remove edges and count the number of connected components.\n\n```{.cpp file=dynamic-conn}\nstruct dsu_save {\n    int v, rnkv, u, rnku;\n\n    dsu_save() {}\n\n    dsu_save(int _v, int _rnkv, int _u, int _rnku)\n        : v(_v), rnkv(_rnkv), u(_u), rnku(_rnku) {}\n};\n\nstruct dsu_with_rollbacks {\n    vector<int> p, rnk;\n    int comps;\n    stack<dsu_save> op;\n\n    dsu_with_rollbacks() {}\n\n    dsu_with_rollbacks(int n) {\n        p.resize(n);\n        rnk.resize(n);\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n            rnk[i] = 0;\n        }\n        comps = n;\n    }\n\n    int find_set(int v) {\n        return (v == p[v]) ? v : find_set(p[v]);\n    }\n\n    bool unite(int v, int u) {\n        v = find_set(v);\n        u = find_set(u);\n        if (v == u)\n            return false;\n        comps--;\n        if (rnk[v] > rnk[u])\n            swap(v, u);\n        op.push(dsu_save(v, rnk[v], u, rnk[u]));\n        p[v] = u;\n        if (rnk[u] == rnk[v])\n            rnk[u]++;\n        return true;\n    }\n\n    void rollback() {\n        if (op.empty())\n            return;\n        dsu_save x = op.top();\n        op.pop();\n        comps++;\n        p[x.v] = x.v;\n        rnk[x.v] = x.rnkv;\n        p[x.u] = x.u;\n        rnk[x.u] = x.rnku;\n    }\n};\n\nstruct query {\n    int v, u;\n    bool united;\n    query(int _v, int _u) : v(_v), u(_u) {\n    }\n};\n\nstruct QueryTree {\n    vector<vector<query>> t;\n    dsu_with_rollbacks dsu;\n    int T;\n\n    QueryTree() {}\n\n    QueryTree(int _T, int n) : T(_T) {\n        dsu = dsu_with_rollbacks(n);\n        t.resize(4 * T + 4);\n    }\n\n    void add_to_tree(int v, int l, int r, int ul, int ur, query& q) {\n        if (ul > ur)\n            return;\n        if (l == ul && r == ur) {\n            t[v].push_back(q);\n            return;\n        }\n        int mid = (l + r) / 2;\n        add_to_tree(2 * v, l, mid, ul, min(ur, mid), q);\n        add_to_tree(2 * v + 1, mid + 1, r, max(ul, mid + 1), ur, q);\n    }\n\n    void add_query(query q, int l, int r) {\n        add_to_tree(1, 0, T - 1, l, r, q);\n    }\n\n    void dfs(int v, int l, int r, vector<int>& ans) {\n        for (query& q : t[v]) {\n            q.united = dsu.unite(q.v, q.u);\n        }\n        if (l == r)\n            ans[l] = dsu.comps;\n        else {\n            int mid = (l + r) / 2;\n            dfs(2 * v, l, mid, ans);\n            dfs(2 * v + 1, mid + 1, r, ans);\n        }\n        for (query q : t[v]) {\n            if (q.united)\n                dsu.rollback();\n        }\n    }\n\n    vector<int> solve() {\n        vector<int> ans(T);\n        dfs(1, 0, T - 1, ans);\n        return ans;\n    }\n};\n```\n\n", "full_article": "---\ntitle: Deleting from a data structure in O(T(n) log n)\ntags:\n  - Original\n---\n# Deleting from a data structure in $O(T(n)\\log n)$\n\nSuppose you have a data structure which allows adding elements in **true** $O(T(n))$.\nThis article will describe a technique that allows deletion in $O(T(n)\\log n)$ offline.\n\n## Algorithm\n\nEach element lives in the data structure for some segments of time between additions and deletions.\nLet's build a segment tree over the queries.\nEach segment when some element is alive splits into $O(\\log n)$ nodes of the tree.\nLet's put each query when we want to know something about the structure into the corresponding leaf.\nNow to process all queries we will run a DFS on the segment tree.\nWhen entering the node we will add all the elements that are inside this node.\nThen we will go further to the children of this node or answer the queries (if the node is a leaf).\nWhen leaving the node, we must undo the additions.\nNote that if we change the structure in $O(T(n))$ we can roll back the changes in $O(T(n))$ by keeping a stack of changes.\nNote that rollbacks break amortized complexity.\n\n## Notes\n\nThe idea of creating a segment tree over segments when something is alive may be used not only for data structure problems.\nSee some problems below.\n\n## Implementation\n\nThis implementation is for the [dynamic connectivity](https://en.wikipedia.org/wiki/Dynamic_connectivity) problem.\nIt can add edges, remove edges and count the number of connected components.\n\n```{.cpp file=dynamic-conn}\nstruct dsu_save {\n    int v, rnkv, u, rnku;\n\n    dsu_save() {}\n\n    dsu_save(int _v, int _rnkv, int _u, int _rnku)\n        : v(_v), rnkv(_rnkv), u(_u), rnku(_rnku) {}\n};\n\nstruct dsu_with_rollbacks {\n    vector<int> p, rnk;\n    int comps;\n    stack<dsu_save> op;\n\n    dsu_with_rollbacks() {}\n\n    dsu_with_rollbacks(int n) {\n        p.resize(n);\n        rnk.resize(n);\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n            rnk[i] = 0;\n        }\n        comps = n;\n    }\n\n    int find_set(int v) {\n        return (v == p[v]) ? v : find_set(p[v]);\n    }\n\n    bool unite(int v, int u) {\n        v = find_set(v);\n        u = find_set(u);\n        if (v == u)\n            return false;\n        comps--;\n        if (rnk[v] > rnk[u])\n            swap(v, u);\n        op.push(dsu_save(v, rnk[v], u, rnk[u]));\n        p[v] = u;\n        if (rnk[u] == rnk[v])\n            rnk[u]++;\n        return true;\n    }\n\n    void rollback() {\n        if (op.empty())\n            return;\n        dsu_save x = op.top();\n        op.pop();\n        comps++;\n        p[x.v] = x.v;\n        rnk[x.v] = x.rnkv;\n        p[x.u] = x.u;\n        rnk[x.u] = x.rnku;\n    }\n};\n\nstruct query {\n    int v, u;\n    bool united;\n    query(int _v, int _u) : v(_v), u(_u) {\n    }\n};\n\nstruct QueryTree {\n    vector<vector<query>> t;\n    dsu_with_rollbacks dsu;\n    int T;\n\n    QueryTree() {}\n\n    QueryTree(int _T, int n) : T(_T) {\n        dsu = dsu_with_rollbacks(n);\n        t.resize(4 * T + 4);\n    }\n\n    void add_to_tree(int v, int l, int r, int ul, int ur, query& q) {\n        if (ul > ur)\n            return;\n        if (l == ul && r == ur) {\n            t[v].push_back(q);\n            return;\n        }\n        int mid = (l + r) / 2;\n        add_to_tree(2 * v, l, mid, ul, min(ur, mid), q);\n        add_to_tree(2 * v + 1, mid + 1, r, max(ul, mid + 1), ur, q);\n    }\n\n    void add_query(query q, int l, int r) {\n        add_to_tree(1, 0, T - 1, l, r, q);\n    }\n\n    void dfs(int v, int l, int r, vector<int>& ans) {\n        for (query& q : t[v]) {\n            q.united = dsu.unite(q.v, q.u);\n        }\n        if (l == r)\n            ans[l] = dsu.comps;\n        else {\n            int mid = (l + r) / 2;\n            dfs(2 * v, l, mid, ans);\n            dfs(2 * v + 1, mid + 1, r, ans);\n        }\n        for (query q : t[v]) {\n            if (q.united)\n                dsu.rollback();\n        }\n    }\n\n    vector<int> solve() {\n        vector<int> ans(T);\n        dfs(1, 0, T - 1, ans);\n        return ans;\n    }\n};\n```\n\n## Problems\n\n- [Codeforces - Connect and Disconnect](https://codeforces.com/gym/100551/problem/A)\n- [Codeforces - Addition on Segments](https://codeforces.com/contest/981/problem/E)\n- [Codeforces - Extending Set of Points](https://codeforces.com/contest/1140/problem/F)\n", "problem_ids": ["981_E", "1140_F"], "title": "Deleting from a data structure in $O(T(n)\\log n)$"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: segment_tree\n---\n\n# Segment Tree\n\nA Segment Tree is a data structure that stores information about array intervals as a tree. This allows answering range queries over an array efficiently, while still being flexible enough to allow quick modification of the array.\nThis includes finding the sum of consecutive array elements $a[l \\dots r]$, or finding the minimum element in a such a range in $O(\\log n)$ time. \nBetween answering such queries, the Segment Tree allows modifying the array by replacing one element, or even changing the elements of a whole subsegment (e.g. assigning all elements $a[l \\dots r]$ to any value, or adding a value to all element in the subsegment). \n\nIn general, a Segment Tree is a very flexible data structure, and a huge number of problems can be solved with it. \nAdditionally, it is also possible to apply more complex operations and answer more complex queries (see [Advanced versions of Segment Trees](segment_tree.md#advanced-versions-of-segment-trees)).\nIn particular the Segment Tree can be easily generalized to larger dimensions. \nFor instance, with a two-dimensional Segment Tree you can answer sum or minimum queries over some subrectangle of a given matrix in only $O(\\log^2 n)$ time. \n\nOne important property of Segment Trees is that they require only a linear amount of memory.\nThe standard Segment Tree requires $4n$ vertices for working on an array of size $n$. \n\n## Simplest form of a Segment Tree\n\nTo start easy, we consider the simplest form of a Segment Tree. \nWe want to answer sum queries efficiently. \nThe formal definition of our task is:\nGiven an array $a[0 \\dots n-1]$, the Segment Tree must be able to find the sum of elements between the indices $l$ and $r$ (i.e. computing the sum $\\sum_{i=l}^r a[i]$), and also handle changing values of the elements in the array (i.e. perform assignments of the form $a[i] = x$).\nThe Segment Tree should be able to process **both** queries in $O(\\log n)$ time.\n\nThis is an improvement over the simpler approaches.\nA naive array implementation - just using a simple array - can update elements in $O(1)$, but requires $O(n)$ to compute each sum query.\nAnd precomputed prefix sums can compute sum queries in $O(1)$, but updating an array element requires $O(n)$ changes to the prefix sums.\n\n### Structure of the Segment Tree\n\nWe can take a divide-and-conquer approach when it comes to array segments. \nWe compute and store the sum of the elements of the whole array, i.e. the sum of the segment $a[0 \\dots n-1]$. \nWe then split the array into two halves $a[0 \\dots n/2-1]$ and $a[n/2 \\dots n-1]$ and compute the sum of each halve and store them. \nEach of these two halves in turn are split in half, and so on until all segments reach size $1$. \n\nWe can view these segments as forming a binary tree: \nthe root of this tree is the segment $a[0 \\dots n-1]$, and each vertex (except leaf vertices) has exactly two child vertices. \nThis is why the data structure is called \"Segment Tree\", even though in most implementations the tree is not constructed explicitly (see [Implementation](segment_tree.md#implementation)).\n\nHere is a visual representation of such a Segment Tree over the array $a = [1, 3, -2, 8, -7]$:\n\n![\"Sum Segment Tree\"](sum-segment-tree.png)\n\nFrom this short description of the data structure, we can already conclude that a Segment Tree only requires a linear number of vertices. \nThe first level of the tree contains a single node (the root), the second level will contain two vertices, in the third it will contain four vertices, until the number of vertices reaches $n$. \nThus the number of vertices in the worst case can be estimated by the sum $1 + 2 + 4 + \\dots + 2^{\\lceil\\log_2 n\\rceil} \\lt 2^{\\lceil\\log_2 n\\rceil + 1} \\lt 4n$.\n\nIt is worth noting that whenever $n$ is not a power of two, not all levels of the Segment Tree will be completely filled. \nWe can see that behavior in the image.\nFor now we can forget about this fact, but it will become important later during the implementation.\n\nThe height of the Segment Tree is $O(\\log n)$, because when going down from the root to the leaves the size of the segments decreases approximately by half. \n\n### Construction\n\nBefore constructing the segment tree, we need to decide:\n\n1. the *value* that gets stored at each node of the segment tree.\n   For example, in a sum segment tree, a node would store the sum of the elements in its range $[l, r]$.\n2. the *merge* operation that merges two siblings in a segment tree.\n   For example, in a sum segment tree, the two nodes corresponding to the ranges $a[l_1 \\dots r_1]$ and $a[l_2 \\dots r_2]$ would be merged into a node corresponding to the range $a[l_1 \\dots r_2]$ by adding the values of the two nodes.\n\nNote that a vertex is a \"leaf vertex\", if its corresponding segment covers only one value in the original array. It is present at the lowermost level of a segment tree. Its value would be equal to the (corresponding) element $a[i]$. \n\nNow, for construction of the segment tree, we start at the bottom level (the leaf vertices) and assign them their respective values. On the basis of these values, we can compute the values of the previous level, using the `merge` function.\nAnd on the basis of those, we can compute the values of the previous, and repeat the procedure until we reach the root vertex. \n\nIt is convenient to describe this operation recursively in the other direction, i.e., from the root vertex to the leaf vertices. The construction procedure, if called on a non-leaf vertex, does the following:\n\n1. recursively construct the values of the two child vertices\n2. merge the computed values of these children.\n\nWe start the construction at the root vertex, and hence, we are able to compute the entire segment tree.\n\nThe time complexity of this construction is $O(n)$, assuming that the merge operation is constant time (the merge operation gets called $n$ times, which is equal to the number of internal nodes in the segment tree).\n\n### Sum queries\n\nFor now we are going to answer sum queries. As an input we receive two integers $l$ and $r$, and we have to compute the sum of the segment $a[l \\dots r]$ in $O(\\log n)$ time. \n\nTo do this, we will traverse the Segment Tree and use the precomputed sums of the segments.\nLet's assume that we are currently at the vertex that covers the segment $a[tl \\dots tr]$.\nThere are three possible cases. \n\nThe easiest case is when the segment $a[l \\dots r]$ is equal to the corresponding segment of the current vertex (i.e. $a[l \\dots r] = a[tl \\dots tr]$), then we are finished and can return the precomputed sum that is stored in the vertex.\n\nAlternatively the segment of the query can fall completely into the domain of either the left or the right child.\nRecall that the left child covers the segment $a[tl \\dots tm]$ and the right vertex covers the segment $a[tm + 1 \\dots tr]$ with $tm = (tl + tr) / 2$. \nIn this case we can simply go to the child vertex, which corresponding segment covers the query segment, and execute the algorithm described here with that vertex. \n\nAnd then there is the last case, the query segment intersects with both children. \nIn this case we have no other option as to make two recursive calls, one for each child.\nFirst we go to the left child, compute a partial answer for this vertex (i.e. the sum of values of the intersection between the segment of the query and the segment of the left child), then go to the right child, compute the partial answer using that vertex, and then combine the answers by adding them. \nIn other words, since the left child represents the segment $a[tl \\dots tm]$ and the right child the segment $a[tm+1 \\dots tr]$, we compute the sum query $a[l \\dots tm]$ using the left child, and the sum query $a[tm+1 \\dots r]$ using the right child. \n\nSo processing a sum query is a function that recursively calls itself once with either the left or the right child (without changing the query boundaries), or twice, once for the left and once for the right child (by splitting the query into two subqueries). \nAnd the recursion ends, whenever the boundaries of the current query segment coincides with the boundaries of the segment of the current vertex. \nIn that case the answer will be the precomputed value of the sum of this segment, which is stored in the tree.\n\nIn other words, the calculation of the query is a traversal of the tree, which spreads through all necessary branches of the tree, and uses the precomputed sum values of the segments in the tree. \n\nObviously we will start the traversal from the root vertex of the Segment Tree.\n\nThe procedure is illustrated in the following image.\nAgain the array $a = [1, 3, -2, 8, -7]$ is used, and here we want to compute the sum $\\sum_{i=2}^4 a[i]$.\nThe colored vertices will be visited, and we will use the precomputed values of the green vertices.\nThis gives us the result $-2 + 1 = -1$.\n\n![\"Sum Segment Tree Query\"](sum-segment-tree-query.png)\n\nWhy is the complexity of this algorithm $O(\\log n)$?\nTo show this complexity we look at each level of the tree. \nIt turns out, that for each level we only visit not more than four vertices. \nAnd since the height of the tree is $O(\\log n)$, we receive the desired running time. \n\nWe can show that this proposition (at most four vertices each level) is true by induction.\nAt the first level, we only visit one vertex, the root vertex, so here we visit less than four vertices. \nNow let's look at an arbitrary level.\nBy induction hypothesis, we visit at most four vertices. \nIf we only visit at most two vertices, the next level has at most four vertices. That is trivial, because each vertex can only cause at most two recursive calls. \nSo let's assume that we visit three or four vertices in the current level. \nFrom those vertices, we will analyze the vertices in the middle more carefully. \nSince the sum query asks for the sum of a continuous subarray, we know that segments corresponding to the visited vertices in the middle will be completely covered by the segment of the sum query. \nTherefore these vertices will not make any recursive calls. \nSo only the most left, and the most right vertex will have the potential to make recursive calls. \nAnd those will only create at most four recursive calls, so also the next level will satisfy the assertion.\nWe can say that one branch approaches the left boundary of the query, and the second branch approaches the right one. \n\nTherefore we visit at most $4 \\log n$ vertices in total, and that is equal to a running time of $O(\\log n)$. \n\nIn conclusion the query works by dividing the input segment into several sub-segments for which all the sums are already precomputed and stored in the tree. \nAnd if we stop partitioning whenever the query segment coincides with the vertex segment, then we only need $O(\\log n)$ such segments, which gives the effectiveness of the Segment Tree. \n\n### Update queries\n\nNow we want to modify a specific element in the array, let's say we want to do the assignment $a[i] = x$. \nAnd we have to rebuild the Segment Tree, such that it correspond to the new, modified array. \n\nThis query is easier than the sum query. \nEach level of a Segment Tree forms a partition of the array. \nTherefore an element $a[i]$ only contributes to one segment from each level. \nThus only $O(\\log n)$ vertices need to be updated. \n\nIt is easy to see, that the update request can be implemented using a recursive function. \nThe function gets passed the current tree vertex, and it recursively calls itself with one of the two child vertices (the one that contains $a[i]$ in its segment), and after that recomputes its sum value, similar how it is done in the build method (that is as the sum of its two children). \n\nAgain here is a visualization using the same array.\nHere we perform the update $a[2] = 3$.\nThe green vertices are the vertices that we visit and update.\n\n![\"Sum Segment Tree Update\"](sum-segment-tree-update.png)\n\n### Implementation ### { #implementation}\n\nThe main consideration is how to store the Segment Tree.\nOf course we can define a $\\text{Vertex}$ struct and create objects, that store the boundaries of the segment, its sum and additionally also pointers to its child vertices.\nHowever, this requires storing a lot of redundant information in the form of pointers.\nWe will use a simple trick to make this a lot more efficient by using an _implicit data structure_: Only storing the sums in an array.\n(A similar method is used for binary heaps).\nThe sum of the root vertex at index 1, the sums of its two child vertices at indices 2 and 3, the sums of the children of those two vertices at indices 4 to 7, and so on. \nWith 1-indexing, conveniently the left child of a vertex at index $i$ is stored at index $2i$, and the right one at index $2i + 1$. \nEquivalently, the parent of a vertex at index $i$ is stored at $i/2$ (integer division).\n\nThis simplifies the implementation a lot. \nWe don't need to store the structure of the tree in memory. \nIt is defined implicitly. \nWe only need one array which contains the sums of all segments. \n\nAs noted before, we need to store at most $4n$ vertices.\nIt might be less, but for convenience we always allocate an array of size $4n$.\nThere will be some elements in the sum array, that will not correspond to any vertices in the actual tree, but this doesn't complicate the implementation.\n\nSo, we store the Segment Tree simply as an array $t[]$ with a size of four times the input size $n$:\n\n```{.cpp file=segment_tree_implementation_definition}\nint n, t[4*MAXN];\n```\n\nThe procedure for constructing the Segment Tree from a given array $a[]$ looks like this: \nit is a recursive function with the parameters $a[]$ (the input array), $v$ (the index of the current vertex), and the boundaries $tl$ and $tr$ of the current segment. \nIn the main program this function will be called with the parameters of the root vertex: $v = 1$, $tl = 0$, and $tr = n - 1$. \n\n```{.cpp file=segment_tree_implementation_build}\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = a[tl];\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = t[v*2] + t[v*2+1];\n    }\n}\n```\n\nFurther the function for answering sum queries is also a recursive function, which receives as parameters information about the current vertex/segment (i.e. the index $v$ and the boundaries $tl$ and $tr$) and also the information about the boundaries of the query, $l$ and $r$. \nIn order to simplify the code, this function always does two recursive calls, even if only one is necessary - in that case the superfluous recursive call will have $l > r$, and this can easily be caught using an additional check at the beginning of the function.\n\n```{.cpp file=segment_tree_implementation_sum}\nint sum(int v, int tl, int tr, int l, int r) {\n    if (l > r) \n        return 0;\n    if (l == tl && r == tr) {\n        return t[v];\n    }\n    int tm = (tl + tr) / 2;\n    return sum(v*2, tl, tm, l, min(r, tm))\n           + sum(v*2+1, tm+1, tr, max(l, tm+1), r);\n}\n```\n\nFinally the update query. The function will also receive information about the current vertex/segment, and additionally also the parameter of the update query (i.e. the position of the element and its new value).\n\n```{.cpp file=segment_tree_implementation_update}\nvoid update(int v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr) {\n        t[v] = new_val;\n    } else {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n        t[v] = t[v*2] + t[v*2+1];\n    }\n}\n```\n\n### Memory efficient implementation\n\nMost people use the implementation from the previous section. If you look at the array `t` you can see that it follows the numbering of the tree nodes in the order of a BFS traversal (level-order traversal). \nUsing this traversal the children of vertex $v$ are $2v$ and $2v + 1$ respectively.\nHowever if $n$ is not a power of two, this method will skip some indices and leave some parts of the array `t` unused.\nThe memory consumption is limited by $4n$, even though a Segment Tree of an array of $n$ elements requires only $2n - 1$ vertices.\n\nHowever it can be reduced. \nWe renumber the vertices of the tree in the order of an Euler tour traversal (pre-order traversal), and we write all these vertices next to each other.\n\nLets look at a vertex at index $v$, and let him be responsible for the segment $[l, r]$, and let $mid = \\dfrac{l + r}{2}$.\nIt is obvious that the left child will have the index $v + 1$.\nThe left child is responsible for the segment $[l, mid]$, i.e. in total there will be $2 * (mid - l + 1) - 1$ vertices in the left child's subtree.\nThus we can compute the index of the right child of $v$. The index will be $v + 2 * (mid - l + 1)$.\nBy this numbering we achieve a reduction of the necessary memory to $2n$.\n\n## <a name=\"advanced-versions-of-segment-trees\"></a>Advanced versions of Segment Trees\n\n\nA Segment Tree is a very flexible data structure, and allows variations and extensions in many different directions. \nLet's try to categorize them below. \n\n### More complex queries\n\nIt can be quite easy to change the Segment Tree in a direction, such that it computes different queries (e.g. computing the minimum / maximum instead of the sum), but it also can be very nontrivial. \n\n#### Finding the maximum\n\nLet us slightly change the condition of the problem described above: instead of querying the sum, we will now make maximum queries.\n\nThe tree will have exactly the same structure as the tree described above. \nWe only need to change the way $t[v]$ is computed in the $\\text{build}$ and $\\text{update}$ functions.\n$t[v]$ will now store the maximum of the corresponding segment. \nAnd we also need to change the calculation of the returned value of the $\\text{sum}$ function (replacing the summation by the maximum).\n\nOf course this problem can be easily changed into computing the minimum instead of the maximum.\n\nInstead of showing an implementation to this problem, the implementation will be given to a more complex version of this problem in the next section.\n\n#### Finding the maximum and the number of times it appears \n\nThis task is very similar to the previous one.\nIn addition of finding the maximum, we also have to find the number of occurrences of the maximum. \n\nTo solve this problem, we store a pair of numbers at each vertex in the tree: \nIn addition to the maximum we also store the number of occurrences of it in the corresponding segment. \nDetermining the correct pair to store at $t[v]$ can still be done in constant time using the information of the pairs stored at the child vertices. \nCombining two such pairs should be done in a separate function, since this will be an operation that we will do while building the tree, while answering maximum queries and while performing modifications.\n\n```{.cpp file=segment_tree_maximum_and_count}\npair<int, int> t[4*MAXN];\n\npair<int, int> combine(pair<int, int> a, pair<int, int> b) {\n    if (a.first > b.first) \n        return a;\n    if (b.first > a.first)\n        return b;\n    return make_pair(a.first, a.second + b.second);\n}\n\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = make_pair(a[tl], 1);\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n\npair<int, int> get_max(int v, int tl, int tr, int l, int r) {\n    if (l > r)\n        return make_pair(-INF, 0);\n    if (l == tl && r == tr)\n        return t[v];\n    int tm = (tl + tr) / 2;\n    return combine(get_max(v*2, tl, tm, l, min(r, tm)), \n                   get_max(v*2+1, tm+1, tr, max(l, tm+1), r));\n}\n\nvoid update(int v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr) {\n        t[v] = make_pair(new_val, 1);\n    } else {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n```\n#### Compute the greatest common divisor / least common multiple\n\nIn this problem we want to compute the GCD / LCM of all numbers of given ranges of the array. \n\nThis interesting variation of the Segment Tree can be solved in exactly the same way as the Segment Trees we derived for sum / minimum / maximum queries:\nit is enough to store the GCD / LCM of the corresponding vertex in each vertex of the tree. \nCombining two vertices can be done by computing the GCD / LCM of both vertices.\n\n#### Counting the number of zeros, searching for the $k$-th zero { #counting-zero-search-kth data-toc-label=\"Counting the number of zeros, searching for the k-th zero\"}\n\nIn this problem we want to find the number of zeros in a given range, and additionally find the index of the $k$-th zero using a second function.\n\nAgain we have to change the store values of the tree a bit:\nThis time we will store the number of zeros in each segment in $t[]$. \nIt is pretty clear, how to implement the $\\text{build}$, $\\text{update}$ and $\\text{count_zero}$ functions, we can simply use the ideas from the sum query problem.\nThus we solved the first part of the problem.\n\nNow we learn how to solve the problem of finding the $k$-th zero in the array $a[]$. \nTo do this task, we will descend the Segment Tree, starting at the root vertex, and moving each time to either the left or the right child, depending on which segment contains the $k$-th zero.\nIn order to decide to which child we need to go, it is enough to look at the number of zeros appearing in the segment corresponding to the left vertex.\nIf this precomputed count is greater or equal to $k$, it is necessary to descend to the left child, and otherwise descent to the right child.\nNotice, if we chose the right child, we have to subtract the number of zeros of the left child from $k$.\n\nIn the implementation we can handle the special case, $a[]$ containing less than $k$ zeros, by returning -1.\n\n```{.cpp file=segment_tree_kth_zero}\nint find_kth(int v, int tl, int tr, int k) {\n    if (k > t[v])\n        return -1;\n    if (tl == tr)\n        return tl;\n    int tm = (tl + tr) / 2;\n    if (t[v*2] >= k)\n        return find_kth(v*2, tl, tm, k);\n    else \n        return find_kth(v*2+1, tm+1, tr, k - t[v*2]);\n}\n```\n\n#### Searching for an array prefix with a given amount\n\nThe task is as follows: \nfor a given value $x$ we have to quickly find smallest index $i$ such that the sum of the first $i$ elements of the array $a[]$ is greater or equal to $x$ (assuming that the array $a[]$ only contains non-negative values).\n\nThis task can be solved using binary search, computing the sum of the prefixes with the Segment Tree.\nHowever this will lead to a $O(\\log^2 n)$ solution.\n\nInstead we can use the same idea as in the previous section, and find the position by descending the tree:\nby moving each time to the left or the right, depending on the sum of the left child.\nThus finding the answer in $O(\\log n)$ time.\n\n#### Searching for the first element greater than a given amount\n\nThe task is as follows: \nfor a given value $x$ and a range $a[l \\dots r]$ find the smallest $i$  in the range $a[l \\dots r]$, such that $a[i]$ is greater than $x$.\n\nThis task can be solved using binary search over max prefix queries with the Segment Tree.\nHowever, this will lead to a $O(\\log^2 n)$ solution.\n\nInstead, we can use the same idea as in the previous sections, and find the position by descending the tree:\nby moving each time to the left or the right, depending on the maximum value of the left child.\nThus finding the answer in $O(\\log n)$ time.\n\n```{.cpp file=segment_tree_first_greater}\nint get_first(int v, int lv, int rv, int l, int r, int x) {\n    if(lv > r || rv < l) return -1;\n    if(l <= lv && rv <= r) {\n        if(t[v] <= x) return -1;\n        while(lv != rv) {\n            int mid = lv + (rv-lv)/2;\n            if(t[2*v] > x) {\n                v = 2*v;\n                rv = mid;\n            }else {\n                v = 2*v+1;\n                lv = mid+1;\n            }\n        }\n        return lv;\n    }\n\n    int mid = lv + (rv-lv)/2;\n    int rs = get_first(2*v, lv, mid, l, r, x);\n    if(rs != -1) return rs;\n    return get_first(2*v+1, mid+1, rv, l ,r, x);\n}\n```\n\n#### Finding subsegments with the maximal sum\n\nHere again we receive a range $a[l \\dots r]$ for each query, this time we have to find a subsegment $a[l^\\prime \\dots r^\\prime]$ such that $l \\le l^\\prime$ and $r^\\prime \\le r$ and the sum of the elements of this segment is maximal. \nAs before we also want to be able to modify individual elements of the array. \nThe elements of the array can be negative, and the optimal subsegment can be empty (e.g. if all elements are negative).\n\nThis problem is a non-trivial usage of a Segment Tree.\nThis time we will store four values for each vertex: \nthe sum of the segment, the maximum prefix sum, the maximum suffix sum, and the sum of the maximal subsegment in it.\nIn other words for each segment of the Segment Tree the answer is already precomputed as well as the answers for segments touching the left and the right boundaries of the segment.\n\nHow to build a tree with such data?\nAgain we compute it in a recursive fashion: \nwe first compute all four values for the left and the right child, and then combine those to archive the four values for the current vertex.\nNote the answer for the current vertex is either:\n\n * the answer of the left child, which means that the optimal subsegment is entirely placed in the segment of the left child\n * the answer of the right child, which means that the optimal subsegment is entirely placed in the segment of the right child\n * the sum of the maximum suffix sum of the left child and the maximum prefix sum of the right child, which means that the optimal subsegment intersects with both children.\n\nHence the answer to the current vertex is the maximum of these three values. \nComputing the maximum prefix / suffix sum is even easier. \nHere is the implementation of the $\\text{combine}$ function, which receives only data from the left and right child, and returns the data of the current vertex. \n\n```{.cpp file=segment_tree_maximal_sum_subsegments1}\nstruct data {\n    int sum, pref, suff, ans;\n};\n\ndata combine(data l, data r) {\n    data res;\n    res.sum = l.sum + r.sum;\n    res.pref = max(l.pref, l.sum + r.pref);\n    res.suff = max(r.suff, r.sum + l.suff);\n    res.ans = max(max(l.ans, r.ans), l.suff + r.pref);\n    return res;\n}\n```\n\nUsing the $\\text{combine}$ function it is easy to build the Segment Tree. \nWe can implement it in exactly the same way as in the previous implementations.\nTo initialize the leaf vertices, we additionally create the auxiliary function $\\text{make_data}$, which will return a $\\text{data}$ object holding the information of a single value.\n\n```{.cpp file=segment_tree_maximal_sum_subsegments2}\ndata make_data(int val) {\n    data res;\n    res.sum = val;\n    res.pref = res.suff = res.ans = max(0, val);\n    return res;\n}\n\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = make_data(a[tl]);\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n \nvoid update(int v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr) {\n        t[v] = make_data(new_val);\n    } else {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n```\n\nIt only remains, how to compute the answer to a query. \nTo answer it, we go down the tree as before, breaking the query into several subsegments that coincide with the segments of the Segment Tree, and combine the answers in them into a single answer for the query.\nThen it should be clear, that the work is exactly the same as in the simple Segment Tree, but instead of summing / minimizing / maximizing the values, we use the $\\text{combine}$ function.\n\n```{.cpp file=segment_tree_maximal_sum_subsegments3}\ndata query(int v, int tl, int tr, int l, int r) {\n    if (l > r) \n        return make_data(0);\n    if (l == tl && r == tr) \n        return t[v];\n    int tm = (tl + tr) / 2;\n    return combine(query(v*2, tl, tm, l, min(r, tm)), \n                   query(v*2+1, tm+1, tr, max(l, tm+1), r));\n}\n```\n\n### <a name=\"saving-the-entire-subarrays-in-each-vertex\"></a>Saving the entire subarrays in each vertex\n\nThis is a separate subsection that stands apart from the others, because at each vertex of the Segment Tree we don't store information about the corresponding segment in compressed form (sum, minimum, maximum, ...), but store all elements of the segment.\nThus the root of the Segment Tree will store all elements of the array, the left child vertex will store the first half of the array, the right vertex the second half, and so on.\n\nIn its simplest application of this technique we store the elements in sorted order.\nIn more complex versions the elements are not stored in lists, but more advanced data structures (sets, maps, ...). \nBut all these methods have the common factor, that each vertex requires linear memory (i.e. proportional to the length of the corresponding segment).\n\nThe first natural question, when considering these Segment Trees, is about memory consumption.\nIntuitively this might look like $O(n^2)$ memory, but it turns out that the complete tree will only need $O(n \\log n)$ memory.\nWhy is this so?\nQuite simply, because each element of the array falls into $O(\\log n)$ segments (remember the height of the tree is $O(\\log n)$). \n\nSo in spite of the apparent extravagance of such a Segment Tree, it consumes only slightly more memory than the usual Segment Tree. \n\nSeveral typical applications of this data structure are described below.\nIt is worth noting the similarity of these Segment Trees with 2D data structures (in fact this is a 2D data structure, but with rather limited capabilities).\n\n#### Find the smallest number greater or equal to a specified number. No modification queries.\n\nWe want to answer queries of the following form: \nfor three given numbers $(l, r, x)$ we have to find the minimal number in the segment $a[l \\dots r]$ which is greater than or equal to $x$.\n\nWe construct a Segment Tree. \nIn each vertex we store a sorted list of all numbers occurring in the corresponding segment, like described above. \nHow to build such a Segment Tree as effectively as possible?\nAs always we approach this problem recursively: let the lists of the left and right children already be constructed, and we want to build the list for the current vertex.\nFrom this view the operation is now trivial and can be accomplished in linear time:\nWe only need to combine the two sorted lists into one, which can be done by iterating over them using two pointers. \nThe C++ STL already has an implementation of this algorithm.\n\nBecause this structure of the Segment Tree and the similarities to the merge sort algorithm, the data structure is also often called \"Merge Sort Tree\".\n\n```{.cpp file=segment_tree_smallest_number_greater1}\nvector<int> t[4*MAXN];\n\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = vector<int>(1, a[tl]);\n    } else { \n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        merge(t[v*2].begin(), t[v*2].end(), t[v*2+1].begin(), t[v*2+1].end(),\n              back_inserter(t[v]));\n    }\n}\n```\n\nWe already know that the Segment Tree constructed in this way will require $O(n \\log n)$ memory.\nAnd thanks to this implementation its construction also takes $O(n \\log n)$ time, after all each list is constructed in linear time in respect to its size. \n\nNow consider the answer to the query. \nWe will go down the tree, like in the regular Segment Tree, breaking our segment $a[l \\dots r]$ into several subsegments (into at most $O(\\log n)$ pieces). \nIt is clear that the answer of the whole answer is the minimum of each of the subqueries.\nSo now we only need to understand, how to respond to a query on one such subsegment that corresponds with some vertex of the tree.\n\nWe are at some vertex of the Segment Tree and we want to compute the answer to the query, i.e. find the minimum number greater that or equal to a given number $x$. \nSince the vertex contains the list of elements in sorted order, we can simply perform a binary search on this list and return the first number, greater than or equal to $x$.\n\nThus the answer to the query in one segment of the tree takes $O(\\log n)$ time, and the entire query is processed in $O(\\log^2 n)$.\n\n```{.cpp file=segment_tree_smallest_number_greater2}\nint query(int v, int tl, int tr, int l, int r, int x) {\n    if (l > r)\n        return INF;\n    if (l == tl && r == tr) {\n        vector<int>::iterator pos = lower_bound(t[v].begin(), t[v].end(), x);\n        if (pos != t[v].end())\n            return *pos;\n        return INF;\n    }\n    int tm = (tl + tr) / 2;\n    return min(query(v*2, tl, tm, l, min(r, tm), x), \n               query(v*2+1, tm+1, tr, max(l, tm+1), r, x));\n}\n```\n\nThe constant $\\text{INF}$ is equal to some large number that is bigger than all numbers in the array. \nIts usage means, that there is no number greater than or equal to $x$ in the segment. \nIt has the meaning of \"there is no answer in the given interval\".\n\n#### Find the smallest number greater or equal to a specified number. With modification queries.\n\nThis task is similar to the previous.\nThe last approach has a disadvantage, it was not possible to modify the array between answering queries.\nNow we want to do exactly this: a modification query will do the assignment $a[i] = y$.\n\nThe solution is similar to the solution of the previous problem, but instead of lists at each vertex of the Segment Tree, we will store a balanced list that allows you to quickly search for numbers, delete numbers, and insert new numbers. \nSince the array can contain a number repeated, the optimal choice is the data structure $\\text{multiset}$. \n\nThe construction of such a Segment Tree is done in pretty much the same way as in the previous problem, only now we need to combine $\\text{multiset}$s and not sorted lists.\nThis leads to a construction time of $O(n \\log^2 n)$ (in general merging two red-black trees can be done in linear time, but the C++ STL doesn't guarantee this time complexity).\n\nThe $\\text{query}$ function is also almost equivalent, only now the $\\text{lower_bound}$ function of the $\\text{multiset}$ function should be called instead ($\\text{std::lower_bound}$ only works in $O(\\log n)$ time if used with random-access iterators).\n\nFinally the modification request. \nTo process it, we must go down the tree, and modify all $\\text{multiset}$ from the corresponding segments that contain the effected element.\nWe simply delete the old value of this element (but only one occurrence), and insert the new value.\n\n```cpp\nvoid update(int v, int tl, int tr, int pos, int new_val) {\n    t[v].erase(t[v].find(a[pos]));\n    t[v].insert(new_val);\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n    } else {\n        a[pos] = new_val;\n    }\n}\n```\n\nProcessing of this modification query also takes $O(\\log^2 n)$ time.\n\n#### Find the smallest number greater or equal to a specified number. Acceleration with \"fractional cascading\".\n\nWe have the same problem statement, we want to find the minimal number greater than or equal to $x$ in a segment, but this time in $O(\\log n)$ time.\nWe will improve the time complexity using the technique \"fractional cascading\".\n\nFractional cascading is a simple technique that allows you to improve the running time of multiple binary searches, which are conducted at the same time. \nOur previous approach to the search query was, that we divide the task into several subtasks, each of which is solved with a binary search. \nFractional cascading allows you to replace all of these binary searches with a single one.\n\nThe simplest and most obvious example of fractional cascading is the following problem:\nthere are $k$ sorted lists of numbers, and we must find in each list the first number greater than or equal to the given number.\n\nInstead of performing a binary search for each list, we could merge all lists into one big sorted list.\nAdditionally for each element $y$ we store a list of results of searching for $y$ in each of the $k$ lists.\nTherefore if we want to find the smallest number greater than or equal to $x$, we just need to perform one single binary search, and from the list of indices we can determine the smallest number in each list.\nThis approach however requires $O(n \\cdot k)$ ($n$ is the length of the combined lists), which can be quite inefficient. \n\nFractional cascading reduces this memory complexity to $O(n)$ memory, by creating from the $k$ input lists $k$ new lists, in which each list contains the corresponding list and additionally also every second element of the following new list.\nUsing this structure it is only necessary to store two indices, the index of the element in the original list, and the index of the element in the following new list.\nSo this approach only uses $O(n)$ memory, and still can answer the queries using a single binary search. \n\nBut for our application we do not need the full power of fractional cascading.\nIn our Segment Tree a vertex will contain the sorted list of all elements that occur in either the left or the right subtrees (like in the Merge Sort Tree). \nAdditionally to this sorted list, we store two positions for each element.\nFor an element $y$ we store the smallest index $i$, such that the $i$th element in the sorted list of the left child is greater or equal to $y$.\nAnd we store the smallest index $j$, such that the $j$th element in the sorted list of the right child is greater or equal to $y$.\nThese values can be computed in parallel to the merging step when we build the tree.\n\nHow does this speed up the queries?\n\nRemember, in the normal solution we did a binary search in ever node.\nBut with this modification, we can avoid all except one.\n\nTo answer a query, we simply to a binary search in the root node.\nThis gives as the smallest element $y \\ge x$ in the complete array, but it also gives us two positions.\nThe index of the smallest element greater or equal $x$ in the left subtree, and the index of the smallest element $y$ in the right subtree. Notice that $\\ge y$ is the same as $\\ge x$, since our array doesn't contain any elements between $x$ and $y$.\nIn the normal Merge Sort Tree solution we would compute these indices via binary search, but with the help of the precomputed values we can just look them up in $O(1)$.\nAnd we can repeat that until we visited all nodes that cover our query interval.\n\nTo summarize, as usual we touch $O(\\log n)$ nodes during a query. In the root node we do a binary search, and in all other nodes we only do constant work.\nThis means the complexity for answering a query is $O(\\log n)$.\n\nBut notice, that this uses three times more memory than a normal Merge Sort Tree, which already uses a lot of memory ($O(n \\log n)$).\n\nIt is straightforward to apply this technique to a problem, that doesn't require any modification queries.\nThe two positions are just integers and can easily be computed by counting when merging the two sorted sequences.\n\nIt it still possible to also allow modification queries, but that complicates the entire code.\nInstead of integers, you need to store the sorted array as `multiset`, and instead of indices you need to store iterators.\nAnd you need to work very carefully, so that you increment or decrement the correct iterators during a modification query.\n\n#### Other possible variations\n\nThis technique implies a whole new class of possible applications. \nInstead of storing a $\\text{vector}$ or a $\\text{multiset}$ in each vertex, other data structures can be used:\nother Segment Trees (somewhat discussed in [Generalization to higher dimensions](segment_tree.md#generalization-to-higher-dimensions)), Fenwick Trees, Cartesian trees, etc.\n\n### Range updates (Lazy Propagation)\n\nAll problems in the above sections discussed modification queries that only effected a single element of the array each.\nHowever the Segment Tree allows applying modification queries to an entire segment of contiguous elements, and perform the query in the same time $O(\\log n)$. \n\n#### Addition on segments\n\nWe begin by considering problems of the simplest form: the modification query should add a number $x$ to all numbers in the segment $a[l \\dots r]$.\nThe second query, that we are supposed to answer, asked simply for the value of $a[i]$.\n\nTo make the addition query efficient, we store at each vertex in the Segment Tree how many we should add to all numbers in the corresponding segment. \nFor example, if the query \"add 3 to the whole array $a[0 \\dots n-1]$\" comes, then we place the number 3 in the root of the tree.\nIn general we have to place this number to multiple segments, which form a partition of the query segment. \nThus we don't have to change all $O(n)$ values, but only $O(\\log n)$ many.\n\nIf now there comes a query that asks the current value of a particular array entry, it is enough to go down the tree and add up all values found along the way.\n\n```cpp\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = a[tl];\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = 0;\n    }\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int add) {\n    if (l > r)\n        return;\n    if (l == tl && r == tr) {\n        t[v] += add;\n    } else {\n        int tm = (tl + tr) / 2;\n        update(v*2, tl, tm, l, min(r, tm), add);\n        update(v*2+1, tm+1, tr, max(l, tm+1), r, add);\n    }\n}\n\nint get(int v, int tl, int tr, int pos) {\n    if (tl == tr)\n        return t[v];\n    int tm = (tl + tr) / 2;\n    if (pos <= tm)\n        return t[v] + get(v*2, tl, tm, pos);\n    else\n        return t[v] + get(v*2+1, tm+1, tr, pos);\n}\n```\n\n#### Assignment on segments\n\nSuppose now that the modification query asks to assign each element of a certain segment $a[l \\dots r]$ to some value $p$.\nAs a second query we will again consider reading the value of the array $a[i]$.\n\nTo perform this modification query on a whole segment, you have to store at each vertex of the Segment Tree whether the corresponding segment is covered entirely with the same value or not.\nThis allows us to make a \"lazy\" update: \ninstead of changing all segments in the tree that cover the query segment, we only change some, and leave others unchanged.\nA marked vertex will mean, that every element of the corresponding segment is assigned to that value, and actually also the complete subtree should only contain this value.\nIn a sense we are lazy and delay writing the new value to all those vertices.\nWe can do this tedious task later, if this is necessary.\n\nSo after the modification query is executed, some parts of the tree become irrelevant - some modifications remain unfulfilled in it.\n\nFor example if a modification query \"assign a number to the whole array $a[0 \\dots n-1]$\" gets executed, in the Segment Tree only a single change is made - the number is placed in the root of the tree and this vertex gets marked.\nThe remaining segments remain unchanged, although in fact the number should be placed in the whole tree.\n\nSuppose now that the second modification query says, that the first half of the array $a[0 \\dots n/2]$ should be assigned with some other number. \nTo process this query we must assign each element in the whole left child of the root vertex with that number. \nBut before we do this, we must first sort out the root vertex first. \nThe subtlety here is that the right half of the array should still be assigned to the value of the first query, and at the moment there is no information for the right half stored.\n\nThe way to solve this is to push the information of the root to its children, i.e. if the root of the tree was assigned with any number, then we assign the left and the right child vertices with this number and remove the mark of the root.\nAfter that, we can assign the left child with the new value, without loosing any necessary information.\n\nSummarizing we get:\nfor any queries (a modification or reading query) during the descent along the tree we should always push information from the current vertex into both of its children. \nWe can understand this in such a way, that when we descent the tree we apply delayed modifications, but exactly as much as necessary (so not to degrade the complexity of $O(\\log n)$). \n\nFor the implementation we need to make a $\\text{push}$ function, which will receive the current vertex, and it will push the information for its vertex to both its children. \nWe will call this function at the beginning of the query functions (but we will not call it from the leaves, because there is no need to push information from them any further).\n\n```cpp\nvoid push(int v) {\n    if (marked[v]) {\n        t[v*2] = t[v*2+1] = t[v];\n        marked[v*2] = marked[v*2+1] = true;\n        marked[v] = false;\n    }\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int new_val) {\n    if (l > r) \n        return;\n    if (l == tl && tr == r) {\n        t[v] = new_val;\n        marked[v] = true;\n    } else {\n        push(v);\n        int tm = (tl + tr) / 2;\n        update(v*2, tl, tm, l, min(r, tm), new_val);\n        update(v*2+1, tm+1, tr, max(l, tm+1), r, new_val);\n    }\n}\n\nint get(int v, int tl, int tr, int pos) {\n    if (tl == tr) {\n        return t[v];\n    }\n    push(v);\n    int tm = (tl + tr) / 2;\n    if (pos <= tm) \n        return get(v*2, tl, tm, pos);\n    else\n        return get(v*2+1, tm+1, tr, pos);\n}\n```\n\nNotice: the function $\\text{get}$ can also be implemented in a different way: \ndo not make delayed updates, but immediately return the value $t[v]$ if $marked[v]$ is true.\n\n#### Adding on segments, querying for maximum\n\nNow the modification query is to add a number to all elements in a range, and the reading query is to find the maximum in a range.\n\nSo for each vertex of the Segment Tree we have to store the maximum of the corresponding subsegment. \nThe interesting part is how to recompute these values during a modification request.\n\nFor this purpose we keep store an additional value for each vertex. \nIn this value we store the addends we haven't propagated to the child vertices.\nBefore traversing to a child vertex, we call $\\text{push}$ and propagate the value to both children.\nWe have to do this in both the $\\text{update}$ function and the $\\text{query}$ function.\n\n```cpp\nvoid push(int v) {\n    t[v*2] += lazy[v];\n    lazy[v*2] += lazy[v];\n    t[v*2+1] += lazy[v];\n    lazy[v*2+1] += lazy[v];\n    lazy[v] = 0;\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int addend) {\n    if (l > r) \n        return;\n    if (l == tl && tr == r) {\n        t[v] += addend;\n        lazy[v] += addend;\n    } else {\n        push(v);\n        int tm = (tl + tr) / 2;\n        update(v*2, tl, tm, l, min(r, tm), addend);\n        update(v*2+1, tm+1, tr, max(l, tm+1), r, addend);\n        t[v] = max(t[v*2], t[v*2+1]);\n    }\n}\n\nint query(int v, int tl, int tr, int l, int r) {\n    if (l > r)\n        return -INF;\n    if (l == tl && tr == r)\n        return t[v];\n    push(v);\n    int tm = (tl + tr) / 2;\n    return max(query(v*2, tl, tm, l, min(r, tm)), \n               query(v*2+1, tm+1, tr, max(l, tm+1), r));\n}\n```\n\n### <a name=\"generalization-to-higher-dimensions\"></a>Generalization to higher dimensions\n\nA Segment Tree can be generalized quite natural to higher dimensions.\nIf in the one-dimensional case we split the indices of the array into segments, then in the two-dimensional we make an ordinary Segment Tree with respect to the first indices, and for each segment we build an ordinary Segment Tree with respect to the second indices.\n\n#### Simple 2D Segment Tree\n\nA matrix $a[0 \\dots n-1, 0 \\dots m-1]$ is given, and we have to find the sum (or minimum/maximum) on some submatrix $a[x_1 \\dots x_2, y_1 \\dots y_2]$, as well as perform modifications of individual matrix elements (i.e. queries of the form $a[x][y] = p$).\n\nSo we build a 2D Segment Tree: first the Segment Tree using the first coordinate ($x$), then the second ($y$).\n\nTo make the construction process more understandable, you can forget for a while that the matrix is two-dimensional, and only leave the first coordinate.\nWe will construct an ordinary one-dimensional Segment Tree using only the first coordinate.\nBut instead of storing a number in a segment, we store an entire Segment Tree: \ni.e. at this moment we remember that we also have a second coordinate; but because at this moment the first coordinate is already fixed to some interval $[l \\dots r]$, we actually work with such a strip $a[l \\dots r, 0 \\dots m-1]$ and for it we build a Segment Tree.\n\nHere is the implementation of the construction of a 2D Segment Tree.\nIt actually represents two separate blocks: \nthe construction of a Segment Tree along the $x$ coordinate ($\\text{build}_x$), and the $y$ coordinate ($\\text{build}_y$).\nFor the leaf nodes in $\\text{build}_y$ we have to separate two cases: \nwhen the current segment of the first coordinate $[tlx \\dots trx]$ has length 1, and when it has a length greater than one. In the first case, we just take the corresponding value from the matrix, and in the second case we can combine the values of two Segment Trees from the left and the right son in the coordinate $x$.\n\n```cpp\nvoid build_y(int vx, int lx, int rx, int vy, int ly, int ry) {\n    if (ly == ry) {\n        if (lx == rx)\n            t[vx][vy] = a[lx][ly];\n        else\n            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];\n    } else {\n        int my = (ly + ry) / 2;\n        build_y(vx, lx, rx, vy*2, ly, my);\n        build_y(vx, lx, rx, vy*2+1, my+1, ry);\n        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];\n    }\n}\n\nvoid build_x(int vx, int lx, int rx) {\n    if (lx != rx) {\n        int mx = (lx + rx) / 2;\n        build_x(vx*2, lx, mx);\n        build_x(vx*2+1, mx+1, rx);\n    }\n    build_y(vx, lx, rx, 1, 0, m-1);\n}\n```\n\nSuch a Segment Tree still uses a linear amount of memory, but with a larger constant: $16 n m$.\nIt is clear that the described procedure $\\text{build}_x$ also works in linear time. \n\nNow we turn to processing of queries. We will answer to the two-dimensional query using the same principle: \nfirst break the query on the first coordinate, and then for every reached vertex, we call the corresponding Segment Tree of the second coordinate.\n\n```cpp\nint sum_y(int vx, int vy, int tly, int try_, int ly, int ry) {\n    if (ly > ry) \n        return 0;\n    if (ly == tly && try_ == ry)\n        return t[vx][vy];\n    int tmy = (tly + try_) / 2;\n    return sum_y(vx, vy*2, tly, tmy, ly, min(ry, tmy))\n         + sum_y(vx, vy*2+1, tmy+1, try_, max(ly, tmy+1), ry);\n}\n\nint sum_x(int vx, int tlx, int trx, int lx, int rx, int ly, int ry) {\n    if (lx > rx)\n        return 0;\n    if (lx == tlx && trx == rx)\n        return sum_y(vx, 1, 0, m-1, ly, ry);\n    int tmx = (tlx + trx) / 2;\n    return sum_x(vx*2, tlx, tmx, lx, min(rx, tmx), ly, ry)\n         + sum_x(vx*2+1, tmx+1, trx, max(lx, tmx+1), rx, ly, ry);\n}\n```\n\nThis function works in $O(\\log n \\log m)$ time, since it first descends the tree in the first coordinate, and for each traversed vertex in the tree it makes a query in the corresponding Segment Tree along the second coordinate.\n\nFinally we consider the modification query. \nWe want to learn how to modify the Segment Tree in accordance with the change in the value of some element $a[x][y] = p$.\nIt is clear, that the changes will occur only in those vertices of the first Segment Tree that cover the coordinate $x$ (and such will be $O(\\log n)$), and for Segment Trees corresponding to them the changes will only occurs at those vertices that covers the coordinate $y$ (and such will be $O(\\log m)$).\nTherefore the implementation will be not very different form the one-dimensional case, only now we first descend the first coordinate, and then the second.\n\n```cpp\nvoid update_y(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int new_val) {\n    if (ly == ry) {\n        if (lx == rx)\n            t[vx][vy] = new_val;\n        else\n            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];\n    } else {\n        int my = (ly + ry) / 2;\n        if (y <= my)\n            update_y(vx, lx, rx, vy*2, ly, my, x, y, new_val);\n        else\n            update_y(vx, lx, rx, vy*2+1, my+1, ry, x, y, new_val);\n        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];\n    }\n}\n\nvoid update_x(int vx, int lx, int rx, int x, int y, int new_val) {\n    if (lx != rx) {\n        int mx = (lx + rx) / 2;\n        if (x <= mx)\n            update_x(vx*2, lx, mx, x, y, new_val);\n        else\n            update_x(vx*2+1, mx+1, rx, x, y, new_val);\n    }\n    update_y(vx, lx, rx, 1, 0, m-1, x, y, new_val);\n}\n```\n\n#### Compression of 2D Segment Tree\n\nLet the problem be the following: there are $n$ points on the plane given by their coordinates $(x_i, y_i)$ and queries of the form \"count the number of points lying in the rectangle $((x_1, y_1), (x_2, y_2))$\".\nIt is clear that in the case of such a problem it becomes unreasonably wasteful to construct a two-dimensional Segment Tree with $O(n^2)$ elements.\nMost on this memory will be wasted, since each single point can only get into $O(\\log n)$ segments of the tree along the first coordinate, and therefore the total \"useful\" size of all tree segments on the second coordinate is $O(n \\log n)$.\n\nSo we proceed as follows:\nat each vertex of the Segment Tree with respect to the first coordinate we store a Segment Tree constructed only by those second coordinates that occur in the current segment of the first coordinates. \nIn other words, when constructing a Segment Tree inside some vertex with index $vx$ and the boundaries $tlx$ and $trx$, we only consider those points that fall into this interval $x \\in [tlx, trx]$, and build a Segment Tree just using them.\n\nThus we will achieve that each Segment Tree on the second coordinate will occupy exactly as much memory as it should.\nAs a result, the total amount of memory will decrease to $O(n \\log n)$.\nWe still can answer the queries in $O(\\log^2 n)$ time, we just have to make a binary search on the second coordinate, but this will not worsen the complexity.\n\nBut modification queries will be impossible with this structure:\nin fact if a new point appears, we have to add a new element in the middle of some Segment Tree along the second coordinate, which cannot be effectively done.\n\nIn conclusion we note that the two-dimensional Segment Tree contracted in the described way becomes practically equivalent to the modification of the one-dimensional Segment Tree (see [Saving the entire subarrays in each vertex](segment_tree.md#saving-the-entire-subarrays-in-each-vertex)).\nIn particular the two-dimensional Segment Tree is just a special case of storing a subarray in each vertex of the tree.\nIt follows, that if you gave to abandon a two-dimensional Segment Tree due to the impossibility of executing a query, it makes sense to try to replace the nested Segment Tree with some more powerful data structure, for example a Cartesian tree.\n\n### Preserving the history of its values (Persistent Segment Tree)\n\nA persistent data structure is a data structure that remembers it previous state for each modification.\nThis allows to access any version of this data structure that interest us and execute a query on it.\n\nSegment Tree is a data structure that can be turned into a persistent data structure efficiently (both in time and memory consumption).\nWe want to avoid copying the complete tree before each modification, and we don't want to loose the $O(\\log n)$ time behavior for answering range queries.\n\nIn fact, any change request in the Segment Tree leads to a change in the data of only $O(\\log n)$ vertices along the path starting from the root. \nSo if we store the Segment Tree using pointers (i.e. a vertex stores pointers to the left and the right child vertices), then when performing the modification query, we simply need to create new vertices instead of changing the available vertices.\nVertices that are not affected by the modification query can still be used by pointing the pointers to the old vertices.\nThus for a modification query $O(\\log n)$ new vertices will be created, including a new root vertex of the Segment Tree, and the entire previous version of the tree rooted at the old root vertex will remain unchanged.\n\nLet's give an example implementation for the simplest Segment Tree: when there is only a query asking for sums, and modification queries of single elements. \n\n```cpp\nstruct Vertex {\n    Vertex *l, *r;\n    int sum;\n\n    Vertex(int val) : l(nullptr), r(nullptr), sum(val) {}\n    Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) {\n        if (l) sum += l->sum;\n        if (r) sum += r->sum;\n    }\n};\n\nVertex* build(int a[], int tl, int tr) {\n    if (tl == tr)\n        return new Vertex(a[tl]);\n    int tm = (tl + tr) / 2;\n    return new Vertex(build(a, tl, tm), build(a, tm+1, tr));\n}\n\nint get_sum(Vertex* v, int tl, int tr, int l, int r) {\n    if (l > r)\n        return 0;\n    if (l == tl && tr == r)\n        return v->sum;\n    int tm = (tl + tr) / 2;\n    return get_sum(v->l, tl, tm, l, min(r, tm))\n         + get_sum(v->r, tm+1, tr, max(l, tm+1), r);\n}\n\nVertex* update(Vertex* v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr)\n        return new Vertex(new_val);\n    int tm = (tl + tr) / 2;\n    if (pos <= tm)\n        return new Vertex(update(v->l, tl, tm, pos, new_val), v->r);\n    else\n        return new Vertex(v->l, update(v->r, tm+1, tr, pos, new_val));\n}\n```\n\nFor each modification of the Segment Tree we will receive a new root vertex.\nTo quickly jump between two different versions of the Segment Tree, we need to store this roots in an array.\nTo use a specific version of the Segment Tree we simply call the query using the appropriate root vertex.\n\nWith the approach described above almost any Segment Tree can be turned into a persistent data structure.\n\n#### Finding the $k$-th smallest number in a range {data-toc-label=\"Finding the k-th smallest number in a range\"}\n\nThis time we have to answer queries of the form \"What is the $k$-th smallest element in the range $a[l \\dots r]$. \nThis query can be answered using a binary search and a Merge Sort Tree, but the time complexity for a single query would be $O(\\log^3 n)$.\nWe will accomplish the same task using a persistent Segment Tree in $O(\\log n)$.\n\nFirst we will discuss a solution for a simpler problem:\nWe will only consider arrays in which the elements are bound by $0 \\le a[i] \\lt n$.\nAnd we only want to find the $k$-th smallest element in some prefix of the array $a$.\nIt will be very easy to extent the developed ideas later for not restricted arrays and not restricted range queries.\nNote that we will be using 1 based indexing for $a$.\n\nWe will use a Segment Tree that counts all appearing numbers, i.e. in the Segment Tree we will store the histogram of the array.\nSo the leaf vertices will store how often the values $0$, $1$, $\\dots$, $n-1$ will appear in the array, and the other vertices store how many numbers in some range are in the array. \nIn other words we create a regular Segment Tree with sum queries over the histogram of the array.\nBut instead of creating all $n$ Segment Trees for every possible prefix, we will create one persistent one, that will contain the same information.\nWe will start with an empty Segment Tree (all counts will be $0$) pointed to by $root_0$, and add the elements $a[1]$, $a[2]$, $\\dots$, $a[n]$ one after another.\nFor each modification we will receive a new root vertex, let's call $root_i$ the root of the Segment Tree after inserting the first $i$ elements of the array $a$.\nThe Segment Tree rooted at $root_i$ will contain the histogram of the prefix $a[1 \\dots i]$.\nUsing this Segment Tree we can find in $O(\\log n)$ time the position of the $k$-th element using the same technique discussed in [Counting the number of zeros, searching for the $k$-th zero](segment_tree.md#counting-zero-search-kth).\n\nNow to the not-restricted version of the problem.\n\nFirst for the restriction on the queries: \nInstead of only performing these queries over a prefix of $a$, we want to use any arbitrary segments $a[l \\dots r]$.\nHere we need a Segment Tree that represents the histogram of the elements in the range $a[l \\dots r]$. \nIt is easy to see that such a Segment Tree is just the difference between the Segment Tree rooted at $root_{r}$ and the Segment Tree rooted at $root_{l-1}$, i.e. every vertex in the $[l \\dots r]$ Segment Tree can be computed with the vertex of the $root_{r}$ tree minus the vertex of the $root_{l-1}$ tree.\n\nIn the implementation of the $\\text{find_kth}$ function this can be handled by passing two vertex pointer and computing the count/sum of the current segment as difference of the two counts/sums of the vertices.\n\nHere are the modified $\\text{build}$, $\\text{update}$  and $\\text{find_kth}$ functions\n\n```{.cpp file=kth_smallest_persistent_segment_tree}\nVertex* build(int tl, int tr) {\n    if (tl == tr)\n        return new Vertex(0);\n    int tm = (tl + tr) / 2;\n    return new Vertex(build(tl, tm), build(tm+1, tr));\n}\n\nVertex* update(Vertex* v, int tl, int tr, int pos) {\n    if (tl == tr)\n        return new Vertex(v->sum+1);\n    int tm = (tl + tr) / 2;\n    if (pos <= tm)\n        return new Vertex(update(v->l, tl, tm, pos), v->r);\n    else\n        return new Vertex(v->l, update(v->r, tm+1, tr, pos));\n}\n\nint find_kth(Vertex* vl, Vertex *vr, int tl, int tr, int k) {\n    if (tl == tr)\n    \treturn tl;\n    int tm = (tl + tr) / 2, left_count = vr->l->sum - vl->l->sum;\n    if (left_count >= k)\n    \treturn find_kth(vl->l, vr->l, tl, tm, k);\n    return find_kth(vl->r, vr->r, tm+1, tr, k-left_count);\n}\n```\n\nAs already written above, we need to store the root of the initial Segment Tree, and also all the roots after each update.\nHere is the code for building a persistent Segment Tree over an vector `a` with elements in the range `[0, MAX_VALUE]`.\n\n```{.cpp file=kth_smallest_persistent_segment_tree_build}\nint tl = 0, tr = MAX_VALUE + 1;\nstd::vector<Vertex*> roots;\nroots.push_back(build(tl, tr));\nfor (int i = 0; i < a.size(); i++) {\n    roots.push_back(update(roots.back(), tl, tr, a[i]));\n}\n\n// find the 5th smallest number from the subarray [a[2], a[3], ..., a[19]]\nint result = find_kth(roots[2], roots[20], tl, tr, 5);\n```\n\nNow to the restrictions on the array elements:\nWe can actually transform any array to such an array by index compression.\nThe smallest element in the array will gets assigned the value 0, the second smallest the value 1, and so forth.\nIt is easy to generate lookup tables (e.g. using $\\text{map}$), that convert a value to its index and vice versa in $O(\\log n)$ time.\n\n\n\n### Dynamic segment tree\n\n(Called so because its shape is dynamic and the nodes are usually dynamically allocated.\nAlso known as _implicit segment tree_ or _sparse segment tree_.)\n\nPreviously, we considered cases when we have the ability to build the original segment tree. But what to do if the original size is filled with some default element, but its size does not allow you to completely build up to it in advance?\n\nWe can solve this problem by creating a segment tree lazily (incrementally). Initially, we will create only the root, and we will create the other vertexes only when we need them.\nIn this case, we will use the implementation on pointers(before going to the vertex children, check whether they are created, and if not, create them).\nEach query has still only the complexity $O(\\log n)$, which is small enough for most use-cases (e.g. $\\log_2 10^9 \\approx 30$).\n\nIn this implementation we have two queries, adding a value to a position (initially all values  are $0$), and computing the sum of all values in a range.\n`Vertex(0, n)` will be the root vertex of the implicit tree.\n\n```cpp\nstruct Vertex {\n    int left, right;\n    int sum = 0;\n    Vertex *left_child = nullptr, *right_child = nullptr;\n\n    Vertex(int lb, int rb) {\n        left = lb;\n        right = rb;\n    }\n\n    void extend() {\n        if (!left_child && left + 1 < right) {\n            int t = (left + right) / 2;\n            left_child = new Vertex(left, t);\n            right_child = new Vertex(t, right);\n        }\n    }\n\n    void add(int k, int x) {\n        extend();\n        sum += x;\n        if (left_child) {\n            if (k < left_child->right)\n                left_child->add(k, x);\n            else\n                right_child->add(k, x);\n        }\n    }\n\n    int get_sum(int lq, int rq) {\n        if (lq <= left && right <= rq)\n            return sum;\n        if (max(left, lq) >= min(right, rq))\n            return 0;\n        extend();\n        return left_child->get_sum(lq, rq) + right_child->get_sum(lq, rq);\n    }\n};\n```\n\nObviously this idea can be extended in lots of different ways. E.g. by adding support for range updates via lazy propagation.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: segment_tree\n---\n\n# Segment Tree\n\nA Segment Tree is a data structure that stores information about array intervals as a tree. This allows answering range queries over an array efficiently, while still being flexible enough to allow quick modification of the array.\nThis includes finding the sum of consecutive array elements $a[l \\dots r]$, or finding the minimum element in a such a range in $O(\\log n)$ time. \nBetween answering such queries, the Segment Tree allows modifying the array by replacing one element, or even changing the elements of a whole subsegment (e.g. assigning all elements $a[l \\dots r]$ to any value, or adding a value to all element in the subsegment). \n\nIn general, a Segment Tree is a very flexible data structure, and a huge number of problems can be solved with it. \nAdditionally, it is also possible to apply more complex operations and answer more complex queries (see [Advanced versions of Segment Trees](segment_tree.md#advanced-versions-of-segment-trees)).\nIn particular the Segment Tree can be easily generalized to larger dimensions. \nFor instance, with a two-dimensional Segment Tree you can answer sum or minimum queries over some subrectangle of a given matrix in only $O(\\log^2 n)$ time. \n\nOne important property of Segment Trees is that they require only a linear amount of memory.\nThe standard Segment Tree requires $4n$ vertices for working on an array of size $n$. \n\n## Simplest form of a Segment Tree\n\nTo start easy, we consider the simplest form of a Segment Tree. \nWe want to answer sum queries efficiently. \nThe formal definition of our task is:\nGiven an array $a[0 \\dots n-1]$, the Segment Tree must be able to find the sum of elements between the indices $l$ and $r$ (i.e. computing the sum $\\sum_{i=l}^r a[i]$), and also handle changing values of the elements in the array (i.e. perform assignments of the form $a[i] = x$).\nThe Segment Tree should be able to process **both** queries in $O(\\log n)$ time.\n\nThis is an improvement over the simpler approaches.\nA naive array implementation - just using a simple array - can update elements in $O(1)$, but requires $O(n)$ to compute each sum query.\nAnd precomputed prefix sums can compute sum queries in $O(1)$, but updating an array element requires $O(n)$ changes to the prefix sums.\n\n### Structure of the Segment Tree\n\nWe can take a divide-and-conquer approach when it comes to array segments. \nWe compute and store the sum of the elements of the whole array, i.e. the sum of the segment $a[0 \\dots n-1]$. \nWe then split the array into two halves $a[0 \\dots n/2-1]$ and $a[n/2 \\dots n-1]$ and compute the sum of each halve and store them. \nEach of these two halves in turn are split in half, and so on until all segments reach size $1$. \n\nWe can view these segments as forming a binary tree: \nthe root of this tree is the segment $a[0 \\dots n-1]$, and each vertex (except leaf vertices) has exactly two child vertices. \nThis is why the data structure is called \"Segment Tree\", even though in most implementations the tree is not constructed explicitly (see [Implementation](segment_tree.md#implementation)).\n\nHere is a visual representation of such a Segment Tree over the array $a = [1, 3, -2, 8, -7]$:\n\n![\"Sum Segment Tree\"](sum-segment-tree.png)\n\nFrom this short description of the data structure, we can already conclude that a Segment Tree only requires a linear number of vertices. \nThe first level of the tree contains a single node (the root), the second level will contain two vertices, in the third it will contain four vertices, until the number of vertices reaches $n$. \nThus the number of vertices in the worst case can be estimated by the sum $1 + 2 + 4 + \\dots + 2^{\\lceil\\log_2 n\\rceil} \\lt 2^{\\lceil\\log_2 n\\rceil + 1} \\lt 4n$.\n\nIt is worth noting that whenever $n$ is not a power of two, not all levels of the Segment Tree will be completely filled. \nWe can see that behavior in the image.\nFor now we can forget about this fact, but it will become important later during the implementation.\n\nThe height of the Segment Tree is $O(\\log n)$, because when going down from the root to the leaves the size of the segments decreases approximately by half. \n\n### Construction\n\nBefore constructing the segment tree, we need to decide:\n\n1. the *value* that gets stored at each node of the segment tree.\n   For example, in a sum segment tree, a node would store the sum of the elements in its range $[l, r]$.\n2. the *merge* operation that merges two siblings in a segment tree.\n   For example, in a sum segment tree, the two nodes corresponding to the ranges $a[l_1 \\dots r_1]$ and $a[l_2 \\dots r_2]$ would be merged into a node corresponding to the range $a[l_1 \\dots r_2]$ by adding the values of the two nodes.\n\nNote that a vertex is a \"leaf vertex\", if its corresponding segment covers only one value in the original array. It is present at the lowermost level of a segment tree. Its value would be equal to the (corresponding) element $a[i]$. \n\nNow, for construction of the segment tree, we start at the bottom level (the leaf vertices) and assign them their respective values. On the basis of these values, we can compute the values of the previous level, using the `merge` function.\nAnd on the basis of those, we can compute the values of the previous, and repeat the procedure until we reach the root vertex. \n\nIt is convenient to describe this operation recursively in the other direction, i.e., from the root vertex to the leaf vertices. The construction procedure, if called on a non-leaf vertex, does the following:\n\n1. recursively construct the values of the two child vertices\n2. merge the computed values of these children.\n\nWe start the construction at the root vertex, and hence, we are able to compute the entire segment tree.\n\nThe time complexity of this construction is $O(n)$, assuming that the merge operation is constant time (the merge operation gets called $n$ times, which is equal to the number of internal nodes in the segment tree).\n\n### Sum queries\n\nFor now we are going to answer sum queries. As an input we receive two integers $l$ and $r$, and we have to compute the sum of the segment $a[l \\dots r]$ in $O(\\log n)$ time. \n\nTo do this, we will traverse the Segment Tree and use the precomputed sums of the segments.\nLet's assume that we are currently at the vertex that covers the segment $a[tl \\dots tr]$.\nThere are three possible cases. \n\nThe easiest case is when the segment $a[l \\dots r]$ is equal to the corresponding segment of the current vertex (i.e. $a[l \\dots r] = a[tl \\dots tr]$), then we are finished and can return the precomputed sum that is stored in the vertex.\n\nAlternatively the segment of the query can fall completely into the domain of either the left or the right child.\nRecall that the left child covers the segment $a[tl \\dots tm]$ and the right vertex covers the segment $a[tm + 1 \\dots tr]$ with $tm = (tl + tr) / 2$. \nIn this case we can simply go to the child vertex, which corresponding segment covers the query segment, and execute the algorithm described here with that vertex. \n\nAnd then there is the last case, the query segment intersects with both children. \nIn this case we have no other option as to make two recursive calls, one for each child.\nFirst we go to the left child, compute a partial answer for this vertex (i.e. the sum of values of the intersection between the segment of the query and the segment of the left child), then go to the right child, compute the partial answer using that vertex, and then combine the answers by adding them. \nIn other words, since the left child represents the segment $a[tl \\dots tm]$ and the right child the segment $a[tm+1 \\dots tr]$, we compute the sum query $a[l \\dots tm]$ using the left child, and the sum query $a[tm+1 \\dots r]$ using the right child. \n\nSo processing a sum query is a function that recursively calls itself once with either the left or the right child (without changing the query boundaries), or twice, once for the left and once for the right child (by splitting the query into two subqueries). \nAnd the recursion ends, whenever the boundaries of the current query segment coincides with the boundaries of the segment of the current vertex. \nIn that case the answer will be the precomputed value of the sum of this segment, which is stored in the tree.\n\nIn other words, the calculation of the query is a traversal of the tree, which spreads through all necessary branches of the tree, and uses the precomputed sum values of the segments in the tree. \n\nObviously we will start the traversal from the root vertex of the Segment Tree.\n\nThe procedure is illustrated in the following image.\nAgain the array $a = [1, 3, -2, 8, -7]$ is used, and here we want to compute the sum $\\sum_{i=2}^4 a[i]$.\nThe colored vertices will be visited, and we will use the precomputed values of the green vertices.\nThis gives us the result $-2 + 1 = -1$.\n\n![\"Sum Segment Tree Query\"](sum-segment-tree-query.png)\n\nWhy is the complexity of this algorithm $O(\\log n)$?\nTo show this complexity we look at each level of the tree. \nIt turns out, that for each level we only visit not more than four vertices. \nAnd since the height of the tree is $O(\\log n)$, we receive the desired running time. \n\nWe can show that this proposition (at most four vertices each level) is true by induction.\nAt the first level, we only visit one vertex, the root vertex, so here we visit less than four vertices. \nNow let's look at an arbitrary level.\nBy induction hypothesis, we visit at most four vertices. \nIf we only visit at most two vertices, the next level has at most four vertices. That is trivial, because each vertex can only cause at most two recursive calls. \nSo let's assume that we visit three or four vertices in the current level. \nFrom those vertices, we will analyze the vertices in the middle more carefully. \nSince the sum query asks for the sum of a continuous subarray, we know that segments corresponding to the visited vertices in the middle will be completely covered by the segment of the sum query. \nTherefore these vertices will not make any recursive calls. \nSo only the most left, and the most right vertex will have the potential to make recursive calls. \nAnd those will only create at most four recursive calls, so also the next level will satisfy the assertion.\nWe can say that one branch approaches the left boundary of the query, and the second branch approaches the right one. \n\nTherefore we visit at most $4 \\log n$ vertices in total, and that is equal to a running time of $O(\\log n)$. \n\nIn conclusion the query works by dividing the input segment into several sub-segments for which all the sums are already precomputed and stored in the tree. \nAnd if we stop partitioning whenever the query segment coincides with the vertex segment, then we only need $O(\\log n)$ such segments, which gives the effectiveness of the Segment Tree. \n\n### Update queries\n\nNow we want to modify a specific element in the array, let's say we want to do the assignment $a[i] = x$. \nAnd we have to rebuild the Segment Tree, such that it correspond to the new, modified array. \n\nThis query is easier than the sum query. \nEach level of a Segment Tree forms a partition of the array. \nTherefore an element $a[i]$ only contributes to one segment from each level. \nThus only $O(\\log n)$ vertices need to be updated. \n\nIt is easy to see, that the update request can be implemented using a recursive function. \nThe function gets passed the current tree vertex, and it recursively calls itself with one of the two child vertices (the one that contains $a[i]$ in its segment), and after that recomputes its sum value, similar how it is done in the build method (that is as the sum of its two children). \n\nAgain here is a visualization using the same array.\nHere we perform the update $a[2] = 3$.\nThe green vertices are the vertices that we visit and update.\n\n![\"Sum Segment Tree Update\"](sum-segment-tree-update.png)\n\n### Implementation ### { #implementation}\n\nThe main consideration is how to store the Segment Tree.\nOf course we can define a $\\text{Vertex}$ struct and create objects, that store the boundaries of the segment, its sum and additionally also pointers to its child vertices.\nHowever, this requires storing a lot of redundant information in the form of pointers.\nWe will use a simple trick to make this a lot more efficient by using an _implicit data structure_: Only storing the sums in an array.\n(A similar method is used for binary heaps).\nThe sum of the root vertex at index 1, the sums of its two child vertices at indices 2 and 3, the sums of the children of those two vertices at indices 4 to 7, and so on. \nWith 1-indexing, conveniently the left child of a vertex at index $i$ is stored at index $2i$, and the right one at index $2i + 1$. \nEquivalently, the parent of a vertex at index $i$ is stored at $i/2$ (integer division).\n\nThis simplifies the implementation a lot. \nWe don't need to store the structure of the tree in memory. \nIt is defined implicitly. \nWe only need one array which contains the sums of all segments. \n\nAs noted before, we need to store at most $4n$ vertices.\nIt might be less, but for convenience we always allocate an array of size $4n$.\nThere will be some elements in the sum array, that will not correspond to any vertices in the actual tree, but this doesn't complicate the implementation.\n\nSo, we store the Segment Tree simply as an array $t[]$ with a size of four times the input size $n$:\n\n```{.cpp file=segment_tree_implementation_definition}\nint n, t[4*MAXN];\n```\n\nThe procedure for constructing the Segment Tree from a given array $a[]$ looks like this: \nit is a recursive function with the parameters $a[]$ (the input array), $v$ (the index of the current vertex), and the boundaries $tl$ and $tr$ of the current segment. \nIn the main program this function will be called with the parameters of the root vertex: $v = 1$, $tl = 0$, and $tr = n - 1$. \n\n```{.cpp file=segment_tree_implementation_build}\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = a[tl];\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = t[v*2] + t[v*2+1];\n    }\n}\n```\n\nFurther the function for answering sum queries is also a recursive function, which receives as parameters information about the current vertex/segment (i.e. the index $v$ and the boundaries $tl$ and $tr$) and also the information about the boundaries of the query, $l$ and $r$. \nIn order to simplify the code, this function always does two recursive calls, even if only one is necessary - in that case the superfluous recursive call will have $l > r$, and this can easily be caught using an additional check at the beginning of the function.\n\n```{.cpp file=segment_tree_implementation_sum}\nint sum(int v, int tl, int tr, int l, int r) {\n    if (l > r) \n        return 0;\n    if (l == tl && r == tr) {\n        return t[v];\n    }\n    int tm = (tl + tr) / 2;\n    return sum(v*2, tl, tm, l, min(r, tm))\n           + sum(v*2+1, tm+1, tr, max(l, tm+1), r);\n}\n```\n\nFinally the update query. The function will also receive information about the current vertex/segment, and additionally also the parameter of the update query (i.e. the position of the element and its new value).\n\n```{.cpp file=segment_tree_implementation_update}\nvoid update(int v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr) {\n        t[v] = new_val;\n    } else {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n        t[v] = t[v*2] + t[v*2+1];\n    }\n}\n```\n\n### Memory efficient implementation\n\nMost people use the implementation from the previous section. If you look at the array `t` you can see that it follows the numbering of the tree nodes in the order of a BFS traversal (level-order traversal). \nUsing this traversal the children of vertex $v$ are $2v$ and $2v + 1$ respectively.\nHowever if $n$ is not a power of two, this method will skip some indices and leave some parts of the array `t` unused.\nThe memory consumption is limited by $4n$, even though a Segment Tree of an array of $n$ elements requires only $2n - 1$ vertices.\n\nHowever it can be reduced. \nWe renumber the vertices of the tree in the order of an Euler tour traversal (pre-order traversal), and we write all these vertices next to each other.\n\nLets look at a vertex at index $v$, and let him be responsible for the segment $[l, r]$, and let $mid = \\dfrac{l + r}{2}$.\nIt is obvious that the left child will have the index $v + 1$.\nThe left child is responsible for the segment $[l, mid]$, i.e. in total there will be $2 * (mid - l + 1) - 1$ vertices in the left child's subtree.\nThus we can compute the index of the right child of $v$. The index will be $v + 2 * (mid - l + 1)$.\nBy this numbering we achieve a reduction of the necessary memory to $2n$.\n\n## <a name=\"advanced-versions-of-segment-trees\"></a>Advanced versions of Segment Trees\n\n\nA Segment Tree is a very flexible data structure, and allows variations and extensions in many different directions. \nLet's try to categorize them below. \n\n### More complex queries\n\nIt can be quite easy to change the Segment Tree in a direction, such that it computes different queries (e.g. computing the minimum / maximum instead of the sum), but it also can be very nontrivial. \n\n#### Finding the maximum\n\nLet us slightly change the condition of the problem described above: instead of querying the sum, we will now make maximum queries.\n\nThe tree will have exactly the same structure as the tree described above. \nWe only need to change the way $t[v]$ is computed in the $\\text{build}$ and $\\text{update}$ functions.\n$t[v]$ will now store the maximum of the corresponding segment. \nAnd we also need to change the calculation of the returned value of the $\\text{sum}$ function (replacing the summation by the maximum).\n\nOf course this problem can be easily changed into computing the minimum instead of the maximum.\n\nInstead of showing an implementation to this problem, the implementation will be given to a more complex version of this problem in the next section.\n\n#### Finding the maximum and the number of times it appears \n\nThis task is very similar to the previous one.\nIn addition of finding the maximum, we also have to find the number of occurrences of the maximum. \n\nTo solve this problem, we store a pair of numbers at each vertex in the tree: \nIn addition to the maximum we also store the number of occurrences of it in the corresponding segment. \nDetermining the correct pair to store at $t[v]$ can still be done in constant time using the information of the pairs stored at the child vertices. \nCombining two such pairs should be done in a separate function, since this will be an operation that we will do while building the tree, while answering maximum queries and while performing modifications.\n\n```{.cpp file=segment_tree_maximum_and_count}\npair<int, int> t[4*MAXN];\n\npair<int, int> combine(pair<int, int> a, pair<int, int> b) {\n    if (a.first > b.first) \n        return a;\n    if (b.first > a.first)\n        return b;\n    return make_pair(a.first, a.second + b.second);\n}\n\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = make_pair(a[tl], 1);\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n\npair<int, int> get_max(int v, int tl, int tr, int l, int r) {\n    if (l > r)\n        return make_pair(-INF, 0);\n    if (l == tl && r == tr)\n        return t[v];\n    int tm = (tl + tr) / 2;\n    return combine(get_max(v*2, tl, tm, l, min(r, tm)), \n                   get_max(v*2+1, tm+1, tr, max(l, tm+1), r));\n}\n\nvoid update(int v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr) {\n        t[v] = make_pair(new_val, 1);\n    } else {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n```\n#### Compute the greatest common divisor / least common multiple\n\nIn this problem we want to compute the GCD / LCM of all numbers of given ranges of the array. \n\nThis interesting variation of the Segment Tree can be solved in exactly the same way as the Segment Trees we derived for sum / minimum / maximum queries:\nit is enough to store the GCD / LCM of the corresponding vertex in each vertex of the tree. \nCombining two vertices can be done by computing the GCD / LCM of both vertices.\n\n#### Counting the number of zeros, searching for the $k$-th zero { #counting-zero-search-kth data-toc-label=\"Counting the number of zeros, searching for the k-th zero\"}\n\nIn this problem we want to find the number of zeros in a given range, and additionally find the index of the $k$-th zero using a second function.\n\nAgain we have to change the store values of the tree a bit:\nThis time we will store the number of zeros in each segment in $t[]$. \nIt is pretty clear, how to implement the $\\text{build}$, $\\text{update}$ and $\\text{count_zero}$ functions, we can simply use the ideas from the sum query problem.\nThus we solved the first part of the problem.\n\nNow we learn how to solve the problem of finding the $k$-th zero in the array $a[]$. \nTo do this task, we will descend the Segment Tree, starting at the root vertex, and moving each time to either the left or the right child, depending on which segment contains the $k$-th zero.\nIn order to decide to which child we need to go, it is enough to look at the number of zeros appearing in the segment corresponding to the left vertex.\nIf this precomputed count is greater or equal to $k$, it is necessary to descend to the left child, and otherwise descent to the right child.\nNotice, if we chose the right child, we have to subtract the number of zeros of the left child from $k$.\n\nIn the implementation we can handle the special case, $a[]$ containing less than $k$ zeros, by returning -1.\n\n```{.cpp file=segment_tree_kth_zero}\nint find_kth(int v, int tl, int tr, int k) {\n    if (k > t[v])\n        return -1;\n    if (tl == tr)\n        return tl;\n    int tm = (tl + tr) / 2;\n    if (t[v*2] >= k)\n        return find_kth(v*2, tl, tm, k);\n    else \n        return find_kth(v*2+1, tm+1, tr, k - t[v*2]);\n}\n```\n\n#### Searching for an array prefix with a given amount\n\nThe task is as follows: \nfor a given value $x$ we have to quickly find smallest index $i$ such that the sum of the first $i$ elements of the array $a[]$ is greater or equal to $x$ (assuming that the array $a[]$ only contains non-negative values).\n\nThis task can be solved using binary search, computing the sum of the prefixes with the Segment Tree.\nHowever this will lead to a $O(\\log^2 n)$ solution.\n\nInstead we can use the same idea as in the previous section, and find the position by descending the tree:\nby moving each time to the left or the right, depending on the sum of the left child.\nThus finding the answer in $O(\\log n)$ time.\n\n#### Searching for the first element greater than a given amount\n\nThe task is as follows: \nfor a given value $x$ and a range $a[l \\dots r]$ find the smallest $i$  in the range $a[l \\dots r]$, such that $a[i]$ is greater than $x$.\n\nThis task can be solved using binary search over max prefix queries with the Segment Tree.\nHowever, this will lead to a $O(\\log^2 n)$ solution.\n\nInstead, we can use the same idea as in the previous sections, and find the position by descending the tree:\nby moving each time to the left or the right, depending on the maximum value of the left child.\nThus finding the answer in $O(\\log n)$ time.\n\n```{.cpp file=segment_tree_first_greater}\nint get_first(int v, int lv, int rv, int l, int r, int x) {\n    if(lv > r || rv < l) return -1;\n    if(l <= lv && rv <= r) {\n        if(t[v] <= x) return -1;\n        while(lv != rv) {\n            int mid = lv + (rv-lv)/2;\n            if(t[2*v] > x) {\n                v = 2*v;\n                rv = mid;\n            }else {\n                v = 2*v+1;\n                lv = mid+1;\n            }\n        }\n        return lv;\n    }\n\n    int mid = lv + (rv-lv)/2;\n    int rs = get_first(2*v, lv, mid, l, r, x);\n    if(rs != -1) return rs;\n    return get_first(2*v+1, mid+1, rv, l ,r, x);\n}\n```\n\n#### Finding subsegments with the maximal sum\n\nHere again we receive a range $a[l \\dots r]$ for each query, this time we have to find a subsegment $a[l^\\prime \\dots r^\\prime]$ such that $l \\le l^\\prime$ and $r^\\prime \\le r$ and the sum of the elements of this segment is maximal. \nAs before we also want to be able to modify individual elements of the array. \nThe elements of the array can be negative, and the optimal subsegment can be empty (e.g. if all elements are negative).\n\nThis problem is a non-trivial usage of a Segment Tree.\nThis time we will store four values for each vertex: \nthe sum of the segment, the maximum prefix sum, the maximum suffix sum, and the sum of the maximal subsegment in it.\nIn other words for each segment of the Segment Tree the answer is already precomputed as well as the answers for segments touching the left and the right boundaries of the segment.\n\nHow to build a tree with such data?\nAgain we compute it in a recursive fashion: \nwe first compute all four values for the left and the right child, and then combine those to archive the four values for the current vertex.\nNote the answer for the current vertex is either:\n\n * the answer of the left child, which means that the optimal subsegment is entirely placed in the segment of the left child\n * the answer of the right child, which means that the optimal subsegment is entirely placed in the segment of the right child\n * the sum of the maximum suffix sum of the left child and the maximum prefix sum of the right child, which means that the optimal subsegment intersects with both children.\n\nHence the answer to the current vertex is the maximum of these three values. \nComputing the maximum prefix / suffix sum is even easier. \nHere is the implementation of the $\\text{combine}$ function, which receives only data from the left and right child, and returns the data of the current vertex. \n\n```{.cpp file=segment_tree_maximal_sum_subsegments1}\nstruct data {\n    int sum, pref, suff, ans;\n};\n\ndata combine(data l, data r) {\n    data res;\n    res.sum = l.sum + r.sum;\n    res.pref = max(l.pref, l.sum + r.pref);\n    res.suff = max(r.suff, r.sum + l.suff);\n    res.ans = max(max(l.ans, r.ans), l.suff + r.pref);\n    return res;\n}\n```\n\nUsing the $\\text{combine}$ function it is easy to build the Segment Tree. \nWe can implement it in exactly the same way as in the previous implementations.\nTo initialize the leaf vertices, we additionally create the auxiliary function $\\text{make_data}$, which will return a $\\text{data}$ object holding the information of a single value.\n\n```{.cpp file=segment_tree_maximal_sum_subsegments2}\ndata make_data(int val) {\n    data res;\n    res.sum = val;\n    res.pref = res.suff = res.ans = max(0, val);\n    return res;\n}\n\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = make_data(a[tl]);\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n \nvoid update(int v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr) {\n        t[v] = make_data(new_val);\n    } else {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n```\n\nIt only remains, how to compute the answer to a query. \nTo answer it, we go down the tree as before, breaking the query into several subsegments that coincide with the segments of the Segment Tree, and combine the answers in them into a single answer for the query.\nThen it should be clear, that the work is exactly the same as in the simple Segment Tree, but instead of summing / minimizing / maximizing the values, we use the $\\text{combine}$ function.\n\n```{.cpp file=segment_tree_maximal_sum_subsegments3}\ndata query(int v, int tl, int tr, int l, int r) {\n    if (l > r) \n        return make_data(0);\n    if (l == tl && r == tr) \n        return t[v];\n    int tm = (tl + tr) / 2;\n    return combine(query(v*2, tl, tm, l, min(r, tm)), \n                   query(v*2+1, tm+1, tr, max(l, tm+1), r));\n}\n```\n\n### <a name=\"saving-the-entire-subarrays-in-each-vertex\"></a>Saving the entire subarrays in each vertex\n\nThis is a separate subsection that stands apart from the others, because at each vertex of the Segment Tree we don't store information about the corresponding segment in compressed form (sum, minimum, maximum, ...), but store all elements of the segment.\nThus the root of the Segment Tree will store all elements of the array, the left child vertex will store the first half of the array, the right vertex the second half, and so on.\n\nIn its simplest application of this technique we store the elements in sorted order.\nIn more complex versions the elements are not stored in lists, but more advanced data structures (sets, maps, ...). \nBut all these methods have the common factor, that each vertex requires linear memory (i.e. proportional to the length of the corresponding segment).\n\nThe first natural question, when considering these Segment Trees, is about memory consumption.\nIntuitively this might look like $O(n^2)$ memory, but it turns out that the complete tree will only need $O(n \\log n)$ memory.\nWhy is this so?\nQuite simply, because each element of the array falls into $O(\\log n)$ segments (remember the height of the tree is $O(\\log n)$). \n\nSo in spite of the apparent extravagance of such a Segment Tree, it consumes only slightly more memory than the usual Segment Tree. \n\nSeveral typical applications of this data structure are described below.\nIt is worth noting the similarity of these Segment Trees with 2D data structures (in fact this is a 2D data structure, but with rather limited capabilities).\n\n#### Find the smallest number greater or equal to a specified number. No modification queries.\n\nWe want to answer queries of the following form: \nfor three given numbers $(l, r, x)$ we have to find the minimal number in the segment $a[l \\dots r]$ which is greater than or equal to $x$.\n\nWe construct a Segment Tree. \nIn each vertex we store a sorted list of all numbers occurring in the corresponding segment, like described above. \nHow to build such a Segment Tree as effectively as possible?\nAs always we approach this problem recursively: let the lists of the left and right children already be constructed, and we want to build the list for the current vertex.\nFrom this view the operation is now trivial and can be accomplished in linear time:\nWe only need to combine the two sorted lists into one, which can be done by iterating over them using two pointers. \nThe C++ STL already has an implementation of this algorithm.\n\nBecause this structure of the Segment Tree and the similarities to the merge sort algorithm, the data structure is also often called \"Merge Sort Tree\".\n\n```{.cpp file=segment_tree_smallest_number_greater1}\nvector<int> t[4*MAXN];\n\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = vector<int>(1, a[tl]);\n    } else { \n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        merge(t[v*2].begin(), t[v*2].end(), t[v*2+1].begin(), t[v*2+1].end(),\n              back_inserter(t[v]));\n    }\n}\n```\n\nWe already know that the Segment Tree constructed in this way will require $O(n \\log n)$ memory.\nAnd thanks to this implementation its construction also takes $O(n \\log n)$ time, after all each list is constructed in linear time in respect to its size. \n\nNow consider the answer to the query. \nWe will go down the tree, like in the regular Segment Tree, breaking our segment $a[l \\dots r]$ into several subsegments (into at most $O(\\log n)$ pieces). \nIt is clear that the answer of the whole answer is the minimum of each of the subqueries.\nSo now we only need to understand, how to respond to a query on one such subsegment that corresponds with some vertex of the tree.\n\nWe are at some vertex of the Segment Tree and we want to compute the answer to the query, i.e. find the minimum number greater that or equal to a given number $x$. \nSince the vertex contains the list of elements in sorted order, we can simply perform a binary search on this list and return the first number, greater than or equal to $x$.\n\nThus the answer to the query in one segment of the tree takes $O(\\log n)$ time, and the entire query is processed in $O(\\log^2 n)$.\n\n```{.cpp file=segment_tree_smallest_number_greater2}\nint query(int v, int tl, int tr, int l, int r, int x) {\n    if (l > r)\n        return INF;\n    if (l == tl && r == tr) {\n        vector<int>::iterator pos = lower_bound(t[v].begin(), t[v].end(), x);\n        if (pos != t[v].end())\n            return *pos;\n        return INF;\n    }\n    int tm = (tl + tr) / 2;\n    return min(query(v*2, tl, tm, l, min(r, tm), x), \n               query(v*2+1, tm+1, tr, max(l, tm+1), r, x));\n}\n```\n\nThe constant $\\text{INF}$ is equal to some large number that is bigger than all numbers in the array. \nIts usage means, that there is no number greater than or equal to $x$ in the segment. \nIt has the meaning of \"there is no answer in the given interval\".\n\n#### Find the smallest number greater or equal to a specified number. With modification queries.\n\nThis task is similar to the previous.\nThe last approach has a disadvantage, it was not possible to modify the array between answering queries.\nNow we want to do exactly this: a modification query will do the assignment $a[i] = y$.\n\nThe solution is similar to the solution of the previous problem, but instead of lists at each vertex of the Segment Tree, we will store a balanced list that allows you to quickly search for numbers, delete numbers, and insert new numbers. \nSince the array can contain a number repeated, the optimal choice is the data structure $\\text{multiset}$. \n\nThe construction of such a Segment Tree is done in pretty much the same way as in the previous problem, only now we need to combine $\\text{multiset}$s and not sorted lists.\nThis leads to a construction time of $O(n \\log^2 n)$ (in general merging two red-black trees can be done in linear time, but the C++ STL doesn't guarantee this time complexity).\n\nThe $\\text{query}$ function is also almost equivalent, only now the $\\text{lower_bound}$ function of the $\\text{multiset}$ function should be called instead ($\\text{std::lower_bound}$ only works in $O(\\log n)$ time if used with random-access iterators).\n\nFinally the modification request. \nTo process it, we must go down the tree, and modify all $\\text{multiset}$ from the corresponding segments that contain the effected element.\nWe simply delete the old value of this element (but only one occurrence), and insert the new value.\n\n```cpp\nvoid update(int v, int tl, int tr, int pos, int new_val) {\n    t[v].erase(t[v].find(a[pos]));\n    t[v].insert(new_val);\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n    } else {\n        a[pos] = new_val;\n    }\n}\n```\n\nProcessing of this modification query also takes $O(\\log^2 n)$ time.\n\n#### Find the smallest number greater or equal to a specified number. Acceleration with \"fractional cascading\".\n\nWe have the same problem statement, we want to find the minimal number greater than or equal to $x$ in a segment, but this time in $O(\\log n)$ time.\nWe will improve the time complexity using the technique \"fractional cascading\".\n\nFractional cascading is a simple technique that allows you to improve the running time of multiple binary searches, which are conducted at the same time. \nOur previous approach to the search query was, that we divide the task into several subtasks, each of which is solved with a binary search. \nFractional cascading allows you to replace all of these binary searches with a single one.\n\nThe simplest and most obvious example of fractional cascading is the following problem:\nthere are $k$ sorted lists of numbers, and we must find in each list the first number greater than or equal to the given number.\n\nInstead of performing a binary search for each list, we could merge all lists into one big sorted list.\nAdditionally for each element $y$ we store a list of results of searching for $y$ in each of the $k$ lists.\nTherefore if we want to find the smallest number greater than or equal to $x$, we just need to perform one single binary search, and from the list of indices we can determine the smallest number in each list.\nThis approach however requires $O(n \\cdot k)$ ($n$ is the length of the combined lists), which can be quite inefficient. \n\nFractional cascading reduces this memory complexity to $O(n)$ memory, by creating from the $k$ input lists $k$ new lists, in which each list contains the corresponding list and additionally also every second element of the following new list.\nUsing this structure it is only necessary to store two indices, the index of the element in the original list, and the index of the element in the following new list.\nSo this approach only uses $O(n)$ memory, and still can answer the queries using a single binary search. \n\nBut for our application we do not need the full power of fractional cascading.\nIn our Segment Tree a vertex will contain the sorted list of all elements that occur in either the left or the right subtrees (like in the Merge Sort Tree). \nAdditionally to this sorted list, we store two positions for each element.\nFor an element $y$ we store the smallest index $i$, such that the $i$th element in the sorted list of the left child is greater or equal to $y$.\nAnd we store the smallest index $j$, such that the $j$th element in the sorted list of the right child is greater or equal to $y$.\nThese values can be computed in parallel to the merging step when we build the tree.\n\nHow does this speed up the queries?\n\nRemember, in the normal solution we did a binary search in ever node.\nBut with this modification, we can avoid all except one.\n\nTo answer a query, we simply to a binary search in the root node.\nThis gives as the smallest element $y \\ge x$ in the complete array, but it also gives us two positions.\nThe index of the smallest element greater or equal $x$ in the left subtree, and the index of the smallest element $y$ in the right subtree. Notice that $\\ge y$ is the same as $\\ge x$, since our array doesn't contain any elements between $x$ and $y$.\nIn the normal Merge Sort Tree solution we would compute these indices via binary search, but with the help of the precomputed values we can just look them up in $O(1)$.\nAnd we can repeat that until we visited all nodes that cover our query interval.\n\nTo summarize, as usual we touch $O(\\log n)$ nodes during a query. In the root node we do a binary search, and in all other nodes we only do constant work.\nThis means the complexity for answering a query is $O(\\log n)$.\n\nBut notice, that this uses three times more memory than a normal Merge Sort Tree, which already uses a lot of memory ($O(n \\log n)$).\n\nIt is straightforward to apply this technique to a problem, that doesn't require any modification queries.\nThe two positions are just integers and can easily be computed by counting when merging the two sorted sequences.\n\nIt it still possible to also allow modification queries, but that complicates the entire code.\nInstead of integers, you need to store the sorted array as `multiset`, and instead of indices you need to store iterators.\nAnd you need to work very carefully, so that you increment or decrement the correct iterators during a modification query.\n\n#### Other possible variations\n\nThis technique implies a whole new class of possible applications. \nInstead of storing a $\\text{vector}$ or a $\\text{multiset}$ in each vertex, other data structures can be used:\nother Segment Trees (somewhat discussed in [Generalization to higher dimensions](segment_tree.md#generalization-to-higher-dimensions)), Fenwick Trees, Cartesian trees, etc.\n\n### Range updates (Lazy Propagation)\n\nAll problems in the above sections discussed modification queries that only effected a single element of the array each.\nHowever the Segment Tree allows applying modification queries to an entire segment of contiguous elements, and perform the query in the same time $O(\\log n)$. \n\n#### Addition on segments\n\nWe begin by considering problems of the simplest form: the modification query should add a number $x$ to all numbers in the segment $a[l \\dots r]$.\nThe second query, that we are supposed to answer, asked simply for the value of $a[i]$.\n\nTo make the addition query efficient, we store at each vertex in the Segment Tree how many we should add to all numbers in the corresponding segment. \nFor example, if the query \"add 3 to the whole array $a[0 \\dots n-1]$\" comes, then we place the number 3 in the root of the tree.\nIn general we have to place this number to multiple segments, which form a partition of the query segment. \nThus we don't have to change all $O(n)$ values, but only $O(\\log n)$ many.\n\nIf now there comes a query that asks the current value of a particular array entry, it is enough to go down the tree and add up all values found along the way.\n\n```cpp\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = a[tl];\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = 0;\n    }\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int add) {\n    if (l > r)\n        return;\n    if (l == tl && r == tr) {\n        t[v] += add;\n    } else {\n        int tm = (tl + tr) / 2;\n        update(v*2, tl, tm, l, min(r, tm), add);\n        update(v*2+1, tm+1, tr, max(l, tm+1), r, add);\n    }\n}\n\nint get(int v, int tl, int tr, int pos) {\n    if (tl == tr)\n        return t[v];\n    int tm = (tl + tr) / 2;\n    if (pos <= tm)\n        return t[v] + get(v*2, tl, tm, pos);\n    else\n        return t[v] + get(v*2+1, tm+1, tr, pos);\n}\n```\n\n#### Assignment on segments\n\nSuppose now that the modification query asks to assign each element of a certain segment $a[l \\dots r]$ to some value $p$.\nAs a second query we will again consider reading the value of the array $a[i]$.\n\nTo perform this modification query on a whole segment, you have to store at each vertex of the Segment Tree whether the corresponding segment is covered entirely with the same value or not.\nThis allows us to make a \"lazy\" update: \ninstead of changing all segments in the tree that cover the query segment, we only change some, and leave others unchanged.\nA marked vertex will mean, that every element of the corresponding segment is assigned to that value, and actually also the complete subtree should only contain this value.\nIn a sense we are lazy and delay writing the new value to all those vertices.\nWe can do this tedious task later, if this is necessary.\n\nSo after the modification query is executed, some parts of the tree become irrelevant - some modifications remain unfulfilled in it.\n\nFor example if a modification query \"assign a number to the whole array $a[0 \\dots n-1]$\" gets executed, in the Segment Tree only a single change is made - the number is placed in the root of the tree and this vertex gets marked.\nThe remaining segments remain unchanged, although in fact the number should be placed in the whole tree.\n\nSuppose now that the second modification query says, that the first half of the array $a[0 \\dots n/2]$ should be assigned with some other number. \nTo process this query we must assign each element in the whole left child of the root vertex with that number. \nBut before we do this, we must first sort out the root vertex first. \nThe subtlety here is that the right half of the array should still be assigned to the value of the first query, and at the moment there is no information for the right half stored.\n\nThe way to solve this is to push the information of the root to its children, i.e. if the root of the tree was assigned with any number, then we assign the left and the right child vertices with this number and remove the mark of the root.\nAfter that, we can assign the left child with the new value, without loosing any necessary information.\n\nSummarizing we get:\nfor any queries (a modification or reading query) during the descent along the tree we should always push information from the current vertex into both of its children. \nWe can understand this in such a way, that when we descent the tree we apply delayed modifications, but exactly as much as necessary (so not to degrade the complexity of $O(\\log n)$). \n\nFor the implementation we need to make a $\\text{push}$ function, which will receive the current vertex, and it will push the information for its vertex to both its children. \nWe will call this function at the beginning of the query functions (but we will not call it from the leaves, because there is no need to push information from them any further).\n\n```cpp\nvoid push(int v) {\n    if (marked[v]) {\n        t[v*2] = t[v*2+1] = t[v];\n        marked[v*2] = marked[v*2+1] = true;\n        marked[v] = false;\n    }\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int new_val) {\n    if (l > r) \n        return;\n    if (l == tl && tr == r) {\n        t[v] = new_val;\n        marked[v] = true;\n    } else {\n        push(v);\n        int tm = (tl + tr) / 2;\n        update(v*2, tl, tm, l, min(r, tm), new_val);\n        update(v*2+1, tm+1, tr, max(l, tm+1), r, new_val);\n    }\n}\n\nint get(int v, int tl, int tr, int pos) {\n    if (tl == tr) {\n        return t[v];\n    }\n    push(v);\n    int tm = (tl + tr) / 2;\n    if (pos <= tm) \n        return get(v*2, tl, tm, pos);\n    else\n        return get(v*2+1, tm+1, tr, pos);\n}\n```\n\nNotice: the function $\\text{get}$ can also be implemented in a different way: \ndo not make delayed updates, but immediately return the value $t[v]$ if $marked[v]$ is true.\n\n#### Adding on segments, querying for maximum\n\nNow the modification query is to add a number to all elements in a range, and the reading query is to find the maximum in a range.\n\nSo for each vertex of the Segment Tree we have to store the maximum of the corresponding subsegment. \nThe interesting part is how to recompute these values during a modification request.\n\nFor this purpose we keep store an additional value for each vertex. \nIn this value we store the addends we haven't propagated to the child vertices.\nBefore traversing to a child vertex, we call $\\text{push}$ and propagate the value to both children.\nWe have to do this in both the $\\text{update}$ function and the $\\text{query}$ function.\n\n```cpp\nvoid push(int v) {\n    t[v*2] += lazy[v];\n    lazy[v*2] += lazy[v];\n    t[v*2+1] += lazy[v];\n    lazy[v*2+1] += lazy[v];\n    lazy[v] = 0;\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int addend) {\n    if (l > r) \n        return;\n    if (l == tl && tr == r) {\n        t[v] += addend;\n        lazy[v] += addend;\n    } else {\n        push(v);\n        int tm = (tl + tr) / 2;\n        update(v*2, tl, tm, l, min(r, tm), addend);\n        update(v*2+1, tm+1, tr, max(l, tm+1), r, addend);\n        t[v] = max(t[v*2], t[v*2+1]);\n    }\n}\n\nint query(int v, int tl, int tr, int l, int r) {\n    if (l > r)\n        return -INF;\n    if (l == tl && tr == r)\n        return t[v];\n    push(v);\n    int tm = (tl + tr) / 2;\n    return max(query(v*2, tl, tm, l, min(r, tm)), \n               query(v*2+1, tm+1, tr, max(l, tm+1), r));\n}\n```\n\n### <a name=\"generalization-to-higher-dimensions\"></a>Generalization to higher dimensions\n\nA Segment Tree can be generalized quite natural to higher dimensions.\nIf in the one-dimensional case we split the indices of the array into segments, then in the two-dimensional we make an ordinary Segment Tree with respect to the first indices, and for each segment we build an ordinary Segment Tree with respect to the second indices.\n\n#### Simple 2D Segment Tree\n\nA matrix $a[0 \\dots n-1, 0 \\dots m-1]$ is given, and we have to find the sum (or minimum/maximum) on some submatrix $a[x_1 \\dots x_2, y_1 \\dots y_2]$, as well as perform modifications of individual matrix elements (i.e. queries of the form $a[x][y] = p$).\n\nSo we build a 2D Segment Tree: first the Segment Tree using the first coordinate ($x$), then the second ($y$).\n\nTo make the construction process more understandable, you can forget for a while that the matrix is two-dimensional, and only leave the first coordinate.\nWe will construct an ordinary one-dimensional Segment Tree using only the first coordinate.\nBut instead of storing a number in a segment, we store an entire Segment Tree: \ni.e. at this moment we remember that we also have a second coordinate; but because at this moment the first coordinate is already fixed to some interval $[l \\dots r]$, we actually work with such a strip $a[l \\dots r, 0 \\dots m-1]$ and for it we build a Segment Tree.\n\nHere is the implementation of the construction of a 2D Segment Tree.\nIt actually represents two separate blocks: \nthe construction of a Segment Tree along the $x$ coordinate ($\\text{build}_x$), and the $y$ coordinate ($\\text{build}_y$).\nFor the leaf nodes in $\\text{build}_y$ we have to separate two cases: \nwhen the current segment of the first coordinate $[tlx \\dots trx]$ has length 1, and when it has a length greater than one. In the first case, we just take the corresponding value from the matrix, and in the second case we can combine the values of two Segment Trees from the left and the right son in the coordinate $x$.\n\n```cpp\nvoid build_y(int vx, int lx, int rx, int vy, int ly, int ry) {\n    if (ly == ry) {\n        if (lx == rx)\n            t[vx][vy] = a[lx][ly];\n        else\n            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];\n    } else {\n        int my = (ly + ry) / 2;\n        build_y(vx, lx, rx, vy*2, ly, my);\n        build_y(vx, lx, rx, vy*2+1, my+1, ry);\n        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];\n    }\n}\n\nvoid build_x(int vx, int lx, int rx) {\n    if (lx != rx) {\n        int mx = (lx + rx) / 2;\n        build_x(vx*2, lx, mx);\n        build_x(vx*2+1, mx+1, rx);\n    }\n    build_y(vx, lx, rx, 1, 0, m-1);\n}\n```\n\nSuch a Segment Tree still uses a linear amount of memory, but with a larger constant: $16 n m$.\nIt is clear that the described procedure $\\text{build}_x$ also works in linear time. \n\nNow we turn to processing of queries. We will answer to the two-dimensional query using the same principle: \nfirst break the query on the first coordinate, and then for every reached vertex, we call the corresponding Segment Tree of the second coordinate.\n\n```cpp\nint sum_y(int vx, int vy, int tly, int try_, int ly, int ry) {\n    if (ly > ry) \n        return 0;\n    if (ly == tly && try_ == ry)\n        return t[vx][vy];\n    int tmy = (tly + try_) / 2;\n    return sum_y(vx, vy*2, tly, tmy, ly, min(ry, tmy))\n         + sum_y(vx, vy*2+1, tmy+1, try_, max(ly, tmy+1), ry);\n}\n\nint sum_x(int vx, int tlx, int trx, int lx, int rx, int ly, int ry) {\n    if (lx > rx)\n        return 0;\n    if (lx == tlx && trx == rx)\n        return sum_y(vx, 1, 0, m-1, ly, ry);\n    int tmx = (tlx + trx) / 2;\n    return sum_x(vx*2, tlx, tmx, lx, min(rx, tmx), ly, ry)\n         + sum_x(vx*2+1, tmx+1, trx, max(lx, tmx+1), rx, ly, ry);\n}\n```\n\nThis function works in $O(\\log n \\log m)$ time, since it first descends the tree in the first coordinate, and for each traversed vertex in the tree it makes a query in the corresponding Segment Tree along the second coordinate.\n\nFinally we consider the modification query. \nWe want to learn how to modify the Segment Tree in accordance with the change in the value of some element $a[x][y] = p$.\nIt is clear, that the changes will occur only in those vertices of the first Segment Tree that cover the coordinate $x$ (and such will be $O(\\log n)$), and for Segment Trees corresponding to them the changes will only occurs at those vertices that covers the coordinate $y$ (and such will be $O(\\log m)$).\nTherefore the implementation will be not very different form the one-dimensional case, only now we first descend the first coordinate, and then the second.\n\n```cpp\nvoid update_y(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int new_val) {\n    if (ly == ry) {\n        if (lx == rx)\n            t[vx][vy] = new_val;\n        else\n            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];\n    } else {\n        int my = (ly + ry) / 2;\n        if (y <= my)\n            update_y(vx, lx, rx, vy*2, ly, my, x, y, new_val);\n        else\n            update_y(vx, lx, rx, vy*2+1, my+1, ry, x, y, new_val);\n        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];\n    }\n}\n\nvoid update_x(int vx, int lx, int rx, int x, int y, int new_val) {\n    if (lx != rx) {\n        int mx = (lx + rx) / 2;\n        if (x <= mx)\n            update_x(vx*2, lx, mx, x, y, new_val);\n        else\n            update_x(vx*2+1, mx+1, rx, x, y, new_val);\n    }\n    update_y(vx, lx, rx, 1, 0, m-1, x, y, new_val);\n}\n```\n\n#### Compression of 2D Segment Tree\n\nLet the problem be the following: there are $n$ points on the plane given by their coordinates $(x_i, y_i)$ and queries of the form \"count the number of points lying in the rectangle $((x_1, y_1), (x_2, y_2))$\".\nIt is clear that in the case of such a problem it becomes unreasonably wasteful to construct a two-dimensional Segment Tree with $O(n^2)$ elements.\nMost on this memory will be wasted, since each single point can only get into $O(\\log n)$ segments of the tree along the first coordinate, and therefore the total \"useful\" size of all tree segments on the second coordinate is $O(n \\log n)$.\n\nSo we proceed as follows:\nat each vertex of the Segment Tree with respect to the first coordinate we store a Segment Tree constructed only by those second coordinates that occur in the current segment of the first coordinates. \nIn other words, when constructing a Segment Tree inside some vertex with index $vx$ and the boundaries $tlx$ and $trx$, we only consider those points that fall into this interval $x \\in [tlx, trx]$, and build a Segment Tree just using them.\n\nThus we will achieve that each Segment Tree on the second coordinate will occupy exactly as much memory as it should.\nAs a result, the total amount of memory will decrease to $O(n \\log n)$.\nWe still can answer the queries in $O(\\log^2 n)$ time, we just have to make a binary search on the second coordinate, but this will not worsen the complexity.\n\nBut modification queries will be impossible with this structure:\nin fact if a new point appears, we have to add a new element in the middle of some Segment Tree along the second coordinate, which cannot be effectively done.\n\nIn conclusion we note that the two-dimensional Segment Tree contracted in the described way becomes practically equivalent to the modification of the one-dimensional Segment Tree (see [Saving the entire subarrays in each vertex](segment_tree.md#saving-the-entire-subarrays-in-each-vertex)).\nIn particular the two-dimensional Segment Tree is just a special case of storing a subarray in each vertex of the tree.\nIt follows, that if you gave to abandon a two-dimensional Segment Tree due to the impossibility of executing a query, it makes sense to try to replace the nested Segment Tree with some more powerful data structure, for example a Cartesian tree.\n\n### Preserving the history of its values (Persistent Segment Tree)\n\nA persistent data structure is a data structure that remembers it previous state for each modification.\nThis allows to access any version of this data structure that interest us and execute a query on it.\n\nSegment Tree is a data structure that can be turned into a persistent data structure efficiently (both in time and memory consumption).\nWe want to avoid copying the complete tree before each modification, and we don't want to loose the $O(\\log n)$ time behavior for answering range queries.\n\nIn fact, any change request in the Segment Tree leads to a change in the data of only $O(\\log n)$ vertices along the path starting from the root. \nSo if we store the Segment Tree using pointers (i.e. a vertex stores pointers to the left and the right child vertices), then when performing the modification query, we simply need to create new vertices instead of changing the available vertices.\nVertices that are not affected by the modification query can still be used by pointing the pointers to the old vertices.\nThus for a modification query $O(\\log n)$ new vertices will be created, including a new root vertex of the Segment Tree, and the entire previous version of the tree rooted at the old root vertex will remain unchanged.\n\nLet's give an example implementation for the simplest Segment Tree: when there is only a query asking for sums, and modification queries of single elements. \n\n```cpp\nstruct Vertex {\n    Vertex *l, *r;\n    int sum;\n\n    Vertex(int val) : l(nullptr), r(nullptr), sum(val) {}\n    Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) {\n        if (l) sum += l->sum;\n        if (r) sum += r->sum;\n    }\n};\n\nVertex* build(int a[], int tl, int tr) {\n    if (tl == tr)\n        return new Vertex(a[tl]);\n    int tm = (tl + tr) / 2;\n    return new Vertex(build(a, tl, tm), build(a, tm+1, tr));\n}\n\nint get_sum(Vertex* v, int tl, int tr, int l, int r) {\n    if (l > r)\n        return 0;\n    if (l == tl && tr == r)\n        return v->sum;\n    int tm = (tl + tr) / 2;\n    return get_sum(v->l, tl, tm, l, min(r, tm))\n         + get_sum(v->r, tm+1, tr, max(l, tm+1), r);\n}\n\nVertex* update(Vertex* v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr)\n        return new Vertex(new_val);\n    int tm = (tl + tr) / 2;\n    if (pos <= tm)\n        return new Vertex(update(v->l, tl, tm, pos, new_val), v->r);\n    else\n        return new Vertex(v->l, update(v->r, tm+1, tr, pos, new_val));\n}\n```\n\nFor each modification of the Segment Tree we will receive a new root vertex.\nTo quickly jump between two different versions of the Segment Tree, we need to store this roots in an array.\nTo use a specific version of the Segment Tree we simply call the query using the appropriate root vertex.\n\nWith the approach described above almost any Segment Tree can be turned into a persistent data structure.\n\n#### Finding the $k$-th smallest number in a range {data-toc-label=\"Finding the k-th smallest number in a range\"}\n\nThis time we have to answer queries of the form \"What is the $k$-th smallest element in the range $a[l \\dots r]$. \nThis query can be answered using a binary search and a Merge Sort Tree, but the time complexity for a single query would be $O(\\log^3 n)$.\nWe will accomplish the same task using a persistent Segment Tree in $O(\\log n)$.\n\nFirst we will discuss a solution for a simpler problem:\nWe will only consider arrays in which the elements are bound by $0 \\le a[i] \\lt n$.\nAnd we only want to find the $k$-th smallest element in some prefix of the array $a$.\nIt will be very easy to extent the developed ideas later for not restricted arrays and not restricted range queries.\nNote that we will be using 1 based indexing for $a$.\n\nWe will use a Segment Tree that counts all appearing numbers, i.e. in the Segment Tree we will store the histogram of the array.\nSo the leaf vertices will store how often the values $0$, $1$, $\\dots$, $n-1$ will appear in the array, and the other vertices store how many numbers in some range are in the array. \nIn other words we create a regular Segment Tree with sum queries over the histogram of the array.\nBut instead of creating all $n$ Segment Trees for every possible prefix, we will create one persistent one, that will contain the same information.\nWe will start with an empty Segment Tree (all counts will be $0$) pointed to by $root_0$, and add the elements $a[1]$, $a[2]$, $\\dots$, $a[n]$ one after another.\nFor each modification we will receive a new root vertex, let's call $root_i$ the root of the Segment Tree after inserting the first $i$ elements of the array $a$.\nThe Segment Tree rooted at $root_i$ will contain the histogram of the prefix $a[1 \\dots i]$.\nUsing this Segment Tree we can find in $O(\\log n)$ time the position of the $k$-th element using the same technique discussed in [Counting the number of zeros, searching for the $k$-th zero](segment_tree.md#counting-zero-search-kth).\n\nNow to the not-restricted version of the problem.\n\nFirst for the restriction on the queries: \nInstead of only performing these queries over a prefix of $a$, we want to use any arbitrary segments $a[l \\dots r]$.\nHere we need a Segment Tree that represents the histogram of the elements in the range $a[l \\dots r]$. \nIt is easy to see that such a Segment Tree is just the difference between the Segment Tree rooted at $root_{r}$ and the Segment Tree rooted at $root_{l-1}$, i.e. every vertex in the $[l \\dots r]$ Segment Tree can be computed with the vertex of the $root_{r}$ tree minus the vertex of the $root_{l-1}$ tree.\n\nIn the implementation of the $\\text{find_kth}$ function this can be handled by passing two vertex pointer and computing the count/sum of the current segment as difference of the two counts/sums of the vertices.\n\nHere are the modified $\\text{build}$, $\\text{update}$  and $\\text{find_kth}$ functions\n\n```{.cpp file=kth_smallest_persistent_segment_tree}\nVertex* build(int tl, int tr) {\n    if (tl == tr)\n        return new Vertex(0);\n    int tm = (tl + tr) / 2;\n    return new Vertex(build(tl, tm), build(tm+1, tr));\n}\n\nVertex* update(Vertex* v, int tl, int tr, int pos) {\n    if (tl == tr)\n        return new Vertex(v->sum+1);\n    int tm = (tl + tr) / 2;\n    if (pos <= tm)\n        return new Vertex(update(v->l, tl, tm, pos), v->r);\n    else\n        return new Vertex(v->l, update(v->r, tm+1, tr, pos));\n}\n\nint find_kth(Vertex* vl, Vertex *vr, int tl, int tr, int k) {\n    if (tl == tr)\n    \treturn tl;\n    int tm = (tl + tr) / 2, left_count = vr->l->sum - vl->l->sum;\n    if (left_count >= k)\n    \treturn find_kth(vl->l, vr->l, tl, tm, k);\n    return find_kth(vl->r, vr->r, tm+1, tr, k-left_count);\n}\n```\n\nAs already written above, we need to store the root of the initial Segment Tree, and also all the roots after each update.\nHere is the code for building a persistent Segment Tree over an vector `a` with elements in the range `[0, MAX_VALUE]`.\n\n```{.cpp file=kth_smallest_persistent_segment_tree_build}\nint tl = 0, tr = MAX_VALUE + 1;\nstd::vector<Vertex*> roots;\nroots.push_back(build(tl, tr));\nfor (int i = 0; i < a.size(); i++) {\n    roots.push_back(update(roots.back(), tl, tr, a[i]));\n}\n\n// find the 5th smallest number from the subarray [a[2], a[3], ..., a[19]]\nint result = find_kth(roots[2], roots[20], tl, tr, 5);\n```\n\nNow to the restrictions on the array elements:\nWe can actually transform any array to such an array by index compression.\nThe smallest element in the array will gets assigned the value 0, the second smallest the value 1, and so forth.\nIt is easy to generate lookup tables (e.g. using $\\text{map}$), that convert a value to its index and vice versa in $O(\\log n)$ time.\n\n\n\n### Dynamic segment tree\n\n(Called so because its shape is dynamic and the nodes are usually dynamically allocated.\nAlso known as _implicit segment tree_ or _sparse segment tree_.)\n\nPreviously, we considered cases when we have the ability to build the original segment tree. But what to do if the original size is filled with some default element, but its size does not allow you to completely build up to it in advance?\n\nWe can solve this problem by creating a segment tree lazily (incrementally). Initially, we will create only the root, and we will create the other vertexes only when we need them.\nIn this case, we will use the implementation on pointers(before going to the vertex children, check whether they are created, and if not, create them).\nEach query has still only the complexity $O(\\log n)$, which is small enough for most use-cases (e.g. $\\log_2 10^9 \\approx 30$).\n\nIn this implementation we have two queries, adding a value to a position (initially all values  are $0$), and computing the sum of all values in a range.\n`Vertex(0, n)` will be the root vertex of the implicit tree.\n\n```cpp\nstruct Vertex {\n    int left, right;\n    int sum = 0;\n    Vertex *left_child = nullptr, *right_child = nullptr;\n\n    Vertex(int lb, int rb) {\n        left = lb;\n        right = rb;\n    }\n\n    void extend() {\n        if (!left_child && left + 1 < right) {\n            int t = (left + right) / 2;\n            left_child = new Vertex(left, t);\n            right_child = new Vertex(t, right);\n        }\n    }\n\n    void add(int k, int x) {\n        extend();\n        sum += x;\n        if (left_child) {\n            if (k < left_child->right)\n                left_child->add(k, x);\n            else\n                right_child->add(k, x);\n        }\n    }\n\n    int get_sum(int lq, int rq) {\n        if (lq <= left && right <= rq)\n            return sum;\n        if (max(left, lq) >= min(right, rq))\n            return 0;\n        extend();\n        return left_child->get_sum(lq, rq) + right_child->get_sum(lq, rq);\n    }\n};\n```\n\nObviously this idea can be extended in lots of different ways. E.g. by adding support for range updates via lazy propagation.\n\n## Practice Problems\n\n* [SPOJ - KQUERY](http://www.spoj.com/problems/KQUERY/) [Persistent segment tree / Merge sort tree]\n* [Codeforces - Xenia and Bit Operations](https://codeforces.com/problemset/problem/339/D)\n* [UVA 11402 - Ahoy, Pirates!](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2397)\n* [SPOJ - GSS3](http://www.spoj.com/problems/GSS3/)\n* [Codeforces - Distinct Characters Queries](https://codeforces.com/problemset/problem/1234/D)\n* [Codeforces - Knight Tournament](https://codeforces.com/contest/356/problem/A) [For beginners]\n* [Codeforces - Ant colony](https://codeforces.com/contest/474/problem/F)\n* [Codeforces - Drazil and Park](https://codeforces.com/contest/515/problem/E)\n* [Codeforces - Circular RMQ](https://codeforces.com/problemset/problem/52/C)\n* [Codeforces - Lucky Array](https://codeforces.com/contest/121/problem/E)\n* [Codeforces - The Child and Sequence](https://codeforces.com/contest/438/problem/D)\n* [Codeforces - DZY Loves Fibonacci Numbers](https://codeforces.com/contest/446/problem/C) [Lazy propagation]\n* [Codeforces - Alphabet Permutations](https://codeforces.com/problemset/problem/610/E)\n* [Codeforces - Eyes Closed](https://codeforces.com/problemset/problem/895/E)\n* [Codeforces - Kefa and Watch](https://codeforces.com/problemset/problem/580/E)\n* [Codeforces - A Simple Task](https://codeforces.com/problemset/problem/558/E)\n* [Codeforces - SUM and REPLACE](https://codeforces.com/problemset/problem/920/F)\n* [Codeforces - XOR on Segment](https://codeforces.com/problemset/problem/242/E) [Lazy propagation]\n* [Codeforces - Please, another Queries on Array?](https://codeforces.com/problemset/problem/1114/F) [Lazy propagation]\n* [COCI - Deda](https://oj.uz/problem/view/COCI17_deda) [Last element smaller or equal to x / Binary search]\n* [Codeforces - The Untended Antiquity](https://codeforces.com/problemset/problem/869/E) [2D]\n* [CSES - Hotel Queries](https://cses.fi/problemset/task/1143)\n* [CSES - Polynomial Queries](https://cses.fi/problemset/task/1736)\n* [CSES - Range Updates and Sums](https://cses.fi/problemset/task/1735)\n\n", "problem_ids": ["339_D", "1234_D", "356_A", "474_F", "515_E", "52_C", "121_E", "438_D", "446_C", "610_E", "895_E", "580_E", "558_E", "920_F", "242_E", "1114_F", "869_E"], "title": "Segment Tree"}, {"article": "---\ntags:\n  - Original\n---\n\n# Sqrt Tree\n\nGiven an array $a$ that contains $n$ elements and the operation $\\circ$ that satisfies associative property: $(x \\circ y) \\circ z = x \\circ (y \\circ z)$ is true for any $x$, $y$, $z$.\n\nSo, such operations as $\\gcd$, $\\min$, $\\max$, $+$, $\\text{and}$, $\\text{or}$, $\\text{xor}$, etc. satisfy these conditions.\n\nAlso we have some queries $q(l, r)$. For each query, we need to compute $a_l \\circ a_{l+1} \\circ \\dots \\circ a_r$.\n\nSqrt Tree can process such queries in $O(1)$ time with $O(n \\cdot \\log \\log n)$ preprocessing time and $O(n \\cdot \\log \\log n)$ memory.\n\n## Description\n\n### Building sqrt decomposition\n\nLet's make a [sqrt decomposition](/data_structures/sqrt_decomposition.html). We divide our array in $\\sqrt{n}$ blocks, each block has size $\\sqrt{n}$. For each block, we compute:\n\n1. Answers to the queries that lie in the block and begin at the beginning of the block ($\\text{prefixOp}$)\n2. Answers to the queries that lie in the block and end at the end of the block ($\\text{suffixOp}$)\n\nAnd we'll compute an additional array:\n\n3. $\\text{between}_{i, j}$ (for $i \\le j$) - answer to the query that begins at the start of block $i$ and ends at the end of block $j$. Note that we have $\\sqrt{n}$ blocks, so the size of this array will be $O(\\sqrt{n}^2) = O(n)$.\n\nLet's see the example.\n\nLet $\\circ$ be $+$ (we calculate sum on a segment) and we have the following array $a$:\n\n`{1, 2, 3, 4, 5, 6, 7, 8, 9}`\n\nIt will be divided onto three blocks: `{1, 2, 3}`, `{4, 5, 6}` and `{7, 8, 9}`.\n\nFor first block $\\text{prefixOp}$ is `{1, 3, 6}` and $\\text{suffixOp}$ is `{6, 5, 3}`.\n\nFor second block $\\text{prefixOp}$ is `{4, 9, 15}` and $\\text{suffixOp}$ is `{15, 11, 6}`.\n\nFor third block $\\text{prefixOp}$ is `{7, 15, 24}` and $\\text{suffixOp}$ is `{24, 17, 9}`.\n\n$\\text{between}$ array is:\n\n~~~~~\n{\n    {6, 21, 45},\n    {0, 15, 39},\n    {0, 0,  24}\n}\n~~~~~\n\n(we assume that invalid elements where $i > j$ are filled with zeroes)\n\nIt's obvious to see that these arrays can be easily calculated in $O(n)$ time and memory.\n\nWe already can answer some queries using these arrays. If the query doesn't fit into one block, we can divide it onto three parts: suffix of a block, then some segment of contiguous blocks and then prefix of some block. We can answer a query by dividing it into three parts and taking our operation of some value from $\\text{suffixOp}$, then some value from $\\text{between}$, then some value from $\\text{prefixOp}$.\n\nBut if we have queries that entirely fit into one block, we cannot process them using these three arrays. So, we need to do something.\n\n### Making a tree\n\nWe cannot answer only the queries that entirely fit in one block. But what **if we build the same structure as described above for each block?** Yes, we can do it. And we do it recursively, until we reach the block size of $1$ or $2$. Answers for such blocks can be calculated easily in $O(1)$.\n\nSo, we get a tree. Each node of the tree represents some segment of the array. Node that represents array segment with size $k$ has $\\sqrt{k}$ children -- for each block. Also each node contains the three arrays described above for the segment it contains. The root of the tree represents the entire array. Nodes with segment lengths $1$ or $2$ are leaves.\n\nAlso it's obvious that the height of this tree is $O(\\log \\log n)$, because if some vertex of the tree represents an array with length $k$, then its children have length $\\sqrt{k}$. $\\log(\\sqrt{k}) = \\frac{\\log{k}}{2}$, so $\\log k$ decreases two times every layer of the tree and so its height is $O(\\log \\log n)$. The time for building and memory usage will be $O(n \\cdot \\log \\log n)$, because every element of the array appears exactly once on each layer of the tree.\n\nNow we can answer the queries in $O(\\log \\log n)$. We can go down on the tree until we meet a segment with length $1$ or $2$ (answer for it can be calculated in $O(1)$ time) or meet the first segment in which our query doesn't fit entirely into one block. See the first section on how to answer the query in this case.\n\nOK, now we can do $O(\\log \\log n)$ per query. Can it be done faster?\n\n### Optimizing the query complexity\n\nOne of the most obvious optimization is to binary search the tree node we need. Using binary search, we can reach the $O(\\log \\log \\log n)$ complexity per query. Can we do it even faster?\n\nThe answer is yes. Let's assume the following two things:\n\n1. Each block size is a power of two.\n2. All the blocks are equal on each layer.\n\nTo reach this, we can add some zero elements to our array so that its size becomes a power of two.\n\nWhen we use this, some block sizes may become twice larger to be a power of two, but it still be $O(\\sqrt{k})$ in size and we keep linear complexity for building the arrays in a segment.\n\nNow, we can easily check if the query fits entirely into a block with size $2^k$. Let's write the ranges of the query, $l$ and $r$ (we use 0-indexation) in binary form. For instance, let's assume $k=4, l=39, r=46$. The binary representation of $l$ and $r$ is:\n\n$l = 39_{10} = 100111_2$\n\n$r = 46_{10} = 101110_2$\n\nRemember that one layer contains segments of the equal size, and the block on one layer have also equal size (in our case, their size is $2^k = 2^4 = 16$. The blocks cover the array entirely, so the first block covers elements $(0 - 15)$ ($(000000_2 - 001111_2)$ in binary), the second one covers elements $(16 - 31)$ ($(010000_2 - 011111_2)$ in binary) and so on. We see that the indices of the positions covered by one block may differ only in $k$ (in our case, $4$) last bits. In our case $l$ and $r$ have equal bits except four lowest, so they lie in one block.\n\nSo, we need to check if nothing more that $k$ smallest bits differ (or $l\\ \\text{xor}\\ r$ doesn't exceed $2^k-1$).\n\nUsing this observation, we can find a layer that is suitable to answer the query quickly. How to do this:\n\n1. For each $i$ that doesn't exceed the array size, we find the highest bit that is equal to $1$. To do this quickly, we use DP and a precalculated array.\n\n2. Now, for each $q(l, r)$ we find the highest bit of $l\\ \\text{xor}\\ r$ and, using this information, it's easy to choose the layer on which we can process the query easily. We can also use a precalculated array here.\n\nFor more details, see the code below.\n\nSo, using this, we can answer the queries in $O(1)$ each. Hooray! :)\n\n## Updating elements\n\nWe can also update elements in Sqrt Tree. Both single element updates and updates on a segment are supported.\n\n### Updating a single element\n\nConsider a query $\\text{update}(x, val)$ that does the assignment $a_x = val$. We need to perform this query fast enough.\n\n#### Naive approach\n\nFirst, let's take a look of what is changed in the tree when a single element changes. Consider a tree node with length $l$ and its arrays: $\\text{prefixOp}$, $\\text{suffixOp}$ and $\\text{between}$. It is easy to see that only $O(\\sqrt{l})$ elements from $\\text{prefixOp}$ and $\\text{suffixOp}$ change (only inside the block with the changed element). $O(l)$ elements are changed in $\\text{between}$. Therefore, $O(l)$ elements in the tree node are updated.\n\nWe remember that any element $x$ is present in exactly one tree node at each layer. Root node (layer $0$) has length $O(n)$, nodes on layer $1$ have length $O(\\sqrt{n})$, nodes on layer $2$ have length $O(\\sqrt{\\sqrt{n}})$, etc. So the time complexity per update is $O(n + \\sqrt{n} + \\sqrt{\\sqrt{n}} + \\dots) = O(n)$.\n\nBut it's too slow. Can it be done faster?\n\n#### An sqrt-tree inside the sqrt-tree\n\nNote that the bottleneck of updating is rebuilding $\\text{between}$ of the root node. To optimize the tree, let's get rid of this array! Instead of $\\text{between}$ array, we store another sqrt-tree for the root node. Let's call it $\\text{index}$. It plays the same role as $\\text{between}$&mdash; answers the queries on segments of blocks. Note that the rest of the tree nodes don't have $\\text{index}$, they keep their $\\text{between}$ arrays.\n\nA sqrt-tree is _indexed_, if its root node has $\\text{index}$. A sqrt-tree with $\\text{between}$ array in its root node is _unindexed_. Note that $\\text{index}$ **is _unindexed_ itself**.\n\nSo, we have the following algorithm for updating an _indexed_ tree:\n\n* Update $\\text{prefixOp}$ and $\\text{suffixOp}$ in $O(\\sqrt{n})$.\n\n* Update $\\text{index}$. It has length $O(\\sqrt{n})$ and we need to update only one item in it (that represents the changed block). So, the time complexity for this step is $O(\\sqrt{n})$. We can use the algorithm described in the beginning of this section (the \"slow\" one) to do it.\n\n* Go into the child node that represents the changed block and update it in $O(\\sqrt{n})$ with the \"slow\" algorithm.\n\nNote that the query complexity is still $O(1)$: we need to use $\\text{index}$ in query no more than once, and this will take $O(1)$ time.\n\nSo, total time complexity for updating a single element is $O(\\sqrt{n})$. Hooray! :)\n\n### Updating a segment\n\nSqrt-tree also can do things like assigning an element on a segment. $\\text{massUpdate}(x, l, r)$ means $a_i = x$ for all $l \\le i \\le r$.\n\nThere are two approaches to do this: one of them does $\\text{massUpdate}$ in $O(\\sqrt{n}\\cdot \\log \\log n)$, keeping $O(1)$ per query. The second one does $\\text{massUpdate}$ in $O(\\sqrt{n})$, but the query complexity becomes $O(\\log \\log n)$.\n\nWe will do lazy propagation in the same way as it is done in segment trees: we mark some nodes as _lazy_, meaning that we'll push them when it's necessary. But one thing is different from segment trees: pushing a node is expensive, so it cannot be done in queries. On the layer $0$, pushing a node takes $O(\\sqrt{n})$ time. So, we don't push nodes inside queries, we only look if the current node or its parent are _lazy_, and just take it into account while performing queries.\n\n#### First approach\n\nIn the first approach, we say that only nodes on layer $1$ (with length $O(\\sqrt{n}$) can be _lazy_. When pushing such node, it updates all its subtree including itself in $O(\\sqrt{n}\\cdot \\log \\log n)$. The $\\text{massUpdate}$ process is done as follows:\n\n* Consider the nodes on layer $1$ and blocks corresponding to them.\n\n* Some blocks are entirely covered by $\\text{massUpdate}$. Mark them as _lazy_ in $O(\\sqrt{n})$.\n\n* Some blocks are partially covered. Note there are no more than two blocks of this kind. Rebuild them in $O(\\sqrt{n}\\cdot \\log \\log n)$. If they were _lazy_, take it into account.\n\n* Update $\\text{prefixOp}$ and $\\text{suffixOp}$ for partially covered blocks in $O(\\sqrt{n})$ (because there are only two such blocks).\n\n* Rebuild the $\\text{index}$ in $O(\\sqrt{n}\\cdot \\log \\log n)$.\n\nSo we can do $\\text{massUpdate}$ fast. But how lazy propagation affects queries? They will have the following modifications:\n\n* If our query entirely lies in a _lazy_ block, calculate it and take _lazy_ into account. $O(1)$.\n\n* If our query consists of many blocks, some of which are _lazy_, we need to take care of _lazy_ only on the leftmost and the rightmost block. The rest of the blocks are calculated using $\\text{index}$, which already knows the answer on _lazy_ block (because it's rebuilt after each modification). $O(1)$.\n\nThe query complexity still remains $O(1)$.\n\n#### Second approach\n\nIn this approach, each node can be _lazy_ (except root). Even nodes in $\\text{index}$ can be _lazy_. So, while processing a query, we have to look for _lazy_ tags in all the parent nodes, i. e. query complexity will be $O(\\log \\log n)$.\n\nBut $\\text{massUpdate}$ becomes faster. It looks in the following way:\n\n* Some blocks are fully covered with $\\text{massUpdate}$. So, _lazy_ tags are added to them. It is $O(\\sqrt{n})$.\n\n* Update $\\text{prefixOp}$ and $\\text{suffixOp}$ for partially covered blocks in $O(\\sqrt{n})$ (because there are only two such blocks).\n\n* Do not forget to update the index. It is $O(\\sqrt{n})$ (we use the same $\\text{massUpdate}$ algorithm).\n\n* Update $\\text{between}$ array for _unindexed_ subtrees. \n\n* Go into the nodes representing partially covered blocks and call $\\text{massUpdate}$ recursively.\n\nNote that when we do the recursive call, we do prefix or suffix $\\text{massUpdate}$. But for prefix and suffix updates we can have no more than one partially covered child. So, we visit one node on layer $1$, two nodes on layer $2$ and two nodes on any deeper level. So, the time complexity is $O(\\sqrt{n} + \\sqrt{\\sqrt{n}} + \\dots) = O(\\sqrt{n})$. The approach here is similar to the segment tree mass update.\n\n## Implementation\n\nThe following implementation of Sqrt Tree can perform the following operations: build in $O(n \\cdot \\log \\log n)$, answer queries in $O(1)$ and update an element in $O(\\sqrt{n})$.\n\n~~~~~cpp\nSqrtTreeItem op(const SqrtTreeItem &a, const SqrtTreeItem &b);\n\ninline int log2Up(int n) {\n\tint res = 0;\n\twhile ((1 << res) < n) {\n\t\tres++;\n\t}\n\treturn res;\n}\n\nclass SqrtTree {\nprivate:\n\tint n, lg, indexSz;\n\tvector<SqrtTreeItem> v;\n\tvector<int> clz, layers, onLayer;\n\tvector< vector<SqrtTreeItem> > pref, suf, between;\n\t\n\tinline void buildBlock(int layer, int l, int r) {\n\t\tpref[layer][l] = v[l];\n\t\tfor (int i = l+1; i < r; i++) {\n\t\t\tpref[layer][i] = op(pref[layer][i-1], v[i]);\n\t\t}\n\t\tsuf[layer][r-1] = v[r-1];\n\t\tfor (int i = r-2; i >= l; i--) {\n\t\t\tsuf[layer][i] = op(v[i], suf[layer][i+1]);\n\t\t}\n\t}\n\t\n\tinline void buildBetween(int layer, int lBound, int rBound, int betweenOffs) {\n\t\tint bSzLog = (layers[layer]+1) >> 1;\n\t\tint bCntLog = layers[layer] >> 1;\n\t\tint bSz = 1 << bSzLog;\n\t\tint bCnt = (rBound - lBound + bSz - 1) >> bSzLog;\n\t\tfor (int i = 0; i < bCnt; i++) {\n\t\t\tSqrtTreeItem ans;\n\t\t\tfor (int j = i; j < bCnt; j++) {\n\t\t\t\tSqrtTreeItem add = suf[layer][lBound + (j << bSzLog)];\n\t\t\t\tans = (i == j) ? add : op(ans, add);\n\t\t\t\tbetween[layer-1][betweenOffs + lBound + (i << bCntLog) + j] = ans;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinline void buildBetweenZero() {\n\t\tint bSzLog = (lg+1) >> 1;\n\t\tfor (int i = 0; i < indexSz; i++) {\n\t\t\tv[n+i] = suf[0][i << bSzLog];\n\t\t}\n\t\tbuild(1, n, n + indexSz, (1 << lg) - n);\n\t}\n\t\n\tinline void updateBetweenZero(int bid) {\n\t\tint bSzLog = (lg+1) >> 1;\n\t\tv[n+bid] = suf[0][bid << bSzLog];\n\t\tupdate(1, n, n + indexSz, (1 << lg) - n, n+bid);\n\t}\n\t\n\tvoid build(int layer, int lBound, int rBound, int betweenOffs) {\n\t\tif (layer >= (int)layers.size()) {\n\t\t\treturn;\n\t\t}\n\t\tint bSz = 1 << ((layers[layer]+1) >> 1);\n\t\tfor (int l = lBound; l < rBound; l += bSz) {\n\t\t\tint r = min(l + bSz, rBound);\n\t\t\tbuildBlock(layer, l, r);\n\t\t\tbuild(layer+1, l, r, betweenOffs);\n\t\t}\n\t\tif (layer == 0) {\n\t\t\tbuildBetweenZero();\n\t\t} else {\n\t\t\tbuildBetween(layer, lBound, rBound, betweenOffs);\n\t\t}\n\t}\n\t\n\tvoid update(int layer, int lBound, int rBound, int betweenOffs, int x) {\n\t\tif (layer >= (int)layers.size()) {\n\t\t\treturn;\n\t\t}\n\t\tint bSzLog = (layers[layer]+1) >> 1;\n\t\tint bSz = 1 << bSzLog;\n\t\tint blockIdx = (x - lBound) >> bSzLog;\n\t\tint l = lBound + (blockIdx << bSzLog);\n\t\tint r = min(l + bSz, rBound);\n\t\tbuildBlock(layer, l, r);\n\t\tif (layer == 0) {\n\t\t\tupdateBetweenZero(blockIdx);\n\t\t} else {\n\t\t\tbuildBetween(layer, lBound, rBound, betweenOffs);\n\t\t}\n\t\tupdate(layer+1, l, r, betweenOffs, x);\n\t}\n\t\n\tinline SqrtTreeItem query(int l, int r, int betweenOffs, int base) {\n\t\tif (l == r) {\n\t\t\treturn v[l];\n\t\t}\n\t\tif (l + 1 == r) {\n\t\t\treturn op(v[l], v[r]);\n\t\t}\n\t\tint layer = onLayer[clz[(l - base) ^ (r - base)]];\n\t\tint bSzLog = (layers[layer]+1) >> 1;\n\t\tint bCntLog = layers[layer] >> 1;\n\t\tint lBound = (((l - base) >> layers[layer]) << layers[layer]) + base;\n\t\tint lBlock = ((l - lBound) >> bSzLog) + 1;\n\t\tint rBlock = ((r - lBound) >> bSzLog) - 1;\n\t\tSqrtTreeItem ans = suf[layer][l];\n\t\tif (lBlock <= rBlock) {\n\t\t\tSqrtTreeItem add = (layer == 0) ? (\n\t\t\t\tquery(n + lBlock, n + rBlock, (1 << lg) - n, n)\n\t\t\t) : (\n\t\t\t\tbetween[layer-1][betweenOffs + lBound + (lBlock << bCntLog) + rBlock]\n\t\t\t);\n\t\t\tans = op(ans, add);\n\t\t}\n\t\tans = op(ans, pref[layer][r]);\n\t\treturn ans;\n\t}\npublic:\n\tinline SqrtTreeItem query(int l, int r) {\n\t\treturn query(l, r, 0, 0);\n\t}\n\t\n\tinline void update(int x, const SqrtTreeItem &item) {\n\t\tv[x] = item;\n\t\tupdate(0, 0, n, 0, x);\n\t}\n\t\n\tSqrtTree(const vector<SqrtTreeItem>& a)\n\t\t: n((int)a.size()), lg(log2Up(n)), v(a), clz(1 << lg), onLayer(lg+1) {\n\t\tclz[0] = 0;\n\t\tfor (int i = 1; i < (int)clz.size(); i++) {\n\t\t\tclz[i] = clz[i >> 1] + 1;\n\t\t}\n\t\tint tlg = lg;\n\t\twhile (tlg > 1) {\n\t\t\tonLayer[tlg] = (int)layers.size();\n\t\t\tlayers.push_back(tlg);\n\t\t\ttlg = (tlg+1) >> 1;\n\t\t}\n\t\tfor (int i = lg-1; i >= 0; i--) {\n\t\t\tonLayer[i] = max(onLayer[i], onLayer[i+1]);\n\t\t}\n\t\tint betweenLayers = max(0, (int)layers.size() - 1);\n\t\tint bSzLog = (lg+1) >> 1;\n\t\tint bSz = 1 << bSzLog;\n\t\tindexSz = (n + bSz - 1) >> bSzLog;\n\t\tv.resize(n + indexSz);\n\t\tpref.assign(layers.size(), vector<SqrtTreeItem>(n + indexSz));\n\t\tsuf.assign(layers.size(), vector<SqrtTreeItem>(n + indexSz));\n\t\tbetween.assign(betweenLayers, vector<SqrtTreeItem>((1 << lg) + bSz));\n\t\tbuild(0, 0, n, 0);\n\t}\n};\n\n~~~~~\n\n", "full_article": "---\ntags:\n  - Original\n---\n\n# Sqrt Tree\n\nGiven an array $a$ that contains $n$ elements and the operation $\\circ$ that satisfies associative property: $(x \\circ y) \\circ z = x \\circ (y \\circ z)$ is true for any $x$, $y$, $z$.\n\nSo, such operations as $\\gcd$, $\\min$, $\\max$, $+$, $\\text{and}$, $\\text{or}$, $\\text{xor}$, etc. satisfy these conditions.\n\nAlso we have some queries $q(l, r)$. For each query, we need to compute $a_l \\circ a_{l+1} \\circ \\dots \\circ a_r$.\n\nSqrt Tree can process such queries in $O(1)$ time with $O(n \\cdot \\log \\log n)$ preprocessing time and $O(n \\cdot \\log \\log n)$ memory.\n\n## Description\n\n### Building sqrt decomposition\n\nLet's make a [sqrt decomposition](/data_structures/sqrt_decomposition.html). We divide our array in $\\sqrt{n}$ blocks, each block has size $\\sqrt{n}$. For each block, we compute:\n\n1. Answers to the queries that lie in the block and begin at the beginning of the block ($\\text{prefixOp}$)\n2. Answers to the queries that lie in the block and end at the end of the block ($\\text{suffixOp}$)\n\nAnd we'll compute an additional array:\n\n3. $\\text{between}_{i, j}$ (for $i \\le j$) - answer to the query that begins at the start of block $i$ and ends at the end of block $j$. Note that we have $\\sqrt{n}$ blocks, so the size of this array will be $O(\\sqrt{n}^2) = O(n)$.\n\nLet's see the example.\n\nLet $\\circ$ be $+$ (we calculate sum on a segment) and we have the following array $a$:\n\n`{1, 2, 3, 4, 5, 6, 7, 8, 9}`\n\nIt will be divided onto three blocks: `{1, 2, 3}`, `{4, 5, 6}` and `{7, 8, 9}`.\n\nFor first block $\\text{prefixOp}$ is `{1, 3, 6}` and $\\text{suffixOp}$ is `{6, 5, 3}`.\n\nFor second block $\\text{prefixOp}$ is `{4, 9, 15}` and $\\text{suffixOp}$ is `{15, 11, 6}`.\n\nFor third block $\\text{prefixOp}$ is `{7, 15, 24}` and $\\text{suffixOp}$ is `{24, 17, 9}`.\n\n$\\text{between}$ array is:\n\n~~~~~\n{\n    {6, 21, 45},\n    {0, 15, 39},\n    {0, 0,  24}\n}\n~~~~~\n\n(we assume that invalid elements where $i > j$ are filled with zeroes)\n\nIt's obvious to see that these arrays can be easily calculated in $O(n)$ time and memory.\n\nWe already can answer some queries using these arrays. If the query doesn't fit into one block, we can divide it onto three parts: suffix of a block, then some segment of contiguous blocks and then prefix of some block. We can answer a query by dividing it into three parts and taking our operation of some value from $\\text{suffixOp}$, then some value from $\\text{between}$, then some value from $\\text{prefixOp}$.\n\nBut if we have queries that entirely fit into one block, we cannot process them using these three arrays. So, we need to do something.\n\n### Making a tree\n\nWe cannot answer only the queries that entirely fit in one block. But what **if we build the same structure as described above for each block?** Yes, we can do it. And we do it recursively, until we reach the block size of $1$ or $2$. Answers for such blocks can be calculated easily in $O(1)$.\n\nSo, we get a tree. Each node of the tree represents some segment of the array. Node that represents array segment with size $k$ has $\\sqrt{k}$ children -- for each block. Also each node contains the three arrays described above for the segment it contains. The root of the tree represents the entire array. Nodes with segment lengths $1$ or $2$ are leaves.\n\nAlso it's obvious that the height of this tree is $O(\\log \\log n)$, because if some vertex of the tree represents an array with length $k$, then its children have length $\\sqrt{k}$. $\\log(\\sqrt{k}) = \\frac{\\log{k}}{2}$, so $\\log k$ decreases two times every layer of the tree and so its height is $O(\\log \\log n)$. The time for building and memory usage will be $O(n \\cdot \\log \\log n)$, because every element of the array appears exactly once on each layer of the tree.\n\nNow we can answer the queries in $O(\\log \\log n)$. We can go down on the tree until we meet a segment with length $1$ or $2$ (answer for it can be calculated in $O(1)$ time) or meet the first segment in which our query doesn't fit entirely into one block. See the first section on how to answer the query in this case.\n\nOK, now we can do $O(\\log \\log n)$ per query. Can it be done faster?\n\n### Optimizing the query complexity\n\nOne of the most obvious optimization is to binary search the tree node we need. Using binary search, we can reach the $O(\\log \\log \\log n)$ complexity per query. Can we do it even faster?\n\nThe answer is yes. Let's assume the following two things:\n\n1. Each block size is a power of two.\n2. All the blocks are equal on each layer.\n\nTo reach this, we can add some zero elements to our array so that its size becomes a power of two.\n\nWhen we use this, some block sizes may become twice larger to be a power of two, but it still be $O(\\sqrt{k})$ in size and we keep linear complexity for building the arrays in a segment.\n\nNow, we can easily check if the query fits entirely into a block with size $2^k$. Let's write the ranges of the query, $l$ and $r$ (we use 0-indexation) in binary form. For instance, let's assume $k=4, l=39, r=46$. The binary representation of $l$ and $r$ is:\n\n$l = 39_{10} = 100111_2$\n\n$r = 46_{10} = 101110_2$\n\nRemember that one layer contains segments of the equal size, and the block on one layer have also equal size (in our case, their size is $2^k = 2^4 = 16$. The blocks cover the array entirely, so the first block covers elements $(0 - 15)$ ($(000000_2 - 001111_2)$ in binary), the second one covers elements $(16 - 31)$ ($(010000_2 - 011111_2)$ in binary) and so on. We see that the indices of the positions covered by one block may differ only in $k$ (in our case, $4$) last bits. In our case $l$ and $r$ have equal bits except four lowest, so they lie in one block.\n\nSo, we need to check if nothing more that $k$ smallest bits differ (or $l\\ \\text{xor}\\ r$ doesn't exceed $2^k-1$).\n\nUsing this observation, we can find a layer that is suitable to answer the query quickly. How to do this:\n\n1. For each $i$ that doesn't exceed the array size, we find the highest bit that is equal to $1$. To do this quickly, we use DP and a precalculated array.\n\n2. Now, for each $q(l, r)$ we find the highest bit of $l\\ \\text{xor}\\ r$ and, using this information, it's easy to choose the layer on which we can process the query easily. We can also use a precalculated array here.\n\nFor more details, see the code below.\n\nSo, using this, we can answer the queries in $O(1)$ each. Hooray! :)\n\n## Updating elements\n\nWe can also update elements in Sqrt Tree. Both single element updates and updates on a segment are supported.\n\n### Updating a single element\n\nConsider a query $\\text{update}(x, val)$ that does the assignment $a_x = val$. We need to perform this query fast enough.\n\n#### Naive approach\n\nFirst, let's take a look of what is changed in the tree when a single element changes. Consider a tree node with length $l$ and its arrays: $\\text{prefixOp}$, $\\text{suffixOp}$ and $\\text{between}$. It is easy to see that only $O(\\sqrt{l})$ elements from $\\text{prefixOp}$ and $\\text{suffixOp}$ change (only inside the block with the changed element). $O(l)$ elements are changed in $\\text{between}$. Therefore, $O(l)$ elements in the tree node are updated.\n\nWe remember that any element $x$ is present in exactly one tree node at each layer. Root node (layer $0$) has length $O(n)$, nodes on layer $1$ have length $O(\\sqrt{n})$, nodes on layer $2$ have length $O(\\sqrt{\\sqrt{n}})$, etc. So the time complexity per update is $O(n + \\sqrt{n} + \\sqrt{\\sqrt{n}} + \\dots) = O(n)$.\n\nBut it's too slow. Can it be done faster?\n\n#### An sqrt-tree inside the sqrt-tree\n\nNote that the bottleneck of updating is rebuilding $\\text{between}$ of the root node. To optimize the tree, let's get rid of this array! Instead of $\\text{between}$ array, we store another sqrt-tree for the root node. Let's call it $\\text{index}$. It plays the same role as $\\text{between}$&mdash; answers the queries on segments of blocks. Note that the rest of the tree nodes don't have $\\text{index}$, they keep their $\\text{between}$ arrays.\n\nA sqrt-tree is _indexed_, if its root node has $\\text{index}$. A sqrt-tree with $\\text{between}$ array in its root node is _unindexed_. Note that $\\text{index}$ **is _unindexed_ itself**.\n\nSo, we have the following algorithm for updating an _indexed_ tree:\n\n* Update $\\text{prefixOp}$ and $\\text{suffixOp}$ in $O(\\sqrt{n})$.\n\n* Update $\\text{index}$. It has length $O(\\sqrt{n})$ and we need to update only one item in it (that represents the changed block). So, the time complexity for this step is $O(\\sqrt{n})$. We can use the algorithm described in the beginning of this section (the \"slow\" one) to do it.\n\n* Go into the child node that represents the changed block and update it in $O(\\sqrt{n})$ with the \"slow\" algorithm.\n\nNote that the query complexity is still $O(1)$: we need to use $\\text{index}$ in query no more than once, and this will take $O(1)$ time.\n\nSo, total time complexity for updating a single element is $O(\\sqrt{n})$. Hooray! :)\n\n### Updating a segment\n\nSqrt-tree also can do things like assigning an element on a segment. $\\text{massUpdate}(x, l, r)$ means $a_i = x$ for all $l \\le i \\le r$.\n\nThere are two approaches to do this: one of them does $\\text{massUpdate}$ in $O(\\sqrt{n}\\cdot \\log \\log n)$, keeping $O(1)$ per query. The second one does $\\text{massUpdate}$ in $O(\\sqrt{n})$, but the query complexity becomes $O(\\log \\log n)$.\n\nWe will do lazy propagation in the same way as it is done in segment trees: we mark some nodes as _lazy_, meaning that we'll push them when it's necessary. But one thing is different from segment trees: pushing a node is expensive, so it cannot be done in queries. On the layer $0$, pushing a node takes $O(\\sqrt{n})$ time. So, we don't push nodes inside queries, we only look if the current node or its parent are _lazy_, and just take it into account while performing queries.\n\n#### First approach\n\nIn the first approach, we say that only nodes on layer $1$ (with length $O(\\sqrt{n}$) can be _lazy_. When pushing such node, it updates all its subtree including itself in $O(\\sqrt{n}\\cdot \\log \\log n)$. The $\\text{massUpdate}$ process is done as follows:\n\n* Consider the nodes on layer $1$ and blocks corresponding to them.\n\n* Some blocks are entirely covered by $\\text{massUpdate}$. Mark them as _lazy_ in $O(\\sqrt{n})$.\n\n* Some blocks are partially covered. Note there are no more than two blocks of this kind. Rebuild them in $O(\\sqrt{n}\\cdot \\log \\log n)$. If they were _lazy_, take it into account.\n\n* Update $\\text{prefixOp}$ and $\\text{suffixOp}$ for partially covered blocks in $O(\\sqrt{n})$ (because there are only two such blocks).\n\n* Rebuild the $\\text{index}$ in $O(\\sqrt{n}\\cdot \\log \\log n)$.\n\nSo we can do $\\text{massUpdate}$ fast. But how lazy propagation affects queries? They will have the following modifications:\n\n* If our query entirely lies in a _lazy_ block, calculate it and take _lazy_ into account. $O(1)$.\n\n* If our query consists of many blocks, some of which are _lazy_, we need to take care of _lazy_ only on the leftmost and the rightmost block. The rest of the blocks are calculated using $\\text{index}$, which already knows the answer on _lazy_ block (because it's rebuilt after each modification). $O(1)$.\n\nThe query complexity still remains $O(1)$.\n\n#### Second approach\n\nIn this approach, each node can be _lazy_ (except root). Even nodes in $\\text{index}$ can be _lazy_. So, while processing a query, we have to look for _lazy_ tags in all the parent nodes, i. e. query complexity will be $O(\\log \\log n)$.\n\nBut $\\text{massUpdate}$ becomes faster. It looks in the following way:\n\n* Some blocks are fully covered with $\\text{massUpdate}$. So, _lazy_ tags are added to them. It is $O(\\sqrt{n})$.\n\n* Update $\\text{prefixOp}$ and $\\text{suffixOp}$ for partially covered blocks in $O(\\sqrt{n})$ (because there are only two such blocks).\n\n* Do not forget to update the index. It is $O(\\sqrt{n})$ (we use the same $\\text{massUpdate}$ algorithm).\n\n* Update $\\text{between}$ array for _unindexed_ subtrees. \n\n* Go into the nodes representing partially covered blocks and call $\\text{massUpdate}$ recursively.\n\nNote that when we do the recursive call, we do prefix or suffix $\\text{massUpdate}$. But for prefix and suffix updates we can have no more than one partially covered child. So, we visit one node on layer $1$, two nodes on layer $2$ and two nodes on any deeper level. So, the time complexity is $O(\\sqrt{n} + \\sqrt{\\sqrt{n}} + \\dots) = O(\\sqrt{n})$. The approach here is similar to the segment tree mass update.\n\n## Implementation\n\nThe following implementation of Sqrt Tree can perform the following operations: build in $O(n \\cdot \\log \\log n)$, answer queries in $O(1)$ and update an element in $O(\\sqrt{n})$.\n\n~~~~~cpp\nSqrtTreeItem op(const SqrtTreeItem &a, const SqrtTreeItem &b);\n\ninline int log2Up(int n) {\n\tint res = 0;\n\twhile ((1 << res) < n) {\n\t\tres++;\n\t}\n\treturn res;\n}\n\nclass SqrtTree {\nprivate:\n\tint n, lg, indexSz;\n\tvector<SqrtTreeItem> v;\n\tvector<int> clz, layers, onLayer;\n\tvector< vector<SqrtTreeItem> > pref, suf, between;\n\t\n\tinline void buildBlock(int layer, int l, int r) {\n\t\tpref[layer][l] = v[l];\n\t\tfor (int i = l+1; i < r; i++) {\n\t\t\tpref[layer][i] = op(pref[layer][i-1], v[i]);\n\t\t}\n\t\tsuf[layer][r-1] = v[r-1];\n\t\tfor (int i = r-2; i >= l; i--) {\n\t\t\tsuf[layer][i] = op(v[i], suf[layer][i+1]);\n\t\t}\n\t}\n\t\n\tinline void buildBetween(int layer, int lBound, int rBound, int betweenOffs) {\n\t\tint bSzLog = (layers[layer]+1) >> 1;\n\t\tint bCntLog = layers[layer] >> 1;\n\t\tint bSz = 1 << bSzLog;\n\t\tint bCnt = (rBound - lBound + bSz - 1) >> bSzLog;\n\t\tfor (int i = 0; i < bCnt; i++) {\n\t\t\tSqrtTreeItem ans;\n\t\t\tfor (int j = i; j < bCnt; j++) {\n\t\t\t\tSqrtTreeItem add = suf[layer][lBound + (j << bSzLog)];\n\t\t\t\tans = (i == j) ? add : op(ans, add);\n\t\t\t\tbetween[layer-1][betweenOffs + lBound + (i << bCntLog) + j] = ans;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinline void buildBetweenZero() {\n\t\tint bSzLog = (lg+1) >> 1;\n\t\tfor (int i = 0; i < indexSz; i++) {\n\t\t\tv[n+i] = suf[0][i << bSzLog];\n\t\t}\n\t\tbuild(1, n, n + indexSz, (1 << lg) - n);\n\t}\n\t\n\tinline void updateBetweenZero(int bid) {\n\t\tint bSzLog = (lg+1) >> 1;\n\t\tv[n+bid] = suf[0][bid << bSzLog];\n\t\tupdate(1, n, n + indexSz, (1 << lg) - n, n+bid);\n\t}\n\t\n\tvoid build(int layer, int lBound, int rBound, int betweenOffs) {\n\t\tif (layer >= (int)layers.size()) {\n\t\t\treturn;\n\t\t}\n\t\tint bSz = 1 << ((layers[layer]+1) >> 1);\n\t\tfor (int l = lBound; l < rBound; l += bSz) {\n\t\t\tint r = min(l + bSz, rBound);\n\t\t\tbuildBlock(layer, l, r);\n\t\t\tbuild(layer+1, l, r, betweenOffs);\n\t\t}\n\t\tif (layer == 0) {\n\t\t\tbuildBetweenZero();\n\t\t} else {\n\t\t\tbuildBetween(layer, lBound, rBound, betweenOffs);\n\t\t}\n\t}\n\t\n\tvoid update(int layer, int lBound, int rBound, int betweenOffs, int x) {\n\t\tif (layer >= (int)layers.size()) {\n\t\t\treturn;\n\t\t}\n\t\tint bSzLog = (layers[layer]+1) >> 1;\n\t\tint bSz = 1 << bSzLog;\n\t\tint blockIdx = (x - lBound) >> bSzLog;\n\t\tint l = lBound + (blockIdx << bSzLog);\n\t\tint r = min(l + bSz, rBound);\n\t\tbuildBlock(layer, l, r);\n\t\tif (layer == 0) {\n\t\t\tupdateBetweenZero(blockIdx);\n\t\t} else {\n\t\t\tbuildBetween(layer, lBound, rBound, betweenOffs);\n\t\t}\n\t\tupdate(layer+1, l, r, betweenOffs, x);\n\t}\n\t\n\tinline SqrtTreeItem query(int l, int r, int betweenOffs, int base) {\n\t\tif (l == r) {\n\t\t\treturn v[l];\n\t\t}\n\t\tif (l + 1 == r) {\n\t\t\treturn op(v[l], v[r]);\n\t\t}\n\t\tint layer = onLayer[clz[(l - base) ^ (r - base)]];\n\t\tint bSzLog = (layers[layer]+1) >> 1;\n\t\tint bCntLog = layers[layer] >> 1;\n\t\tint lBound = (((l - base) >> layers[layer]) << layers[layer]) + base;\n\t\tint lBlock = ((l - lBound) >> bSzLog) + 1;\n\t\tint rBlock = ((r - lBound) >> bSzLog) - 1;\n\t\tSqrtTreeItem ans = suf[layer][l];\n\t\tif (lBlock <= rBlock) {\n\t\t\tSqrtTreeItem add = (layer == 0) ? (\n\t\t\t\tquery(n + lBlock, n + rBlock, (1 << lg) - n, n)\n\t\t\t) : (\n\t\t\t\tbetween[layer-1][betweenOffs + lBound + (lBlock << bCntLog) + rBlock]\n\t\t\t);\n\t\t\tans = op(ans, add);\n\t\t}\n\t\tans = op(ans, pref[layer][r]);\n\t\treturn ans;\n\t}\npublic:\n\tinline SqrtTreeItem query(int l, int r) {\n\t\treturn query(l, r, 0, 0);\n\t}\n\t\n\tinline void update(int x, const SqrtTreeItem &item) {\n\t\tv[x] = item;\n\t\tupdate(0, 0, n, 0, x);\n\t}\n\t\n\tSqrtTree(const vector<SqrtTreeItem>& a)\n\t\t: n((int)a.size()), lg(log2Up(n)), v(a), clz(1 << lg), onLayer(lg+1) {\n\t\tclz[0] = 0;\n\t\tfor (int i = 1; i < (int)clz.size(); i++) {\n\t\t\tclz[i] = clz[i >> 1] + 1;\n\t\t}\n\t\tint tlg = lg;\n\t\twhile (tlg > 1) {\n\t\t\tonLayer[tlg] = (int)layers.size();\n\t\t\tlayers.push_back(tlg);\n\t\t\ttlg = (tlg+1) >> 1;\n\t\t}\n\t\tfor (int i = lg-1; i >= 0; i--) {\n\t\t\tonLayer[i] = max(onLayer[i], onLayer[i+1]);\n\t\t}\n\t\tint betweenLayers = max(0, (int)layers.size() - 1);\n\t\tint bSzLog = (lg+1) >> 1;\n\t\tint bSz = 1 << bSzLog;\n\t\tindexSz = (n + bSz - 1) >> bSzLog;\n\t\tv.resize(n + indexSz);\n\t\tpref.assign(layers.size(), vector<SqrtTreeItem>(n + indexSz));\n\t\tsuf.assign(layers.size(), vector<SqrtTreeItem>(n + indexSz));\n\t\tbetween.assign(betweenLayers, vector<SqrtTreeItem>((1 << lg) + bSz));\n\t\tbuild(0, 0, n, 0);\n\t}\n};\n\n~~~~~\n\n## Problems\n\n[CodeChef - SEGPROD](https://www.codechef.com/NOV17/problems/SEGPROD)\n", "problem_ids": [], "title": "Sqrt Tree"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: sqrt_decomposition\n---\n\n# Sqrt Decomposition\n\nSqrt Decomposition is a method (or a data structure) that allows you to perform some common operations (finding sum of the elements of the sub-array, finding the minimal/maximal element, etc.) in $O(\\sqrt n)$ operations, which is much faster than $O(n)$ for the trivial algorithm.\n\nFirst we describe the data structure for one of the simplest applications of this idea, then show how to generalize it to solve some other problems, and finally look at a slightly different use of this idea: splitting the input requests into sqrt blocks.\n\n## Sqrt-decomposition based data structure\n\nGiven an array $a[0 \\dots n-1]$, implement a data structure that allows to find the sum of the elements $a[l \\dots r]$ for arbitrary $l$ and $r$ in $O(\\sqrt n)$ operations.\n\n### Description\n\nThe basic idea of sqrt decomposition is preprocessing. We'll divide the array $a$ into blocks of length approximately $\\sqrt n$, and for each block $i$ we'll precalculate the sum of elements in it $b[i]$.\n\nWe can assume that both the size of the block and the number of blocks are equal to $\\sqrt n$ rounded up:\n\n$$ s = \\lceil \\sqrt n \\rceil $$\n\nThen the array $a$ is divided into blocks in the following way:\n\n$$ \\underbrace{a[0], a[1], \\dots, a[s-1]}_{\\text{b[0]}}, \\underbrace{a[s], \\dots, a[2s-1]}_{\\text{b[1]}}, \\dots, \\underbrace{a[(s-1) \\cdot s], \\dots, a[n-1]}_{\\text{b[s-1]}} $$\n\nThe last block may have fewer elements than the others (if $n$ not a multiple of $s$), it is not important to the discussion (as it can be handled easily).\nThus, for each block $k$, we know the sum of elements on it $b[k]$:\n\n$$ b[k] = \\sum\\limits_{i=k\\cdot s}^{\\min {(n-1,(k+1)\\cdot s - 1})} a[i] $$\n\nSo, we have calculated the values of $b[k]$ (this required $O(n)$ operations). How can they help us to answer each query $[l, r]$ ?\nNotice that if the interval $[l, r]$ is long enough, it will contain several whole blocks, and for those blocks we can find the sum of elements in them in a single operation. As a result, the interval $[l, r]$ will contain parts of only two blocks, and we'll have to calculate the sum of elements in these parts trivially.\n\nThus, in order to calculate the sum of elements on the interval $[l, r]$ we only need to sum the elements of the two \"tails\":\n$[l\\dots (k + 1)\\cdot s-1]$ and $[p\\cdot s\\dots r]$ , and sum the values $b[i]$ in all the blocks from $k + 1$ to $p-1$:\n\n$$ \\sum\\limits_{i=l}^r a[i] = \\sum\\limits_{i=l}^{(k+1) \\cdot s-1} a[i] + \\sum\\limits_{i=k+1}^{p-1} b[i] + \\sum\\limits_{i=p\\cdot s}^r a[i] $$\n\n_Note: When $k = p$, i.e. $l$ and $r$ belong to the same block, the formula can't be applied, and the sum should be calculated trivially._\n\nThis approach allows us to significantly reduce the number of operations. Indeed, the size of each \"tail\" does not exceed the block length $s$, and the number of blocks in the sum does not exceed $s$. Since we have chosen $s \\approx \\sqrt n$, the total number of operations required to find the sum of elements on the interval $[l, r]$ is $O(\\sqrt n)$.\n\n### Implementation\n\nLet's start with the simplest implementation:\n\n```cpp\n// input data\nint n;\nvector<int> a (n);\n\n// preprocessing\nint len = (int) sqrt (n + .0) + 1; // size of the block and the number of blocks\nvector<int> b (len);\nfor (int i=0; i<n; ++i)\n    b[i / len] += a[i];\n\n// answering the queries\nfor (;;) {\n    int l, r;\n  // read input data for the next query\n    int sum = 0;\n    for (int i=l; i<=r; )\n        if (i % len == 0 && i + len - 1 <= r) {\n            // if the whole block starting at i belongs to [l, r]\n            sum += b[i / len];\n            i += len;\n        }\n        else {\n            sum += a[i];\n            ++i;\n        }\n}\n```\n\nThis implementation has unreasonably many division operations (which are much slower than other arithmetical operations). Instead, we can calculate the indices of the blocks $c_l$ and $c_r$ which contain indices $l$ and $r$, and loop through blocks $c_l+1 \\dots c_r-1$ with separate processing of the \"tails\" in blocks $c_l$ and $c_r$. This approach corresponds to the last formula in the description, and makes the case $c_l = c_r$ a special case.\n\n```cpp\nint sum = 0;\nint c_l = l / len,   c_r = r / len;\nif (c_l == c_r)\n    for (int i=l; i<=r; ++i)\n        sum += a[i];\nelse {\n    for (int i=l, end=(c_l+1)*len-1; i<=end; ++i)\n        sum += a[i];\n    for (int i=c_l+1; i<=c_r-1; ++i)\n        sum += b[i];\n    for (int i=c_r*len; i<=r; ++i)\n        sum += a[i];\n}\n```\n\n## Other problems\n\nSo far we were discussing the problem of finding the sum of elements of a continuous subarray. This problem can be extended to allow to **update individual array elements**. If an element $a[i]$ changes, it's sufficient to update the value of $b[k]$ for the block to which this element belongs ($k = i / s$) in one operation:\n\n$$ b[k] += a_{new}[i] - a_{old}[i] $$\n\nOn the other hand, the task of finding the sum of elements can be replaced with the task of finding minimal/maximal element of a subarray. If this problem has to address individual elements' updates as well, updating the value of $b[k]$ is also possible, but it will require iterating through all values of block $k$ in $O(s) = O(\\sqrt{n})$ operations.\n\nSqrt decomposition can be applied in a similar way to a whole class of other problems: finding the number of zero elements, finding the first non-zero element, counting elements which satisfy a certain property etc.\n\nAnother class of problems appears when we need to **update array elements on intervals**: increment existing elements or replace them with a given value.\n\nFor example, let's say we can do two types of operations on an array: add a given value $\\delta$ to all array elements on interval $[l, r]$ or query the value of element $a[i]$. Let's store the value which has to be added to all elements of block $k$ in $b[k]$ (initially all $b[k] = 0$). During each \"add\" operation we need to add $\\delta$ to $b[k]$ for all blocks which belong to interval $[l, r]$ and to add $\\delta$ to $a[i]$ for all elements which belong to the \"tails\" of the interval. The answer a query $i$ is simply $a[i] + b[i/s]$. This way \"add\" operation has $O(\\sqrt{n})$ complexity, and answering a query has $O(1)$ complexity.\n\nFinally, those two classes of problems can be combined if the task requires doing **both** element updates on an interval and queries on an interval. Both operations can be done with $O(\\sqrt{n})$ complexity. This will require two block arrays $b$ and $c$: one to keep track of element updates and another to keep track of answers to the query.\n\nThere exist other problems which can be solved using sqrt decomposition, for example, a problem about maintaining a set of numbers which would allow adding/deleting numbers, checking whether a number belongs to the set and finding $k$-th largest number. To solve it one has to store numbers in increasing order, split into several blocks with $\\sqrt{n}$ numbers in each. Every time a number is added/deleted, the blocks have to be rebalanced by moving numbers between beginnings and ends of adjacent blocks.\n\n## Mo's algorithm\n\nA similar idea, based on sqrt decomposition, can be used to answer range queries ($Q$) offline in $O((N+Q)\\sqrt{N})$.\nThis might sound like a lot worse than the methods in the previous section, since this is a slightly worse complexity than we had earlier and cannot update values between two queries.\nBut in a lot of situations this method has advantages.\nDuring a normal sqrt decomposition, we have to precompute the answers for each block, and merge them during answering queries.\nIn some problems this merging step can be quite problematic.\nE.g. when each queries asks to find the **mode** of its range (the number that appears the most often).\nFor this each block would have to store the count of each number in it in some sort of data structure, and we cannot longer perform the merge step fast enough any more.\n**Mo's algorithm** uses a completely different approach, that can answer these kind of queries fast, because it only keeps track of one data structure, and the only operations with it are easy and fast.\n\nThe idea is to answer the queries in a special order based on the indices.\nWe will first answer all queries which have the left index in block 0, then answer all queries which have left index in block 1 and so on.\nAnd also we will have to answer the queries of a block is a special order, namely sorted by the right index of the queries.\n\nAs already said we will use a single data structure.\nThis data structure will store information about the range.\nAt the beginning this range will be empty.\nWhen we want to answer the next query (in the special order), we simply extend or reduce the range, by adding/removing elements on both sides of the current range, until we transformed it into the query range.\nThis way, we only need to add or remove a single element once at a time, which should be pretty easy operations in our data structure.\n\nSince we change the order of answering the queries, this is only possible when we are allowed to answer the queries in offline mode.\n\n### Implementation\n\nIn Mo's algorithm we use two functions for adding an index and for removing an index from the range which we are currently maintaining.\n\n```cpp\nvoid remove(idx);  // TODO: remove value at idx from data structure\nvoid add(idx);     // TODO: add value at idx from data structure\nint get_answer();  // TODO: extract the current answer of the data structure\n\nint block_size;\n\nstruct Query {\n    int l, r, idx;\n    bool operator<(Query other) const\n    {\n        return make_pair(l / block_size, r) <\n               make_pair(other.l / block_size, other.r);\n    }\n};\n\nvector<int> mo_s_algorithm(vector<Query> queries) {\n    vector<int> answers(queries.size());\n    sort(queries.begin(), queries.end());\n\n    // TODO: initialize data structure\n\n    int cur_l = 0;\n    int cur_r = -1;\n    // invariant: data structure will always reflect the range [cur_l, cur_r]\n    for (Query q : queries) {\n        while (cur_l > q.l) {\n            cur_l--;\n            add(cur_l);\n        }\n        while (cur_r < q.r) {\n            cur_r++;\n            add(cur_r);\n        }\n        while (cur_l < q.l) {\n            remove(cur_l);\n            cur_l++;\n        }\n        while (cur_r > q.r) {\n            remove(cur_r);\n            cur_r--;\n        }\n        answers[q.idx] = get_answer();\n    }\n    return answers;\n}\n```\n\nBased on the problem we can use a different data structure and modify the `add`/`remove`/`get_answer` functions accordingly.\nFor example if we are asked to find range sum queries then we use a simple integer as data structure, which is $0$ at the beginning.\nThe `add` function will simply add the value of the position and subsequently update the answer variable.\nOn the other hand `remove` function will subtract the value at position and subsequently update the answer variable.\nAnd `get_answer` just returns the integer.\n\nFor answering mode-queries, we can use a binary search tree (e.g. `map<int, int>`) for storing how often each number appears in the current range, and a second binary search tree (e.g. `set<pair<int, int>>`) for keeping counts of the numbers (e.g. as count-number pairs) in order.\nThe `add` method removes the current number from the second BST, increases the count in the first one, and inserts the number back into the second one.\n`remove` does the same thing, it only decreases the count.\nAnd `get_answer` just looks at second tree and returns the best value in $O(1)$.\n\n### Complexity\n\n\nSorting all queries will take $O(Q \\log Q)$.\n\nHow about the other operations?\nHow many times will the `add` and `remove` be called?\n\nLet's say the block size is $S$.\n\nIf we only look at all queries having the left index in the same block, the queries are sorted by the right index.\nTherefore we will call `add(cur_r)` and `remove(cur_r)` only $O(N)$ times for all these queries combined.\nThis gives $O(\\frac{N}{S} N)$ calls for all blocks.\n\nThe value of `cur_l` can change by at most $O(S)$ during between two queries.\nTherefore we have an additional $O(S Q)$ calls of `add(cur_l)` and `remove(cur_l)`.\n\nFor $S \\approx \\sqrt{N}$ this gives $O((N + Q) \\sqrt{N})$ operations in total.\nThus the complexity is $O((N+Q)F\\sqrt{N})$ where $O(F)$  is the complexity of `add` and `remove` function.\n\n### Tips for improving runtime\n\n* Block size of precisely $\\sqrt{N}$ doesn't always offer the best runtime.  For example, if $\\sqrt{N}=750$ then it may happen that block size of $700$ or $800$ may run better.\nMore importantly, don't compute the block size at runtime - make it `const`. Division by constants is well optimized by compilers.\n* In odd blocks sort the right index in ascending order and in even blocks sort it in descending order. This will minimize the movement of right pointer, as the normal sorting will move the right pointer from the end back to the beginning at the start of every block. With the improved version this resetting is no more necessary.\n\n```cpp\nbool cmp(pair<int, int> p, pair<int, int> q) {\n    if (p.first / BLOCK_SIZE != q.first / BLOCK_SIZE)\n        return p < q;\n    return (p.first / BLOCK_SIZE & 1) ? (p.second < q.second) : (p.second > q.second);\n}\n```\n\nYou can read about even faster sorting approach [here](https://codeforces.com/blog/entry/61203).\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: sqrt_decomposition\n---\n\n# Sqrt Decomposition\n\nSqrt Decomposition is a method (or a data structure) that allows you to perform some common operations (finding sum of the elements of the sub-array, finding the minimal/maximal element, etc.) in $O(\\sqrt n)$ operations, which is much faster than $O(n)$ for the trivial algorithm.\n\nFirst we describe the data structure for one of the simplest applications of this idea, then show how to generalize it to solve some other problems, and finally look at a slightly different use of this idea: splitting the input requests into sqrt blocks.\n\n## Sqrt-decomposition based data structure\n\nGiven an array $a[0 \\dots n-1]$, implement a data structure that allows to find the sum of the elements $a[l \\dots r]$ for arbitrary $l$ and $r$ in $O(\\sqrt n)$ operations.\n\n### Description\n\nThe basic idea of sqrt decomposition is preprocessing. We'll divide the array $a$ into blocks of length approximately $\\sqrt n$, and for each block $i$ we'll precalculate the sum of elements in it $b[i]$.\n\nWe can assume that both the size of the block and the number of blocks are equal to $\\sqrt n$ rounded up:\n\n$$ s = \\lceil \\sqrt n \\rceil $$\n\nThen the array $a$ is divided into blocks in the following way:\n\n$$ \\underbrace{a[0], a[1], \\dots, a[s-1]}_{\\text{b[0]}}, \\underbrace{a[s], \\dots, a[2s-1]}_{\\text{b[1]}}, \\dots, \\underbrace{a[(s-1) \\cdot s], \\dots, a[n-1]}_{\\text{b[s-1]}} $$\n\nThe last block may have fewer elements than the others (if $n$ not a multiple of $s$), it is not important to the discussion (as it can be handled easily).\nThus, for each block $k$, we know the sum of elements on it $b[k]$:\n\n$$ b[k] = \\sum\\limits_{i=k\\cdot s}^{\\min {(n-1,(k+1)\\cdot s - 1})} a[i] $$\n\nSo, we have calculated the values of $b[k]$ (this required $O(n)$ operations). How can they help us to answer each query $[l, r]$ ?\nNotice that if the interval $[l, r]$ is long enough, it will contain several whole blocks, and for those blocks we can find the sum of elements in them in a single operation. As a result, the interval $[l, r]$ will contain parts of only two blocks, and we'll have to calculate the sum of elements in these parts trivially.\n\nThus, in order to calculate the sum of elements on the interval $[l, r]$ we only need to sum the elements of the two \"tails\":\n$[l\\dots (k + 1)\\cdot s-1]$ and $[p\\cdot s\\dots r]$ , and sum the values $b[i]$ in all the blocks from $k + 1$ to $p-1$:\n\n$$ \\sum\\limits_{i=l}^r a[i] = \\sum\\limits_{i=l}^{(k+1) \\cdot s-1} a[i] + \\sum\\limits_{i=k+1}^{p-1} b[i] + \\sum\\limits_{i=p\\cdot s}^r a[i] $$\n\n_Note: When $k = p$, i.e. $l$ and $r$ belong to the same block, the formula can't be applied, and the sum should be calculated trivially._\n\nThis approach allows us to significantly reduce the number of operations. Indeed, the size of each \"tail\" does not exceed the block length $s$, and the number of blocks in the sum does not exceed $s$. Since we have chosen $s \\approx \\sqrt n$, the total number of operations required to find the sum of elements on the interval $[l, r]$ is $O(\\sqrt n)$.\n\n### Implementation\n\nLet's start with the simplest implementation:\n\n```cpp\n// input data\nint n;\nvector<int> a (n);\n\n// preprocessing\nint len = (int) sqrt (n + .0) + 1; // size of the block and the number of blocks\nvector<int> b (len);\nfor (int i=0; i<n; ++i)\n    b[i / len] += a[i];\n\n// answering the queries\nfor (;;) {\n    int l, r;\n  // read input data for the next query\n    int sum = 0;\n    for (int i=l; i<=r; )\n        if (i % len == 0 && i + len - 1 <= r) {\n            // if the whole block starting at i belongs to [l, r]\n            sum += b[i / len];\n            i += len;\n        }\n        else {\n            sum += a[i];\n            ++i;\n        }\n}\n```\n\nThis implementation has unreasonably many division operations (which are much slower than other arithmetical operations). Instead, we can calculate the indices of the blocks $c_l$ and $c_r$ which contain indices $l$ and $r$, and loop through blocks $c_l+1 \\dots c_r-1$ with separate processing of the \"tails\" in blocks $c_l$ and $c_r$. This approach corresponds to the last formula in the description, and makes the case $c_l = c_r$ a special case.\n\n```cpp\nint sum = 0;\nint c_l = l / len,   c_r = r / len;\nif (c_l == c_r)\n    for (int i=l; i<=r; ++i)\n        sum += a[i];\nelse {\n    for (int i=l, end=(c_l+1)*len-1; i<=end; ++i)\n        sum += a[i];\n    for (int i=c_l+1; i<=c_r-1; ++i)\n        sum += b[i];\n    for (int i=c_r*len; i<=r; ++i)\n        sum += a[i];\n}\n```\n\n## Other problems\n\nSo far we were discussing the problem of finding the sum of elements of a continuous subarray. This problem can be extended to allow to **update individual array elements**. If an element $a[i]$ changes, it's sufficient to update the value of $b[k]$ for the block to which this element belongs ($k = i / s$) in one operation:\n\n$$ b[k] += a_{new}[i] - a_{old}[i] $$\n\nOn the other hand, the task of finding the sum of elements can be replaced with the task of finding minimal/maximal element of a subarray. If this problem has to address individual elements' updates as well, updating the value of $b[k]$ is also possible, but it will require iterating through all values of block $k$ in $O(s) = O(\\sqrt{n})$ operations.\n\nSqrt decomposition can be applied in a similar way to a whole class of other problems: finding the number of zero elements, finding the first non-zero element, counting elements which satisfy a certain property etc.\n\nAnother class of problems appears when we need to **update array elements on intervals**: increment existing elements or replace them with a given value.\n\nFor example, let's say we can do two types of operations on an array: add a given value $\\delta$ to all array elements on interval $[l, r]$ or query the value of element $a[i]$. Let's store the value which has to be added to all elements of block $k$ in $b[k]$ (initially all $b[k] = 0$). During each \"add\" operation we need to add $\\delta$ to $b[k]$ for all blocks which belong to interval $[l, r]$ and to add $\\delta$ to $a[i]$ for all elements which belong to the \"tails\" of the interval. The answer a query $i$ is simply $a[i] + b[i/s]$. This way \"add\" operation has $O(\\sqrt{n})$ complexity, and answering a query has $O(1)$ complexity.\n\nFinally, those two classes of problems can be combined if the task requires doing **both** element updates on an interval and queries on an interval. Both operations can be done with $O(\\sqrt{n})$ complexity. This will require two block arrays $b$ and $c$: one to keep track of element updates and another to keep track of answers to the query.\n\nThere exist other problems which can be solved using sqrt decomposition, for example, a problem about maintaining a set of numbers which would allow adding/deleting numbers, checking whether a number belongs to the set and finding $k$-th largest number. To solve it one has to store numbers in increasing order, split into several blocks with $\\sqrt{n}$ numbers in each. Every time a number is added/deleted, the blocks have to be rebalanced by moving numbers between beginnings and ends of adjacent blocks.\n\n## Mo's algorithm\n\nA similar idea, based on sqrt decomposition, can be used to answer range queries ($Q$) offline in $O((N+Q)\\sqrt{N})$.\nThis might sound like a lot worse than the methods in the previous section, since this is a slightly worse complexity than we had earlier and cannot update values between two queries.\nBut in a lot of situations this method has advantages.\nDuring a normal sqrt decomposition, we have to precompute the answers for each block, and merge them during answering queries.\nIn some problems this merging step can be quite problematic.\nE.g. when each queries asks to find the **mode** of its range (the number that appears the most often).\nFor this each block would have to store the count of each number in it in some sort of data structure, and we cannot longer perform the merge step fast enough any more.\n**Mo's algorithm** uses a completely different approach, that can answer these kind of queries fast, because it only keeps track of one data structure, and the only operations with it are easy and fast.\n\nThe idea is to answer the queries in a special order based on the indices.\nWe will first answer all queries which have the left index in block 0, then answer all queries which have left index in block 1 and so on.\nAnd also we will have to answer the queries of a block is a special order, namely sorted by the right index of the queries.\n\nAs already said we will use a single data structure.\nThis data structure will store information about the range.\nAt the beginning this range will be empty.\nWhen we want to answer the next query (in the special order), we simply extend or reduce the range, by adding/removing elements on both sides of the current range, until we transformed it into the query range.\nThis way, we only need to add or remove a single element once at a time, which should be pretty easy operations in our data structure.\n\nSince we change the order of answering the queries, this is only possible when we are allowed to answer the queries in offline mode.\n\n### Implementation\n\nIn Mo's algorithm we use two functions for adding an index and for removing an index from the range which we are currently maintaining.\n\n```cpp\nvoid remove(idx);  // TODO: remove value at idx from data structure\nvoid add(idx);     // TODO: add value at idx from data structure\nint get_answer();  // TODO: extract the current answer of the data structure\n\nint block_size;\n\nstruct Query {\n    int l, r, idx;\n    bool operator<(Query other) const\n    {\n        return make_pair(l / block_size, r) <\n               make_pair(other.l / block_size, other.r);\n    }\n};\n\nvector<int> mo_s_algorithm(vector<Query> queries) {\n    vector<int> answers(queries.size());\n    sort(queries.begin(), queries.end());\n\n    // TODO: initialize data structure\n\n    int cur_l = 0;\n    int cur_r = -1;\n    // invariant: data structure will always reflect the range [cur_l, cur_r]\n    for (Query q : queries) {\n        while (cur_l > q.l) {\n            cur_l--;\n            add(cur_l);\n        }\n        while (cur_r < q.r) {\n            cur_r++;\n            add(cur_r);\n        }\n        while (cur_l < q.l) {\n            remove(cur_l);\n            cur_l++;\n        }\n        while (cur_r > q.r) {\n            remove(cur_r);\n            cur_r--;\n        }\n        answers[q.idx] = get_answer();\n    }\n    return answers;\n}\n```\n\nBased on the problem we can use a different data structure and modify the `add`/`remove`/`get_answer` functions accordingly.\nFor example if we are asked to find range sum queries then we use a simple integer as data structure, which is $0$ at the beginning.\nThe `add` function will simply add the value of the position and subsequently update the answer variable.\nOn the other hand `remove` function will subtract the value at position and subsequently update the answer variable.\nAnd `get_answer` just returns the integer.\n\nFor answering mode-queries, we can use a binary search tree (e.g. `map<int, int>`) for storing how often each number appears in the current range, and a second binary search tree (e.g. `set<pair<int, int>>`) for keeping counts of the numbers (e.g. as count-number pairs) in order.\nThe `add` method removes the current number from the second BST, increases the count in the first one, and inserts the number back into the second one.\n`remove` does the same thing, it only decreases the count.\nAnd `get_answer` just looks at second tree and returns the best value in $O(1)$.\n\n### Complexity\n\n\nSorting all queries will take $O(Q \\log Q)$.\n\nHow about the other operations?\nHow many times will the `add` and `remove` be called?\n\nLet's say the block size is $S$.\n\nIf we only look at all queries having the left index in the same block, the queries are sorted by the right index.\nTherefore we will call `add(cur_r)` and `remove(cur_r)` only $O(N)$ times for all these queries combined.\nThis gives $O(\\frac{N}{S} N)$ calls for all blocks.\n\nThe value of `cur_l` can change by at most $O(S)$ during between two queries.\nTherefore we have an additional $O(S Q)$ calls of `add(cur_l)` and `remove(cur_l)`.\n\nFor $S \\approx \\sqrt{N}$ this gives $O((N + Q) \\sqrt{N})$ operations in total.\nThus the complexity is $O((N+Q)F\\sqrt{N})$ where $O(F)$  is the complexity of `add` and `remove` function.\n\n### Tips for improving runtime\n\n* Block size of precisely $\\sqrt{N}$ doesn't always offer the best runtime.  For example, if $\\sqrt{N}=750$ then it may happen that block size of $700$ or $800$ may run better.\nMore importantly, don't compute the block size at runtime - make it `const`. Division by constants is well optimized by compilers.\n* In odd blocks sort the right index in ascending order and in even blocks sort it in descending order. This will minimize the movement of right pointer, as the normal sorting will move the right pointer from the end back to the beginning at the start of every block. With the improved version this resetting is no more necessary.\n\n```cpp\nbool cmp(pair<int, int> p, pair<int, int> q) {\n    if (p.first / BLOCK_SIZE != q.first / BLOCK_SIZE)\n        return p < q;\n    return (p.first / BLOCK_SIZE & 1) ? (p.second < q.second) : (p.second > q.second);\n}\n```\n\nYou can read about even faster sorting approach [here](https://codeforces.com/blog/entry/61203).\n\n## Practice Problems\n\n* [UVA - 12003 - Array Transformer](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3154)\n* [UVA - 11990 Dynamic Inversion](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3141)\n* [SPOJ - Give Away](http://www.spoj.com/problems/GIVEAWAY/)\n* [Codeforces - Till I Collapse](http://codeforces.com/contest/786/problem/C)\n* [Codeforces - Destiny](http://codeforces.com/contest/840/problem/D)\n* [Codeforces - Holes](http://codeforces.com/contest/13/problem/E)\n* [Codeforces - XOR and Favorite Number](https://codeforces.com/problemset/problem/617/E)\n* [Codeforces - Powerful array](http://codeforces.com/problemset/problem/86/D)\n* [SPOJ - DQUERY](https://www.spoj.com/problems/DQUERY)\n", "problem_ids": ["786_C", "840_D", "13_E", "617_E", "86_D"], "title": "Sqrt Decomposition"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: stacks_for_minima\n---\n\n# Minimum stack / Minimum queue\n\nIn this article we will consider three problems: \nfirst we will modify a stack in a way that allows us to find the smallest element of the stack in $O(1)$, then we will do the same thing with a queue, and finally we will use these data structures to find the minimum in all subarrays of a fixed length in an array in $O(n)$\n\n## Stack modification\n\nWe want to modify the stack data structure in such a way, that it possible to find the smallest element in the stack in $O(1)$ time, while maintaining the same asymptotic behavior for adding and removing elements from the stack.\nQuick reminder, on a stack we only add and remove elements on one end.\n\nTo do this, we will not only store the elements in the stack, but we will store them in pairs: the element itself and the minimum in the stack starting from this element and below.\n\n```cpp\nstack<pair<int, int>> st;\n```\n\nIt is clear that finding the minimum in the whole stack consists only of looking at the value `stack.top().second`.\n\nIt is also obvious that adding or removing a new element to the stack can be done in constant time.\n\nImplementation:\n\n* Adding an element:\n```cpp\nint new_min = st.empty() ? new_elem : min(new_elem, st.top().second);\nst.push({new_elem, new_min});\n```\n\n* Removing an element:\n```cpp\nint removed_element = st.top().first;\nst.pop();\n```\n\n* Finding the minimum:\n```cpp\nint minimum = st.top().second;\n```\n\n## Queue modification (method 1)\n\nNow we want to achieve the same operations with a queue, i.e. we want to add elements at the end and remove them from the front.\n\nHere we consider a simple method for modifying a queue.\nIt has a big disadvantage though, because the modified queue will actually not store all elements.\n\nThe key idea is to only store the items in the queue that are needed to determine the minimum.\nNamely we will keep the queue in nondecreasing order (i.e. the smallest value will be stored in the head), and of course not in any arbitrary way, the actual minimum has to be always contained in the queue.\nThis way the smallest element will always be in the head of the queue.\nBefore adding a new element to the queue, it is enough to make a \"cut\":\nwe will remove all trailing elements of the queue that are larger than the new element, and afterwards add the new element to the queue. \nThis way we don't break the order of the queue, and we will also not loose the current element if it is at any subsequent step the minimum. \nAll the elements that we removed can never be a minimum itself, so this operation is allowed.\nWhen we want to extract an element from the head, it actually might not be there (because we removed it previously while adding a smaller element). \nTherefore when deleting an element from a queue we need to know the value of the element.\nIf the head of the queue has the same value, we can safely remove it, otherwise we do nothing.\n\nConsider the implementations of the above operations:\n\n```cpp\ndeque<int> q;\n```\n\n* Finding the minimum:\n```cpp\nint minimum = q.front();\n```\n\n* Adding an element:\n```cpp\nwhile (!q.empty() && q.back() > new_element)\n    q.pop_back();\nq.push_back(new_element);\n```\n\n* Removing an element:\n```cpp\nif (!q.empty() && q.front() == remove_element)\n    q.pop_front();\n```\n\nIt is clear that on average all these operation only take $O(1)$ time (because every element can only be pushed and popped once).\n\n## Queue modification (method 2)\n\nThis is a modification of method 1.\nWe want to be able to remove elements without knowing which element we have to remove.\nWe can accomplish that by storing the index for each element in the queue.\nAnd we also remember how many elements we already have added and removed.\n\n```cpp\ndeque<pair<int, int>> q;\nint cnt_added = 0;\nint cnt_removed = 0;\n```\n\n* Finding the minimum:\n```cpp\nint minimum = q.front().first;\n```\n\n* Adding an element:\n```cpp\nwhile (!q.empty() && q.back().first > new_element)\n    q.pop_back();\nq.push_back({new_element, cnt_added});\ncnt_added++;\n```\n\n* Removing an element:\n```cpp\nif (!q.empty() && q.front().second == cnt_removed) \n    q.pop_front();\ncnt_removed++;\n```\n\n## Queue modification (method 3)\n\nHere we consider another way of modifying a queue to find the minimum in $O(1)$.\nThis way is somewhat more complicated to implement, but this time we actually store all elements.\nAnd we also can remove an element from the front without knowing its value.\n\nThe idea is to reduce the problem to the problem of stacks, which was already solved by us.\nSo we only need to learn how to simulate a queue using two stacks.\n\nWe make two stacks, `s1` and `s2`. \nOf course these stack will be of the modified form, so that we can find the minimum in $O(1)$. \nWe will add new elements to the stack `s1`, and remove elements from the stack `s2`.\nIf at any time the stack `s2` is empty, we move all elements from `s1` to `s2` (which essentially reverses the order of those elements).\nFinally finding the minimum in a queue involves just finding the minimum of both stacks.\n\nThus we perform all operations in $O(1)$ on average (each element will be once added to stack `s1`, once transferred to `s2`, and once popped from `s2`)\n\nImplementation:\n\n```cpp\nstack<pair<int, int>> s1, s2;\n```\n\n* Finding the minimum:\n```cpp\nif (s1.empty() || s2.empty()) \n    minimum = s1.empty() ? s2.top().second : s1.top().second;\nelse\n    minimum = min(s1.top().second, s2.top().second);\n```\n\n* Add element:\n```cpp\nint minimum = s1.empty() ? new_element : min(new_element, s1.top().second);\ns1.push({new_element, minimum});\n```\n\n* Removing an element:\n```cpp\nif (s2.empty()) {\n    while (!s1.empty()) {\n        int element = s1.top().first;\n        s1.pop();\n        int minimum = s2.empty() ? element : min(element, s2.top().second);\n        s2.push({element, minimum});\n    }\n}\nint remove_element = s2.top().first;\ns2.pop();\n```\n\n## Finding the minimum for all subarrays of fixed length\n\nSuppose we are given an array $A$ of length $N$ and a given $M \\le N$.\nWe have to find the minimum of each subarray of length $M$ in this array, i.e. we have to find:\n\n$$\\min_{0 \\le i \\le M-1} A[i], \\min_{1 \\le i \\le M} A[i], \\min_{2 \\le i \\le M+1} A[i],~\\dots~, \\min_{N-M \\le i \\le N-1} A[i]$$\n\nWe have to solve this problem in linear time, i.e. $O(n)$.\n\nWe can use any of the three modified queues to solve the problem.\nThe solutions should be clear:\nwe add the first $M$ element of the array, find and output its minimum, then add the next element to the queue and remove the first element of the array, find and output its minimum, etc. \nSince all operations with the queue are performed in constant time on average, the complexity of the whole algorithm will be $O(n)$.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: stacks_for_minima\n---\n\n# Minimum stack / Minimum queue\n\nIn this article we will consider three problems: \nfirst we will modify a stack in a way that allows us to find the smallest element of the stack in $O(1)$, then we will do the same thing with a queue, and finally we will use these data structures to find the minimum in all subarrays of a fixed length in an array in $O(n)$\n\n## Stack modification\n\nWe want to modify the stack data structure in such a way, that it possible to find the smallest element in the stack in $O(1)$ time, while maintaining the same asymptotic behavior for adding and removing elements from the stack.\nQuick reminder, on a stack we only add and remove elements on one end.\n\nTo do this, we will not only store the elements in the stack, but we will store them in pairs: the element itself and the minimum in the stack starting from this element and below.\n\n```cpp\nstack<pair<int, int>> st;\n```\n\nIt is clear that finding the minimum in the whole stack consists only of looking at the value `stack.top().second`.\n\nIt is also obvious that adding or removing a new element to the stack can be done in constant time.\n\nImplementation:\n\n* Adding an element:\n```cpp\nint new_min = st.empty() ? new_elem : min(new_elem, st.top().second);\nst.push({new_elem, new_min});\n```\n\n* Removing an element:\n```cpp\nint removed_element = st.top().first;\nst.pop();\n```\n\n* Finding the minimum:\n```cpp\nint minimum = st.top().second;\n```\n\n## Queue modification (method 1)\n\nNow we want to achieve the same operations with a queue, i.e. we want to add elements at the end and remove them from the front.\n\nHere we consider a simple method for modifying a queue.\nIt has a big disadvantage though, because the modified queue will actually not store all elements.\n\nThe key idea is to only store the items in the queue that are needed to determine the minimum.\nNamely we will keep the queue in nondecreasing order (i.e. the smallest value will be stored in the head), and of course not in any arbitrary way, the actual minimum has to be always contained in the queue.\nThis way the smallest element will always be in the head of the queue.\nBefore adding a new element to the queue, it is enough to make a \"cut\":\nwe will remove all trailing elements of the queue that are larger than the new element, and afterwards add the new element to the queue. \nThis way we don't break the order of the queue, and we will also not loose the current element if it is at any subsequent step the minimum. \nAll the elements that we removed can never be a minimum itself, so this operation is allowed.\nWhen we want to extract an element from the head, it actually might not be there (because we removed it previously while adding a smaller element). \nTherefore when deleting an element from a queue we need to know the value of the element.\nIf the head of the queue has the same value, we can safely remove it, otherwise we do nothing.\n\nConsider the implementations of the above operations:\n\n```cpp\ndeque<int> q;\n```\n\n* Finding the minimum:\n```cpp\nint minimum = q.front();\n```\n\n* Adding an element:\n```cpp\nwhile (!q.empty() && q.back() > new_element)\n    q.pop_back();\nq.push_back(new_element);\n```\n\n* Removing an element:\n```cpp\nif (!q.empty() && q.front() == remove_element)\n    q.pop_front();\n```\n\nIt is clear that on average all these operation only take $O(1)$ time (because every element can only be pushed and popped once).\n\n## Queue modification (method 2)\n\nThis is a modification of method 1.\nWe want to be able to remove elements without knowing which element we have to remove.\nWe can accomplish that by storing the index for each element in the queue.\nAnd we also remember how many elements we already have added and removed.\n\n```cpp\ndeque<pair<int, int>> q;\nint cnt_added = 0;\nint cnt_removed = 0;\n```\n\n* Finding the minimum:\n```cpp\nint minimum = q.front().first;\n```\n\n* Adding an element:\n```cpp\nwhile (!q.empty() && q.back().first > new_element)\n    q.pop_back();\nq.push_back({new_element, cnt_added});\ncnt_added++;\n```\n\n* Removing an element:\n```cpp\nif (!q.empty() && q.front().second == cnt_removed) \n    q.pop_front();\ncnt_removed++;\n```\n\n## Queue modification (method 3)\n\nHere we consider another way of modifying a queue to find the minimum in $O(1)$.\nThis way is somewhat more complicated to implement, but this time we actually store all elements.\nAnd we also can remove an element from the front without knowing its value.\n\nThe idea is to reduce the problem to the problem of stacks, which was already solved by us.\nSo we only need to learn how to simulate a queue using two stacks.\n\nWe make two stacks, `s1` and `s2`. \nOf course these stack will be of the modified form, so that we can find the minimum in $O(1)$. \nWe will add new elements to the stack `s1`, and remove elements from the stack `s2`.\nIf at any time the stack `s2` is empty, we move all elements from `s1` to `s2` (which essentially reverses the order of those elements).\nFinally finding the minimum in a queue involves just finding the minimum of both stacks.\n\nThus we perform all operations in $O(1)$ on average (each element will be once added to stack `s1`, once transferred to `s2`, and once popped from `s2`)\n\nImplementation:\n\n```cpp\nstack<pair<int, int>> s1, s2;\n```\n\n* Finding the minimum:\n```cpp\nif (s1.empty() || s2.empty()) \n    minimum = s1.empty() ? s2.top().second : s1.top().second;\nelse\n    minimum = min(s1.top().second, s2.top().second);\n```\n\n* Add element:\n```cpp\nint minimum = s1.empty() ? new_element : min(new_element, s1.top().second);\ns1.push({new_element, minimum});\n```\n\n* Removing an element:\n```cpp\nif (s2.empty()) {\n    while (!s1.empty()) {\n        int element = s1.top().first;\n        s1.pop();\n        int minimum = s2.empty() ? element : min(element, s2.top().second);\n        s2.push({element, minimum});\n    }\n}\nint remove_element = s2.top().first;\ns2.pop();\n```\n\n## Finding the minimum for all subarrays of fixed length\n\nSuppose we are given an array $A$ of length $N$ and a given $M \\le N$.\nWe have to find the minimum of each subarray of length $M$ in this array, i.e. we have to find:\n\n$$\\min_{0 \\le i \\le M-1} A[i], \\min_{1 \\le i \\le M} A[i], \\min_{2 \\le i \\le M+1} A[i],~\\dots~, \\min_{N-M \\le i \\le N-1} A[i]$$\n\nWe have to solve this problem in linear time, i.e. $O(n)$.\n\nWe can use any of the three modified queues to solve the problem.\nThe solutions should be clear:\nwe add the first $M$ element of the array, find and output its minimum, then add the next element to the queue and remove the first element of the array, find and output its minimum, etc. \nSince all operations with the queue are performed in constant time on average, the complexity of the whole algorithm will be $O(n)$.\n\n## Practice Problems\n* [Queries with Fixed Length](https://www.hackerrank.com/challenges/queries-with-fixed-length/problem)\n* [Binary Land](https://www.codechef.com/MAY20A/problems/BINLAND)\n\n", "problem_ids": [], "title": "Minimum stack / Minimum queue"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: dsu\n---\n\n# Disjoint Set Union\n\nThis article discusses the data structure **Disjoint Set Union** or **DSU**.\nOften it is also called **Union Find** because of its two main operations.\n\nThis data structure provides the following capabilities.\nWe are given several elements, each of which is a separate set.\nA DSU will have an operation to combine any two sets, and it will be able to tell in which set a specific element is.\nThe classical version also introduces a third operation, it can create a set from a new element.\n\nThus the basic interface of this data structure consists of only three operations:\n\n- `make_set(v)` - creates a new set consisting of the new element `v`\n- `union_sets(a, b)` - merges the two specified sets (the set in which the element `a` is located, and the set in which the element `b` is located)\n- `find_set(v)` - returns the representative (also called leader) of the set that contains the element `v`.\nThis representative is an element of its corresponding set.\nIt is selected in each set by the data structure itself (and can change over time, namely after `union_sets` calls).\nThis representative can be used to check if two elements are part of the same set or not.\n`a` and `b` are exactly in the same set, if `find_set(a) == find_set(b)`.\nOtherwise they are in different sets.\n\nAs described in more detail later, the data structure allows you to do each of these operations in almost $O(1)$ time on average.\n\nAlso in one of the subsections an alternative structure of a DSU is explained, which achieves a slower average complexity of $O(\\log n)$, but can be more powerful than the regular DSU structure.\n\n## Build an efficient data structure\n\nWe will store the sets in the form of **trees**: each tree will correspond to one set.\nAnd the root of the tree will be the representative/leader of the set.\n\nIn the following image you can see the representation of such trees.\n\n![Example-image of the set representation with trees](DSU_example.png)\n\nIn the beginning, every element starts as a single set, therefore each vertex is its own tree.\nThen we combine the set containing the element 1 and the set containing the element 2.\nThen we combine the set containing the element 3 and the set containing the element 4.\nAnd in the last step, we combine the set containing the element 1 and the set containing the element 3.\n\nFor the implementation this means that we will have to maintain an array `parent` that stores a reference to its immediate ancestor in the tree.\n\n### Naive implementation\n\nWe can already write the first implementation of the Disjoint Set Union data structure.\nIt will be pretty inefficient at first, but later we can improve it using two optimizations, so that it will take nearly constant time for each function call.\n\nAs we said, all the information about the sets of elements will be kept in an array `parent`.\n\nTo create a new set (operation `make_set(v)`), we simply create a tree with root in the vertex `v`, meaning that it is its own ancestor.\n\nTo combine two sets (operation `union_sets(a, b)`), we first find the representative of the set in which `a` is located, and the representative of the set in which `b` is located.\nIf the representatives are identical, that we have nothing to do, the sets are already merged.\nOtherwise, we can simply specify that one of the representatives is the parent of the other representative - thereby combining the two trees.\n\nFinally the implementation of the find representative function (operation `find_set(v)`):\nwe simply climb the ancestors of the vertex `v` until we reach the root, i.e. a vertex such that the reference to the ancestor leads to itself.\nThis operation is easily implemented recursively.\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = v;\n}\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b)\n        parent[b] = a;\n}\n```\n\nHowever this implementation is inefficient.\nIt is easy to construct an example, so that the trees degenerate into long chains.\nIn that case each call `find_set(v)` can take $O(n)$ time.\n\nThis is far away from the complexity that we want to have (nearly constant time).\nTherefore we will consider two optimizations that will allow to significantly accelerate the work.\n\n### Path compression optimization\n\nThis optimization is designed for speeding up `find_set`.\n\nIf we call `find_set(v)` for some vertex `v`, we actually find the representative `p` for all vertices that we visit on the path between `v` and the actual representative `p`.\nThe trick is to make the paths for all those nodes shorter, by setting the parent of each visited vertex directly to `p`.\n\nYou can see the operation in the following image.\nOn the left there is a tree, and on the right side there is the compressed tree after calling `find_set(7)`, which shortens the paths for the visited nodes 7, 5, 3 and 2.\n\n![Path compression of call `find_set(7)`](DSU_path_compression.png)\n\nThe new implementation of `find_set` is as follows:\n\n```cpp\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n```\n\nThe simple implementation does what was intended:\nfirst find the representative of the set (root vertex), and then in the process of stack unwinding the visited nodes are attached directly to the representative.\n\nThis simple modification of the operation already achieves the time complexity $O(\\log n)$ per call on average (here without proof).\nThere is a second modification, that will make it even faster.\n\n### Union by size / rank\nIn this optimization we will change the `union_set` operation.\nTo be precise, we will change which tree gets attached to the other one.\nIn the naive implementation the second tree always got attached to the first one.\nIn practice that can lead to trees containing chains of length $O(n)$.\nWith this optimization we will avoid this by choosing very carefully which tree gets attached.\n\nThere are many possible heuristics that can be used.\nMost popular are the following two approaches:\nIn the first approach we use the size of the trees as rank, and in the second one we use the depth of the tree (more precisely, the upper bound on the tree depth, because the depth will get smaller when applying path compression).\n\nIn both approaches the essence of the optimization is the same: we attach the tree with the lower rank to the one with the bigger rank.\n\nHere is the implementation of union by size:\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = v;\n    size[v] = 1;\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (size[a] < size[b])\n            swap(a, b);\n        parent[b] = a;\n        size[a] += size[b];\n    }\n}\n```\n\nAnd here is the implementation of union by rank based on the depth of the trees:\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = v;\n    rank[v] = 0;\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n```\nBoth optimizations are equivalent in terms of time and space complexity. So in practice you can use any of them.\n\n### Time complexity\n\nAs mentioned before, if we combine both optimizations - path compression with union by size / rank - we will reach nearly constant time queries.\nIt turns out, that the final amortized time complexity is $O(\\alpha(n))$, where $\\alpha(n)$ is the inverse Ackermann function, which grows very slowly.\nIn fact it grows so slowly, that it doesn't exceed $4$ for all reasonable $n$ (approximately $n < 10^{600}$).\n\nAmortized complexity is the total time per operation, evaluated over a sequence of multiple operations.\nThe idea is to guarantee the total time of the entire sequence, while allowing single operations to be much slower then the amortized time.\nE.g. in our case a single call might take $O(\\log n)$ in the worst case, but if we do $m$ such calls back to back we will end up with an average time of $O(\\alpha(n))$.\n\nWe will also not present a proof for this time complexity, since it is quite long and complicated.\n\nAlso, it's worth mentioning that DSU with union by size / rank, but without path compression works in $O(\\log n)$ time per query.\n\n### Linking by index / coin-flip linking\n\nBoth union by rank and union by size require that you store additional data for each set, and maintain these values during each union operation.\nThere exist also a randomized algorithm, that simplifies the union operation a little bit: linking by index.\n\nWe assign each set a random value called the index, and we attach the set with the smaller index to the one with the larger one.\nIt is likely that a bigger set will have a bigger index than the smaller set, therefore this operation is closely related to union by size.\nIn fact it can be proven, that this operation has the same time complexity as union by size.\nHowever in practice it is slightly slower than union by size.\n\nYou can find a proof of the complexity and even more union techniques [here](http://www.cis.upenn.edu/~sanjeev/papers/soda14_disjoint_set_union.pdf).\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = v;\n    index[v] = rand();\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (index[a] < index[b])\n            swap(a, b);\n        parent[b] = a;\n    }\n}\n```\n\nIt's a common misconception that just flipping a coin, to decide which set we attach to the other, has the same complexity.\nHowever that's not true.\nThe paper linked above conjectures that coin-flip linking combined with path compression has complexity $\\Omega\\left(n \\frac{\\log n}{\\log \\log n}\\right)$.\nAnd in benchmarks it performs a lot worse than union by size/rank or linking by index.\n\n```cpp\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rand() % 2)\n            swap(a, b);\n        parent[b] = a;\n    }\n}\n```\n\n## Applications and various improvements\n\nIn this section we consider several applications of the data structure, both the trivial uses and some improvements to the data structure.\n\n### Connected components in a graph\n\nThis is one of the obvious applications of DSU.\n\nFormally the problem is defined in the following way:\nInitially we have an empty graph.\nWe have to add vertices and undirected edges, and answer queries of the form $(a, b)$ - \"are the vertices $a$ and $b$ in the same connected component of the graph?\"\n\nHere we can directly apply the data structure, and get a solution that handles an addition of a vertex or an edge and a query in nearly constant time on average.\n\nThis application is quite important, because nearly the same problem appears in [Kruskal's algorithm for finding a minimum spanning tree](../graph/mst_kruskal.md).\nUsing DSU we can [improve](../graph/mst_kruskal_with_dsu.md) the $O(m \\log n + n^2)$ complexity to $O(m \\log n)$.\n\n### Search for connected components in an image\n\nOne of the applications of DSU is the following task:\nthere is an image of $n \\times m$ pixels.\nOriginally all are white, but then a few black pixels are drawn.\nYou want to determine the size of each white connected component in the final image.\n\nFor the solution we simply iterate over all white pixels in the image, for each cell iterate over its four neighbors, and if the neighbor is white call `union_sets`.\nThus we will have a DSU with $n m$ nodes corresponding to image pixels.\nThe resulting trees in the DSU are the desired connected components.\n\nThe problem can also be solved by [DFS](../graph/depth-first-search.md) or [BFS](../graph/breadth-first-search.md), but the method described here has an advantage:\nit can process the matrix row by row (i.e. to process a row we only need the previous and the current row, and only need a DSU built for the elements of one row) in $O(\\min(n, m))$ memory.\n\n### Store additional information for each set\n\nDSU allows you to easily store additional information in the sets.\n\nA simple example is the size of the sets:\nstoring the sizes was already described in the Union by size section (the information was stored by the current representative of the set).\n\nIn the same way - by storing it at the representative nodes - you can also store any other information about the sets.\n\n### Compress jumps along a segment / Painting subarrays offline\n\nOne common application of the DSU is the following:\nThere is a set of vertices, and each vertex has an outgoing edge to another vertex.\nWith DSU you can find the end point, to which we get after following all edges from a given starting point, in almost constant time.\n\nA good example of this application is the **problem of painting subarrays**.\nWe have a segment of length $L$, each element initially has the color 0.\nWe have to repaint the subarray $[l, r]$ with the color $c$ for each query $(l, r, c)$.\nAt the end we want to find the final color of each cell.\nWe assume that we know all the queries in advance, i.e. the task is offline.\n\nFor the solution we can make a DSU, which for each cell stores a link to the next unpainted cell.\nThus initially each cell points to itself.\nAfter painting one requested repaint of a segment, all cells from that segment will point to the cell after the segment.\n\nNow to solve this problem, we consider the queries **in the reverse order**: from last to first.\nThis way when we execute a query, we only have to paint exactly the unpainted cells in the subarray $[l, r]$.\nAll other cells already contain their final color.\nTo quickly iterate over all unpainted cells, we use the DSU.\nWe find the left-most unpainted cell inside of a segment, repaint it, and with the pointer we move to the next empty cell to the right.\n\nHere we can use the DSU with path compression, but we cannot use union by rank / size (because it is important who becomes the leader after the merge).\nTherefore the complexity will be $O(\\log n)$ per union (which is also quite fast).\n\nImplementation:\n\n```cpp\nfor (int i = 0; i <= L; i++) {\n    make_set(i);\n}\n\nfor (int i = m-1; i >= 0; i--) {\n    int l = query[i].l;\n    int r = query[i].r;\n    int c = query[i].c;\n    for (int v = find_set(l); v <= r; v = find_set(v)) {\n        answer[v] = c;\n        parent[v] = v + 1;\n    }\n}\n```\n\nThere is one optimization:\nWe can use **union by rank**, if we store the next unpainted cell in an additional array `end[]`.\nThen we can merge two sets into one ranked according to their heuristics, and we obtain the solution in $O(\\alpha(n))$.\n\n### Support distances up to representative\n\nSometimes in specific applications of the DSU you need to maintain the distance between a vertex and the representative of its set (i.e. the path length in the tree from the current node to the root of the tree).\n\nIf we don't use path compression, the distance is just the number of recursive calls.\nBut this will be inefficient.\n\nHowever it is possible to do path compression, if we store the **distance to the parent** as additional information for each node.\n\nIn the implementation it is convenient to use an array of pairs for `parent[]` and the function `find_set` now returns two numbers: the representative of the set, and the distance to it.\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = make_pair(v, 0);\n    rank[v] = 0;\n}\n\npair<int, int> find_set(int v) {\n    if (v != parent[v].first) {\n        int len = parent[v].second;\n        parent[v] = find_set(parent[v].first);\n        parent[v].second += len;\n    }\n    return parent[v];\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a).first;\n    b = find_set(b).first;\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = make_pair(a, 1);\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n```\n\n### Support the parity of the path length / Checking bipartiteness online\n\nIn the same way as computing the path length to the leader, it is possible to maintain the parity of the length of the path before him.\nWhy is this application in a separate paragraph?\n\nThe unusual requirement of storing the parity of the path comes up in the following task:\ninitially we are given an empty graph, it can be added edges, and we have to answer queries of the form \"is the connected component containing this vertex **bipartite**?\".\n\nTo solve this problem, we make a DSU for storing of the components and store the parity of the path up to the representative for each vertex.\nThus we can quickly check if adding an edge leads to a violation of the bipartiteness or not:\nnamely if the ends of the edge lie in the same connected component and have the same parity length to the leader, then adding this edge will produce a cycle of odd length, and the component will lose the bipartiteness property.\n\nThe only difficulty that we face is to compute the parity in the `union_find` method.\n\nIf we add an edge $(a, b)$ that connects two connected components into one, then when you attach one tree to another we need to adjust the parity.\n\nLet's derive a formula, which computes the parity issued to the leader of the set that will get attached to another set.\nLet $x$ be the parity of the path length from vertex $a$ up to its leader $A$, and $y$ as the parity of the path length from vertex $b$ up to its leader $B$, and $t$ the desired parity that we have to assign to $B$ after the merge.\nThe path contains the of the three parts:\nfrom $B$ to $b$, from $b$ to $a$, which is connected by one edge and therefore has parity $1$, and from $a$ to $A$.\nTherefore we receive the formula ($\\oplus$ denotes the XOR operation):\n\n$$t = x \\oplus y \\oplus 1$$\n\nThus regardless of how many joins we perform, the parity of the edges is carried from one leader to another.\n\nWe give the implementation of the DSU that supports parity. As in the previous section we use a pair to store the ancestor and the parity. In addition for each set we store in the array `bipartite[]` whether it is still bipartite or not.\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = make_pair(v, 0);\n    rank[v] = 0;\n    bipartite[v] = true;\n}\n\npair<int, int> find_set(int v) {\n    if (v != parent[v].first) {\n        int parity = parent[v].second;\n        parent[v] = find_set(parent[v].first);\n        parent[v].second ^= parity;\n    }\n    return parent[v];\n}\n\nvoid add_edge(int a, int b) {\n    pair<int, int> pa = find_set(a);\n    a = pa.first;\n    int x = pa.second;\n\n    pair<int, int> pb = find_set(b);\n    b = pb.first;\n    int y = pb.second;\n\n    if (a == b) {\n        if (x == y)\n            bipartite[a] = false;\n    } else {\n        if (rank[a] < rank[b])\n            swap (a, b);\n        parent[b] = make_pair(a, x^y^1);\n        bipartite[a] &= bipartite[b];\n        if (rank[a] == rank[b])\n            ++rank[a];\n    }\n}\n\nbool is_bipartite(int v) {\n    return bipartite[find_set(v).first];\n}\n```\n\n### Offline RMQ (range minimum query) in $O(\\alpha(n))$ on average / Arpa's trick { #arpa data-toc-label=\"Offline RMQ / Arpa's trick\"}\n\nWe are given an array `a[]` and we have to compute some minima in given segments of the array.\n\nThe idea to solve this problem with DSU is the following:\nWe will iterate over the array and when we are at the `i`th element we will answer all queries `(L, R)` with `R == i`.\nTo do this efficiently we will keep a DSU using the first `i` elements with the following structure: the parent of an element is the next smaller element to the right of it.\nThen using this structure the answer to a query will be the `a[find_set(L)]`, the smallest number to the right of `L`.\n\nThis approach obviously only works offline, i.e. if we know all queries beforehand.\n\nIt is easy to see that we can apply path compression.\nAnd we can also use Union by rank, if we store the actual leader in an separate array.\n\n```cpp\nstruct Query {\n    int L, R, idx;\n};\n\nvector<int> answer;\nvector<vector<Query>> container;\n```\n\n`container[i]` contains all queries with `R == i`.\n\n```cpp\nstack<int> s;\nfor (int i = 0; i < n; i++) {\n    while (!s.empty() && a[s.top()] > a[i]) {\n        parent[s.top()] = i;\n        s.pop();\n    }\n    s.push(i);\n    for (Query q : container[i]) {\n        answer[q.idx] = a[find_set(q.L)];\n    }\n}\n```\n\nNowadays this algorithm is known as Arpa's trick.\nIt is named after AmirReza Poorakhavan, who independently discovered and popularized this technique.\nAlthough this algorithm existed already before his discovery.\n\n### Offline LCA (lowest common ancestor in a tree) in $O(\\alpha(n))$ on average {data-toc-label=\"Offline LCA\"}\n\nThe algorithm for finding the LCA is discussed in the article [Lowest Common Ancestor - Tarjan's off-line algorithm](../graph/lca_tarjan.md).\nThis algorithm compares favorable with other algorithms for finding the LCA due to its simplicity (especially compared to an optimal algorithm like the one from [Farach-Colton and Bender](../graph/lca_farachcoltonbender.md)).\n\n### Storing the DSU explicitly in a set list / Applications of this idea when merging various data structures\n\nOne of the alternative ways of storing the DSU is the preservation of each set in the form of an **explicitly stored list of its elements**.\nAt the same time each element also stores the reference to the representative of his set.\n\nAt first glance this looks like an inefficient data structure:\nby combining two sets we will have to add one list to the end of another and have to update the leadership in all elements of one of the lists.\n\nHowever it turns out, the use of a **weighting heuristic** (similar to Union by size) can significantly reduce the asymptotic complexity:\n$O(m + n \\log n)$ to perform $m$ queries on the $n$ elements.\n\nUnder weighting heuristic we mean, that we will always **add the smaller of the two sets to the bigger set**.\nAdding one set to another is easy to implement in `union_sets` and will take time proportional to the size of the added set.\nAnd the search for the leader in `find_set` will take $O(1)$ with this method of storing.\n\nLet us prove the **time complexity** $O(m + n \\log n)$ for the execution of $m$ queries.\nWe will fix an arbitrary element $x$ and count how often it was touched in the merge operation `union_sets`.\nWhen the element $x$ gets touched the first time, the size of the new set will be at least $2$.\nWhen it gets touched the second time, the resulting set will have size of at least $4$, because the smaller set gets added to the bigger one.\nAnd so on.\nThis means, that $x$ can only be moved in at most $\\log n$ merge operations.\nThus the sum over all vertices gives $O(n \\log n)$ plus $O(1)$ for each request.\n\nHere is an implementation:\n\n```cpp\nvector<int> lst[MAXN];\nint parent[MAXN];\n\nvoid make_set(int v) {\n    lst[v] = vector<int>(1, v);\n    parent[v] = v;\n}\n\nint find_set(int v) {\n    return parent[v];\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (lst[a].size() < lst[b].size())\n            swap(a, b);\n        while (!lst[b].empty()) {\n            int v = lst[b].back();\n            lst[b].pop_back();\n            parent[v] = a;\n            lst[a].push_back (v);\n        }\n    }\n}\n```\n\nThis idea of adding the smaller part to a bigger part can also be used in a lot of solutions that have nothing to do with DSU.\n\nFor example consider the following **problem**:\nwe are given a tree, each leaf has a number assigned (same number can appear multiple times on different leaves).\nWe want to compute the number of different numbers in the subtree for every node of the tree.\n\nApplying to this task the same idea it is possible to obtain this solution:\nwe can implement a [DFS](../graph/depth-first-search.md), which will return a pointer to a set of integers - the list of numbers in that subtree.\nThen to get the answer for the current node (unless of course it is a leaf), we call DFS for all children of that node, and merge all the received sets together.\nThe size of the resulting set will be the answer for the current node.\nTo efficiently combine multiple sets we just apply the above-described recipe:\nwe merge the sets by simply adding smaller ones to larger.\nIn the end we get a $O(n \\log^2 n)$ solution, because one number will only added to a set at most $O(\\log n)$ times.\n\n### Storing the DSU by maintaining a clear tree structure / Online bridge finding in $O(\\alpha(n))$ on average  {data-toc-label=\"Storing the DSU by maintaining a clear tree structure / Online bridge finding\"}\n\nOne of the most powerful applications of DSU is that it allows you to store both as **compressed and uncompressed trees**.\nThe compressed form can be used for merging of trees and for the verification if two vertices are in the same tree, and the uncompressed form can be used - for example - to search for paths between two given vertices, or other traversals of the tree structure.\n\nIn the implementation this means that in addition to the compressed ancestor array `parent[]` we will need to keep the array of uncompressed ancestors `real_parent[]`.\nIt is trivial that maintaining this additional array will not worsen the complexity:\nchanges in it only occur when we merge two trees, and only in one element.\n\nOn the other hand when applied in practice, we often need to connect trees using a specified edge other that using the two root nodes.\nThis means that we have no other choice but to re-root one of the trees (make the ends of the edge the new root of the tree).\n\nAt first glance it seems that this re-rooting is very costly and will greatly worsen the time complexity.\nIndeed, for rooting a tree at vertex $v$ we must go from the vertex to the old root and change directions in `parent[]` and `real_parent[]` for all nodes on that path.\n\nHowever in reality it isn't so bad, we can just re-root the smaller of the two trees similar to the ideas in the previous sections, and get $O(\\log n)$ on average.\n\nMore details (including proof of the time complexity) can be found in the article [Finding Bridges Online](../graph/bridge-searching-online.md).\n\n## Historical retrospective\n\nThe data structure DSU has been known for a long time.\n\nThis way of storing this structure in the form **of a forest of trees** was apparently first described by Galler and Fisher in 1964 (Galler, Fisher, \"An Improved Equivalence Algorithm), however the complete analysis of the time complexity was conducted much later.\n\nThe optimizations path compression and Union by rank has been developed by McIlroy and Morris, and independently of them also by Tritter.\n\nHopcroft and Ullman showed in 1973 the time complexity $O(\\log^\\star n)$ (Hopcroft, Ullman \"Set-merging algorithms\") - here $\\log^\\star$ is the **iterated logarithm** (this is a slow-growing function, but still not as slow as the inverse Ackermann function).\n\nFor the first time the evaluation of $O(\\alpha(n))$ was shown in 1975 (Tarjan \"Efficiency of a Good But Not Linear Set Union Algorithm\").\nLater in 1985 he, along with Leeuwen, published multiple complexity analyses for several different rank heuristics and ways of compressing the path (Tarjan, Leeuwen \"Worst-case Analysis of Set Union Algorithms\").\n\nFinally in 1989 Fredman and Sachs proved that in the adopted model of computation **any** algorithm for the disjoint set union problem has to work in at least $O(\\alpha(n))$ time on average (Fredman, Saks, \"The cell probe complexity of dynamic data structures\").\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: dsu\n---\n\n# Disjoint Set Union\n\nThis article discusses the data structure **Disjoint Set Union** or **DSU**.\nOften it is also called **Union Find** because of its two main operations.\n\nThis data structure provides the following capabilities.\nWe are given several elements, each of which is a separate set.\nA DSU will have an operation to combine any two sets, and it will be able to tell in which set a specific element is.\nThe classical version also introduces a third operation, it can create a set from a new element.\n\nThus the basic interface of this data structure consists of only three operations:\n\n- `make_set(v)` - creates a new set consisting of the new element `v`\n- `union_sets(a, b)` - merges the two specified sets (the set in which the element `a` is located, and the set in which the element `b` is located)\n- `find_set(v)` - returns the representative (also called leader) of the set that contains the element `v`.\nThis representative is an element of its corresponding set.\nIt is selected in each set by the data structure itself (and can change over time, namely after `union_sets` calls).\nThis representative can be used to check if two elements are part of the same set or not.\n`a` and `b` are exactly in the same set, if `find_set(a) == find_set(b)`.\nOtherwise they are in different sets.\n\nAs described in more detail later, the data structure allows you to do each of these operations in almost $O(1)$ time on average.\n\nAlso in one of the subsections an alternative structure of a DSU is explained, which achieves a slower average complexity of $O(\\log n)$, but can be more powerful than the regular DSU structure.\n\n## Build an efficient data structure\n\nWe will store the sets in the form of **trees**: each tree will correspond to one set.\nAnd the root of the tree will be the representative/leader of the set.\n\nIn the following image you can see the representation of such trees.\n\n![Example-image of the set representation with trees](DSU_example.png)\n\nIn the beginning, every element starts as a single set, therefore each vertex is its own tree.\nThen we combine the set containing the element 1 and the set containing the element 2.\nThen we combine the set containing the element 3 and the set containing the element 4.\nAnd in the last step, we combine the set containing the element 1 and the set containing the element 3.\n\nFor the implementation this means that we will have to maintain an array `parent` that stores a reference to its immediate ancestor in the tree.\n\n### Naive implementation\n\nWe can already write the first implementation of the Disjoint Set Union data structure.\nIt will be pretty inefficient at first, but later we can improve it using two optimizations, so that it will take nearly constant time for each function call.\n\nAs we said, all the information about the sets of elements will be kept in an array `parent`.\n\nTo create a new set (operation `make_set(v)`), we simply create a tree with root in the vertex `v`, meaning that it is its own ancestor.\n\nTo combine two sets (operation `union_sets(a, b)`), we first find the representative of the set in which `a` is located, and the representative of the set in which `b` is located.\nIf the representatives are identical, that we have nothing to do, the sets are already merged.\nOtherwise, we can simply specify that one of the representatives is the parent of the other representative - thereby combining the two trees.\n\nFinally the implementation of the find representative function (operation `find_set(v)`):\nwe simply climb the ancestors of the vertex `v` until we reach the root, i.e. a vertex such that the reference to the ancestor leads to itself.\nThis operation is easily implemented recursively.\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = v;\n}\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b)\n        parent[b] = a;\n}\n```\n\nHowever this implementation is inefficient.\nIt is easy to construct an example, so that the trees degenerate into long chains.\nIn that case each call `find_set(v)` can take $O(n)$ time.\n\nThis is far away from the complexity that we want to have (nearly constant time).\nTherefore we will consider two optimizations that will allow to significantly accelerate the work.\n\n### Path compression optimization\n\nThis optimization is designed for speeding up `find_set`.\n\nIf we call `find_set(v)` for some vertex `v`, we actually find the representative `p` for all vertices that we visit on the path between `v` and the actual representative `p`.\nThe trick is to make the paths for all those nodes shorter, by setting the parent of each visited vertex directly to `p`.\n\nYou can see the operation in the following image.\nOn the left there is a tree, and on the right side there is the compressed tree after calling `find_set(7)`, which shortens the paths for the visited nodes 7, 5, 3 and 2.\n\n![Path compression of call `find_set(7)`](DSU_path_compression.png)\n\nThe new implementation of `find_set` is as follows:\n\n```cpp\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n```\n\nThe simple implementation does what was intended:\nfirst find the representative of the set (root vertex), and then in the process of stack unwinding the visited nodes are attached directly to the representative.\n\nThis simple modification of the operation already achieves the time complexity $O(\\log n)$ per call on average (here without proof).\nThere is a second modification, that will make it even faster.\n\n### Union by size / rank\nIn this optimization we will change the `union_set` operation.\nTo be precise, we will change which tree gets attached to the other one.\nIn the naive implementation the second tree always got attached to the first one.\nIn practice that can lead to trees containing chains of length $O(n)$.\nWith this optimization we will avoid this by choosing very carefully which tree gets attached.\n\nThere are many possible heuristics that can be used.\nMost popular are the following two approaches:\nIn the first approach we use the size of the trees as rank, and in the second one we use the depth of the tree (more precisely, the upper bound on the tree depth, because the depth will get smaller when applying path compression).\n\nIn both approaches the essence of the optimization is the same: we attach the tree with the lower rank to the one with the bigger rank.\n\nHere is the implementation of union by size:\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = v;\n    size[v] = 1;\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (size[a] < size[b])\n            swap(a, b);\n        parent[b] = a;\n        size[a] += size[b];\n    }\n}\n```\n\nAnd here is the implementation of union by rank based on the depth of the trees:\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = v;\n    rank[v] = 0;\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n```\nBoth optimizations are equivalent in terms of time and space complexity. So in practice you can use any of them.\n\n### Time complexity\n\nAs mentioned before, if we combine both optimizations - path compression with union by size / rank - we will reach nearly constant time queries.\nIt turns out, that the final amortized time complexity is $O(\\alpha(n))$, where $\\alpha(n)$ is the inverse Ackermann function, which grows very slowly.\nIn fact it grows so slowly, that it doesn't exceed $4$ for all reasonable $n$ (approximately $n < 10^{600}$).\n\nAmortized complexity is the total time per operation, evaluated over a sequence of multiple operations.\nThe idea is to guarantee the total time of the entire sequence, while allowing single operations to be much slower then the amortized time.\nE.g. in our case a single call might take $O(\\log n)$ in the worst case, but if we do $m$ such calls back to back we will end up with an average time of $O(\\alpha(n))$.\n\nWe will also not present a proof for this time complexity, since it is quite long and complicated.\n\nAlso, it's worth mentioning that DSU with union by size / rank, but without path compression works in $O(\\log n)$ time per query.\n\n### Linking by index / coin-flip linking\n\nBoth union by rank and union by size require that you store additional data for each set, and maintain these values during each union operation.\nThere exist also a randomized algorithm, that simplifies the union operation a little bit: linking by index.\n\nWe assign each set a random value called the index, and we attach the set with the smaller index to the one with the larger one.\nIt is likely that a bigger set will have a bigger index than the smaller set, therefore this operation is closely related to union by size.\nIn fact it can be proven, that this operation has the same time complexity as union by size.\nHowever in practice it is slightly slower than union by size.\n\nYou can find a proof of the complexity and even more union techniques [here](http://www.cis.upenn.edu/~sanjeev/papers/soda14_disjoint_set_union.pdf).\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = v;\n    index[v] = rand();\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (index[a] < index[b])\n            swap(a, b);\n        parent[b] = a;\n    }\n}\n```\n\nIt's a common misconception that just flipping a coin, to decide which set we attach to the other, has the same complexity.\nHowever that's not true.\nThe paper linked above conjectures that coin-flip linking combined with path compression has complexity $\\Omega\\left(n \\frac{\\log n}{\\log \\log n}\\right)$.\nAnd in benchmarks it performs a lot worse than union by size/rank or linking by index.\n\n```cpp\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rand() % 2)\n            swap(a, b);\n        parent[b] = a;\n    }\n}\n```\n\n## Applications and various improvements\n\nIn this section we consider several applications of the data structure, both the trivial uses and some improvements to the data structure.\n\n### Connected components in a graph\n\nThis is one of the obvious applications of DSU.\n\nFormally the problem is defined in the following way:\nInitially we have an empty graph.\nWe have to add vertices and undirected edges, and answer queries of the form $(a, b)$ - \"are the vertices $a$ and $b$ in the same connected component of the graph?\"\n\nHere we can directly apply the data structure, and get a solution that handles an addition of a vertex or an edge and a query in nearly constant time on average.\n\nThis application is quite important, because nearly the same problem appears in [Kruskal's algorithm for finding a minimum spanning tree](../graph/mst_kruskal.md).\nUsing DSU we can [improve](../graph/mst_kruskal_with_dsu.md) the $O(m \\log n + n^2)$ complexity to $O(m \\log n)$.\n\n### Search for connected components in an image\n\nOne of the applications of DSU is the following task:\nthere is an image of $n \\times m$ pixels.\nOriginally all are white, but then a few black pixels are drawn.\nYou want to determine the size of each white connected component in the final image.\n\nFor the solution we simply iterate over all white pixels in the image, for each cell iterate over its four neighbors, and if the neighbor is white call `union_sets`.\nThus we will have a DSU with $n m$ nodes corresponding to image pixels.\nThe resulting trees in the DSU are the desired connected components.\n\nThe problem can also be solved by [DFS](../graph/depth-first-search.md) or [BFS](../graph/breadth-first-search.md), but the method described here has an advantage:\nit can process the matrix row by row (i.e. to process a row we only need the previous and the current row, and only need a DSU built for the elements of one row) in $O(\\min(n, m))$ memory.\n\n### Store additional information for each set\n\nDSU allows you to easily store additional information in the sets.\n\nA simple example is the size of the sets:\nstoring the sizes was already described in the Union by size section (the information was stored by the current representative of the set).\n\nIn the same way - by storing it at the representative nodes - you can also store any other information about the sets.\n\n### Compress jumps along a segment / Painting subarrays offline\n\nOne common application of the DSU is the following:\nThere is a set of vertices, and each vertex has an outgoing edge to another vertex.\nWith DSU you can find the end point, to which we get after following all edges from a given starting point, in almost constant time.\n\nA good example of this application is the **problem of painting subarrays**.\nWe have a segment of length $L$, each element initially has the color 0.\nWe have to repaint the subarray $[l, r]$ with the color $c$ for each query $(l, r, c)$.\nAt the end we want to find the final color of each cell.\nWe assume that we know all the queries in advance, i.e. the task is offline.\n\nFor the solution we can make a DSU, which for each cell stores a link to the next unpainted cell.\nThus initially each cell points to itself.\nAfter painting one requested repaint of a segment, all cells from that segment will point to the cell after the segment.\n\nNow to solve this problem, we consider the queries **in the reverse order**: from last to first.\nThis way when we execute a query, we only have to paint exactly the unpainted cells in the subarray $[l, r]$.\nAll other cells already contain their final color.\nTo quickly iterate over all unpainted cells, we use the DSU.\nWe find the left-most unpainted cell inside of a segment, repaint it, and with the pointer we move to the next empty cell to the right.\n\nHere we can use the DSU with path compression, but we cannot use union by rank / size (because it is important who becomes the leader after the merge).\nTherefore the complexity will be $O(\\log n)$ per union (which is also quite fast).\n\nImplementation:\n\n```cpp\nfor (int i = 0; i <= L; i++) {\n    make_set(i);\n}\n\nfor (int i = m-1; i >= 0; i--) {\n    int l = query[i].l;\n    int r = query[i].r;\n    int c = query[i].c;\n    for (int v = find_set(l); v <= r; v = find_set(v)) {\n        answer[v] = c;\n        parent[v] = v + 1;\n    }\n}\n```\n\nThere is one optimization:\nWe can use **union by rank**, if we store the next unpainted cell in an additional array `end[]`.\nThen we can merge two sets into one ranked according to their heuristics, and we obtain the solution in $O(\\alpha(n))$.\n\n### Support distances up to representative\n\nSometimes in specific applications of the DSU you need to maintain the distance between a vertex and the representative of its set (i.e. the path length in the tree from the current node to the root of the tree).\n\nIf we don't use path compression, the distance is just the number of recursive calls.\nBut this will be inefficient.\n\nHowever it is possible to do path compression, if we store the **distance to the parent** as additional information for each node.\n\nIn the implementation it is convenient to use an array of pairs for `parent[]` and the function `find_set` now returns two numbers: the representative of the set, and the distance to it.\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = make_pair(v, 0);\n    rank[v] = 0;\n}\n\npair<int, int> find_set(int v) {\n    if (v != parent[v].first) {\n        int len = parent[v].second;\n        parent[v] = find_set(parent[v].first);\n        parent[v].second += len;\n    }\n    return parent[v];\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a).first;\n    b = find_set(b).first;\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = make_pair(a, 1);\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n```\n\n### Support the parity of the path length / Checking bipartiteness online\n\nIn the same way as computing the path length to the leader, it is possible to maintain the parity of the length of the path before him.\nWhy is this application in a separate paragraph?\n\nThe unusual requirement of storing the parity of the path comes up in the following task:\ninitially we are given an empty graph, it can be added edges, and we have to answer queries of the form \"is the connected component containing this vertex **bipartite**?\".\n\nTo solve this problem, we make a DSU for storing of the components and store the parity of the path up to the representative for each vertex.\nThus we can quickly check if adding an edge leads to a violation of the bipartiteness or not:\nnamely if the ends of the edge lie in the same connected component and have the same parity length to the leader, then adding this edge will produce a cycle of odd length, and the component will lose the bipartiteness property.\n\nThe only difficulty that we face is to compute the parity in the `union_find` method.\n\nIf we add an edge $(a, b)$ that connects two connected components into one, then when you attach one tree to another we need to adjust the parity.\n\nLet's derive a formula, which computes the parity issued to the leader of the set that will get attached to another set.\nLet $x$ be the parity of the path length from vertex $a$ up to its leader $A$, and $y$ as the parity of the path length from vertex $b$ up to its leader $B$, and $t$ the desired parity that we have to assign to $B$ after the merge.\nThe path contains the of the three parts:\nfrom $B$ to $b$, from $b$ to $a$, which is connected by one edge and therefore has parity $1$, and from $a$ to $A$.\nTherefore we receive the formula ($\\oplus$ denotes the XOR operation):\n\n$$t = x \\oplus y \\oplus 1$$\n\nThus regardless of how many joins we perform, the parity of the edges is carried from one leader to another.\n\nWe give the implementation of the DSU that supports parity. As in the previous section we use a pair to store the ancestor and the parity. In addition for each set we store in the array `bipartite[]` whether it is still bipartite or not.\n\n```cpp\nvoid make_set(int v) {\n    parent[v] = make_pair(v, 0);\n    rank[v] = 0;\n    bipartite[v] = true;\n}\n\npair<int, int> find_set(int v) {\n    if (v != parent[v].first) {\n        int parity = parent[v].second;\n        parent[v] = find_set(parent[v].first);\n        parent[v].second ^= parity;\n    }\n    return parent[v];\n}\n\nvoid add_edge(int a, int b) {\n    pair<int, int> pa = find_set(a);\n    a = pa.first;\n    int x = pa.second;\n\n    pair<int, int> pb = find_set(b);\n    b = pb.first;\n    int y = pb.second;\n\n    if (a == b) {\n        if (x == y)\n            bipartite[a] = false;\n    } else {\n        if (rank[a] < rank[b])\n            swap (a, b);\n        parent[b] = make_pair(a, x^y^1);\n        bipartite[a] &= bipartite[b];\n        if (rank[a] == rank[b])\n            ++rank[a];\n    }\n}\n\nbool is_bipartite(int v) {\n    return bipartite[find_set(v).first];\n}\n```\n\n### Offline RMQ (range minimum query) in $O(\\alpha(n))$ on average / Arpa's trick { #arpa data-toc-label=\"Offline RMQ / Arpa's trick\"}\n\nWe are given an array `a[]` and we have to compute some minima in given segments of the array.\n\nThe idea to solve this problem with DSU is the following:\nWe will iterate over the array and when we are at the `i`th element we will answer all queries `(L, R)` with `R == i`.\nTo do this efficiently we will keep a DSU using the first `i` elements with the following structure: the parent of an element is the next smaller element to the right of it.\nThen using this structure the answer to a query will be the `a[find_set(L)]`, the smallest number to the right of `L`.\n\nThis approach obviously only works offline, i.e. if we know all queries beforehand.\n\nIt is easy to see that we can apply path compression.\nAnd we can also use Union by rank, if we store the actual leader in an separate array.\n\n```cpp\nstruct Query {\n    int L, R, idx;\n};\n\nvector<int> answer;\nvector<vector<Query>> container;\n```\n\n`container[i]` contains all queries with `R == i`.\n\n```cpp\nstack<int> s;\nfor (int i = 0; i < n; i++) {\n    while (!s.empty() && a[s.top()] > a[i]) {\n        parent[s.top()] = i;\n        s.pop();\n    }\n    s.push(i);\n    for (Query q : container[i]) {\n        answer[q.idx] = a[find_set(q.L)];\n    }\n}\n```\n\nNowadays this algorithm is known as Arpa's trick.\nIt is named after AmirReza Poorakhavan, who independently discovered and popularized this technique.\nAlthough this algorithm existed already before his discovery.\n\n### Offline LCA (lowest common ancestor in a tree) in $O(\\alpha(n))$ on average {data-toc-label=\"Offline LCA\"}\n\nThe algorithm for finding the LCA is discussed in the article [Lowest Common Ancestor - Tarjan's off-line algorithm](../graph/lca_tarjan.md).\nThis algorithm compares favorable with other algorithms for finding the LCA due to its simplicity (especially compared to an optimal algorithm like the one from [Farach-Colton and Bender](../graph/lca_farachcoltonbender.md)).\n\n### Storing the DSU explicitly in a set list / Applications of this idea when merging various data structures\n\nOne of the alternative ways of storing the DSU is the preservation of each set in the form of an **explicitly stored list of its elements**.\nAt the same time each element also stores the reference to the representative of his set.\n\nAt first glance this looks like an inefficient data structure:\nby combining two sets we will have to add one list to the end of another and have to update the leadership in all elements of one of the lists.\n\nHowever it turns out, the use of a **weighting heuristic** (similar to Union by size) can significantly reduce the asymptotic complexity:\n$O(m + n \\log n)$ to perform $m$ queries on the $n$ elements.\n\nUnder weighting heuristic we mean, that we will always **add the smaller of the two sets to the bigger set**.\nAdding one set to another is easy to implement in `union_sets` and will take time proportional to the size of the added set.\nAnd the search for the leader in `find_set` will take $O(1)$ with this method of storing.\n\nLet us prove the **time complexity** $O(m + n \\log n)$ for the execution of $m$ queries.\nWe will fix an arbitrary element $x$ and count how often it was touched in the merge operation `union_sets`.\nWhen the element $x$ gets touched the first time, the size of the new set will be at least $2$.\nWhen it gets touched the second time, the resulting set will have size of at least $4$, because the smaller set gets added to the bigger one.\nAnd so on.\nThis means, that $x$ can only be moved in at most $\\log n$ merge operations.\nThus the sum over all vertices gives $O(n \\log n)$ plus $O(1)$ for each request.\n\nHere is an implementation:\n\n```cpp\nvector<int> lst[MAXN];\nint parent[MAXN];\n\nvoid make_set(int v) {\n    lst[v] = vector<int>(1, v);\n    parent[v] = v;\n}\n\nint find_set(int v) {\n    return parent[v];\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (lst[a].size() < lst[b].size())\n            swap(a, b);\n        while (!lst[b].empty()) {\n            int v = lst[b].back();\n            lst[b].pop_back();\n            parent[v] = a;\n            lst[a].push_back (v);\n        }\n    }\n}\n```\n\nThis idea of adding the smaller part to a bigger part can also be used in a lot of solutions that have nothing to do with DSU.\n\nFor example consider the following **problem**:\nwe are given a tree, each leaf has a number assigned (same number can appear multiple times on different leaves).\nWe want to compute the number of different numbers in the subtree for every node of the tree.\n\nApplying to this task the same idea it is possible to obtain this solution:\nwe can implement a [DFS](../graph/depth-first-search.md), which will return a pointer to a set of integers - the list of numbers in that subtree.\nThen to get the answer for the current node (unless of course it is a leaf), we call DFS for all children of that node, and merge all the received sets together.\nThe size of the resulting set will be the answer for the current node.\nTo efficiently combine multiple sets we just apply the above-described recipe:\nwe merge the sets by simply adding smaller ones to larger.\nIn the end we get a $O(n \\log^2 n)$ solution, because one number will only added to a set at most $O(\\log n)$ times.\n\n### Storing the DSU by maintaining a clear tree structure / Online bridge finding in $O(\\alpha(n))$ on average  {data-toc-label=\"Storing the DSU by maintaining a clear tree structure / Online bridge finding\"}\n\nOne of the most powerful applications of DSU is that it allows you to store both as **compressed and uncompressed trees**.\nThe compressed form can be used for merging of trees and for the verification if two vertices are in the same tree, and the uncompressed form can be used - for example - to search for paths between two given vertices, or other traversals of the tree structure.\n\nIn the implementation this means that in addition to the compressed ancestor array `parent[]` we will need to keep the array of uncompressed ancestors `real_parent[]`.\nIt is trivial that maintaining this additional array will not worsen the complexity:\nchanges in it only occur when we merge two trees, and only in one element.\n\nOn the other hand when applied in practice, we often need to connect trees using a specified edge other that using the two root nodes.\nThis means that we have no other choice but to re-root one of the trees (make the ends of the edge the new root of the tree).\n\nAt first glance it seems that this re-rooting is very costly and will greatly worsen the time complexity.\nIndeed, for rooting a tree at vertex $v$ we must go from the vertex to the old root and change directions in `parent[]` and `real_parent[]` for all nodes on that path.\n\nHowever in reality it isn't so bad, we can just re-root the smaller of the two trees similar to the ideas in the previous sections, and get $O(\\log n)$ on average.\n\nMore details (including proof of the time complexity) can be found in the article [Finding Bridges Online](../graph/bridge-searching-online.md).\n\n## Historical retrospective\n\nThe data structure DSU has been known for a long time.\n\nThis way of storing this structure in the form **of a forest of trees** was apparently first described by Galler and Fisher in 1964 (Galler, Fisher, \"An Improved Equivalence Algorithm), however the complete analysis of the time complexity was conducted much later.\n\nThe optimizations path compression and Union by rank has been developed by McIlroy and Morris, and independently of them also by Tritter.\n\nHopcroft and Ullman showed in 1973 the time complexity $O(\\log^\\star n)$ (Hopcroft, Ullman \"Set-merging algorithms\") - here $\\log^\\star$ is the **iterated logarithm** (this is a slow-growing function, but still not as slow as the inverse Ackermann function).\n\nFor the first time the evaluation of $O(\\alpha(n))$ was shown in 1975 (Tarjan \"Efficiency of a Good But Not Linear Set Union Algorithm\").\nLater in 1985 he, along with Leeuwen, published multiple complexity analyses for several different rank heuristics and ways of compressing the path (Tarjan, Leeuwen \"Worst-case Analysis of Set Union Algorithms\").\n\nFinally in 1989 Fredman and Sachs proved that in the adopted model of computation **any** algorithm for the disjoint set union problem has to work in at least $O(\\alpha(n))$ time on average (Fredman, Saks, \"The cell probe complexity of dynamic data structures\").\n\n## Problems\n\n* [TIMUS - Anansi's Cobweb](http://acm.timus.ru/problem.aspx?space=1&num=1671)\n* [Codeforces - Roads not only in Berland](http://codeforces.com/contest/25/problem/D)\n* [TIMUS - Parity](http://acm.timus.ru/problem.aspx?space=1&num=1003)\n* [SPOJ - Strange Food Chain](http://www.spoj.com/problems/CHAIN/)\n* [SPOJ - COLORFUL ARRAY](https://www.spoj.com/problems/CLFLARR/)\n* [SPOJ - Consecutive Letters](https://www.spoj.com/problems/CONSEC/)\n* [Toph - Unbelievable Array](https://toph.co/p/unbelievable-array)\n* [HackerEarth - Lexicographically minimal string](https://www.hackerearth.com/practice/data-structures/disjoint-data-strutures/basics-of-disjoint-data-structures/practice-problems/algorithm/lexicographically-minimal-string-6edc1406/description/)\n* [HackerEarth - Fight in Ninja World](https://www.hackerearth.com/practice/algorithms/graphs/breadth-first-search/practice-problems/algorithm/containers-of-choclates-1/)\n\n", "problem_ids": ["25_D"], "title": "Disjoint Set Union"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: fenwick_tree\n---\n\n# Fenwick Tree\n\nLet, $f$ be some group operation (binary associative function over a set with identity element and inverse elements) and $A$ be an array of integers of length $N$.\n\nFenwick tree is a data structure which:\n\n* calculates the value of function $f$ in the given range $[l, r]$ (i.e. $f(A_l, A_{l+1}, \\dots, A_r)$) in $O(\\log N)$ time;\n* updates the value of an element of $A$ in $O(\\log N)$ time;\n* requires $O(N)$ memory, or in other words, exactly the same memory required for $A$;\n* is easy to use and code, especially, in the case of multidimensional arrays.\n\nThe most common application of Fenwick tree is _calculating the sum of a range_ (i.e. using addition over the set of integers $\\mathbb{Z}$: $f(A_1, A_2, \\dots, A_k) = A_1 + A_2 + \\dots + A_k$).\n\nFenwick tree is also called **Binary Indexed Tree**, or just **BIT** abbreviated.\n\nFenwick tree was first described in a paper titled \"A new data structure for cumulative frequency tables\" (Peter M. Fenwick, 1994).\n\n## Description\n\n### Overview\n\nFor the sake of simplicity, we will assume that function $f$ is just a *sum function*.\n\nGiven an array of integers $A[0 \\dots N-1]$.\nA Fenwick tree is just an array $T[0 \\dots N-1]$, where each of its elements is equal to the sum of elements of $A$ in some range $[g(i), i]$:\n\n$$T_i = \\sum_{j = g(i)}^{i}{A_j},$$\n\nwhere $g$ is some function that satisfies $0 \\le g(i) \\le i$.\nWe will define the function in the next few paragraphs.\n\nThe data structure is called tree, because there is a nice representation of the data structure as tree, although we don't need to model an actual tree with nodes and edges.\nWe will only need to maintain the array $T$ to handle all queries.\n\n**Note:** The Fenwick tree presented here uses zero-based indexing.\nMany people will actually use a version of the Fenwick tree that uses one-based indexing.\nTherefore you will also find an alternative implementation using one-based indexing in the implementation section.\nBoth versions are equivalent in terms of time and memory complexity.\n\nNow we can write some pseudo-code for the two operations mentioned above - get the sum of elements of $A$ in the range $[0, r]$ and update (increase) some element $A_i$:\n\n```python\ndef sum(int r):\n    res = 0\n    while (r >= 0):\n        res += t[r]\n        r = g(r) - 1\n    return res\n\ndef increase(int i, int delta):\n    for all j with g(j) <= i <= j:\n        t[j] += delta\n```\n\nThe function `sum` works as follows:\n\n1. first, it adds the sum of the range $[g(r), r]$ (i.e. $T[r]$) to the `result`\n2. then, it \"jumps\" to the range $[g(g(r)-1), g(r)-1]$, and adds this range's sum to the `result`\n3. and so on, until it \"jumps\" from $[0, g(g( \\dots g(r)-1 \\dots -1)-1)]$ to $[g(-1), -1]$; that is where the `sum` function stops jumping.\n\nThe function `increase` works with the same analogy, but \"jumps\" in the direction of increasing indices:\n\n1. sums of the ranges $[g(j), j]$ that satisfy the condition $g(j) \\le i \\le j$ are increased by `delta` , that is `t[j] += delta`. Therefore we updated all elements in $T$ that correspond to ranges in which $A_i$ lies.\n\nIt is obvious that the complexity of both `sum` and `increase` depend on the function $g$.\nThere are lots of ways to choose the function $g$, as long as $0 \\le g(i) \\le i$ for all $i$.\nFor instance the function $g(i) = i$ works, which results just in $T = A$, and therefore summation queries are slow.\nWe can also take the function $g(i) = 0$.\nThis will correspond to prefix sum arrays, which means that finding the sum of the range $[0, i]$ will only take constant time, but updates are slow.\nThe clever part of the Fenwick algorithm is, that there it uses a special definition of the function $g$ that can handle both operations in $O(\\log N)$ time.\n\n### Definition of $g(i)$ { data-toc-label='Definition of <script type=\"math/tex\">g(i)</script>' }\n\nThe computation of $g(i)$ is defined using the following simple operation:\nwe replace all trailing $1$ bits in the binary representation of $i$ with $0$ bits.\n\nIn other words, if the least significant digit of $i$ in binary is $0$, then $g(i) = i$.\nAnd otherwise the least significant digit is a $1$, and we take this $1$ and all other trailing $1$s and flip them.\n\nFor instance we get\n\n$$\\begin{align}\ng(11) = g(1011_2) = 1000_2 &= 8 \\\\\\\\\ng(12) = g(1100_2) = 1100_2 &= 12 \\\\\\\\\ng(13) = g(1101_2) = 1100_2 &= 12 \\\\\\\\\ng(14) = g(1110_2) = 1110_2 &= 14 \\\\\\\\\ng(15) = g(1111_2) = 0000_2 &= 0 \\\\\\\\\n\\end{align}$$\n\nThere exists a simple implementation using bitwise operations for the non-trivial operation described above:\n\n$$g(i) = i ~\\&~ (i+1),$$\n\nwhere $\\&$ is the bitwise AND operator. It is not hard to convince yourself that this solution does the same thing as the operation described above.\n\nNow, we just need to find a way to iterate over all $j$'s, such that $g(j) \\le i \\le j$.\n\nIt is easy to see that we can find all such $j$'s by starting with $i$ and flipping the last unset bit.\nWe will call this operation $h(j)$.\nFor example, for $i = 10$ we have:\n\n$$\\begin{align}\n10 &= 0001010_2 \\\\\\\\\nh(10) = 11 &= 0001011_2 \\\\\\\\\nh(11) = 15 &= 0001111_2 \\\\\\\\\nh(15) = 31 &= 0011111_2 \\\\\\\\\nh(31) = 63 &= 0111111_2 \\\\\\\\\n\\vdots &\n\\end{align}$$\n\nUnsurprisingly, there also exists a simple way to perform $h$ using bitwise operations:\n\n$$h(j) = j ~\\|~ (j+1),$$\n\nwhere $\\|$ is the bitwise OR operator.\n\nThe following image shows a possible interpretation of the Fenwick tree as tree.\nThe nodes of the tree show the ranges they cover.\n\n<center>![Binary Indexed Tree](binary_indexed_tree.png)</center>\n\n## Implementation\n\n### Finding sum in one-dimensional array\n\nHere we present an implementation of the Fenwick tree for sum queries and single updates.\n\nThe normal Fenwick tree can only answer sum queries of the type $[0, r]$ using `sum(int r)`, however we can also answer other queries of the type $[l, r]$ by computing two sums $[0, r]$ and $[0, l-1]$ and subtract them.\nThis is handled in the `sum(int l, int r)` method.\n\nAlso this implementation supports two constructors.\nYou can create a Fenwick tree initialized with zeros, or you can convert an existing array into the Fenwick form.\n\n\n```{.cpp file=fenwick_sum}\nstruct FenwickTree {\n    vector<int> bit;  // binary indexed tree\n    int n;\n\n    FenwickTree(int n) {\n        this->n = n;\n        bit.assign(n, 0);\n    }\n\n    FenwickTree(vector<int> const &a) : FenwickTree(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int r) {\n        int ret = 0;\n        for (; r >= 0; r = (r & (r + 1)) - 1)\n            ret += bit[r];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (; idx < n; idx = idx | (idx + 1))\n            bit[idx] += delta;\n    }\n};\n```\n\n### Linear construction\n\nThe above implementation requires $O(N \\log N)$ time.\nIt's possible to improve that to $O(N)$ time.\n\nThe idea is, that the number $a[i]$ at index $i$ will contribute to the range stored in $bit[i]$, and to all ranges that the index $i | (i + 1)$ contributes to.\nSo by adding the numbers in order, you only have to push the current sum further to the next range, where it will then get pushed further to the next range, and so on.\n\n```cpp\nFenwickTree(vector<int> const &a) : FenwickTree(a.size()){\n    for (int i = 0; i < n; i++) {\n        bit[i] += a[i];\n        int r = i | (i + 1);\n        if (r < n) bit[r] += bit[i];\n    }\n}\n```\n\n### Finding minimum of $[0, r]$ in one-dimensional array { data-toc-label='Finding minimum of <script type=\"math/tex\">[0, r]</script> in one-dimensional array' }\n\nIt is obvious that there is no easy way of finding minimum of range $[l, r]$ using Fenwick tree, as Fenwick tree can only answer queries of type $[0, r]$.\nAdditionally, each time a value is `update`'d, the new value has to be smaller than the current value.\nBoth significant limitations are because the $min$ operation together with the set of integers doesn't form a group, as there are no inverse elements.\n\n```{.cpp file=fenwick_min}\nstruct FenwickTreeMin {\n    vector<int> bit;\n    int n;\n    const int INF = (int)1e9;\n\n    FenwickTreeMin(int n) {\n        this->n = n;\n        bit.assign(n, INF);\n    }\n\n    FenwickTreeMin(vector<int> a) : FenwickTreeMin(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            update(i, a[i]);\n    }\n\n    int getmin(int r) {\n        int ret = INF;\n        for (; r >= 0; r = (r & (r + 1)) - 1)\n            ret = min(ret, bit[r]);\n        return ret;\n    }\n\n    void update(int idx, int val) {\n        for (; idx < n; idx = idx | (idx + 1))\n            bit[idx] = min(bit[idx], val);\n    }\n};\n```\n\nNote: it is possible to implement a Fenwick tree that can handle arbitrary minimum range queries and arbitrary updates.\nThe paper [Efficient Range Minimum Queries using Binary Indexed Trees](http://ioinformatics.org/oi/pdf/v9_2015_39_44.pdf) describes such an approach.\nHowever with that approach you need to maintain a second binary indexed trees over the data, with a slightly different structure, since you one tree is not enough to store the values of all elements in the array.\nThe implementation is also a lot harder compared to the normal implementation for sums.\n\n### Finding sum in two-dimensional array\n\nAs claimed before, it is very easy to implement Fenwick Tree for multidimensional array.\n\n```cpp\nstruct FenwickTree2D {\n    vector<vector<int>> bit;\n    int n, m;\n\n    // init(...) { ... }\n\n    int sum(int x, int y) {\n        int ret = 0;\n        for (int i = x; i >= 0; i = (i & (i + 1)) - 1)\n            for (int j = y; j >= 0; j = (j & (j + 1)) - 1)\n                ret += bit[i][j];\n        return ret;\n    }\n\n    void add(int x, int y, int delta) {\n        for (int i = x; i < n; i = i | (i + 1))\n            for (int j = y; j < m; j = j | (j + 1))\n                bit[i][j] += delta;\n    }\n};\n```\n\n### One-based indexing approach\n\nFor this approach we change the requirements and definition for $T[]$ and $g()$ a little bit.\nWe want $T[i]$ to store the sum of $[g(i)+1; i]$.\nThis changes the implementation a little bit, and allows for a similar nice definition for $g(i)$:\n\n```python\ndef sum(int r):\n    res = 0\n    while (r > 0):\n        res += t[r]\n        r = g(r)\n    return res\n\ndef increase(int i, int delta):\n    for all j with g(j) < i <= j:\n        t[j] += delta\n```\n\nThe computation of $g(i)$ is defined as:\ntoggling of the last set $1$ bit in the binary representation of $i$.\n\n$$\\begin{align}\ng(7) = g(111_2) = 110_2 &= 6 \\\\\\\\\ng(6) = g(110_2) = 100_2 &= 4 \\\\\\\\\ng(4) = g(100_2) = 000_2 &= 0 \\\\\\\\\n\\end{align}$$\n\nThe last set bit can be extracted using $i ~\\&~ (-i)$, so the operation can be expressed as:\n\n$$g(i) = i - (i ~\\&~ (-i)).$$\n\nAnd it's not hard to see, that you need to change all values $T[j]$ in the sequence $i,~ h(i),~ h(h(i)),~ \\dots$ when you want to update $A[j]$, where $h(i)$ is defined as:\n\n$$h(i) = i + (i ~\\&~ (-i)).$$\n\nAs you can see, the main benefit of this approach is that the binary operations complement each other very nicely.\n\nThe following implementation can be used like the other implementations, however it uses one-based indexing internally.\n\n```{.cpp file=fenwick_sum_onebased}\nstruct FenwickTreeOneBasedIndexing {\n    vector<int> bit;  // binary indexed tree\n    int n;\n\n    FenwickTreeOneBasedIndexing(int n) {\n        this->n = n + 1;\n        bit.assign(n + 1, 0);\n    }\n\n    FenwickTreeOneBasedIndexing(vector<int> a)\n        : FenwickTreeOneBasedIndexing(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int idx) {\n        int ret = 0;\n        for (++idx; idx > 0; idx -= idx & -idx)\n            ret += bit[idx];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (++idx; idx < n; idx += idx & -idx)\n            bit[idx] += delta;\n    }\n};\n```\n\n## Range operations\n\nA Fenwick tree can support the following range operations:\n\n1. Point Update and Range Query\n2. Range Update and Point Query\n3. Range Update and Range Query\n\n### 1. Point Update and Range Query\n\nThis is just the ordinary Fenwick tree as explained above.\n\n### 2. Range Update and Point Query\n\nUsing simple tricks we can also do the reverse operations: increasing ranges and querying for single values.\n\nLet the Fenwick tree be initialized with zeros.\nSuppose that we want to increment the interval $[l, r]$ by $x$.\nWe make two point update operations on Fenwick tree which are `add(l, x)` and `add(r+1, -x)`.\n\nIf we want to get the value of $A[i]$, we just need to take the prefix sum using the ordinary range sum method.\nTo see why this is true, we can just focus on the previous increment operation again.\nIf $i < l$, then the two update operations have no effect on the query and we get the sum $0$.\nIf $i \\in [l, r]$, then we get the answer $x$ because of the first update operation.\nAnd if $i > r$, then the second update operation will cancel the effect of first one.\n\nThe following implementation uses one-based indexing.\n\n```cpp\nvoid add(int idx, int val) {\n    for (++idx; idx < n; idx += idx & -idx)\n        bit[idx] += val;\n}\n\nvoid range_add(int l, int r, int val) {\n    add(l, val);\n    add(r + 1, -val);\n}\n\nint point_query(int idx) {\n    int ret = 0;\n    for (++idx; idx > 0; idx -= idx & -idx)\n        ret += bit[idx];\n    return ret;\n}\n```\n\nNote: of course it is also possible to increase a single point $A[i]$ with `range_add(i, i, val)`.\n\n### 3. Range Updates and Range Queries\n\nTo support both range updates and range queries we will use two BITs namely $B_1[]$ and $B_2[]$, initialized with zeros.\n\nSuppose that we want to increment the interval $[l, r]$ by the value $x$.\nSimilarly as in the previous method, we perform two point updates on $B_1$: `add(B1, l, x)` and `add(B1, r+1, -x)`.\nAnd we also update $B_2$. The details will be explained later.\n\n```python\ndef range_add(l, r, x):\n    add(B1, l, x)\n    add(B1, r+1, -x)\n    add(B2, l, x*(l-1))\n    add(B2, r+1, -x*r))\n```\nAfter the range update $(l, r, x)$ the range sum query should return the following values:\n\n$$\nsum[0, i]=\n\\begin{cases}\n0 & i < l \\\\\\\\\nx \\cdot (i-(l-1)) & l \\le i \\le r \\\\\\\\\nx \\cdot (r-l+1) & i > r \\\\\\\\\n\\end{cases}\n$$\n\nWe can write the range sum as difference of two terms, where we use $B_1$ for first term and $B_2$ for second term.\nThe difference of the queries will give us prefix sum over $[0, i]$.\n\n$$\\begin{align}\nsum[0, i] &= sum(B_1, i) \\cdot i - sum(B_2, i) \\\\\\\\\n&= \\begin{cases}\n0 \\cdot i - 0 & i < l\\\\\\\\\nx \\cdot i - x \\cdot (l-1) & l \\le i \\le r \\\\\\\\\n0 \\cdot i - (x \\cdot (l-1) - x \\cdot r) & i > r \\\\\\\\\n\\end{cases}\n\\end{align}\n$$\n\nThe last expression is exactly equal to the required terms.\nThus we can use $B_2$ for shaving off extra terms when we multiply $B_1[i]\\times i$.\n\nWe can find arbitrary range sums by computing the prefix sums for $l-1$ and $r$ and taking the difference of them again.\n\n```python\ndef add(b, idx, x):\n    while idx <= N:\n        b[idx] += x\n        idx += idx & -idx\n\ndef range_add(l,r,x):\n    add(B1, l, x)\n    add(B1, r+1, -x)\n    add(B2, l, x*(l-1))\n    add(B2, r+1, -x*r)\n\ndef sum(b, idx):\n    total = 0\n    while idx > 0:\n        total += b[idx]\n        idx -= idx & -idx\n    return total\n\ndef prefix_sum(idx):\n    return sum(B1, idx)*idx -  sum(B2, idx)\n\ndef range_sum(l, r):\n    return prefix_sum(r) - prefix_sum(l-1)\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: fenwick_tree\n---\n\n# Fenwick Tree\n\nLet, $f$ be some group operation (binary associative function over a set with identity element and inverse elements) and $A$ be an array of integers of length $N$.\n\nFenwick tree is a data structure which:\n\n* calculates the value of function $f$ in the given range $[l, r]$ (i.e. $f(A_l, A_{l+1}, \\dots, A_r)$) in $O(\\log N)$ time;\n* updates the value of an element of $A$ in $O(\\log N)$ time;\n* requires $O(N)$ memory, or in other words, exactly the same memory required for $A$;\n* is easy to use and code, especially, in the case of multidimensional arrays.\n\nThe most common application of Fenwick tree is _calculating the sum of a range_ (i.e. using addition over the set of integers $\\mathbb{Z}$: $f(A_1, A_2, \\dots, A_k) = A_1 + A_2 + \\dots + A_k$).\n\nFenwick tree is also called **Binary Indexed Tree**, or just **BIT** abbreviated.\n\nFenwick tree was first described in a paper titled \"A new data structure for cumulative frequency tables\" (Peter M. Fenwick, 1994).\n\n## Description\n\n### Overview\n\nFor the sake of simplicity, we will assume that function $f$ is just a *sum function*.\n\nGiven an array of integers $A[0 \\dots N-1]$.\nA Fenwick tree is just an array $T[0 \\dots N-1]$, where each of its elements is equal to the sum of elements of $A$ in some range $[g(i), i]$:\n\n$$T_i = \\sum_{j = g(i)}^{i}{A_j},$$\n\nwhere $g$ is some function that satisfies $0 \\le g(i) \\le i$.\nWe will define the function in the next few paragraphs.\n\nThe data structure is called tree, because there is a nice representation of the data structure as tree, although we don't need to model an actual tree with nodes and edges.\nWe will only need to maintain the array $T$ to handle all queries.\n\n**Note:** The Fenwick tree presented here uses zero-based indexing.\nMany people will actually use a version of the Fenwick tree that uses one-based indexing.\nTherefore you will also find an alternative implementation using one-based indexing in the implementation section.\nBoth versions are equivalent in terms of time and memory complexity.\n\nNow we can write some pseudo-code for the two operations mentioned above - get the sum of elements of $A$ in the range $[0, r]$ and update (increase) some element $A_i$:\n\n```python\ndef sum(int r):\n    res = 0\n    while (r >= 0):\n        res += t[r]\n        r = g(r) - 1\n    return res\n\ndef increase(int i, int delta):\n    for all j with g(j) <= i <= j:\n        t[j] += delta\n```\n\nThe function `sum` works as follows:\n\n1. first, it adds the sum of the range $[g(r), r]$ (i.e. $T[r]$) to the `result`\n2. then, it \"jumps\" to the range $[g(g(r)-1), g(r)-1]$, and adds this range's sum to the `result`\n3. and so on, until it \"jumps\" from $[0, g(g( \\dots g(r)-1 \\dots -1)-1)]$ to $[g(-1), -1]$; that is where the `sum` function stops jumping.\n\nThe function `increase` works with the same analogy, but \"jumps\" in the direction of increasing indices:\n\n1. sums of the ranges $[g(j), j]$ that satisfy the condition $g(j) \\le i \\le j$ are increased by `delta` , that is `t[j] += delta`. Therefore we updated all elements in $T$ that correspond to ranges in which $A_i$ lies.\n\nIt is obvious that the complexity of both `sum` and `increase` depend on the function $g$.\nThere are lots of ways to choose the function $g$, as long as $0 \\le g(i) \\le i$ for all $i$.\nFor instance the function $g(i) = i$ works, which results just in $T = A$, and therefore summation queries are slow.\nWe can also take the function $g(i) = 0$.\nThis will correspond to prefix sum arrays, which means that finding the sum of the range $[0, i]$ will only take constant time, but updates are slow.\nThe clever part of the Fenwick algorithm is, that there it uses a special definition of the function $g$ that can handle both operations in $O(\\log N)$ time.\n\n### Definition of $g(i)$ { data-toc-label='Definition of <script type=\"math/tex\">g(i)</script>' }\n\nThe computation of $g(i)$ is defined using the following simple operation:\nwe replace all trailing $1$ bits in the binary representation of $i$ with $0$ bits.\n\nIn other words, if the least significant digit of $i$ in binary is $0$, then $g(i) = i$.\nAnd otherwise the least significant digit is a $1$, and we take this $1$ and all other trailing $1$s and flip them.\n\nFor instance we get\n\n$$\\begin{align}\ng(11) = g(1011_2) = 1000_2 &= 8 \\\\\\\\\ng(12) = g(1100_2) = 1100_2 &= 12 \\\\\\\\\ng(13) = g(1101_2) = 1100_2 &= 12 \\\\\\\\\ng(14) = g(1110_2) = 1110_2 &= 14 \\\\\\\\\ng(15) = g(1111_2) = 0000_2 &= 0 \\\\\\\\\n\\end{align}$$\n\nThere exists a simple implementation using bitwise operations for the non-trivial operation described above:\n\n$$g(i) = i ~\\&~ (i+1),$$\n\nwhere $\\&$ is the bitwise AND operator. It is not hard to convince yourself that this solution does the same thing as the operation described above.\n\nNow, we just need to find a way to iterate over all $j$'s, such that $g(j) \\le i \\le j$.\n\nIt is easy to see that we can find all such $j$'s by starting with $i$ and flipping the last unset bit.\nWe will call this operation $h(j)$.\nFor example, for $i = 10$ we have:\n\n$$\\begin{align}\n10 &= 0001010_2 \\\\\\\\\nh(10) = 11 &= 0001011_2 \\\\\\\\\nh(11) = 15 &= 0001111_2 \\\\\\\\\nh(15) = 31 &= 0011111_2 \\\\\\\\\nh(31) = 63 &= 0111111_2 \\\\\\\\\n\\vdots &\n\\end{align}$$\n\nUnsurprisingly, there also exists a simple way to perform $h$ using bitwise operations:\n\n$$h(j) = j ~\\|~ (j+1),$$\n\nwhere $\\|$ is the bitwise OR operator.\n\nThe following image shows a possible interpretation of the Fenwick tree as tree.\nThe nodes of the tree show the ranges they cover.\n\n<center>![Binary Indexed Tree](binary_indexed_tree.png)</center>\n\n## Implementation\n\n### Finding sum in one-dimensional array\n\nHere we present an implementation of the Fenwick tree for sum queries and single updates.\n\nThe normal Fenwick tree can only answer sum queries of the type $[0, r]$ using `sum(int r)`, however we can also answer other queries of the type $[l, r]$ by computing two sums $[0, r]$ and $[0, l-1]$ and subtract them.\nThis is handled in the `sum(int l, int r)` method.\n\nAlso this implementation supports two constructors.\nYou can create a Fenwick tree initialized with zeros, or you can convert an existing array into the Fenwick form.\n\n\n```{.cpp file=fenwick_sum}\nstruct FenwickTree {\n    vector<int> bit;  // binary indexed tree\n    int n;\n\n    FenwickTree(int n) {\n        this->n = n;\n        bit.assign(n, 0);\n    }\n\n    FenwickTree(vector<int> const &a) : FenwickTree(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int r) {\n        int ret = 0;\n        for (; r >= 0; r = (r & (r + 1)) - 1)\n            ret += bit[r];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (; idx < n; idx = idx | (idx + 1))\n            bit[idx] += delta;\n    }\n};\n```\n\n### Linear construction\n\nThe above implementation requires $O(N \\log N)$ time.\nIt's possible to improve that to $O(N)$ time.\n\nThe idea is, that the number $a[i]$ at index $i$ will contribute to the range stored in $bit[i]$, and to all ranges that the index $i | (i + 1)$ contributes to.\nSo by adding the numbers in order, you only have to push the current sum further to the next range, where it will then get pushed further to the next range, and so on.\n\n```cpp\nFenwickTree(vector<int> const &a) : FenwickTree(a.size()){\n    for (int i = 0; i < n; i++) {\n        bit[i] += a[i];\n        int r = i | (i + 1);\n        if (r < n) bit[r] += bit[i];\n    }\n}\n```\n\n### Finding minimum of $[0, r]$ in one-dimensional array { data-toc-label='Finding minimum of <script type=\"math/tex\">[0, r]</script> in one-dimensional array' }\n\nIt is obvious that there is no easy way of finding minimum of range $[l, r]$ using Fenwick tree, as Fenwick tree can only answer queries of type $[0, r]$.\nAdditionally, each time a value is `update`'d, the new value has to be smaller than the current value.\nBoth significant limitations are because the $min$ operation together with the set of integers doesn't form a group, as there are no inverse elements.\n\n```{.cpp file=fenwick_min}\nstruct FenwickTreeMin {\n    vector<int> bit;\n    int n;\n    const int INF = (int)1e9;\n\n    FenwickTreeMin(int n) {\n        this->n = n;\n        bit.assign(n, INF);\n    }\n\n    FenwickTreeMin(vector<int> a) : FenwickTreeMin(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            update(i, a[i]);\n    }\n\n    int getmin(int r) {\n        int ret = INF;\n        for (; r >= 0; r = (r & (r + 1)) - 1)\n            ret = min(ret, bit[r]);\n        return ret;\n    }\n\n    void update(int idx, int val) {\n        for (; idx < n; idx = idx | (idx + 1))\n            bit[idx] = min(bit[idx], val);\n    }\n};\n```\n\nNote: it is possible to implement a Fenwick tree that can handle arbitrary minimum range queries and arbitrary updates.\nThe paper [Efficient Range Minimum Queries using Binary Indexed Trees](http://ioinformatics.org/oi/pdf/v9_2015_39_44.pdf) describes such an approach.\nHowever with that approach you need to maintain a second binary indexed trees over the data, with a slightly different structure, since you one tree is not enough to store the values of all elements in the array.\nThe implementation is also a lot harder compared to the normal implementation for sums.\n\n### Finding sum in two-dimensional array\n\nAs claimed before, it is very easy to implement Fenwick Tree for multidimensional array.\n\n```cpp\nstruct FenwickTree2D {\n    vector<vector<int>> bit;\n    int n, m;\n\n    // init(...) { ... }\n\n    int sum(int x, int y) {\n        int ret = 0;\n        for (int i = x; i >= 0; i = (i & (i + 1)) - 1)\n            for (int j = y; j >= 0; j = (j & (j + 1)) - 1)\n                ret += bit[i][j];\n        return ret;\n    }\n\n    void add(int x, int y, int delta) {\n        for (int i = x; i < n; i = i | (i + 1))\n            for (int j = y; j < m; j = j | (j + 1))\n                bit[i][j] += delta;\n    }\n};\n```\n\n### One-based indexing approach\n\nFor this approach we change the requirements and definition for $T[]$ and $g()$ a little bit.\nWe want $T[i]$ to store the sum of $[g(i)+1; i]$.\nThis changes the implementation a little bit, and allows for a similar nice definition for $g(i)$:\n\n```python\ndef sum(int r):\n    res = 0\n    while (r > 0):\n        res += t[r]\n        r = g(r)\n    return res\n\ndef increase(int i, int delta):\n    for all j with g(j) < i <= j:\n        t[j] += delta\n```\n\nThe computation of $g(i)$ is defined as:\ntoggling of the last set $1$ bit in the binary representation of $i$.\n\n$$\\begin{align}\ng(7) = g(111_2) = 110_2 &= 6 \\\\\\\\\ng(6) = g(110_2) = 100_2 &= 4 \\\\\\\\\ng(4) = g(100_2) = 000_2 &= 0 \\\\\\\\\n\\end{align}$$\n\nThe last set bit can be extracted using $i ~\\&~ (-i)$, so the operation can be expressed as:\n\n$$g(i) = i - (i ~\\&~ (-i)).$$\n\nAnd it's not hard to see, that you need to change all values $T[j]$ in the sequence $i,~ h(i),~ h(h(i)),~ \\dots$ when you want to update $A[j]$, where $h(i)$ is defined as:\n\n$$h(i) = i + (i ~\\&~ (-i)).$$\n\nAs you can see, the main benefit of this approach is that the binary operations complement each other very nicely.\n\nThe following implementation can be used like the other implementations, however it uses one-based indexing internally.\n\n```{.cpp file=fenwick_sum_onebased}\nstruct FenwickTreeOneBasedIndexing {\n    vector<int> bit;  // binary indexed tree\n    int n;\n\n    FenwickTreeOneBasedIndexing(int n) {\n        this->n = n + 1;\n        bit.assign(n + 1, 0);\n    }\n\n    FenwickTreeOneBasedIndexing(vector<int> a)\n        : FenwickTreeOneBasedIndexing(a.size()) {\n        for (size_t i = 0; i < a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int idx) {\n        int ret = 0;\n        for (++idx; idx > 0; idx -= idx & -idx)\n            ret += bit[idx];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (++idx; idx < n; idx += idx & -idx)\n            bit[idx] += delta;\n    }\n};\n```\n\n## Range operations\n\nA Fenwick tree can support the following range operations:\n\n1. Point Update and Range Query\n2. Range Update and Point Query\n3. Range Update and Range Query\n\n### 1. Point Update and Range Query\n\nThis is just the ordinary Fenwick tree as explained above.\n\n### 2. Range Update and Point Query\n\nUsing simple tricks we can also do the reverse operations: increasing ranges and querying for single values.\n\nLet the Fenwick tree be initialized with zeros.\nSuppose that we want to increment the interval $[l, r]$ by $x$.\nWe make two point update operations on Fenwick tree which are `add(l, x)` and `add(r+1, -x)`.\n\nIf we want to get the value of $A[i]$, we just need to take the prefix sum using the ordinary range sum method.\nTo see why this is true, we can just focus on the previous increment operation again.\nIf $i < l$, then the two update operations have no effect on the query and we get the sum $0$.\nIf $i \\in [l, r]$, then we get the answer $x$ because of the first update operation.\nAnd if $i > r$, then the second update operation will cancel the effect of first one.\n\nThe following implementation uses one-based indexing.\n\n```cpp\nvoid add(int idx, int val) {\n    for (++idx; idx < n; idx += idx & -idx)\n        bit[idx] += val;\n}\n\nvoid range_add(int l, int r, int val) {\n    add(l, val);\n    add(r + 1, -val);\n}\n\nint point_query(int idx) {\n    int ret = 0;\n    for (++idx; idx > 0; idx -= idx & -idx)\n        ret += bit[idx];\n    return ret;\n}\n```\n\nNote: of course it is also possible to increase a single point $A[i]$ with `range_add(i, i, val)`.\n\n### 3. Range Updates and Range Queries\n\nTo support both range updates and range queries we will use two BITs namely $B_1[]$ and $B_2[]$, initialized with zeros.\n\nSuppose that we want to increment the interval $[l, r]$ by the value $x$.\nSimilarly as in the previous method, we perform two point updates on $B_1$: `add(B1, l, x)` and `add(B1, r+1, -x)`.\nAnd we also update $B_2$. The details will be explained later.\n\n```python\ndef range_add(l, r, x):\n    add(B1, l, x)\n    add(B1, r+1, -x)\n    add(B2, l, x*(l-1))\n    add(B2, r+1, -x*r))\n```\nAfter the range update $(l, r, x)$ the range sum query should return the following values:\n\n$$\nsum[0, i]=\n\\begin{cases}\n0 & i < l \\\\\\\\\nx \\cdot (i-(l-1)) & l \\le i \\le r \\\\\\\\\nx \\cdot (r-l+1) & i > r \\\\\\\\\n\\end{cases}\n$$\n\nWe can write the range sum as difference of two terms, where we use $B_1$ for first term and $B_2$ for second term.\nThe difference of the queries will give us prefix sum over $[0, i]$.\n\n$$\\begin{align}\nsum[0, i] &= sum(B_1, i) \\cdot i - sum(B_2, i) \\\\\\\\\n&= \\begin{cases}\n0 \\cdot i - 0 & i < l\\\\\\\\\nx \\cdot i - x \\cdot (l-1) & l \\le i \\le r \\\\\\\\\n0 \\cdot i - (x \\cdot (l-1) - x \\cdot r) & i > r \\\\\\\\\n\\end{cases}\n\\end{align}\n$$\n\nThe last expression is exactly equal to the required terms.\nThus we can use $B_2$ for shaving off extra terms when we multiply $B_1[i]\\times i$.\n\nWe can find arbitrary range sums by computing the prefix sums for $l-1$ and $r$ and taking the difference of them again.\n\n```python\ndef add(b, idx, x):\n    while idx <= N:\n        b[idx] += x\n        idx += idx & -idx\n\ndef range_add(l,r,x):\n    add(B1, l, x)\n    add(B1, r+1, -x)\n    add(B2, l, x*(l-1))\n    add(B2, r+1, -x*r)\n\ndef sum(b, idx):\n    total = 0\n    while idx > 0:\n        total += b[idx]\n        idx -= idx & -idx\n    return total\n\ndef prefix_sum(idx):\n    return sum(B1, idx)*idx -  sum(B2, idx)\n\ndef range_sum(l, r):\n    return prefix_sum(r) - prefix_sum(l-1)\n```\n\n## Practice Problems\n\n* [UVA 12086 - Potentiometers](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3238)\n* [LOJ 1112 - Curious Robin Hood](http://www.lightoj.com/volume_showproblem.php?problem=1112)\n* [LOJ 1266 - Points in Rectangle](http://www.lightoj.com/volume_showproblem.php?problem=1266 \"2D Fenwick Tree\")\n* [Codechef - SPREAD](http://www.codechef.com/problems/SPREAD)\n* [SPOJ - CTRICK](http://www.spoj.com/problems/CTRICK/)\n* [SPOJ - MATSUM](http://www.spoj.com/problems/MATSUM/)\n* [SPOJ - DQUERY](http://www.spoj.com/problems/DQUERY/)\n* [SPOJ - NKTEAM](http://www.spoj.com/problems/NKTEAM/)\n* [SPOJ - YODANESS](http://www.spoj.com/problems/YODANESS/)\n* [SRM 310 - FloatingMedian](https://community.topcoder.com/stat?c=problem_statement&pm=6551&rd=9990)\n* [SPOJ - Ada and Behives](http://www.spoj.com/problems/ADABEHIVE/)\n* [Hackerearth - Counting in Byteland](https://www.hackerearth.com/practice/data-structures/advanced-data-structures/fenwick-binary-indexed-trees/practice-problems/algorithm/counting-in-byteland/)\n* [DevSkill - Shan and String (archived)](http://web.archive.org/web/20210322010617/https://devskill.com/CodingProblems/ViewProblem/300)\n* [Codeforces - Little Artem and Time Machine](http://codeforces.com/contest/669/problem/E)\n* [Codeforces - Hanoi Factory](http://codeforces.com/contest/777/problem/E)\n* [SPOJ - Tulip and Numbers](http://www.spoj.com/problems/TULIPNUM/)\n* [SPOJ - SUMSUM](http://www.spoj.com/problems/SUMSUM/)\n* [SPOJ - Sabir and Gifts](http://www.spoj.com/problems/SGIFT/)\n* [SPOJ - The Permutation Game Again](http://www.spoj.com/problems/TPGA/)\n* [SPOJ - Zig when you Zag](http://www.spoj.com/problems/ZIGZAG2/)\n* [SPOJ - Cryon](http://www.spoj.com/problems/CRAYON/)\n* [SPOJ - Weird Points](http://www.spoj.com/problems/DCEPC705/)\n* [SPOJ - Its a Murder](http://www.spoj.com/problems/DCEPC206/)\n* [SPOJ - Bored of Suffixes and Prefixes](http://www.spoj.com/problems/KOPC12G/)\n* [SPOJ - Mega Inversions](http://www.spoj.com/problems/TRIPINV/)\n* [Codeforces - Subsequences](http://codeforces.com/contest/597/problem/C)\n* [Codeforces - Ball](http://codeforces.com/contest/12/problem/D)\n* [GYM - The Kamphaeng Phet's Chedis](http://codeforces.com/gym/101047/problem/J)\n* [Codeforces - Garlands](http://codeforces.com/contest/707/problem/E)\n* [Codeforces - Inversions after Shuffle](http://codeforces.com/contest/749/problem/E)\n* [GYM - Cairo Market](http://codeforces.com/problemset/gymProblem/101055/D)\n* [Codeforces - Goodbye Souvenir](http://codeforces.com/contest/849/problem/E)\n* [SPOJ - Ada and Species](http://www.spoj.com/problems/ADACABAA/)\n* [Codeforces - Thor](https://codeforces.com/problemset/problem/704/A)\n* [CSES - Forest Queries II](https://cses.fi/problemset/task/1739/)\n* [Latin American Regionals 2017 - Fundraising](http://matcomgrader.com/problem/9346/fundraising/)\n\n## Other sources\n\n* [Fenwick tree on Wikipedia](http://en.wikipedia.org/wiki/Fenwick_tree)\n* [Binary indexed trees tutorial on TopCoder](https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/)\n* [Range updates and queries ](https://programmingcontests.quora.com/Tutorial-Range-Updates-in-Fenwick-Tree)\n", "problem_ids": ["669_E", "777_E", "597_C", "12_D", "707_E", "849_E", "704_A"], "title": "Fenwick Tree"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: suffix_automata\n---\n\n# Suffix Automaton\n\nA **suffix automaton** is a powerful data structure that allows solving many string-related problems. \n\nFor example, you can search for all occurrences of one string in another, or count the amount of different substrings of a given string.\nBoth tasks can be solved in linear time with the help of a suffix automaton.\n\nIntuitively a suffix automaton can be understood as a compressed form of **all substrings** of a given string.\nAn impressive fact is, that the suffix automaton contains all this information in a highly compressed form.\nFor a string of length $n$ it only requires $O(n)$ memory.\nMoreover, it can also be built in $O(n)$ time (if we consider the size $k$ of the alphabet as a constant), otherwise both the memory and the time complexity will be $O(n \\log k)$.\n\nThe linearity of the size of the suffix automaton was first discovered in 1983 by Blumer et al., and in 1985 the first linear algorithms for the construction was presented by Crochemore and Blumer.\n\n## Definition of a suffix automaton\n\nA suffix automaton for a given string $s$ is a minimal **DFA** (deterministic finite automaton / deterministic finite state machine) that accepts all the suffixes of the string $s$.\n\nIn other words:\n\n -  A suffix automaton is an oriented acyclic graph.\n    The vertices are called **states**, and the edges are called **transitions** between states.\n -  One of the states $t_0$ is the **initial state**, and it must be the source of the graph (all other states are reachable from $t_0$).\n -  Each **transition** is labeled with some character.\n    All transitions originating from a state must have **different** labels.\n -  One or multiple states are marked as **terminal states**.\n    If we start from the initial state $t_0$ and move along transitions to a terminal state, then the labels of the passed transitions must spell one of the suffixes of the string $s$.\n    Each of the suffixes of $s$ must be spellable using a path from $t_0$ to a terminal state.\n -  The suffix automaton contains the minimum number of vertices among all automata satisfying the conditions described above.\n\n### Substring property\n\nThe simplest and most important property of a suffix automaton is, that it contains information about all substrings of the string $s$.\nAny path starting at the initial state $t_0$, if we write down the labels of the transitions, forms a **substring** of $s$.\nAnd conversely every substring of $s$ corresponds to a certain path starting at $t_0$.\n\nIn order to simplify the explanations, we will say that the substring **corresponds** to that path (starting at $t_0$ and the labels spell the substring).\nAnd conversely we say that any path **corresponds** to the string spelled by its labels.\n\nOne or multiple paths can lead to a state.\nThus, we will say that a state **corresponds** to the set of strings, which correspond to these paths.\n\n### Examples of constructed suffix automata\n\nHere we will show some examples of suffix automata for several simple strings.\n\nWe will denote the initial state with blue and the terminal states with green.\n\nFor the string $s =~ \\text{\"\"}$:\n\n![Suffix automaton for \"\"](SA.png)\n\nFor the string $s =~ \\text{\"a\"}$:\n\n![Suffix automaton for \"a\"](SAa.png)\n\nFor the string $s =~ \\text{\"aa\"}$:\n\n![Suffix automaton for \"aa\"](SAaa.png)\n\nFor the string $s =~ \\text{\"ab\"}$:\n\n![Suffix automaton for \"ab\"](SAab.png)\n\nFor the string $s =~ \\text{\"aba\"}$:\n\n![Suffix automaton for \"aba\"](SAaba.png)\n\nFor the string $s =~ \\text{\"abb\"}$:\n\n![Suffix automaton for \"abb\"](SAabb.png)\n\nFor the string $s =~ \\text{\"abbb\"}$:\n\n![Suffix automaton for \"abbb\"](SAabbb.png)\n\n## Construction in linear time\n\nBefore we describe the algorithm to construct a suffix automaton in linear time, we need to introduce several new concepts and simple proofs, which will be very important in understanding the construction.\n\n### End positions $endpos$ {data-toc-label=\"End positions\"}\n\nConsider any non-empty substring $t$ of the string $s$.\nWe will denote with $endpos(t)$ the set of all positions in the string $s$, in which the occurrences of $t$ end. For instance, we have $endpos(\\text{\"bc\"}) = \\{2, 4\\}$ for the string $\\text{\"abcbc\"}$.\n\nWe will call two substrings $t_1$ and $t_2$ $endpos$-equivalent, if their ending sets coincide: $endpos(t_1) = endpos(t_2)$.\nThus all non-empty substrings of the string $s$ can be decomposed into several **equivalence classes** according to their sets $endpos$.\n\nIt turns out, that in a suffix machine $endpos$-equivalent substrings **correspond to the same state**.\nIn other words the number of states in a suffix automaton is equal to the number of equivalence classes among all substrings, plus the initial state.\nEach state of a suffix automaton corresponds to one or more substrings having the same value $endpos$.\n\nWe will later describe the construction algorithm using this assumption.\nWe will then see, that all the required properties of a suffix automaton, except for the minimality, are fulfilled.\nAnd the minimality follows from Nerode's theorem (which will not be proven in this article).\n\nWe can make some important observations concerning the values $endpos$:\n\n**Lemma 1**:\nTwo non-empty substrings $u$ and $w$ (with $length(u) \\le length(w)$) are $endpos$-equivalent, if and only if the string $u$ occurs in $s$ only in the form of a suffix of $w$.\n\nThe proof is obvious.\nIf $u$ and $w$ have the same $endpos$ values, then $u$ is a suffix of $w$ and appears only in the form of a suffix of $w$ in $s$.\nAnd if $u$ is a suffix of $w$ and appears only in the form as a suffix in $s$, then the values $endpos$ are equal by definition.\n\n**Lemma 2**:\nConsider two non-empty substrings $u$ and $w$ (with $length(u) \\le length(w)$).\nThen their sets $endpos$ either don't intersect at all, or $endpos(w)$ is a subset of $endpos(u)$.\nAnd it depends on if $u$ is a suffix of $w$ or not.\n\n$$\\begin{cases}\nendpos(w) \\subseteq endpos(u) & \\text{if } u \\text{ is a suffix of } w \\\\\\\\\nendpos(w) \\cap endpos(u) = \\emptyset & \\text{otherwise}\n\\end{cases}$$\n\nProof:\nIf the sets $endpos(u)$ and $endpos(w)$ have at least one common element, then the strings $u$ and $w$ both end in that position, i.e. $u$ is a suffix of $w$.\nBut then at every occurrence of $w$ also appears the substring $u$, which means that $endpos(w)$ is a subset of $endpos(u)$.\n\n**Lemma 3**:\nConsider an $endpos$-equivalence class.\nSort all the substrings in this class by decreasing length.\nThen in the resulting sequence each substring will be one shorter than the previous one, and at the same time will be a suffix of the previous one.\nIn other words, in a same equivalence class, the shorter substrings are actually suffixes of the longer substrings, and they take all possible lengths in a certain interval $[x; y]$.\n\nProof:\nFix some $endpos$-equivalence class.\nIf it only contains one string, then the lemma is obviously true.\nNow let's say that the number of strings in the class is greater than one.\n\nAccording to Lemma 1, two different $endpos$-equivalent strings are always in such a way, that the shorter one is a proper suffix of the longer one.\nConsequently, there cannot be two strings of the same length in the equivalence class.\n\nLet's denote by $w$ the longest, and through $u$ the shortest string in the equivalence class.\nAccording to Lemma 1, the string $u$ is a proper suffix of the string $w$.\nConsider now any suffix of $w$ with a length in the interval $[length(u); length(w)]$.\nIt is easy to see, that this suffix is also contained in the same equivalence class.\nBecause this suffix can only appear in the form of a suffix of $w$ in the string $s$ (since also the shorter suffix $u$ occurs in $s$ only in the form of a suffix of $w$).\nConsequently, according to Lemma 1, this suffix is $endpos$-equivalent to the string $w$.\n\n### Suffix links $link$ {data-toc-label=\"Suffix links\"}\n\nConsider some state $v \\ne t_0$ in the automaton.\nAs we know, the state $v$ corresponds to the class of strings with the same $endpos$ values.\nAnd if we denote by $w$ the longest of these strings, then all the other strings are suffixes of $w$.\n\nWe also know the first few suffixes of a string $w$ (if we consider suffixes in descending order of their length) are all contained in this equivalence class, and all other suffixes (at least one other - the empty suffix) are in some other classes.\nWe denote by $t$ the biggest such suffix, and make a suffix link to it.\n\nIn other words, a **suffix link** $link(v)$ leads to the state that corresponds to the **longest suffix** of $w$ that is in another $endpos$-equivalence class.\n\nHere we assume that the initial state $t_0$ corresponds to its own equivalence class (containing only the empty string), and for convenience we set $endpos(t_0) = \\{-1, 0, \\dots, length(s)-1\\}$.\n\n**Lemma 4**:\nSuffix links form a **tree** with the root $t_0$.\n\nProof:\nConsider an arbitrary state $v \\ne t_0$.\nA suffix link $link(v)$ leads to a state corresponding to strings with strictly smaller length (this follows from the definition of the suffix links and from Lemma 3).\nTherefore, by moving along the suffix links, we will sooner or later come to the initial state $t_0$, which corresponds to the empty string.\n\n**Lemma 5**:\nIf we construct a tree using the sets $endpos$ (by the rule that the set of a parent node contains the sets of all children as subsets), then the structure will coincide with the tree of suffix links.\n\nProof:\nThe fact that we can construct a tree using the sets $endpos$ follows directly from Lemma 2 (that any two sets either do not intersect or one is contained in the other).\n\nLet us now consider an arbitrary state $v \\ne t_0$, and its suffix link $link(v)$.\nFrom the definition of the suffix link and from Lemma 2 it follows that\n\n$$endpos(v) \\subseteq endpos(link(v)),$$\n\nwhich together with the previous lemma proves the assertion:\nthe tree of suffix links is essentially a tree of sets $endpos$.\n\nHere is an **example** of a tree of suffix links in the suffix automaton build for the string $\\text{\"abcbc\"}$.\nThe nodes are labeled with the longest substring from the corresponding equivalence class.\n\n![Suffix automaton for \"abcbc\" with suffix links](SA_suffix_links.png)\n\n### Recap\n\nBefore proceeding to the algorithm itself, we recap the accumulated knowledge, and introduce a few auxiliary notations.\n\n- The substrings of the string $s$ can be decomposed into equivalence classes according to their end positions $endpos$.\n- The suffix automaton consists of the initial state $t_0$, as well as of one state for each $endpos$-equivalence class.\n- For each state $v$ one or multiple substrings match.\n  We denote by $longest(v)$ the longest such string, and through $len(v)$ its length.\n  We denote by $shortest(v)$ the shortest such substring, and its length with $minlen(v)$.\n  Then all the strings corresponding to this state are different suffixes of the string $longest(v)$ and have all possible lengths in the interval $[minlen(v); len(v)]$.\n- For each state $v \\ne t_0$ a suffix link is defined as a link, that leads to a state that corresponds to the suffix of the string $longest(v)$ of length $minlen(v) - 1$.\n  The suffix links form a tree with the root in $t_0$, and at the same time this tree forms an inclusion relationship between the sets $endpos$.\n- We can express $minlen(v)$ for $v \\ne t_0$ using the suffix link $link(v)$ as:\n  \n$$minlen(v) = len(link(v)) + 1$$\n\n- If we start from an arbitrary state $v_0$ and follow the suffix links, then sooner or later we will reach the initial state $t_0$.\n  In this case we obtain a sequence of disjoint intervals $[minlen(v_i); len(v_i)]$, which in union forms the continuous interval $[0; len(v_0)]$.\n\n### Algorithm\n\nNow we can proceed to the algorithm itself.\nThe algorithm will be **online**, i.e. we will add the characters of the string one by one, and modify the automaton accordingly in each step.\n\nTo achieve linear memory consumption, we will only store the values $len$, $link$ and a list of transitions in each state.\nWe will not label terminal states (but we will later show how to arrange these labels after constructing the suffix automaton).\n\nInitially the automaton consists of a single state $t_0$, which will be the index $0$ (the remaining states will receive the indices $1, 2, \\dots$).\nWe assign it $len = 0$ and $link = -1$ for convenience ($-1$ will be a fictional, non-existing state).\n\nNow the whole task boils down to implementing the process of **adding one character** $c$ to the end of the current string.\nLet us describe this process:\n\n  - Let $last$ be the state corresponding to the entire string before adding the character $c$.\n    (Initially we set $last = 0$, and we will change $last$ in the last step of the algorithm accordingly.)\n  - Create a new state $cur$, and assign it with $len(cur) = len(last) + 1$.\n    The value $link(cur)$ is not known at the time.\n  - Now we to the following procedure:\n    We start at the state $last$.\n    While there isn't a transition through the letter $c$, we will add a transition to the state $cur$, and follow the suffix link.\n    If at some point there already exists a transition through the letter $c$, then we will stop and denote this state with $p$.\n  - If it haven't found such a state $p$, then we reached the fictitious state $-1$, then we can just assign $link(cur) = 0$ and leave.\n  - Suppose now that we have found a state $p$, from which there exists a transition through the letter $c$.\n    We will denote the state, to which the transition leads,  with $q$.\n  - Now we have two cases. Either $len(p) + 1 = len(q)$, or not.\n  - If $len(p) + 1 = len(q)$, then we can simply assign $link(cur) = q$ and leave.\n  - Otherwise it is a bit more complicated.\n    It is necessary to **clone** the state $q$:\n    we create a new state $clone$, copy all the data from $q$ (suffix link and transition) except the value $len$.\n    We will assign $len(clone) = len(p) + 1$.\n\n    After cloning we direct the suffix link from $cur$ to $clone$, and also from $q$ to clone.\n\n    Finally we need to walk from the state $p$ back using suffix links as long as there is a transition through $c$ to the state $q$, and redirect all those to the state $clone$.\n\n  - In any of the three cases, after completing the procedure, we update the value $last$ with the state $cur$.\n\nIf we also want to know which states are **terminal** and which are not, the we can find all terminal states after constructing the complete suffix automaton for the entire string $s$.\nTo do this, we take the state corresponding to the entire string (stored in the variable $last$), and follow its suffix links until we reach the initial state.\nWe will mark all visited states as terminal.\nIt is easy to understand that by doing so we will mark exactly the states corresponding to all the suffixes of the string $s$, which are exactly the terminal states.\n\nIn the next section we will look in detail at each step and show its **correctness**.\n\nHere we only note that, since we only create one or two new states for each character of $s$, the suffix automaton contains a **linear number of states**.\n\nThe linearity of the number of transitions, and in general the linearity of the runtime of the algorithm is less clear, and they will be proven after we proved the correctness.\n\n### Correctness\n\n  - We will call a transition $(p, q)$ **continuous** if $len(p) + 1 = len(q)$.\n    Otherwise, i.e. when $len(p) + 1 < len(q)$, the transition will be called **non-continuous**.\n\n    As we can see from the description of the algorithm, continuous and non-continuous transitions will lead to different cases of the algorithm.\n    Continuous transitions are fixed, and will never change again.\n    In contrast non-continuous transition may change, when new letters are added to the string (the end of the transition edge may change).\n\n  - To avoid ambiguity we will denote the string, for which the suffix automaton was built before adding the current character $c$, with $s$.\n\n  - The algorithm begins with creating a new state $cur$, which will correspond to the entire string $s + c$.\n    It is clear why we have to create a new state.\n    Together with the new character a new equivalence class is created.\n\n  - After creating a new state we traverse by suffix links starting from the state corresponding to the entire string $s$.\n    For each state we try to add a transition with the character $c$ to the new state $cur$.\n    Thus we append to each suffix of $s$ the character $c$.\n    However we can only add these new transitions, if they don't conflict with an already existing one.\n    Therefore as soon as we find an already existing transition with $c$ we have to stop.\n\n  - In the simplest case we reached the fictitious state $-1$.\n    This means we added the transition with $c$ to all suffixes of $s$.\n    This also means, that the character $c$ hasn't been part of the string $s$ before.\n    Therefore the suffix link of $cur$ has to lead to the state $0$.\n\n  - In the second case we came across an existing transition $(p, q)$.\n    This means that we tried to add a string $x + c$ (where $x$ is a suffix of $s$) to the machine that **already exists** in the machine (the string $x + c$ already appears as a substring of $s$).\n    Since we assume that the automaton for the string $s$ is build correctly, we should not add a new transition here.\n\n    However there is a difficulty.\n    To which state should the suffix link from the state $cur$ lead?\n    We have to make a suffix link to a state, in which the longest string is exactly $x + c$, i.e. the $len$ of this state should be $len(p) + 1$.\n    However it is possible, that such a state doesn't yet exists, i.e. $len(q) > len(p) + 1$.\n    In this case we have to create such a state, by **splitting** the state $q$.\n\n  - If the transition $(p, q)$ turns out to be continuous, then $len(q) = len(p) + 1$.\n    In this case everything is simple.\n    We direct the suffix link from $cur$ to the state $q$.\n\n  - Otherwise the transition is non-continuous, i.e. $len(q) > len(p) + 1$.\n    This means that the state $q$ corresponds to not only the suffix of $s + c$ with length $len(p) + 1$, but also to longer substrings of $s$.\n    We can do nothing other than **splitting** the state $q$ into two sub-states, so that the first one has length $len(p) + 1$.\n\n    How can we split a state?\n    We **clone** the state $q$, which gives us the state $clone$, and we set $len(clone) = len(p) + 1$.\n    We copy all the transitions from $q$ to $clone$, because we don't want to change the paths that traverse through $q$.\n    Also we set the suffix link from $clone$ to the target of the suffix link of $q$, and set the suffix link of $q$ to $clone$.\n\n    And after splitting the state, we set the suffix link from $cur$ to $clone$.\n\n    In the last step we change some of the transitions to $q$, we redirect them to $clone$.\n    Which transitions do we have to change?\n    It is enough to redirect only the transitions corresponding to all the suffixes of the string $w + c$ (where $w$ is the longest string of $p$), i.e. we need to continue to move along the suffix links, starting from the vertex $p$ until we reach the fictitious state $-1$ or a transition that leads to a different state than $q$.\n\n### Linear number of operations\n\nFirst we immediately make the assumption that the size of the alphabet is **constant**.\nIf this is not the case, then it will not be possible to talk about the linear time complexity.\nThe list of transitions from one vertex will be stored in a balanced tree, which allows you to quickly perform key search operations and adding keys.\nTherefore if we denote with $k$ the size of the alphabet, then the asymptotic behavior of the algorithm will be $O(n \\log k)$ with $O(n)$ memory.\nHowever if the alphabet is small enough, then you can sacrifice memory by avoiding balanced trees, and store the transitions at each vertex as an array of length $k$ (for quick searching by key) and a dynamic list (to quickly traverse all available keys).\nThus we reach the $O(n)$ time complexity for the algorithm, but at a cost of $O(n k)$ memory complexity.\n\nSo we will consider the size of the alphabet to be constant, i.e. each operation of searching for a transition on a character, adding a transition, searching for the next transition - all these operations can be done in $O(1)$.\n\nIf we consider all parts of the algorithm, then it contains three places in the algorithm in which the linear complexity is not obvious:\n\n  - The first place is the traversal through the suffix links from the state $last$, adding transitions with the character $c$.\n  - The second place is the copying of transitions when the state $q$ is cloned into a new state $clone$.\n  - Third place is changing the transition leading to $q$, redirecting them to $clone$.\n\nWe use the fact that the size of the suffix automaton (both in number of states and in the number of transitions) is **linear**.\n(The proof of the linearity of the number of states is the algorithm itself, and the proof of linearity of the number of states is given below, after the implementation of the algorithm).\n\nThus the total complexity of the **first and second places** is obvious, after all each operation adds only one amortized new transition to the automaton.\n\nIt remains to estimate the total complexity of the **third place**, in which we redirect transitions, that pointed originally to $q$, to $clone$.\nWe denote $v = longest(p)$.\nThis is a suffix of the string $s$, and with each iteration its length decreases - and therefore the position $v$ as the suffix of the string $s$ increases monotonically with each iteration.\nIn this case, if before the first iteration of the loop, the corresponding string $v$ was at the depth $k$ ($k \\ge 2$) from $last$ (by counting the depth as the number of suffix links), then after the last iteration the string $v + c$ will be a $2$-th suffix link on the path from $cur$ (which will become the new value $last$).\n\nThus, each iteration of this loop leads to the fact that the position of the string $longest(link(link(last))$ as suffix of the current string will monotonically increase.\nTherefore this cycle cannot be executed more than $n$ iterations, which was required to prove.\n\n### Implementation\n\nFirst we describe a data structure that will store all information about a specific transition ($len$, $link$ and the list of transitions).\nIf necessary you can add a terminal flag here, as well as other information.\nWe will store the list of transitions in the form of a $map$, which allows us to achieve total $O(n)$ memory and $O(n \\log k)$ time for processing the entire string.\n\n```{.cpp file=suffix_automaton_struct}\nstruct state {\n    int len, link;\n    map<char, int> next;\n};\n```\n\nThe suffix automaton itself will be stored in an array of these structures $state$.\nWe store the current size $sz$ and also the variable $last$, the state corresponding to the entire string at the moment.\n\n```{.cpp file=suffix_automaton_def}\nconst int MAXLEN = 100000;\nstate st[MAXLEN * 2];\nint sz, last;\n```\n\nWe give a function that initializes a suffix automaton (creating a suffix automaton with a single state).\n\n```{.cpp file=suffix_automaton_init}\nvoid sa_init() {\n    st[0].len = 0;\n    st[0].link = -1;\n    sz++;\n    last = 0;\n}\n```\n\nAnd finally we give the implementation of the main function - which adds the next character to the end of the current line, rebuilding the machine accordingly.\n\n```{.cpp file=suffix_automaton_extend}\nvoid sa_extend(char c) {\n    int cur = sz++;\n    st[cur].len = st[last].len + 1;\n    int p = last;\n    while (p != -1 && !st[p].next.count(c)) {\n        st[p].next[c] = cur;\n        p = st[p].link;\n    }\n    if (p == -1) {\n        st[cur].link = 0;\n    } else {\n        int q = st[p].next[c];\n        if (st[p].len + 1 == st[q].len) {\n            st[cur].link = q;\n        } else {\n            int clone = sz++;\n            st[clone].len = st[p].len + 1;\n            st[clone].next = st[q].next;\n            st[clone].link = st[q].link;\n            while (p != -1 && st[p].next[c] == q) {\n                st[p].next[c] = clone;\n                p = st[p].link;\n            }\n            st[q].link = st[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n```\n\nAs mentioned above, if you sacrifice memory ($O(n k)$, where $k$ is the size of the alphabet), then you can achieve the build time of the machine in $O(n)$, even for any alphabet size $k$.\nBut for this you will have to store an array of size $k$ in each state (for quickly jumping to the transition of the letter), and additional a list of all transitions (to quickly iterate over the transitions them).\n\n## Additional properties\n\n### Number of states\n\nThe number of states in a suffix automaton of the string $s$ of length $n$ **doesn't exceed** $2n - 1$ (for $n \\ge 2$).\n\nThe proof is the construction algorithm itself, since initially the automaton consists of one state, and in the first and second iteration only a single state will be created, and in the remaining $n-2$ steps at most $2$ states will be created each.\n\nHowever we can also **show** this estimation **without knowing the algorithm**.\nLet us recall that the number of states is equal to the number of different sets $endpos$.\nIn addition theses sets $endpos$ form a tree (a parent vertex contains all children sets in his set).\nConsider this tree and transform it a little bit:\nas long as it has an internal vertex with only one child (which means that the set of the child misses at least one position from the parent set), we create a new child with the set of the missing positions.\nIn the end we have a tree in which each inner vertex has a degree greater than one, and the number of leaves does not exceed $n$.\nTherefore there are no more than $2n - 1$ vertices in such a tree.\n\nThis bound of the number of states can actually be achieved for each $n$.\nA possible string is:\n\n$$\\text{\"abbb}\\dots \\text{bbb\"}$$\n\nIn each iteration, starting at the third one, the algorithm will split a state, resulting in exactly $2n - 1$ states.\n\n### Number of transitions\n\nThe number of transitions in a suffix automaton of a string $s$ of length $n$ **doesn't exceed** $3n - 4$ (for $n \\ge 3$).\n\nLet us prove this:\n\nLet us first estimate the number of continuous transitions.\nConsider a spanning tree of the longest paths in the automaton starting in the state $t_0$.\nThis skeleton will consist of only the continuous edges, and therefore their number is less than the number of states, i.e. it does not exceed $2n - 2$.\n\nNow let us estimate the number of non-continuous transitions.\nLet the current non-continuous transition be $(p, q)$ with the character $c$.\nWe take the correspondent string $u + c + w$, where the string $u$ corresponds to the longest path from the initial state to $p$, and $w$ to the longest path from $q$ to any terminal state.\nOn one hand, each such string $u + c + w$ for each incomplete strings will be different (since the strings $u$ and $w$ are formed only by complete transitions).\nOn the other hand each such string $u + c + w$, by the definition of the terminal states, will be a suffix of the entire string $s$.\nSince there are only $n$ non-empty suffixes of $s$, and non of the strings $u + c + w$ can contain $s$ (because the entire string only contains complete transitions), the total number of incomplete transitions does not exceed $n - 1$.\n\nCombining these two estimates gives us the bound $3n - 3$.\nHowever, since the maximum number of states can only be achieved with the test case $\\text{\"abbb\\dots bbb\"}$ and this case has clearly less than $3n - 3$ transitions, we get the tighter bound of $3n - 4$ for the number of transitions in a suffix automaton.\n\nThis bound can also be achieved with the string:\n\n$$\\text{\"abbb}\\dots \\text{bbbc\"}$$\n\n## Applications\n\nHere we look at some tasks that can be solved using the suffix automaton.\nFor the simplicity we assume that the alphabet size $k$ is constant, which allows us to consider the complexity of appending a character and the traversal as constant.\n\n### Check for occurrence\n\nGiven a text $T$, and multiple patters $P$.\nWe have to check whether or not the strings $P$ appear as a substring of $T$.\n\nWe build a suffix automaton of the text $T$ in $O(length(T))$ time.\nTo check if a pattern $P$ appears in $T$, we follow the transitions, starting from $t_0$, according to the characters of $P$.\nIf at some point there doesn't exists a transition, then the pattern $P$ doesn't appear as a substring of $T$.\nIf we can process the entire string $P$ this way, then the string appears in $T$.\n\nIt is clear that this will take $O(length(P))$ time for each string $P$.\nMoreover the algorithm actually finds the length of the longest prefix of $P$ that appears in the text.\n\n### Number of different substrings\n\nGiven a string $S$.\nYou want to compute the number of different substrings.\n\nLet us build a suffix automaton for the string $S$.\n\nEach substring of $S$ corresponds to some path in the automaton.\nTherefore the number of different substrings is equal to the number of different paths in the automaton starting at $t_0$.\n\nGiven that the suffix automaton is a directed acyclic graph, the number of different ways can be computed using dynamic programming.\n\nNamely, let $d[v]$ be the number of ways, starting at the state $v$ (including the path of length zero).\nThen we have the recursion:\n\n$$d[v] = 1 + \\sum_{w : (v, w, c) \\in DAWG} d[w]$$\n\nI.e. $d[v]$ can be expressed as the sum of answers for all ends of the transitions of $v$.\n\nThe number of different substrings is the value $d[t_0] - 1$ (since we don't count the empty substring).\n\nTotal time complexity: $O(length(S))$\n\n\nAlternatively, we can take advantage of the fact that each state $v$ matches to substrings of length $[minlen(v),len(v)]$.\nTherefore, given $minlen(v) = 1 + len(link(v))$, we have total distinct substrings at state $v$ being $len(v) - minlen(v) + 1 = len(v) - (1 + len(link(v))) + 1 = len(v) - len(link(v))$.\n\nThis is demonstrated succinctly below:\n\n```cpp\nlong long get_diff_strings(){\n    long long tot = 0;\n    for(int i = 1; i < sz; i++) {\n        tot += st[i].len - st[st[i].link].len;\n    }\n    return tot;\n}\n```\n\nWhile this is also $O(length(S))$, it requires no extra space and no recursive calls, consequently running faster in practice.\n\n### Total length of all different substrings\n\nGiven a string $S$.\nWe want to compute the total length of all its various substrings.\n\nThe solution is similar to the previous one, only now it is necessary to consider two quantities for the dynamic programming part:\nthe number of different substrings $d[v]$ and their total length $ans[v]$.\n\nWe already described how to compute $d[v]$ in the previous task.\nThe value $ans[v]$ can be computed using the recursion:\n\n$$ans[v] = \\sum_{w : (v, w, c) \\in DAWG} d[w] + ans[w]$$\n\nWe take the answer of each adjacent vertex $w$, and add to it $d[w]$ (since every substrings is one character longer when starting from the state $v$).\n\nAgain this task can be computed in $O(length(S))$ time.\n\nAlternatively, we can, again, take advantage of the fact that each state $v$ matches to substrings of length $[minlen(v),len(v)]$.\nSince $minlen(v) = 1 + len(link(v))$ and the arithmetic series formula $S_n = n \\cdot \\frac{a_1+a_n}{2}$ (where $S_n$ denotes the sum of $n$ terms, $a_1$ representing the first term, and $a_n$ representing the last), we can compute the length of substrings at a state in constant time.  We then sum up these totals for each state $v \\neq t_0$ in the automaton. This is shown by the code below:\n\n```cpp\nlong long get_tot_len_diff_substings() {\n    long long tot = 0;\n    for(int i = 1; i < sz; i++) {\n        long long shortest = st[st[i].link].len + 1;\n        long long longest = st[i].len;\n        \n        long long num_strings = longest - shortest + 1;\n        long long cur = num_strings * (longest + shortest) / 2;\n        tot += cur;\n    }\n    return tot;\n}\n```\n\nThis approaches runs in  $O(length(S))$ time, but experimentally runs 20x faster than the memoized dynamic programming version on randomized strings. It requires no extra space and no recursion.\n\n### Lexicographically $k$-th substring {data-toc-label=\"Lexicographically k-th substring\"}\n\nGiven a string $S$.\nWe have to answer multiple queries.\nFor each given number $K_i$ we have to find the $K_i$-th string in the lexicographically ordered list of all substrings.\n\nThe solution of this problem is based on the idea of the previous two problems.\nThe lexicographically $k$-th substring corresponds to the lexicographically $k$-th path in the suffix automaton.\nTherefore after counting the number of paths from each state, we can easily search for the $k$-th path starting from the root of the automaton.\n\nThis takes $O(length(S))$ time for preprocessing and then $O(length(ans) \\cdot k)$ for each query (where $ans$ is the answer for the query and $k$ is the size of the alphabet).\n\n### Smallest cyclic shift\n\nGiven a string $S$.\nWe want to find the lexicographically smallest cyclic shift.\n\nWe construct a suffix automaton for the string $S + S$.\nThen the automaton will contain in itself as paths all the cyclic shifts of the string $S$.\n\nConsequently the problem is reduced to finding the lexicographically smallest path of length $length(S)$, which can be done in a trivial way: we start in the initial state and greedily pass through the transitions with the minimal character.\n\nTotal time complexity is $O(length(S))$.\n\n### Number of occurrences\n\nFor a given text $T$.\nWe have to answer multiple queries.\nFor each given pattern $P$ we have to find out how many times the string $P$ appears in the string $T$ as substring.\n\nWe construct the suffix automaton for the text $T$.\n\nNext we do the following preprocessing:\nfor each state $v$ in the automaton we calculate the number $cnt[v]$ that is equal to the size of the set $endpos(v)$.\nIn fact all strings corresponding to the same state $v$ appear in the text $T$ an equal amount of times, which is equal to the number of positions in the set $endpos$.\n\nHowever we cannot construct the sets $endpos$ explicitly, therefore we only consider their sizes $cnt$.\n\nTo compute them we proceed as follows.\nFor each state, if it was not created by cloning (and if it is not the initial state $t_0$), we initialize it with $cnt = 1$.\nThen we will go through all states in decreasing order of their length $len$, and add the current value $cnt[v]$ to the suffix links:\n\n$$cnt[link(v)] \\text{ += } cnt[v]$$\n\nThis gives the correct value for each state.\n\nWhy is this correct?\nThe total number of states obtained _not_ via cloning is exactly $length(T)$, and the first $i$ of them appeared when we added the first $i$ characters.\nConsequently for each of these states we count the corresponding position at which it was processed.\nTherefore initially we have $cnt = 1$ for each such state, and $cnt = 0$ for all other.\n\nThen we apply the following operation for each $v$: $cnt[link(v)] \\text{ += } cnt[v]$.\nThe meaning behind this is, that if a string $v$ appears $cnt[v]$ times, then also all its suffixes appear at the exact same end positions, therefore also $cnt[v]$ times.\n\nWhy don't we overcount in this procedure (i.e. don't count some position twice)?\nBecause we add the positions of a state to only one other state, so it can not happen that one state directs its positions to another state twice in two different ways.\n\nThus we can compute the quantities $cnt$ for all states in the automaton in $O(length(T))$ time.\n\nAfter that answering a query by just looking up the value $cnt[t]$, where $t$ is the state corresponding to the pattern, if such a state exists.\nOtherwise answer with $0$.\nAnswering a query takes $O(length(P))$ time.\n\n### First occurrence position\n\nGiven a text $T$ and multiple queries.\nFor each query string $P$ we want to find the position of the first occurrence of $P$ in the string $T$ (the position of the beginning of $P$).\n\nWe again construct a suffix automaton.\nAdditionally we precompute the position $firstpos$ for all states in the automaton, i.e. for each state $v$ we want to find the position $firstpos[v]$ of the end of the first occurrence.\nIn other words, we want to find in advance the minimal element of each set $endpos$ (since obviously cannot maintain all sets $endpos$ explicitly).\n\nTo maintain these positions $firstpos$ we extend the function `sa_extend()`.\nWhen we create a new state $cur$, we set:\n\n$$firstpos(cur) = len(cur) - 1$$\n\nAnd when we clone a vertex $q$ as $clone$, we set:\n\n$$firstpos(clone) = firstpos(q)$$\n\n(since the only other option for a value would be $firstpos(cur)$ which is definitely too big)\n\nThus the answer for a query is simply $firstpos(t) - length(P) + 1$, where $t$ is the state corresponding to the string $P$.\nAnswering a query again takes only $O(length(P))$ time.\n\n### All occurrence positions\n\nThis time we have to display all positions of the occurrences in the string $T$.\n\nAgain we construct a suffix automaton for the text $T$.\nSimilar as in the previous task we compute the position $firstpos$ for all states.\n\nClearly $firstpos(t)$ is part of the answer, if $t$ is the state corresponding to a query string $P$.\nSo we took into account the state of the automaton containing $P$.\nWhat other states do we need to take into account?\nAll states that correspond to strings for which $P$ is a suffix.\nIn other words we need to find all the states that can reach the state $t$ via suffix links.\n\nTherefore to solve the problem we need to save for each state a list of suffix references leading to it.\nThe answer to the query then will then contain all $firstpos$ for each state that we can find on a DFS / BFS starting from the state $t$ using only the suffix references.\n\nThis workaround will work in time $O(answer(P))$, because we will not visit a state twice (because only one suffix link leaves each state, so there cannot be two different paths leading to the same state).\n\nWe only must take into account that two different states can have the same $firstpos$ value.\nThis happens if one state was obtained by cloning another.\nHowever, this doesn't ruin the complexity, since each state can only have at most one clone.\n\nMoreover, we can also get rid of the duplicate positions, if we don't output the positions from the cloned states.\nIn fact a state, that a cloned state can reach, is also reachable from the original state.\nThus if we remember the flag `is_cloned` for each state, we can simply ignore the cloned states and only output $firstpos$ for all other states.\n\nHere are some implementation sketches:\n\n```cpp\nstruct state {\n    ...\n    bool is_clone;\n    int first_pos;\n    vector<int> inv_link;\n};\n\n// after constructing the automaton\nfor (int v = 1; v < sz; v++) {\n    st[st[v].link].inv_link.push_back(v);\n}\n\n// output all positions of occurrences\nvoid output_all_occurrences(int v, int P_length) {\n    if (!st[v].is_clone)\n        cout << st[v].first_pos - P_length + 1 << endl;\n    for (int u : st[v].inv_link)\n        output_all_occurrences(u, P_length);\n}\n```\n\n### Shortest non-appearing string\n\nGiven a string $S$ and a certain alphabet.\nWe have to find a string of smallest length, that doesn't appear in $S$.\n\nWe will apply dynamic programming on the suffix automaton built for the string $S$.\n\nLet $d[v]$ be the answer for the node $v$, i.e. we already processed part of the substring, are currently in the state $v$, and want to find the smallest number of characters that have to be added to find a non-existent transition.\nComputing $d[v]$ is very simple.\nIf there is not transition using at least one character of the alphabet, then $d[v] = 1$.\nOtherwise one character is not enough, and so we need to take the minimum of all answers of all transitions:\n\n$$d[v] = 1 + \\min_{w:(v,w,c) \\in SA} d[w].$$\n\nThe answer to the problem will be $d[t_0]$, and the actual string can be restored using the computed array $d[]$.\n\n### Longest common substring of two strings\n\nGiven two strings $S$ and $T$.\nWe have to find the longest common substring, i.e. such a string $X$ that appears as substring in $S$ and also in $T$.\n\nWe construct a suffix automaton for the string $S$.\n\nWe will now take the string $T$, and for each prefix look for the longest suffix of this prefix in $S$.\nIn other words, for each position in the string $T$, we want to find the longest common substring of $S$ and $T$ ending in that position.\n\nFor this we will use two variables, the **current state** $v$, and the **current length** $l$.\nThese two variables will describe the current matching part: its length and the state that corresponds to it.\n\nInitially $v = t_0$ and $l = 0$, i.e. the match is empty.\n\nNow let us describe how we can add a character $T[i]$ and recalculate the answer for it.\n\n  - If there is a transition from $v$ with the character $T[i]$, then we simply follow the transition and increase $l$ by one.\n  - If there is no such transition, we have to shorten the current matching part, which means that we need to follow the suffix link: $v = link(v)$.\n    At the same time, the current length has to be shortened.\n    Obviously we need to assign $l = len(v)$, since after passing through the suffix link we end up in state whose corresponding longest string is a substring.\n  - If there is still no transition using the required character, we repeat and again go through the suffix link and decrease $l$, until we find a transition or we reach the fictional state $-1$ (which means that the symbol $T[i]$ doesn't appear at all in $S$, so we assign $v = l = 0$).\n\nThe answer to the task will be the maximum of all the values $l$.\n\nThe complexity of this part is $O(length(T))$, since in one move we can either increase $l$ by one, or make several passes through the suffix links, each one ends up reducing the value $l$.\n\nImplementation:\n\n```cpp\nstring lcs (string S, string T) {\n    sa_init();\n    for (int i = 0; i < S.size(); i++)\n        sa_extend(S[i]);\n \n    int v = 0, l = 0, best = 0, bestpos = 0;\n    for (int i = 0; i < T.size(); i++) {\n        while (v && !st[v].next.count(T[i])) {\n            v = st[v].link ;\n            l = st[v].len;\n        }\n        if (st[v].next.count(T[i])) {\n            v = st [v].next[T[i]];\n            l++;\n        }\n        if (l > best) {\n            best = l;\n            bestpos = i;\n        }\n    }\n    return T.substr(bestpos - best + 1, best);\n} \n```\n\n### Largest common substring of multiple strings\n\nThere are $k$ strings $S_i$ given.\nWe have to find the longest common substring, i.e. such a string $X$ that appears as substring in each string $S_i$.\n\nWe join all strings into one large string $T$, separating the strings by a special characters $D_i$ (one for each string):\n\n$$T = S_1 + D_1 + S_2 + D_2 + \\dots + S_k + D_k.$$\n\nThen we construct the suffix automaton for the string $T$.\n\nNow we need to find a string in the machine, which is contained in all the strings $S_i$, and this can be done by using the special added characters.\nNote that if a substring is included in some string $S_j$, then in the suffix automaton exists a path starting from this substring containing the character $D_j$ and not containing the other characters $D_1, \\dots, D_{j-1}, D_{j+1}, \\dots, D_k$.\n\nThus we need to calculate the attainability, which tells us for each state of the machine and each symbol $D_i$ if there exists such a path.\nThis can easily be computed by DFS or BFS and dynamic programming.\nAfter that, the answer to the problem will be the string $longest(v)$ for the state $v$, from which the paths were exists for all special characters.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: suffix_automata\n---\n\n# Suffix Automaton\n\nA **suffix automaton** is a powerful data structure that allows solving many string-related problems. \n\nFor example, you can search for all occurrences of one string in another, or count the amount of different substrings of a given string.\nBoth tasks can be solved in linear time with the help of a suffix automaton.\n\nIntuitively a suffix automaton can be understood as a compressed form of **all substrings** of a given string.\nAn impressive fact is, that the suffix automaton contains all this information in a highly compressed form.\nFor a string of length $n$ it only requires $O(n)$ memory.\nMoreover, it can also be built in $O(n)$ time (if we consider the size $k$ of the alphabet as a constant), otherwise both the memory and the time complexity will be $O(n \\log k)$.\n\nThe linearity of the size of the suffix automaton was first discovered in 1983 by Blumer et al., and in 1985 the first linear algorithms for the construction was presented by Crochemore and Blumer.\n\n## Definition of a suffix automaton\n\nA suffix automaton for a given string $s$ is a minimal **DFA** (deterministic finite automaton / deterministic finite state machine) that accepts all the suffixes of the string $s$.\n\nIn other words:\n\n -  A suffix automaton is an oriented acyclic graph.\n    The vertices are called **states**, and the edges are called **transitions** between states.\n -  One of the states $t_0$ is the **initial state**, and it must be the source of the graph (all other states are reachable from $t_0$).\n -  Each **transition** is labeled with some character.\n    All transitions originating from a state must have **different** labels.\n -  One or multiple states are marked as **terminal states**.\n    If we start from the initial state $t_0$ and move along transitions to a terminal state, then the labels of the passed transitions must spell one of the suffixes of the string $s$.\n    Each of the suffixes of $s$ must be spellable using a path from $t_0$ to a terminal state.\n -  The suffix automaton contains the minimum number of vertices among all automata satisfying the conditions described above.\n\n### Substring property\n\nThe simplest and most important property of a suffix automaton is, that it contains information about all substrings of the string $s$.\nAny path starting at the initial state $t_0$, if we write down the labels of the transitions, forms a **substring** of $s$.\nAnd conversely every substring of $s$ corresponds to a certain path starting at $t_0$.\n\nIn order to simplify the explanations, we will say that the substring **corresponds** to that path (starting at $t_0$ and the labels spell the substring).\nAnd conversely we say that any path **corresponds** to the string spelled by its labels.\n\nOne or multiple paths can lead to a state.\nThus, we will say that a state **corresponds** to the set of strings, which correspond to these paths.\n\n### Examples of constructed suffix automata\n\nHere we will show some examples of suffix automata for several simple strings.\n\nWe will denote the initial state with blue and the terminal states with green.\n\nFor the string $s =~ \\text{\"\"}$:\n\n![Suffix automaton for \"\"](SA.png)\n\nFor the string $s =~ \\text{\"a\"}$:\n\n![Suffix automaton for \"a\"](SAa.png)\n\nFor the string $s =~ \\text{\"aa\"}$:\n\n![Suffix automaton for \"aa\"](SAaa.png)\n\nFor the string $s =~ \\text{\"ab\"}$:\n\n![Suffix automaton for \"ab\"](SAab.png)\n\nFor the string $s =~ \\text{\"aba\"}$:\n\n![Suffix automaton for \"aba\"](SAaba.png)\n\nFor the string $s =~ \\text{\"abb\"}$:\n\n![Suffix automaton for \"abb\"](SAabb.png)\n\nFor the string $s =~ \\text{\"abbb\"}$:\n\n![Suffix automaton for \"abbb\"](SAabbb.png)\n\n## Construction in linear time\n\nBefore we describe the algorithm to construct a suffix automaton in linear time, we need to introduce several new concepts and simple proofs, which will be very important in understanding the construction.\n\n### End positions $endpos$ {data-toc-label=\"End positions\"}\n\nConsider any non-empty substring $t$ of the string $s$.\nWe will denote with $endpos(t)$ the set of all positions in the string $s$, in which the occurrences of $t$ end. For instance, we have $endpos(\\text{\"bc\"}) = \\{2, 4\\}$ for the string $\\text{\"abcbc\"}$.\n\nWe will call two substrings $t_1$ and $t_2$ $endpos$-equivalent, if their ending sets coincide: $endpos(t_1) = endpos(t_2)$.\nThus all non-empty substrings of the string $s$ can be decomposed into several **equivalence classes** according to their sets $endpos$.\n\nIt turns out, that in a suffix machine $endpos$-equivalent substrings **correspond to the same state**.\nIn other words the number of states in a suffix automaton is equal to the number of equivalence classes among all substrings, plus the initial state.\nEach state of a suffix automaton corresponds to one or more substrings having the same value $endpos$.\n\nWe will later describe the construction algorithm using this assumption.\nWe will then see, that all the required properties of a suffix automaton, except for the minimality, are fulfilled.\nAnd the minimality follows from Nerode's theorem (which will not be proven in this article).\n\nWe can make some important observations concerning the values $endpos$:\n\n**Lemma 1**:\nTwo non-empty substrings $u$ and $w$ (with $length(u) \\le length(w)$) are $endpos$-equivalent, if and only if the string $u$ occurs in $s$ only in the form of a suffix of $w$.\n\nThe proof is obvious.\nIf $u$ and $w$ have the same $endpos$ values, then $u$ is a suffix of $w$ and appears only in the form of a suffix of $w$ in $s$.\nAnd if $u$ is a suffix of $w$ and appears only in the form as a suffix in $s$, then the values $endpos$ are equal by definition.\n\n**Lemma 2**:\nConsider two non-empty substrings $u$ and $w$ (with $length(u) \\le length(w)$).\nThen their sets $endpos$ either don't intersect at all, or $endpos(w)$ is a subset of $endpos(u)$.\nAnd it depends on if $u$ is a suffix of $w$ or not.\n\n$$\\begin{cases}\nendpos(w) \\subseteq endpos(u) & \\text{if } u \\text{ is a suffix of } w \\\\\\\\\nendpos(w) \\cap endpos(u) = \\emptyset & \\text{otherwise}\n\\end{cases}$$\n\nProof:\nIf the sets $endpos(u)$ and $endpos(w)$ have at least one common element, then the strings $u$ and $w$ both end in that position, i.e. $u$ is a suffix of $w$.\nBut then at every occurrence of $w$ also appears the substring $u$, which means that $endpos(w)$ is a subset of $endpos(u)$.\n\n**Lemma 3**:\nConsider an $endpos$-equivalence class.\nSort all the substrings in this class by decreasing length.\nThen in the resulting sequence each substring will be one shorter than the previous one, and at the same time will be a suffix of the previous one.\nIn other words, in a same equivalence class, the shorter substrings are actually suffixes of the longer substrings, and they take all possible lengths in a certain interval $[x; y]$.\n\nProof:\nFix some $endpos$-equivalence class.\nIf it only contains one string, then the lemma is obviously true.\nNow let's say that the number of strings in the class is greater than one.\n\nAccording to Lemma 1, two different $endpos$-equivalent strings are always in such a way, that the shorter one is a proper suffix of the longer one.\nConsequently, there cannot be two strings of the same length in the equivalence class.\n\nLet's denote by $w$ the longest, and through $u$ the shortest string in the equivalence class.\nAccording to Lemma 1, the string $u$ is a proper suffix of the string $w$.\nConsider now any suffix of $w$ with a length in the interval $[length(u); length(w)]$.\nIt is easy to see, that this suffix is also contained in the same equivalence class.\nBecause this suffix can only appear in the form of a suffix of $w$ in the string $s$ (since also the shorter suffix $u$ occurs in $s$ only in the form of a suffix of $w$).\nConsequently, according to Lemma 1, this suffix is $endpos$-equivalent to the string $w$.\n\n### Suffix links $link$ {data-toc-label=\"Suffix links\"}\n\nConsider some state $v \\ne t_0$ in the automaton.\nAs we know, the state $v$ corresponds to the class of strings with the same $endpos$ values.\nAnd if we denote by $w$ the longest of these strings, then all the other strings are suffixes of $w$.\n\nWe also know the first few suffixes of a string $w$ (if we consider suffixes in descending order of their length) are all contained in this equivalence class, and all other suffixes (at least one other - the empty suffix) are in some other classes.\nWe denote by $t$ the biggest such suffix, and make a suffix link to it.\n\nIn other words, a **suffix link** $link(v)$ leads to the state that corresponds to the **longest suffix** of $w$ that is in another $endpos$-equivalence class.\n\nHere we assume that the initial state $t_0$ corresponds to its own equivalence class (containing only the empty string), and for convenience we set $endpos(t_0) = \\{-1, 0, \\dots, length(s)-1\\}$.\n\n**Lemma 4**:\nSuffix links form a **tree** with the root $t_0$.\n\nProof:\nConsider an arbitrary state $v \\ne t_0$.\nA suffix link $link(v)$ leads to a state corresponding to strings with strictly smaller length (this follows from the definition of the suffix links and from Lemma 3).\nTherefore, by moving along the suffix links, we will sooner or later come to the initial state $t_0$, which corresponds to the empty string.\n\n**Lemma 5**:\nIf we construct a tree using the sets $endpos$ (by the rule that the set of a parent node contains the sets of all children as subsets), then the structure will coincide with the tree of suffix links.\n\nProof:\nThe fact that we can construct a tree using the sets $endpos$ follows directly from Lemma 2 (that any two sets either do not intersect or one is contained in the other).\n\nLet us now consider an arbitrary state $v \\ne t_0$, and its suffix link $link(v)$.\nFrom the definition of the suffix link and from Lemma 2 it follows that\n\n$$endpos(v) \\subseteq endpos(link(v)),$$\n\nwhich together with the previous lemma proves the assertion:\nthe tree of suffix links is essentially a tree of sets $endpos$.\n\nHere is an **example** of a tree of suffix links in the suffix automaton build for the string $\\text{\"abcbc\"}$.\nThe nodes are labeled with the longest substring from the corresponding equivalence class.\n\n![Suffix automaton for \"abcbc\" with suffix links](SA_suffix_links.png)\n\n### Recap\n\nBefore proceeding to the algorithm itself, we recap the accumulated knowledge, and introduce a few auxiliary notations.\n\n- The substrings of the string $s$ can be decomposed into equivalence classes according to their end positions $endpos$.\n- The suffix automaton consists of the initial state $t_0$, as well as of one state for each $endpos$-equivalence class.\n- For each state $v$ one or multiple substrings match.\n  We denote by $longest(v)$ the longest such string, and through $len(v)$ its length.\n  We denote by $shortest(v)$ the shortest such substring, and its length with $minlen(v)$.\n  Then all the strings corresponding to this state are different suffixes of the string $longest(v)$ and have all possible lengths in the interval $[minlen(v); len(v)]$.\n- For each state $v \\ne t_0$ a suffix link is defined as a link, that leads to a state that corresponds to the suffix of the string $longest(v)$ of length $minlen(v) - 1$.\n  The suffix links form a tree with the root in $t_0$, and at the same time this tree forms an inclusion relationship between the sets $endpos$.\n- We can express $minlen(v)$ for $v \\ne t_0$ using the suffix link $link(v)$ as:\n  \n$$minlen(v) = len(link(v)) + 1$$\n\n- If we start from an arbitrary state $v_0$ and follow the suffix links, then sooner or later we will reach the initial state $t_0$.\n  In this case we obtain a sequence of disjoint intervals $[minlen(v_i); len(v_i)]$, which in union forms the continuous interval $[0; len(v_0)]$.\n\n### Algorithm\n\nNow we can proceed to the algorithm itself.\nThe algorithm will be **online**, i.e. we will add the characters of the string one by one, and modify the automaton accordingly in each step.\n\nTo achieve linear memory consumption, we will only store the values $len$, $link$ and a list of transitions in each state.\nWe will not label terminal states (but we will later show how to arrange these labels after constructing the suffix automaton).\n\nInitially the automaton consists of a single state $t_0$, which will be the index $0$ (the remaining states will receive the indices $1, 2, \\dots$).\nWe assign it $len = 0$ and $link = -1$ for convenience ($-1$ will be a fictional, non-existing state).\n\nNow the whole task boils down to implementing the process of **adding one character** $c$ to the end of the current string.\nLet us describe this process:\n\n  - Let $last$ be the state corresponding to the entire string before adding the character $c$.\n    (Initially we set $last = 0$, and we will change $last$ in the last step of the algorithm accordingly.)\n  - Create a new state $cur$, and assign it with $len(cur) = len(last) + 1$.\n    The value $link(cur)$ is not known at the time.\n  - Now we to the following procedure:\n    We start at the state $last$.\n    While there isn't a transition through the letter $c$, we will add a transition to the state $cur$, and follow the suffix link.\n    If at some point there already exists a transition through the letter $c$, then we will stop and denote this state with $p$.\n  - If it haven't found such a state $p$, then we reached the fictitious state $-1$, then we can just assign $link(cur) = 0$ and leave.\n  - Suppose now that we have found a state $p$, from which there exists a transition through the letter $c$.\n    We will denote the state, to which the transition leads,  with $q$.\n  - Now we have two cases. Either $len(p) + 1 = len(q)$, or not.\n  - If $len(p) + 1 = len(q)$, then we can simply assign $link(cur) = q$ and leave.\n  - Otherwise it is a bit more complicated.\n    It is necessary to **clone** the state $q$:\n    we create a new state $clone$, copy all the data from $q$ (suffix link and transition) except the value $len$.\n    We will assign $len(clone) = len(p) + 1$.\n\n    After cloning we direct the suffix link from $cur$ to $clone$, and also from $q$ to clone.\n\n    Finally we need to walk from the state $p$ back using suffix links as long as there is a transition through $c$ to the state $q$, and redirect all those to the state $clone$.\n\n  - In any of the three cases, after completing the procedure, we update the value $last$ with the state $cur$.\n\nIf we also want to know which states are **terminal** and which are not, the we can find all terminal states after constructing the complete suffix automaton for the entire string $s$.\nTo do this, we take the state corresponding to the entire string (stored in the variable $last$), and follow its suffix links until we reach the initial state.\nWe will mark all visited states as terminal.\nIt is easy to understand that by doing so we will mark exactly the states corresponding to all the suffixes of the string $s$, which are exactly the terminal states.\n\nIn the next section we will look in detail at each step and show its **correctness**.\n\nHere we only note that, since we only create one or two new states for each character of $s$, the suffix automaton contains a **linear number of states**.\n\nThe linearity of the number of transitions, and in general the linearity of the runtime of the algorithm is less clear, and they will be proven after we proved the correctness.\n\n### Correctness\n\n  - We will call a transition $(p, q)$ **continuous** if $len(p) + 1 = len(q)$.\n    Otherwise, i.e. when $len(p) + 1 < len(q)$, the transition will be called **non-continuous**.\n\n    As we can see from the description of the algorithm, continuous and non-continuous transitions will lead to different cases of the algorithm.\n    Continuous transitions are fixed, and will never change again.\n    In contrast non-continuous transition may change, when new letters are added to the string (the end of the transition edge may change).\n\n  - To avoid ambiguity we will denote the string, for which the suffix automaton was built before adding the current character $c$, with $s$.\n\n  - The algorithm begins with creating a new state $cur$, which will correspond to the entire string $s + c$.\n    It is clear why we have to create a new state.\n    Together with the new character a new equivalence class is created.\n\n  - After creating a new state we traverse by suffix links starting from the state corresponding to the entire string $s$.\n    For each state we try to add a transition with the character $c$ to the new state $cur$.\n    Thus we append to each suffix of $s$ the character $c$.\n    However we can only add these new transitions, if they don't conflict with an already existing one.\n    Therefore as soon as we find an already existing transition with $c$ we have to stop.\n\n  - In the simplest case we reached the fictitious state $-1$.\n    This means we added the transition with $c$ to all suffixes of $s$.\n    This also means, that the character $c$ hasn't been part of the string $s$ before.\n    Therefore the suffix link of $cur$ has to lead to the state $0$.\n\n  - In the second case we came across an existing transition $(p, q)$.\n    This means that we tried to add a string $x + c$ (where $x$ is a suffix of $s$) to the machine that **already exists** in the machine (the string $x + c$ already appears as a substring of $s$).\n    Since we assume that the automaton for the string $s$ is build correctly, we should not add a new transition here.\n\n    However there is a difficulty.\n    To which state should the suffix link from the state $cur$ lead?\n    We have to make a suffix link to a state, in which the longest string is exactly $x + c$, i.e. the $len$ of this state should be $len(p) + 1$.\n    However it is possible, that such a state doesn't yet exists, i.e. $len(q) > len(p) + 1$.\n    In this case we have to create such a state, by **splitting** the state $q$.\n\n  - If the transition $(p, q)$ turns out to be continuous, then $len(q) = len(p) + 1$.\n    In this case everything is simple.\n    We direct the suffix link from $cur$ to the state $q$.\n\n  - Otherwise the transition is non-continuous, i.e. $len(q) > len(p) + 1$.\n    This means that the state $q$ corresponds to not only the suffix of $s + c$ with length $len(p) + 1$, but also to longer substrings of $s$.\n    We can do nothing other than **splitting** the state $q$ into two sub-states, so that the first one has length $len(p) + 1$.\n\n    How can we split a state?\n    We **clone** the state $q$, which gives us the state $clone$, and we set $len(clone) = len(p) + 1$.\n    We copy all the transitions from $q$ to $clone$, because we don't want to change the paths that traverse through $q$.\n    Also we set the suffix link from $clone$ to the target of the suffix link of $q$, and set the suffix link of $q$ to $clone$.\n\n    And after splitting the state, we set the suffix link from $cur$ to $clone$.\n\n    In the last step we change some of the transitions to $q$, we redirect them to $clone$.\n    Which transitions do we have to change?\n    It is enough to redirect only the transitions corresponding to all the suffixes of the string $w + c$ (where $w$ is the longest string of $p$), i.e. we need to continue to move along the suffix links, starting from the vertex $p$ until we reach the fictitious state $-1$ or a transition that leads to a different state than $q$.\n\n### Linear number of operations\n\nFirst we immediately make the assumption that the size of the alphabet is **constant**.\nIf this is not the case, then it will not be possible to talk about the linear time complexity.\nThe list of transitions from one vertex will be stored in a balanced tree, which allows you to quickly perform key search operations and adding keys.\nTherefore if we denote with $k$ the size of the alphabet, then the asymptotic behavior of the algorithm will be $O(n \\log k)$ with $O(n)$ memory.\nHowever if the alphabet is small enough, then you can sacrifice memory by avoiding balanced trees, and store the transitions at each vertex as an array of length $k$ (for quick searching by key) and a dynamic list (to quickly traverse all available keys).\nThus we reach the $O(n)$ time complexity for the algorithm, but at a cost of $O(n k)$ memory complexity.\n\nSo we will consider the size of the alphabet to be constant, i.e. each operation of searching for a transition on a character, adding a transition, searching for the next transition - all these operations can be done in $O(1)$.\n\nIf we consider all parts of the algorithm, then it contains three places in the algorithm in which the linear complexity is not obvious:\n\n  - The first place is the traversal through the suffix links from the state $last$, adding transitions with the character $c$.\n  - The second place is the copying of transitions when the state $q$ is cloned into a new state $clone$.\n  - Third place is changing the transition leading to $q$, redirecting them to $clone$.\n\nWe use the fact that the size of the suffix automaton (both in number of states and in the number of transitions) is **linear**.\n(The proof of the linearity of the number of states is the algorithm itself, and the proof of linearity of the number of states is given below, after the implementation of the algorithm).\n\nThus the total complexity of the **first and second places** is obvious, after all each operation adds only one amortized new transition to the automaton.\n\nIt remains to estimate the total complexity of the **third place**, in which we redirect transitions, that pointed originally to $q$, to $clone$.\nWe denote $v = longest(p)$.\nThis is a suffix of the string $s$, and with each iteration its length decreases - and therefore the position $v$ as the suffix of the string $s$ increases monotonically with each iteration.\nIn this case, if before the first iteration of the loop, the corresponding string $v$ was at the depth $k$ ($k \\ge 2$) from $last$ (by counting the depth as the number of suffix links), then after the last iteration the string $v + c$ will be a $2$-th suffix link on the path from $cur$ (which will become the new value $last$).\n\nThus, each iteration of this loop leads to the fact that the position of the string $longest(link(link(last))$ as suffix of the current string will monotonically increase.\nTherefore this cycle cannot be executed more than $n$ iterations, which was required to prove.\n\n### Implementation\n\nFirst we describe a data structure that will store all information about a specific transition ($len$, $link$ and the list of transitions).\nIf necessary you can add a terminal flag here, as well as other information.\nWe will store the list of transitions in the form of a $map$, which allows us to achieve total $O(n)$ memory and $O(n \\log k)$ time for processing the entire string.\n\n```{.cpp file=suffix_automaton_struct}\nstruct state {\n    int len, link;\n    map<char, int> next;\n};\n```\n\nThe suffix automaton itself will be stored in an array of these structures $state$.\nWe store the current size $sz$ and also the variable $last$, the state corresponding to the entire string at the moment.\n\n```{.cpp file=suffix_automaton_def}\nconst int MAXLEN = 100000;\nstate st[MAXLEN * 2];\nint sz, last;\n```\n\nWe give a function that initializes a suffix automaton (creating a suffix automaton with a single state).\n\n```{.cpp file=suffix_automaton_init}\nvoid sa_init() {\n    st[0].len = 0;\n    st[0].link = -1;\n    sz++;\n    last = 0;\n}\n```\n\nAnd finally we give the implementation of the main function - which adds the next character to the end of the current line, rebuilding the machine accordingly.\n\n```{.cpp file=suffix_automaton_extend}\nvoid sa_extend(char c) {\n    int cur = sz++;\n    st[cur].len = st[last].len + 1;\n    int p = last;\n    while (p != -1 && !st[p].next.count(c)) {\n        st[p].next[c] = cur;\n        p = st[p].link;\n    }\n    if (p == -1) {\n        st[cur].link = 0;\n    } else {\n        int q = st[p].next[c];\n        if (st[p].len + 1 == st[q].len) {\n            st[cur].link = q;\n        } else {\n            int clone = sz++;\n            st[clone].len = st[p].len + 1;\n            st[clone].next = st[q].next;\n            st[clone].link = st[q].link;\n            while (p != -1 && st[p].next[c] == q) {\n                st[p].next[c] = clone;\n                p = st[p].link;\n            }\n            st[q].link = st[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n```\n\nAs mentioned above, if you sacrifice memory ($O(n k)$, where $k$ is the size of the alphabet), then you can achieve the build time of the machine in $O(n)$, even for any alphabet size $k$.\nBut for this you will have to store an array of size $k$ in each state (for quickly jumping to the transition of the letter), and additional a list of all transitions (to quickly iterate over the transitions them).\n\n## Additional properties\n\n### Number of states\n\nThe number of states in a suffix automaton of the string $s$ of length $n$ **doesn't exceed** $2n - 1$ (for $n \\ge 2$).\n\nThe proof is the construction algorithm itself, since initially the automaton consists of one state, and in the first and second iteration only a single state will be created, and in the remaining $n-2$ steps at most $2$ states will be created each.\n\nHowever we can also **show** this estimation **without knowing the algorithm**.\nLet us recall that the number of states is equal to the number of different sets $endpos$.\nIn addition theses sets $endpos$ form a tree (a parent vertex contains all children sets in his set).\nConsider this tree and transform it a little bit:\nas long as it has an internal vertex with only one child (which means that the set of the child misses at least one position from the parent set), we create a new child with the set of the missing positions.\nIn the end we have a tree in which each inner vertex has a degree greater than one, and the number of leaves does not exceed $n$.\nTherefore there are no more than $2n - 1$ vertices in such a tree.\n\nThis bound of the number of states can actually be achieved for each $n$.\nA possible string is:\n\n$$\\text{\"abbb}\\dots \\text{bbb\"}$$\n\nIn each iteration, starting at the third one, the algorithm will split a state, resulting in exactly $2n - 1$ states.\n\n### Number of transitions\n\nThe number of transitions in a suffix automaton of a string $s$ of length $n$ **doesn't exceed** $3n - 4$ (for $n \\ge 3$).\n\nLet us prove this:\n\nLet us first estimate the number of continuous transitions.\nConsider a spanning tree of the longest paths in the automaton starting in the state $t_0$.\nThis skeleton will consist of only the continuous edges, and therefore their number is less than the number of states, i.e. it does not exceed $2n - 2$.\n\nNow let us estimate the number of non-continuous transitions.\nLet the current non-continuous transition be $(p, q)$ with the character $c$.\nWe take the correspondent string $u + c + w$, where the string $u$ corresponds to the longest path from the initial state to $p$, and $w$ to the longest path from $q$ to any terminal state.\nOn one hand, each such string $u + c + w$ for each incomplete strings will be different (since the strings $u$ and $w$ are formed only by complete transitions).\nOn the other hand each such string $u + c + w$, by the definition of the terminal states, will be a suffix of the entire string $s$.\nSince there are only $n$ non-empty suffixes of $s$, and non of the strings $u + c + w$ can contain $s$ (because the entire string only contains complete transitions), the total number of incomplete transitions does not exceed $n - 1$.\n\nCombining these two estimates gives us the bound $3n - 3$.\nHowever, since the maximum number of states can only be achieved with the test case $\\text{\"abbb\\dots bbb\"}$ and this case has clearly less than $3n - 3$ transitions, we get the tighter bound of $3n - 4$ for the number of transitions in a suffix automaton.\n\nThis bound can also be achieved with the string:\n\n$$\\text{\"abbb}\\dots \\text{bbbc\"}$$\n\n## Applications\n\nHere we look at some tasks that can be solved using the suffix automaton.\nFor the simplicity we assume that the alphabet size $k$ is constant, which allows us to consider the complexity of appending a character and the traversal as constant.\n\n### Check for occurrence\n\nGiven a text $T$, and multiple patters $P$.\nWe have to check whether or not the strings $P$ appear as a substring of $T$.\n\nWe build a suffix automaton of the text $T$ in $O(length(T))$ time.\nTo check if a pattern $P$ appears in $T$, we follow the transitions, starting from $t_0$, according to the characters of $P$.\nIf at some point there doesn't exists a transition, then the pattern $P$ doesn't appear as a substring of $T$.\nIf we can process the entire string $P$ this way, then the string appears in $T$.\n\nIt is clear that this will take $O(length(P))$ time for each string $P$.\nMoreover the algorithm actually finds the length of the longest prefix of $P$ that appears in the text.\n\n### Number of different substrings\n\nGiven a string $S$.\nYou want to compute the number of different substrings.\n\nLet us build a suffix automaton for the string $S$.\n\nEach substring of $S$ corresponds to some path in the automaton.\nTherefore the number of different substrings is equal to the number of different paths in the automaton starting at $t_0$.\n\nGiven that the suffix automaton is a directed acyclic graph, the number of different ways can be computed using dynamic programming.\n\nNamely, let $d[v]$ be the number of ways, starting at the state $v$ (including the path of length zero).\nThen we have the recursion:\n\n$$d[v] = 1 + \\sum_{w : (v, w, c) \\in DAWG} d[w]$$\n\nI.e. $d[v]$ can be expressed as the sum of answers for all ends of the transitions of $v$.\n\nThe number of different substrings is the value $d[t_0] - 1$ (since we don't count the empty substring).\n\nTotal time complexity: $O(length(S))$\n\n\nAlternatively, we can take advantage of the fact that each state $v$ matches to substrings of length $[minlen(v),len(v)]$.\nTherefore, given $minlen(v) = 1 + len(link(v))$, we have total distinct substrings at state $v$ being $len(v) - minlen(v) + 1 = len(v) - (1 + len(link(v))) + 1 = len(v) - len(link(v))$.\n\nThis is demonstrated succinctly below:\n\n```cpp\nlong long get_diff_strings(){\n    long long tot = 0;\n    for(int i = 1; i < sz; i++) {\n        tot += st[i].len - st[st[i].link].len;\n    }\n    return tot;\n}\n```\n\nWhile this is also $O(length(S))$, it requires no extra space and no recursive calls, consequently running faster in practice.\n\n### Total length of all different substrings\n\nGiven a string $S$.\nWe want to compute the total length of all its various substrings.\n\nThe solution is similar to the previous one, only now it is necessary to consider two quantities for the dynamic programming part:\nthe number of different substrings $d[v]$ and their total length $ans[v]$.\n\nWe already described how to compute $d[v]$ in the previous task.\nThe value $ans[v]$ can be computed using the recursion:\n\n$$ans[v] = \\sum_{w : (v, w, c) \\in DAWG} d[w] + ans[w]$$\n\nWe take the answer of each adjacent vertex $w$, and add to it $d[w]$ (since every substrings is one character longer when starting from the state $v$).\n\nAgain this task can be computed in $O(length(S))$ time.\n\nAlternatively, we can, again, take advantage of the fact that each state $v$ matches to substrings of length $[minlen(v),len(v)]$.\nSince $minlen(v) = 1 + len(link(v))$ and the arithmetic series formula $S_n = n \\cdot \\frac{a_1+a_n}{2}$ (where $S_n$ denotes the sum of $n$ terms, $a_1$ representing the first term, and $a_n$ representing the last), we can compute the length of substrings at a state in constant time.  We then sum up these totals for each state $v \\neq t_0$ in the automaton. This is shown by the code below:\n\n```cpp\nlong long get_tot_len_diff_substings() {\n    long long tot = 0;\n    for(int i = 1; i < sz; i++) {\n        long long shortest = st[st[i].link].len + 1;\n        long long longest = st[i].len;\n        \n        long long num_strings = longest - shortest + 1;\n        long long cur = num_strings * (longest + shortest) / 2;\n        tot += cur;\n    }\n    return tot;\n}\n```\n\nThis approaches runs in  $O(length(S))$ time, but experimentally runs 20x faster than the memoized dynamic programming version on randomized strings. It requires no extra space and no recursion.\n\n### Lexicographically $k$-th substring {data-toc-label=\"Lexicographically k-th substring\"}\n\nGiven a string $S$.\nWe have to answer multiple queries.\nFor each given number $K_i$ we have to find the $K_i$-th string in the lexicographically ordered list of all substrings.\n\nThe solution of this problem is based on the idea of the previous two problems.\nThe lexicographically $k$-th substring corresponds to the lexicographically $k$-th path in the suffix automaton.\nTherefore after counting the number of paths from each state, we can easily search for the $k$-th path starting from the root of the automaton.\n\nThis takes $O(length(S))$ time for preprocessing and then $O(length(ans) \\cdot k)$ for each query (where $ans$ is the answer for the query and $k$ is the size of the alphabet).\n\n### Smallest cyclic shift\n\nGiven a string $S$.\nWe want to find the lexicographically smallest cyclic shift.\n\nWe construct a suffix automaton for the string $S + S$.\nThen the automaton will contain in itself as paths all the cyclic shifts of the string $S$.\n\nConsequently the problem is reduced to finding the lexicographically smallest path of length $length(S)$, which can be done in a trivial way: we start in the initial state and greedily pass through the transitions with the minimal character.\n\nTotal time complexity is $O(length(S))$.\n\n### Number of occurrences\n\nFor a given text $T$.\nWe have to answer multiple queries.\nFor each given pattern $P$ we have to find out how many times the string $P$ appears in the string $T$ as substring.\n\nWe construct the suffix automaton for the text $T$.\n\nNext we do the following preprocessing:\nfor each state $v$ in the automaton we calculate the number $cnt[v]$ that is equal to the size of the set $endpos(v)$.\nIn fact all strings corresponding to the same state $v$ appear in the text $T$ an equal amount of times, which is equal to the number of positions in the set $endpos$.\n\nHowever we cannot construct the sets $endpos$ explicitly, therefore we only consider their sizes $cnt$.\n\nTo compute them we proceed as follows.\nFor each state, if it was not created by cloning (and if it is not the initial state $t_0$), we initialize it with $cnt = 1$.\nThen we will go through all states in decreasing order of their length $len$, and add the current value $cnt[v]$ to the suffix links:\n\n$$cnt[link(v)] \\text{ += } cnt[v]$$\n\nThis gives the correct value for each state.\n\nWhy is this correct?\nThe total number of states obtained _not_ via cloning is exactly $length(T)$, and the first $i$ of them appeared when we added the first $i$ characters.\nConsequently for each of these states we count the corresponding position at which it was processed.\nTherefore initially we have $cnt = 1$ for each such state, and $cnt = 0$ for all other.\n\nThen we apply the following operation for each $v$: $cnt[link(v)] \\text{ += } cnt[v]$.\nThe meaning behind this is, that if a string $v$ appears $cnt[v]$ times, then also all its suffixes appear at the exact same end positions, therefore also $cnt[v]$ times.\n\nWhy don't we overcount in this procedure (i.e. don't count some position twice)?\nBecause we add the positions of a state to only one other state, so it can not happen that one state directs its positions to another state twice in two different ways.\n\nThus we can compute the quantities $cnt$ for all states in the automaton in $O(length(T))$ time.\n\nAfter that answering a query by just looking up the value $cnt[t]$, where $t$ is the state corresponding to the pattern, if such a state exists.\nOtherwise answer with $0$.\nAnswering a query takes $O(length(P))$ time.\n\n### First occurrence position\n\nGiven a text $T$ and multiple queries.\nFor each query string $P$ we want to find the position of the first occurrence of $P$ in the string $T$ (the position of the beginning of $P$).\n\nWe again construct a suffix automaton.\nAdditionally we precompute the position $firstpos$ for all states in the automaton, i.e. for each state $v$ we want to find the position $firstpos[v]$ of the end of the first occurrence.\nIn other words, we want to find in advance the minimal element of each set $endpos$ (since obviously cannot maintain all sets $endpos$ explicitly).\n\nTo maintain these positions $firstpos$ we extend the function `sa_extend()`.\nWhen we create a new state $cur$, we set:\n\n$$firstpos(cur) = len(cur) - 1$$\n\nAnd when we clone a vertex $q$ as $clone$, we set:\n\n$$firstpos(clone) = firstpos(q)$$\n\n(since the only other option for a value would be $firstpos(cur)$ which is definitely too big)\n\nThus the answer for a query is simply $firstpos(t) - length(P) + 1$, where $t$ is the state corresponding to the string $P$.\nAnswering a query again takes only $O(length(P))$ time.\n\n### All occurrence positions\n\nThis time we have to display all positions of the occurrences in the string $T$.\n\nAgain we construct a suffix automaton for the text $T$.\nSimilar as in the previous task we compute the position $firstpos$ for all states.\n\nClearly $firstpos(t)$ is part of the answer, if $t$ is the state corresponding to a query string $P$.\nSo we took into account the state of the automaton containing $P$.\nWhat other states do we need to take into account?\nAll states that correspond to strings for which $P$ is a suffix.\nIn other words we need to find all the states that can reach the state $t$ via suffix links.\n\nTherefore to solve the problem we need to save for each state a list of suffix references leading to it.\nThe answer to the query then will then contain all $firstpos$ for each state that we can find on a DFS / BFS starting from the state $t$ using only the suffix references.\n\nThis workaround will work in time $O(answer(P))$, because we will not visit a state twice (because only one suffix link leaves each state, so there cannot be two different paths leading to the same state).\n\nWe only must take into account that two different states can have the same $firstpos$ value.\nThis happens if one state was obtained by cloning another.\nHowever, this doesn't ruin the complexity, since each state can only have at most one clone.\n\nMoreover, we can also get rid of the duplicate positions, if we don't output the positions from the cloned states.\nIn fact a state, that a cloned state can reach, is also reachable from the original state.\nThus if we remember the flag `is_cloned` for each state, we can simply ignore the cloned states and only output $firstpos$ for all other states.\n\nHere are some implementation sketches:\n\n```cpp\nstruct state {\n    ...\n    bool is_clone;\n    int first_pos;\n    vector<int> inv_link;\n};\n\n// after constructing the automaton\nfor (int v = 1; v < sz; v++) {\n    st[st[v].link].inv_link.push_back(v);\n}\n\n// output all positions of occurrences\nvoid output_all_occurrences(int v, int P_length) {\n    if (!st[v].is_clone)\n        cout << st[v].first_pos - P_length + 1 << endl;\n    for (int u : st[v].inv_link)\n        output_all_occurrences(u, P_length);\n}\n```\n\n### Shortest non-appearing string\n\nGiven a string $S$ and a certain alphabet.\nWe have to find a string of smallest length, that doesn't appear in $S$.\n\nWe will apply dynamic programming on the suffix automaton built for the string $S$.\n\nLet $d[v]$ be the answer for the node $v$, i.e. we already processed part of the substring, are currently in the state $v$, and want to find the smallest number of characters that have to be added to find a non-existent transition.\nComputing $d[v]$ is very simple.\nIf there is not transition using at least one character of the alphabet, then $d[v] = 1$.\nOtherwise one character is not enough, and so we need to take the minimum of all answers of all transitions:\n\n$$d[v] = 1 + \\min_{w:(v,w,c) \\in SA} d[w].$$\n\nThe answer to the problem will be $d[t_0]$, and the actual string can be restored using the computed array $d[]$.\n\n### Longest common substring of two strings\n\nGiven two strings $S$ and $T$.\nWe have to find the longest common substring, i.e. such a string $X$ that appears as substring in $S$ and also in $T$.\n\nWe construct a suffix automaton for the string $S$.\n\nWe will now take the string $T$, and for each prefix look for the longest suffix of this prefix in $S$.\nIn other words, for each position in the string $T$, we want to find the longest common substring of $S$ and $T$ ending in that position.\n\nFor this we will use two variables, the **current state** $v$, and the **current length** $l$.\nThese two variables will describe the current matching part: its length and the state that corresponds to it.\n\nInitially $v = t_0$ and $l = 0$, i.e. the match is empty.\n\nNow let us describe how we can add a character $T[i]$ and recalculate the answer for it.\n\n  - If there is a transition from $v$ with the character $T[i]$, then we simply follow the transition and increase $l$ by one.\n  - If there is no such transition, we have to shorten the current matching part, which means that we need to follow the suffix link: $v = link(v)$.\n    At the same time, the current length has to be shortened.\n    Obviously we need to assign $l = len(v)$, since after passing through the suffix link we end up in state whose corresponding longest string is a substring.\n  - If there is still no transition using the required character, we repeat and again go through the suffix link and decrease $l$, until we find a transition or we reach the fictional state $-1$ (which means that the symbol $T[i]$ doesn't appear at all in $S$, so we assign $v = l = 0$).\n\nThe answer to the task will be the maximum of all the values $l$.\n\nThe complexity of this part is $O(length(T))$, since in one move we can either increase $l$ by one, or make several passes through the suffix links, each one ends up reducing the value $l$.\n\nImplementation:\n\n```cpp\nstring lcs (string S, string T) {\n    sa_init();\n    for (int i = 0; i < S.size(); i++)\n        sa_extend(S[i]);\n \n    int v = 0, l = 0, best = 0, bestpos = 0;\n    for (int i = 0; i < T.size(); i++) {\n        while (v && !st[v].next.count(T[i])) {\n            v = st[v].link ;\n            l = st[v].len;\n        }\n        if (st[v].next.count(T[i])) {\n            v = st [v].next[T[i]];\n            l++;\n        }\n        if (l > best) {\n            best = l;\n            bestpos = i;\n        }\n    }\n    return T.substr(bestpos - best + 1, best);\n} \n```\n\n### Largest common substring of multiple strings\n\nThere are $k$ strings $S_i$ given.\nWe have to find the longest common substring, i.e. such a string $X$ that appears as substring in each string $S_i$.\n\nWe join all strings into one large string $T$, separating the strings by a special characters $D_i$ (one for each string):\n\n$$T = S_1 + D_1 + S_2 + D_2 + \\dots + S_k + D_k.$$\n\nThen we construct the suffix automaton for the string $T$.\n\nNow we need to find a string in the machine, which is contained in all the strings $S_i$, and this can be done by using the special added characters.\nNote that if a substring is included in some string $S_j$, then in the suffix automaton exists a path starting from this substring containing the character $D_j$ and not containing the other characters $D_1, \\dots, D_{j-1}, D_{j+1}, \\dots, D_k$.\n\nThus we need to calculate the attainability, which tells us for each state of the machine and each symbol $D_i$ if there exists such a path.\nThis can easily be computed by DFS or BFS and dynamic programming.\nAfter that, the answer to the problem will be the string $longest(v)$ for the state $v$, from which the paths were exists for all special characters.\n\n## Practice Problems\n\n  - [CSES - Finding Patterns](https://cses.fi/problemset/task/2102)\n  - [CSES - Counting Patterns](https://cses.fi/problemset/task/2103)\n  - [CSES - String Matching](https://cses.fi/problemset/task/1753)\n  - [CSES - Patterns Positions](https://cses.fi/problemset/task/2104)\n  - [CSES - Distinct Substrings](https://cses.fi/problemset/task/2105)\n  - [CSES - Word Combinations](https://cses.fi/problemset/task/1731)\n  - [CSES - String Distribution](https://cses.fi/problemset/task/2110)\n  - [AtCoder - K-th Substring](https://atcoder.jp/contests/abc097/tasks/arc097_a)\n  - [SPOJ - SUBLEX](https://www.spoj.com/problems/SUBLEX/)\n  - [Codeforces - Cyclical Quest](https://codeforces.com/problemset/problem/235/C)\n  - [Codeforces - String](https://codeforces.com/contest/128/problem/B)\n", "problem_ids": ["235_C", "128_B"], "title": "Suffix Automaton"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: expressions_parsing\n---\n\n# Expression parsing\n\nA string containing a mathematical expression containing numbers and various operators is given.\nWe have to compute the value of it in $O(n)$, where $n$ is the length of the string.\n\nThe algorithm discussed here translates an expression into the so-called **reverse Polish notation** (explicitly or implicitly), and evaluates this expression.\n\n## Reverse Polish notation\n\nThe reverse Polish notation is a form of writing mathematical expressions, in which the operators are located after their operands.\nFor example the following expression\n\n$$a + b * c * d + (e - f) * (g * h + i)$$\n\ncan be written in reverse Polish notation in the following way:\n\n$$a b c * d * + e f - g h * i + * +$$\n\nThe reverse Polish notation was developed by the Australian philosopher and computer science specialist Charles Hamblin in the mid 1950s on the basis of the Polish notation, which was proposed in 1920 by the Polish mathematician Jan \u0141ukasiewicz.\n\nThe convenience of the reverse Polish notation is, that expressions in this form are very **easy to evaluate** in linear time.\nWe use a stack, which is initially empty.\nWe will iterate over the operands and operators of the expression in reverse Polish notation.\nIf the current element is a number, then we put the value on top of the stack, if the current element is an operator, then we get the top two elements from the stack, perform the operation, and put the result back on top of the stack.\nIn the end there will be exactly one element left in the stack, which will be the value of the expression.\n\nObviously this simple evaluation runs in $O(n)$ time.\n\n## Parsing of simple expressions\n\nFor the time being we only consider a simplified problem:\nwe assume that all operators are **binary** (i.e. they take two arguments), and all are **left-associative** (if the priorities are equal, they get executed from left to right).\nParentheses are allowed.\n\nWe will set up two stacks: one for numbers, and one for operators and parentheses.\nInitially both stacks are empty.\nFor the second stack we will maintain the condition that all operations are ordered by strict descending priority.\nIf there are parenthesis on the stack, than each block of operators (corresponding to one pair of parenthesis) is ordered, and the entire stack is not necessarily ordered.\n\nWe will iterate over the characters of the expression from left to right.\nIf the current character is a digit, then we put the value of this number on the stack.\nIf the current character is an opening parenthesis, then we put it on the stack.\nIf the current character is a closing parenthesis, the we execute all operators on the stack until we reach the opening bracket (in other words we perform all operations inside the parenthesis).\nFinally if the current character is an operator, then while the top of the stack has an operator with the same or higher priority, we will execute this operation, and put the new operation on the stack.\n\nAfter we processed the entire string, some operators might still be in the stack, so we execute them.\n\nHere is the implementation of this method for the four operators $+$ $-$ $*$ $/$:\n\n```{.cpp file=expression_parsing_simple}\nbool delim(char c) {\n    return c == ' ';\n}\n\nbool is_op(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nint priority (char op) {\n    if (op == '+' || op == '-')\n        return 1;\n    if (op == '*' || op == '/')\n        return 2;\n    return -1;\n}\n\nvoid process_op(stack<int>& st, char op) {\n    int r = st.top(); st.pop();\n    int l = st.top(); st.pop();\n    switch (op) {\n        case '+': st.push(l + r); break;\n        case '-': st.push(l - r); break;\n        case '*': st.push(l * r); break;\n        case '/': st.push(l / r); break;\n    }\n}\n\nint evaluate(string& s) {\n    stack<int> st;\n    stack<char> op;\n    for (int i = 0; i < (int)s.size(); i++) {\n        if (delim(s[i]))\n            continue;\n        \n        if (s[i] == '(') {\n            op.push('(');\n        } else if (s[i] == ')') {\n            while (op.top() != '(') {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.pop();\n        } else if (is_op(s[i])) {\n            char cur_op = s[i];\n            while (!op.empty() && priority(op.top()) >= priority(cur_op)) {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.push(cur_op);\n        } else {\n            int number = 0;\n            while (i < (int)s.size() && isalnum(s[i]))\n                number = number * 10 + s[i++] - '0';\n            --i;\n            st.push(number);\n        }\n    }\n\n    while (!op.empty()) {\n        process_op(st, op.top());\n        op.pop();\n    }\n    return st.top();\n}\n```\n\nThus we learned how to calculate the value of an expression in $O(n)$, at the same time we implicitly used the reverse Polish notation.\nBy slightly modifying the above implementation it is also possible to obtain the expression in reverse Polish notation in an explicit form.\n\n## Unary operators\n\nNow suppose that the expression also contains **unary** operators (operators that take one argument).\nThe unary plus and unary minus are common examples of such operators.\n\nOne of the differences in this case, is that we need to determine whether the current operator is a unary or a binary one.\n\nYou can notice, that before an unary operator, there always is another operator or an opening parenthesis, or nothing at all (if it is at the very beginning of the expression).\nOn the contrary before a binary operator there will always be an operand (number) or a closing parenthesis.\nThus it is easy to flag whether the next operator can be unary or not. \n\nAdditionally we need to execute a unary and a binary operator differently.\nAnd we need to chose the priority of a unary operator higher than all of the binary operators.\n\nIn addition it should be noted, that some unary operators (e.g. unary plus and unary minus) are actually **right-associative**.\n\n## Right-associativity\n\nRight-associative means, that whenever the priorities are equal, the operators must be evaluated from right to left.\n\nAs noted above, unary operators are usually right-associative.\nAnother example for an right-associative operator is the exponentiation operator ($a \\wedge b \\wedge c$ is usually perceived as $a^{b^c}$ and not as $(a^b)^c$).\n\nWhat difference do we need to make in order to correctly handle right-associative operators?\nIt turns out that the changes are very minimal.\nThe only difference will be, if the priorities are equal we will postpone the execution of the right-associative operation.\n\nThe only line that needs to be replaced is\n```cpp\nwhile (!op.empty() && priority(op.top()) >= priority(cur_op))\n```\nwith\n```cpp\nwhile (!op.empty() && (\n        (left_assoc(cur_op) && priority(op.top()) >= priority(cur_op)) ||\n        (!left_assoc(cur_op) && priority(op.top()) > priority(cur_op))\n    ))\n```\nwhere `left_assoc` is a function that decides if an operator is left_associative or not.\n\nHere is an implementation for the binary operators $+$ $-$ $*$ $/$ and the unary  operators $+$ and $-$.\n\n```{.cpp file=expression_parsing_unary}\nbool delim(char c) {\n    return c == ' ';\n}\n\nbool is_op(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nbool is_unary(char c) {\n    return c == '+' || c=='-';\n}\n\nint priority (char op) {\n    if (op < 0) // unary operator\n        return 3;\n    if (op == '+' || op == '-')\n        return 1;\n    if (op == '*' || op == '/')\n        return 2;\n    return -1;\n}\n\nvoid process_op(stack<int>& st, char op) {\n    if (op < 0) {\n        int l = st.top(); st.pop();\n        switch (-op) {\n            case '+': st.push(l); break;\n            case '-': st.push(-l); break;\n        }\n    } else {\n        int r = st.top(); st.pop();\n        int l = st.top(); st.pop();\n        switch (op) {\n            case '+': st.push(l + r); break;\n            case '-': st.push(l - r); break;\n            case '*': st.push(l * r); break;\n            case '/': st.push(l / r); break;\n        }\n    }\n}\n\nint evaluate(string& s) {\n    stack<int> st;\n    stack<char> op;\n    bool may_be_unary = true;\n    for (int i = 0; i < (int)s.size(); i++) {\n        if (delim(s[i]))\n            continue;\n        \n        if (s[i] == '(') {\n            op.push('(');\n            may_be_unary = true;\n        } else if (s[i] == ')') {\n            while (op.top() != '(') {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.pop();\n            may_be_unary = false;\n        } else if (is_op(s[i])) {\n            char cur_op = s[i];\n            if (may_be_unary && is_unary(cur_op))\n                cur_op = -cur_op;\n            while (!op.empty() && (\n                    (cur_op >= 0 && priority(op.top()) >= priority(cur_op)) ||\n                    (cur_op < 0 && priority(op.top()) > priority(cur_op))\n                )) {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.push(cur_op);\n            may_be_unary = true;\n        } else {\n            int number = 0;\n            while (i < (int)s.size() && isalnum(s[i]))\n                number = number * 10 + s[i++] - '0';\n            --i;\n            st.push(number);\n            may_be_unary = false;\n        }\n    }\n\n    while (!op.empty()) {\n        process_op(st, op.top());\n        op.pop();\n    }\n    return st.top();\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: expressions_parsing\n---\n\n# Expression parsing\n\nA string containing a mathematical expression containing numbers and various operators is given.\nWe have to compute the value of it in $O(n)$, where $n$ is the length of the string.\n\nThe algorithm discussed here translates an expression into the so-called **reverse Polish notation** (explicitly or implicitly), and evaluates this expression.\n\n## Reverse Polish notation\n\nThe reverse Polish notation is a form of writing mathematical expressions, in which the operators are located after their operands.\nFor example the following expression\n\n$$a + b * c * d + (e - f) * (g * h + i)$$\n\ncan be written in reverse Polish notation in the following way:\n\n$$a b c * d * + e f - g h * i + * +$$\n\nThe reverse Polish notation was developed by the Australian philosopher and computer science specialist Charles Hamblin in the mid 1950s on the basis of the Polish notation, which was proposed in 1920 by the Polish mathematician Jan \u0141ukasiewicz.\n\nThe convenience of the reverse Polish notation is, that expressions in this form are very **easy to evaluate** in linear time.\nWe use a stack, which is initially empty.\nWe will iterate over the operands and operators of the expression in reverse Polish notation.\nIf the current element is a number, then we put the value on top of the stack, if the current element is an operator, then we get the top two elements from the stack, perform the operation, and put the result back on top of the stack.\nIn the end there will be exactly one element left in the stack, which will be the value of the expression.\n\nObviously this simple evaluation runs in $O(n)$ time.\n\n## Parsing of simple expressions\n\nFor the time being we only consider a simplified problem:\nwe assume that all operators are **binary** (i.e. they take two arguments), and all are **left-associative** (if the priorities are equal, they get executed from left to right).\nParentheses are allowed.\n\nWe will set up two stacks: one for numbers, and one for operators and parentheses.\nInitially both stacks are empty.\nFor the second stack we will maintain the condition that all operations are ordered by strict descending priority.\nIf there are parenthesis on the stack, than each block of operators (corresponding to one pair of parenthesis) is ordered, and the entire stack is not necessarily ordered.\n\nWe will iterate over the characters of the expression from left to right.\nIf the current character is a digit, then we put the value of this number on the stack.\nIf the current character is an opening parenthesis, then we put it on the stack.\nIf the current character is a closing parenthesis, the we execute all operators on the stack until we reach the opening bracket (in other words we perform all operations inside the parenthesis).\nFinally if the current character is an operator, then while the top of the stack has an operator with the same or higher priority, we will execute this operation, and put the new operation on the stack.\n\nAfter we processed the entire string, some operators might still be in the stack, so we execute them.\n\nHere is the implementation of this method for the four operators $+$ $-$ $*$ $/$:\n\n```{.cpp file=expression_parsing_simple}\nbool delim(char c) {\n    return c == ' ';\n}\n\nbool is_op(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nint priority (char op) {\n    if (op == '+' || op == '-')\n        return 1;\n    if (op == '*' || op == '/')\n        return 2;\n    return -1;\n}\n\nvoid process_op(stack<int>& st, char op) {\n    int r = st.top(); st.pop();\n    int l = st.top(); st.pop();\n    switch (op) {\n        case '+': st.push(l + r); break;\n        case '-': st.push(l - r); break;\n        case '*': st.push(l * r); break;\n        case '/': st.push(l / r); break;\n    }\n}\n\nint evaluate(string& s) {\n    stack<int> st;\n    stack<char> op;\n    for (int i = 0; i < (int)s.size(); i++) {\n        if (delim(s[i]))\n            continue;\n        \n        if (s[i] == '(') {\n            op.push('(');\n        } else if (s[i] == ')') {\n            while (op.top() != '(') {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.pop();\n        } else if (is_op(s[i])) {\n            char cur_op = s[i];\n            while (!op.empty() && priority(op.top()) >= priority(cur_op)) {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.push(cur_op);\n        } else {\n            int number = 0;\n            while (i < (int)s.size() && isalnum(s[i]))\n                number = number * 10 + s[i++] - '0';\n            --i;\n            st.push(number);\n        }\n    }\n\n    while (!op.empty()) {\n        process_op(st, op.top());\n        op.pop();\n    }\n    return st.top();\n}\n```\n\nThus we learned how to calculate the value of an expression in $O(n)$, at the same time we implicitly used the reverse Polish notation.\nBy slightly modifying the above implementation it is also possible to obtain the expression in reverse Polish notation in an explicit form.\n\n## Unary operators\n\nNow suppose that the expression also contains **unary** operators (operators that take one argument).\nThe unary plus and unary minus are common examples of such operators.\n\nOne of the differences in this case, is that we need to determine whether the current operator is a unary or a binary one.\n\nYou can notice, that before an unary operator, there always is another operator or an opening parenthesis, or nothing at all (if it is at the very beginning of the expression).\nOn the contrary before a binary operator there will always be an operand (number) or a closing parenthesis.\nThus it is easy to flag whether the next operator can be unary or not. \n\nAdditionally we need to execute a unary and a binary operator differently.\nAnd we need to chose the priority of a unary operator higher than all of the binary operators.\n\nIn addition it should be noted, that some unary operators (e.g. unary plus and unary minus) are actually **right-associative**.\n\n## Right-associativity\n\nRight-associative means, that whenever the priorities are equal, the operators must be evaluated from right to left.\n\nAs noted above, unary operators are usually right-associative.\nAnother example for an right-associative operator is the exponentiation operator ($a \\wedge b \\wedge c$ is usually perceived as $a^{b^c}$ and not as $(a^b)^c$).\n\nWhat difference do we need to make in order to correctly handle right-associative operators?\nIt turns out that the changes are very minimal.\nThe only difference will be, if the priorities are equal we will postpone the execution of the right-associative operation.\n\nThe only line that needs to be replaced is\n```cpp\nwhile (!op.empty() && priority(op.top()) >= priority(cur_op))\n```\nwith\n```cpp\nwhile (!op.empty() && (\n        (left_assoc(cur_op) && priority(op.top()) >= priority(cur_op)) ||\n        (!left_assoc(cur_op) && priority(op.top()) > priority(cur_op))\n    ))\n```\nwhere `left_assoc` is a function that decides if an operator is left_associative or not.\n\nHere is an implementation for the binary operators $+$ $-$ $*$ $/$ and the unary  operators $+$ and $-$.\n\n```{.cpp file=expression_parsing_unary}\nbool delim(char c) {\n    return c == ' ';\n}\n\nbool is_op(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nbool is_unary(char c) {\n    return c == '+' || c=='-';\n}\n\nint priority (char op) {\n    if (op < 0) // unary operator\n        return 3;\n    if (op == '+' || op == '-')\n        return 1;\n    if (op == '*' || op == '/')\n        return 2;\n    return -1;\n}\n\nvoid process_op(stack<int>& st, char op) {\n    if (op < 0) {\n        int l = st.top(); st.pop();\n        switch (-op) {\n            case '+': st.push(l); break;\n            case '-': st.push(-l); break;\n        }\n    } else {\n        int r = st.top(); st.pop();\n        int l = st.top(); st.pop();\n        switch (op) {\n            case '+': st.push(l + r); break;\n            case '-': st.push(l - r); break;\n            case '*': st.push(l * r); break;\n            case '/': st.push(l / r); break;\n        }\n    }\n}\n\nint evaluate(string& s) {\n    stack<int> st;\n    stack<char> op;\n    bool may_be_unary = true;\n    for (int i = 0; i < (int)s.size(); i++) {\n        if (delim(s[i]))\n            continue;\n        \n        if (s[i] == '(') {\n            op.push('(');\n            may_be_unary = true;\n        } else if (s[i] == ')') {\n            while (op.top() != '(') {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.pop();\n            may_be_unary = false;\n        } else if (is_op(s[i])) {\n            char cur_op = s[i];\n            if (may_be_unary && is_unary(cur_op))\n                cur_op = -cur_op;\n            while (!op.empty() && (\n                    (cur_op >= 0 && priority(op.top()) >= priority(cur_op)) ||\n                    (cur_op < 0 && priority(op.top()) > priority(cur_op))\n                )) {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.push(cur_op);\n            may_be_unary = true;\n        } else {\n            int number = 0;\n            while (i < (int)s.size() && isalnum(s[i]))\n                number = number * 10 + s[i++] - '0';\n            --i;\n            st.push(number);\n            may_be_unary = false;\n        }\n    }\n\n    while (!op.empty()) {\n        process_op(st, op.top());\n        op.pop();\n    }\n    return st.top();\n}\n```\n\n", "problem_ids": [], "title": "Expression parsing"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: prefix_function\n---\n\n# Prefix function. Knuth\u2013Morris\u2013Pratt algorithm\n\n## Prefix function definition\n\nYou are given a string $s$ of length $n$.\nThe **prefix function** for this string is defined as an array $\\pi$ of length $n$, where $\\pi[i]$ is the length of the longest proper prefix of the substring $s[0 \\dots i]$ which is also a suffix of this substring.\nA proper prefix of a string is a prefix that is not equal to the string itself.\nBy definition, $\\pi[0] = 0$.\n\nMathematically the definition of the prefix function can be written as follows:\n\n$$\\pi[i] = \\max_ {k = 0 \\dots i} \\{k : s[0 \\dots k-1] = s[i-(k-1) \\dots i] \\}$$\n\nFor example, prefix function of string \"abcabcd\" is $[0, 0, 0, 1, 2, 3, 0]$, and prefix function of string \"aabaaab\" is $[0, 1, 0, 1, 2, 2, 3]$.\n\n## Trivial Algorithm\n\nAn algorithm which follows the definition of prefix function exactly is the following:\n\n```{.cpp file=prefix_slow}\nvector<int> prefix_function(string s) {\n    int n = (int)s.length();\n    vector<int> pi(n);\n    for (int i = 0; i < n; i++)\n        for (int k = 0; k <= i; k++)\n            if (s.substr(0, k) == s.substr(i-k+1, k))\n                pi[i] = k;\n    return pi;\n}\n```\n\nIt is easy to see that its complexity is $O(n^3)$, which has room for improvement.\n\n## Efficient Algorithm\n\nThis algorithm was proposed by Knuth and Pratt and independently from them by Morris in 1977. \nIt was used as the main function of a substring search algorithm.\n\n### First optimization\n\nThe first important observation is, that the values of the prefix function can only increase by at most one.\n\nIndeed, otherwise, if $\\pi[i + 1] \\gt \\pi[i] + 1$, then we can take this suffix ending in position $i + 1$ with the length $\\pi[i + 1]$ and remove the last character from it.\nWe end up with a suffix ending in position $i$ with the length $\\pi[i + 1] - 1$, which is better than $\\pi[i]$, i.e. we get a contradiction.\n\nThe following illustration shows this contradiction.\nThe longest proper suffix at position $i$ that also is a prefix is of length $2$, and at position $i+1$ it is of length $4$.\nTherefore the string $s_0 ~ s_1 ~ s_2 ~ s_3$ is equal to the string $s_{i-2} ~ s_{i-1} ~ s_i ~ s_{i+1}$, which means that also the strings $s_0 ~ s_1 ~ s_2$ and $s_{i-2} ~ s_{i-1} ~ s_i$ are equal, therefore $\\pi[i]$ has to be $3$.\n\n$$\\underbrace{\\overbrace{s_0 ~ s_1}^{\\pi[i] = 2} ~ s_2 ~ s_3}_{\\pi[i+1] = 4} ~ \\dots ~ \\underbrace{s_{i-2} ~ \\overbrace{s_{i-1} ~ s_{i}}^{\\pi[i] = 2} ~ s_{i+1}}_{\\pi[i+1] = 4}$$\n\nThus when moving to the next position, the value of the prefix function can either increase by one, stay the same, or decrease by some amount.\nThis fact already allows us to reduce the complexity of the algorithm to $O(n^2)$, because in one step the prefix function can grow at most by one.\nIn total the function can grow at most $n$ steps, and therefore also only can decrease a total of $n$ steps.\nThis means we only have to perform $O(n)$ string comparisons, and reach the complexity $O(n^2)$.\n\n### Second optimization\n\nLet's go further, we want to get rid of the string comparisons.\nTo accomplish this, we have to use all the information computed in the previous steps.\n\nSo let us compute the value of the prefix function $\\pi$ for $i + 1$.\nIf $s[i+1] = s[\\pi[i]]$, then we can say with certainty that $\\pi[i+1] = \\pi[i] + 1$, since we already know that the suffix at position $i$ of length $\\pi[i]$ is equal to the prefix of length $\\pi[i]$.\nThis is illustrated again with an example.\n\n$$\\underbrace{\\overbrace{s_0 ~ s_1 ~ s_2}^{\\pi[i]} ~ \\overbrace{s_3}^{s_3 = s_{i+1}}}_{\\pi[i+1] = \\pi[i] + 1} ~ \\dots ~ \\underbrace{\\overbrace{s_{i-2} ~ s_{i-1} ~ s_{i}}^{\\pi[i]} ~ \\overbrace{s_{i+1}}^{s_3 = s_{i + 1}}}_{\\pi[i+1] = \\pi[i] + 1}$$\n\nIf this is not the case, $s[i+1] \\neq s[\\pi[i]]$, then we need to try a shorter string.\nIn order to speed things up, we would like to immediately move to the longest length $j \\lt \\pi[i]$, such that the prefix property in the position $i$ holds, i.e. $s[0 \\dots j-1] = s[i-j+1 \\dots i]$:\n\n$$\\overbrace{\\underbrace{s_0 ~ s_1}_j ~ s_2 ~ s_3}^{\\pi[i]} ~ \\dots ~ \\overbrace{s_{i-3} ~ s_{i-2} ~ \\underbrace{s_{i-1} ~ s_{i}}_j}^{\\pi[i]} ~ s_{i+1}$$\n\nIndeed, if we find such a length $j$, then we again only need to compare the characters $s[i+1]$ and $s[j]$.\nIf they are equal, then we can assign $\\pi[i+1] = j + 1$.\nOtherwise we will need to find the largest value smaller than $j$, for which the prefix property holds, and so on.\nIt can happen that this goes until $j = 0$.\nIf then $s[i+1] = s[0]$, we assign $\\pi[i+1] = 1$, and $\\pi[i+1] = 0$ otherwise.\n\nSo we already have a general scheme of the algorithm.\nThe only question left is how do we effectively find the lengths for $j$.\nLet's recap:\nfor the current length $j$ at the position $i$ for which the prefix property holds, i.e. $s[0 \\dots j-1] = s[i-j+1 \\dots i]$, we want to find the greatest $k \\lt j$, for which the prefix property holds.\n\n$$\\overbrace{\\underbrace{s_0 ~ s_1}_k ~ s_2 ~ s_3}^j ~ \\dots ~ \\overbrace{s_{i-3} ~ s_{i-2} ~ \\underbrace{s_{i-1} ~ s_{i}}_k}^j ~s_{i+1}$$\n\nThe illustration shows, that this has to be the value of $\\pi[j-1]$, which we already calculated earlier.\n\n### Final algorithm\n\nSo we finally can build an algorithm that doesn't perform any string comparisons and only performs $O(n)$ actions.\n\nHere is the final procedure:\n\n- We compute the prefix values $\\pi[i]$ in a loop by iterating from $i = 1$ to $i = n-1$ ($\\pi[0]$ just gets assigned with $0$).\n- To calculate the current value $\\pi[i]$ we set the variable $j$ denoting the length of the best suffix for $i-1$. Initially $j = \\pi[i-1]$.\n- Test if the suffix of length $j+1$ is also a prefix by comparing $s[j]$ and $s[i]$.\nIf they are equal then we assign $\\pi[i] = j + 1$, otherwise we reduce $j$ to $\\pi[j-1]$ and repeat this step.\n- If we have reached the length $j = 0$ and still don't have a match, then we assign $\\pi[i] = 0$ and go to the next index $i + 1$.\n\n### Implementation\n\nThe implementation ends up being surprisingly short and expressive.\n\n```{.cpp file=prefix_fast}\nvector<int> prefix_function(string s) {\n    int n = (int)s.length();\n    vector<int> pi(n);\n    for (int i = 1; i < n; i++) {\n        int j = pi[i-1];\n        while (j > 0 && s[i] != s[j])\n            j = pi[j-1];\n        if (s[i] == s[j])\n            j++;\n        pi[i] = j;\n    }\n    return pi;\n}\n```\n\nThis is an **online** algorithm, i.e. it processes the data as it arrives - for example, you can read the string characters one by one and process them immediately, finding the value of prefix function for each next character.\nThe algorithm still requires storing the string itself and the previously calculated values of prefix function, but if we know beforehand the maximum value $M$ the prefix function can take on the string, we can store only $M+1$ first characters of the string and the same number of values of the prefix function.\n\n## Applications\n\n### Search for a substring in a string. The Knuth-Morris-Pratt algorithm\n\nThe task is the classical application of the prefix function.\n\nGiven a text $t$ and a string $s$, we want to find and display the positions of all occurrences of the string $s$ in the text $t$.\n\nFor convenience we denote with $n$ the length of the string s and with $m$ the length of the text $t$.\n\nWe generate the string $s + \\# + t$, where $\\#$ is a separator that appears neither in $s$ nor in $t$.\nLet us calculate the prefix function for this string.\nNow think about the meaning of the values of the prefix function, except for the first $n + 1$ entries (which belong to the string $s$ and the separator).\nBy definition the value $\\pi[i]$ shows the longest length of a substring ending in position $i$ that coincides with the prefix.\nBut in our case this is nothing more than the largest block that coincides with $s$ and ends at position $i$.\nThis length cannot be bigger than $n$ due to the separator.\nBut if equality $\\pi[i] = n$ is achieved, then it means that the string $s$ appears completely in at this position, i.e. it ends at position $i$.\nJust do not forget that the positions are indexed in the string $s + \\# + t$.\n\nThus if at some position $i$ we have $\\pi[i] = n$, then at the position $i - (n + 1) - n + 1 = i - 2n$ in the string $t$ the string $s$ appears.\n\nAs already mentioned in the description of the prefix function computation, if we know that the prefix values never exceed a certain value, then we do not need to store the entire string and the entire function, but only its beginning.\nIn our case this means that we only need to store the string $s + \\#$ and the values of the prefix function for it.\nWe can read one character at a time of the string $t$ and calculate the current value of the prefix function.\n\nThus the Knuth-Morris-Pratt algorithm solves the problem in $O(n + m)$ time and $O(n)$ memory.\n\n### Counting the number of occurrences of each prefix\n\nHere we discuss two problems at once.\nGiven a string $s$ of length $n$.\nIn the first variation of the problem we want to count the number of appearances of each prefix $s[0 \\dots i]$ in the same string.\nIn the second variation of the problem another string $t$ is given and we want to count the number of appearances of each prefix $s[0 \\dots i]$ in $t$.\n\nFirst we solve the first problem.\nConsider the value of the prefix function $\\pi[i]$ at a position $i$.\nBy definition it means that the prefix of length $\\pi[i]$ of the string $s$ occurs and ends at position $i$, and there is no longer prefix that follows this definition.\nAt the same time shorter prefixes can end at this position.\nIt is not difficult to see, that we have the same question that we already answered when we computed the prefix function itself:\nGiven a prefix of length $j$ that is a suffix ending at position $i$, what is the next smaller prefix $\\lt j$ that is also a suffix ending at position $i$.\nThus at the position $i$ ends the prefix of length $\\pi[i]$, the prefix of length $\\pi[\\pi[i] - 1]$, the prefix $\\pi[\\pi[\\pi[i] - 1] - 1]$, and so on, until the index becomes zero.\nThus we can compute the answer in the following way.\n\n```{.cpp file=prefix_count_each_prefix}\nvector<int> ans(n + 1);\nfor (int i = 0; i < n; i++)\n    ans[pi[i]]++;\nfor (int i = n-1; i > 0; i--)\n    ans[pi[i-1]] += ans[i];\nfor (int i = 0; i <= n; i++)\n    ans[i]++;\n```\n\nHere for each value of the prefix function we first count how many times it occurs in the array $\\pi$, and then compute the final answers:\nif we know that the length prefix $i$ appears exactly $\\text{ans}[i]$ times, then this number must be added to the number of occurrences of its longest suffix that is also a prefix.\nAt the end we need to add $1$ to each result, since we also need to count the original prefixes also.\n\nNow let us consider the second problem.\nWe apply the trick from Knuth-Morris-Pratt:\nwe create the string $s + \\# + t$ and compute its prefix function.\nThe only differences to the first task is, that we are only interested in the prefix values that relate to the string $t$, i.e. $\\pi[i]$ for $i \\ge n + 1$.\nWith those values we can perform the exact same computations as in the first task.\n\n### The number of different substring in a string\n\nGiven a string $s$ of length $n$.\nWe want to compute the number of different substrings appearing in it.\n\nWe will solve this problem iteratively.\nNamely we will learn, knowing the current number of different substrings, how to recompute this count by adding a character to the end.\n\nSo let $k$ be the current number of different substrings in $s$, and we add the character $c$ to the end of $s$.\nObviously some new substrings ending in $c$ will appear.\nWe want to count these new substrings that didn't appear before.\n\nWe take the string $t = s + c$ and reverse it.\nNow the task is transformed into computing how many prefixes there are that don't appear anywhere else.\nIf we compute the maximal value of the prefix function $\\pi_{\\text{max}}$ of the reversed string $t$, then the longest prefix that appears in $s$ is $\\pi_{\\text{max}}$ long.\nClearly also all prefixes of smaller length appear in it.\n\nTherefore the number of new substrings appearing when we add a new character $c$ is $|s| + 1 - \\pi_{\\text{max}}$.\n\nSo for each character appended we can compute the number of new substrings in $O(n)$ times, which gives a time complexity of $O(n^2)$ in total.\n\nIt is worth noting, that we can also compute the number of different substrings by appending the characters at the beginning, or by deleting characters from the beginning or the end.\n\n### Compressing a string\n\nGiven a string $s$ of length $n$.\nWe want to find the shortest \"compressed\" representation of the string, i.e. we want to find a string $t$ of smallest length such that $s$ can be represented as a concatenation of one or more copies of $t$.\n\nIt is clear, that we only need to find the length of $t$. Knowing the length, the answer to the problem will be the prefix of $s$ with this length.\n\nLet us compute the prefix function for $s$.\nUsing the last value of it we define the value $k = n - \\pi[n - 1]$.\nWe will show, that if $k$ divides $n$, then $k$ will be the answer, otherwise there is no effective compression and the answer is $n$.\n\nLet $n$ be divisible by $k$.\nThen the string can be partitioned into blocks of the length $k$.\nBy definition of the prefix function, the prefix of length $n - k$ will be equal with its suffix.\nBut this means that the last block is equal to the block before.\nAnd the block before has to be equal to the block before it.\nAnd so on.\nAs a result, it turns out that all blocks are equal, therefore we can compress the string $s$ to length $k$.\n\nOf course we still need to show that this is actually the optimum.\nIndeed, if there was a smaller compression than $k$, than the prefix function at the end would be greater than $n - k$.\nTherefore $k$ is really the answer.\n\nNow let us assume that $n$ is not divisible by $k$.\nWe show that this implies that the length of the answer is $n$.\nWe prove it by contradiction.\nAssuming there exists an answer, and the compression has length $p$ ($p$ divides $n$).\nThen the last value of the prefix function has to be greater than $n - p$, i.e. the suffix will partially cover the first block.\nNow consider the second block of the string.\nSince the prefix is equal with the suffix, and both the prefix and the suffix cover this block and their displacement relative to each other $k$ does not divide the block length $p$ (otherwise $k$ divides $n$), then all the characters of the block have to be identical.\nBut then the string consists of only one character repeated over and over, hence we can compress it to a string of size $1$, which gives $k = 1$, and $k$ divides $n$.\nContradiction.\n\n$$\\overbrace{s_0 ~ s_1 ~ s_2 ~ s_3}^p ~ \\overbrace{s_4 ~ s_5 ~ s_6 ~ s_7}^p$$\n\n$$s_0 ~ s_1 ~ s_2 ~ \\underbrace{\\overbrace{s_3 ~ s_4 ~ s_5 ~ s_6}^p ~ s_7}_{\\pi[7] = 5}$$\n\n$$s_4 = s_3, ~ s_5 = s_4, ~ s_6 = s_5, ~ s_7 = s_6 ~ \\Rightarrow ~ s_0 = s_1 = s_2 = s_3$$\n\n### Building an automaton according to the prefix function\n\nLet's return to the concatenation to the two strings through a separator, i.e. for the strings $s$ and $t$ we compute the prefix function for the string $s + \\# + t$.\nObviously, since $\\#$ is a separator, the value of the prefix function will never exceed $|s|$.\nIt follows, that it is sufficient to only store the string $s + \\#$ and the values of the prefix function for it, and we can compute the prefix function for all subsequent character on the fly:\n\n$$\\underbrace{s_0 ~ s_1 ~ \\dots ~ s_{n-1} ~ \\#}_{\\text{need to store}} ~ \\underbrace{t_0 ~ t_1 ~ \\dots ~ t_{m-1}}_{\\text{do not need to store}}$$\n\nIndeed, in such a situation, knowing the next character $c \\in t$ and the value of the prefix function of the previous position is enough information to compute the next value of the prefix function, without using any previous characters of the string $t$ and the value of the prefix function in them.\n\nIn other words, we can construct an **automaton** (a finite state machine): the state in it is the current value of the prefix function, and the transition from one state to another will be performed via the next character.\n\nThus, even without having the string $t$, we can construct such a transition table $(\\text{old}_\\pi, c) \\rightarrow \\text{new}_\\pi$ using the same algorithm as for calculating the transition table:\n\n```{.cpp file=prefix_automaton_slow}\nvoid compute_automaton(string s, vector<vector<int>>& aut) {\n    s += '#';\n    int n = s.size();\n    vector<int> pi = prefix_function(s);\n    aut.assign(n, vector<int>(26));\n    for (int i = 0; i < n; i++) {\n        for (int c = 0; c < 26; c++) {\n            int j = i;\n            while (j > 0 && 'a' + c != s[j])\n                j = pi[j-1];\n            if ('a' + c == s[j])\n                j++;\n            aut[i][c] = j;\n        }\n    }\n}\n```\n\nHowever in this form the algorithm runs in $O(n^2 26)$ time for the lowercase letters of the alphabet.\nNote that we can apply dynamic programming and use the already calculated parts of the table.\nWhenever we go from the value $j$ to the value $\\pi[j-1]$, we actually mean that the transition $(j, c)$ leads to the same state as the transition as $(\\pi[j-1], c)$, and this answer is already accurately computed.\n\n```{.cpp file=prefix_automaton_fast}\nvoid compute_automaton(string s, vector<vector<int>>& aut) {\n    s += '#';\n    int n = s.size();\n    vector<int> pi = prefix_function(s);\n    aut.assign(n, vector<int>(26));\n    for (int i = 0; i < n; i++) {\n        for (int c = 0; c < 26; c++) {\n            if (i > 0 && 'a' + c != s[i])\n                aut[i][c] = aut[pi[i-1]][c];\n            else\n                aut[i][c] = i + ('a' + c == s[i]);\n        }\n    }\n}\n```\n\nAs a result we construct the automaton in $O(26 n)$ time.\n\nWhen is such a automaton useful?\nTo begin with, remember that we use the prefix function for the string $s + \\# + t$ and its values mostly for a single purpose: find all occurrences of the string $s$ in the string $t$.\n\nTherefore the most obvious benefit of this automaton is the **acceleration of calculating the prefix function** for the string $s + \\# + t$.\nBy building the automaton for $s + \\#$, we no longer need to store the string $s$ or the values of the prefix function in it.\nAll transitions are already computed in the table.\n\nBut there is a second, less obvious, application.\nWe can use the automaton when the string $t$ is a **gigantic string constructed using some rules**.\nThis can for instance be the Gray strings, or a string formed by a recursive combination of several short strings from the input.\n\nFor completeness we will solve such a problem:\ngiven a number $k \\le 10^5$ and a string $s$ of length $\\le 10^5$.\nWe have to compute the number of occurrences of $s$ in the $k$-th Gray string.\nRecall that Gray's strings are define in the following way:\n\n$$\\begin{align}\ng_1 &= \\text{\"a\"}\\\\\ng_2 &= \\text{\"aba\"}\\\\\ng_3 &= \\text{\"abacaba\"}\\\\\ng_4 &= \\text{\"abacabadabacaba\"}\n\\end{align}$$\n\nIn such cases even constructing the string $t$ will be impossible, because of its astronomical length.\nThe $k$-th Gray string is $2^k-1$ characters long.\nHowever we can calculate the value of the prefix function at the end of the string effectively, by only knowing the value of the prefix function at the start.\n\nIn addition to the automaton itself, we also compute values $G[i][j]$ - the value of the automaton after processing the string $g_i$ starting with the state $j$.\nAnd additionally we compute values $K[i][j]$ - the number of occurrences of $s$ in $g_i$, before during the processing of $g_i$ starting with the state $j$.\nActually $K[i][j]$ is the number of times that the prefix function took the value $|s|$ while performing the operations.\nThe answer to the problem will then be $K[k][0]$.\n\nHow can we compute these values?\nFirst the basic values are $G[0][j] = j$ and $K[0][j] = 0$.\nAnd all subsequent values can be calculated from the previous values and using the automaton.\nTo calculate the value for some $i$ we remember that the string $g_i$ consists of $g_{i-1}$, the $i$ character of the alphabet, and $g_{i-1}$.\nThus the automaton will go into the state:\n\n$$\\text{mid} = \\text{aut}[G[i-1][j]][i]$$\n\n$$G[i][j] = G[i-1][\\text{mid}]$$\n\nThe values for $K[i][j]$ can also be easily counted.\n\n$$K[i][j] = K[i-1][j] + (\\text{mid} == |s|) + K[i-1][\\text{mid}]$$\n\nSo we can solve the problem for Gray strings, and similarly also a huge number of other similar problems.\nFor example the exact same method also solves the following problem:\nwe are given a string $s$ and some patterns $t_i$, each of which is specified as follows:\nit is a string of ordinary characters, and there might be some recursive insertions of the previous strings of the form $t_k^{\\text{cnt}}$, which means that at this place we have to insert the string $t_k$ $\\text{cnt}$ times.\nAn example of such patterns:\n\n$$\\begin{align}\nt_1 &= \\text{\"abdeca\"}\\\\\nt_2 &= \\text{\"abc\"} + t_1^{30} + \\text{\"abd\"}\\\\\nt_3 &= t_2^{50} + t_1^{100}\\\\\nt_4 &= t_2^{10} + t_3^{100}\n\\end{align}$$\n\nThe recursive substitutions blow the string up, so that their lengths can reach the order of $100^{100}$.\n\nWe have to find the number of times the string $s$ appears in each of the strings.\n\nThe problem can be solved in the same way by constructing the automaton of the prefix function, and then we calculate the transitions in for each pattern by using the previous results.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: prefix_function\n---\n\n# Prefix function. Knuth\u2013Morris\u2013Pratt algorithm\n\n## Prefix function definition\n\nYou are given a string $s$ of length $n$.\nThe **prefix function** for this string is defined as an array $\\pi$ of length $n$, where $\\pi[i]$ is the length of the longest proper prefix of the substring $s[0 \\dots i]$ which is also a suffix of this substring.\nA proper prefix of a string is a prefix that is not equal to the string itself.\nBy definition, $\\pi[0] = 0$.\n\nMathematically the definition of the prefix function can be written as follows:\n\n$$\\pi[i] = \\max_ {k = 0 \\dots i} \\{k : s[0 \\dots k-1] = s[i-(k-1) \\dots i] \\}$$\n\nFor example, prefix function of string \"abcabcd\" is $[0, 0, 0, 1, 2, 3, 0]$, and prefix function of string \"aabaaab\" is $[0, 1, 0, 1, 2, 2, 3]$.\n\n## Trivial Algorithm\n\nAn algorithm which follows the definition of prefix function exactly is the following:\n\n```{.cpp file=prefix_slow}\nvector<int> prefix_function(string s) {\n    int n = (int)s.length();\n    vector<int> pi(n);\n    for (int i = 0; i < n; i++)\n        for (int k = 0; k <= i; k++)\n            if (s.substr(0, k) == s.substr(i-k+1, k))\n                pi[i] = k;\n    return pi;\n}\n```\n\nIt is easy to see that its complexity is $O(n^3)$, which has room for improvement.\n\n## Efficient Algorithm\n\nThis algorithm was proposed by Knuth and Pratt and independently from them by Morris in 1977. \nIt was used as the main function of a substring search algorithm.\n\n### First optimization\n\nThe first important observation is, that the values of the prefix function can only increase by at most one.\n\nIndeed, otherwise, if $\\pi[i + 1] \\gt \\pi[i] + 1$, then we can take this suffix ending in position $i + 1$ with the length $\\pi[i + 1]$ and remove the last character from it.\nWe end up with a suffix ending in position $i$ with the length $\\pi[i + 1] - 1$, which is better than $\\pi[i]$, i.e. we get a contradiction.\n\nThe following illustration shows this contradiction.\nThe longest proper suffix at position $i$ that also is a prefix is of length $2$, and at position $i+1$ it is of length $4$.\nTherefore the string $s_0 ~ s_1 ~ s_2 ~ s_3$ is equal to the string $s_{i-2} ~ s_{i-1} ~ s_i ~ s_{i+1}$, which means that also the strings $s_0 ~ s_1 ~ s_2$ and $s_{i-2} ~ s_{i-1} ~ s_i$ are equal, therefore $\\pi[i]$ has to be $3$.\n\n$$\\underbrace{\\overbrace{s_0 ~ s_1}^{\\pi[i] = 2} ~ s_2 ~ s_3}_{\\pi[i+1] = 4} ~ \\dots ~ \\underbrace{s_{i-2} ~ \\overbrace{s_{i-1} ~ s_{i}}^{\\pi[i] = 2} ~ s_{i+1}}_{\\pi[i+1] = 4}$$\n\nThus when moving to the next position, the value of the prefix function can either increase by one, stay the same, or decrease by some amount.\nThis fact already allows us to reduce the complexity of the algorithm to $O(n^2)$, because in one step the prefix function can grow at most by one.\nIn total the function can grow at most $n$ steps, and therefore also only can decrease a total of $n$ steps.\nThis means we only have to perform $O(n)$ string comparisons, and reach the complexity $O(n^2)$.\n\n### Second optimization\n\nLet's go further, we want to get rid of the string comparisons.\nTo accomplish this, we have to use all the information computed in the previous steps.\n\nSo let us compute the value of the prefix function $\\pi$ for $i + 1$.\nIf $s[i+1] = s[\\pi[i]]$, then we can say with certainty that $\\pi[i+1] = \\pi[i] + 1$, since we already know that the suffix at position $i$ of length $\\pi[i]$ is equal to the prefix of length $\\pi[i]$.\nThis is illustrated again with an example.\n\n$$\\underbrace{\\overbrace{s_0 ~ s_1 ~ s_2}^{\\pi[i]} ~ \\overbrace{s_3}^{s_3 = s_{i+1}}}_{\\pi[i+1] = \\pi[i] + 1} ~ \\dots ~ \\underbrace{\\overbrace{s_{i-2} ~ s_{i-1} ~ s_{i}}^{\\pi[i]} ~ \\overbrace{s_{i+1}}^{s_3 = s_{i + 1}}}_{\\pi[i+1] = \\pi[i] + 1}$$\n\nIf this is not the case, $s[i+1] \\neq s[\\pi[i]]$, then we need to try a shorter string.\nIn order to speed things up, we would like to immediately move to the longest length $j \\lt \\pi[i]$, such that the prefix property in the position $i$ holds, i.e. $s[0 \\dots j-1] = s[i-j+1 \\dots i]$:\n\n$$\\overbrace{\\underbrace{s_0 ~ s_1}_j ~ s_2 ~ s_3}^{\\pi[i]} ~ \\dots ~ \\overbrace{s_{i-3} ~ s_{i-2} ~ \\underbrace{s_{i-1} ~ s_{i}}_j}^{\\pi[i]} ~ s_{i+1}$$\n\nIndeed, if we find such a length $j$, then we again only need to compare the characters $s[i+1]$ and $s[j]$.\nIf they are equal, then we can assign $\\pi[i+1] = j + 1$.\nOtherwise we will need to find the largest value smaller than $j$, for which the prefix property holds, and so on.\nIt can happen that this goes until $j = 0$.\nIf then $s[i+1] = s[0]$, we assign $\\pi[i+1] = 1$, and $\\pi[i+1] = 0$ otherwise.\n\nSo we already have a general scheme of the algorithm.\nThe only question left is how do we effectively find the lengths for $j$.\nLet's recap:\nfor the current length $j$ at the position $i$ for which the prefix property holds, i.e. $s[0 \\dots j-1] = s[i-j+1 \\dots i]$, we want to find the greatest $k \\lt j$, for which the prefix property holds.\n\n$$\\overbrace{\\underbrace{s_0 ~ s_1}_k ~ s_2 ~ s_3}^j ~ \\dots ~ \\overbrace{s_{i-3} ~ s_{i-2} ~ \\underbrace{s_{i-1} ~ s_{i}}_k}^j ~s_{i+1}$$\n\nThe illustration shows, that this has to be the value of $\\pi[j-1]$, which we already calculated earlier.\n\n### Final algorithm\n\nSo we finally can build an algorithm that doesn't perform any string comparisons and only performs $O(n)$ actions.\n\nHere is the final procedure:\n\n- We compute the prefix values $\\pi[i]$ in a loop by iterating from $i = 1$ to $i = n-1$ ($\\pi[0]$ just gets assigned with $0$).\n- To calculate the current value $\\pi[i]$ we set the variable $j$ denoting the length of the best suffix for $i-1$. Initially $j = \\pi[i-1]$.\n- Test if the suffix of length $j+1$ is also a prefix by comparing $s[j]$ and $s[i]$.\nIf they are equal then we assign $\\pi[i] = j + 1$, otherwise we reduce $j$ to $\\pi[j-1]$ and repeat this step.\n- If we have reached the length $j = 0$ and still don't have a match, then we assign $\\pi[i] = 0$ and go to the next index $i + 1$.\n\n### Implementation\n\nThe implementation ends up being surprisingly short and expressive.\n\n```{.cpp file=prefix_fast}\nvector<int> prefix_function(string s) {\n    int n = (int)s.length();\n    vector<int> pi(n);\n    for (int i = 1; i < n; i++) {\n        int j = pi[i-1];\n        while (j > 0 && s[i] != s[j])\n            j = pi[j-1];\n        if (s[i] == s[j])\n            j++;\n        pi[i] = j;\n    }\n    return pi;\n}\n```\n\nThis is an **online** algorithm, i.e. it processes the data as it arrives - for example, you can read the string characters one by one and process them immediately, finding the value of prefix function for each next character.\nThe algorithm still requires storing the string itself and the previously calculated values of prefix function, but if we know beforehand the maximum value $M$ the prefix function can take on the string, we can store only $M+1$ first characters of the string and the same number of values of the prefix function.\n\n## Applications\n\n### Search for a substring in a string. The Knuth-Morris-Pratt algorithm\n\nThe task is the classical application of the prefix function.\n\nGiven a text $t$ and a string $s$, we want to find and display the positions of all occurrences of the string $s$ in the text $t$.\n\nFor convenience we denote with $n$ the length of the string s and with $m$ the length of the text $t$.\n\nWe generate the string $s + \\# + t$, where $\\#$ is a separator that appears neither in $s$ nor in $t$.\nLet us calculate the prefix function for this string.\nNow think about the meaning of the values of the prefix function, except for the first $n + 1$ entries (which belong to the string $s$ and the separator).\nBy definition the value $\\pi[i]$ shows the longest length of a substring ending in position $i$ that coincides with the prefix.\nBut in our case this is nothing more than the largest block that coincides with $s$ and ends at position $i$.\nThis length cannot be bigger than $n$ due to the separator.\nBut if equality $\\pi[i] = n$ is achieved, then it means that the string $s$ appears completely in at this position, i.e. it ends at position $i$.\nJust do not forget that the positions are indexed in the string $s + \\# + t$.\n\nThus if at some position $i$ we have $\\pi[i] = n$, then at the position $i - (n + 1) - n + 1 = i - 2n$ in the string $t$ the string $s$ appears.\n\nAs already mentioned in the description of the prefix function computation, if we know that the prefix values never exceed a certain value, then we do not need to store the entire string and the entire function, but only its beginning.\nIn our case this means that we only need to store the string $s + \\#$ and the values of the prefix function for it.\nWe can read one character at a time of the string $t$ and calculate the current value of the prefix function.\n\nThus the Knuth-Morris-Pratt algorithm solves the problem in $O(n + m)$ time and $O(n)$ memory.\n\n### Counting the number of occurrences of each prefix\n\nHere we discuss two problems at once.\nGiven a string $s$ of length $n$.\nIn the first variation of the problem we want to count the number of appearances of each prefix $s[0 \\dots i]$ in the same string.\nIn the second variation of the problem another string $t$ is given and we want to count the number of appearances of each prefix $s[0 \\dots i]$ in $t$.\n\nFirst we solve the first problem.\nConsider the value of the prefix function $\\pi[i]$ at a position $i$.\nBy definition it means that the prefix of length $\\pi[i]$ of the string $s$ occurs and ends at position $i$, and there is no longer prefix that follows this definition.\nAt the same time shorter prefixes can end at this position.\nIt is not difficult to see, that we have the same question that we already answered when we computed the prefix function itself:\nGiven a prefix of length $j$ that is a suffix ending at position $i$, what is the next smaller prefix $\\lt j$ that is also a suffix ending at position $i$.\nThus at the position $i$ ends the prefix of length $\\pi[i]$, the prefix of length $\\pi[\\pi[i] - 1]$, the prefix $\\pi[\\pi[\\pi[i] - 1] - 1]$, and so on, until the index becomes zero.\nThus we can compute the answer in the following way.\n\n```{.cpp file=prefix_count_each_prefix}\nvector<int> ans(n + 1);\nfor (int i = 0; i < n; i++)\n    ans[pi[i]]++;\nfor (int i = n-1; i > 0; i--)\n    ans[pi[i-1]] += ans[i];\nfor (int i = 0; i <= n; i++)\n    ans[i]++;\n```\n\nHere for each value of the prefix function we first count how many times it occurs in the array $\\pi$, and then compute the final answers:\nif we know that the length prefix $i$ appears exactly $\\text{ans}[i]$ times, then this number must be added to the number of occurrences of its longest suffix that is also a prefix.\nAt the end we need to add $1$ to each result, since we also need to count the original prefixes also.\n\nNow let us consider the second problem.\nWe apply the trick from Knuth-Morris-Pratt:\nwe create the string $s + \\# + t$ and compute its prefix function.\nThe only differences to the first task is, that we are only interested in the prefix values that relate to the string $t$, i.e. $\\pi[i]$ for $i \\ge n + 1$.\nWith those values we can perform the exact same computations as in the first task.\n\n### The number of different substring in a string\n\nGiven a string $s$ of length $n$.\nWe want to compute the number of different substrings appearing in it.\n\nWe will solve this problem iteratively.\nNamely we will learn, knowing the current number of different substrings, how to recompute this count by adding a character to the end.\n\nSo let $k$ be the current number of different substrings in $s$, and we add the character $c$ to the end of $s$.\nObviously some new substrings ending in $c$ will appear.\nWe want to count these new substrings that didn't appear before.\n\nWe take the string $t = s + c$ and reverse it.\nNow the task is transformed into computing how many prefixes there are that don't appear anywhere else.\nIf we compute the maximal value of the prefix function $\\pi_{\\text{max}}$ of the reversed string $t$, then the longest prefix that appears in $s$ is $\\pi_{\\text{max}}$ long.\nClearly also all prefixes of smaller length appear in it.\n\nTherefore the number of new substrings appearing when we add a new character $c$ is $|s| + 1 - \\pi_{\\text{max}}$.\n\nSo for each character appended we can compute the number of new substrings in $O(n)$ times, which gives a time complexity of $O(n^2)$ in total.\n\nIt is worth noting, that we can also compute the number of different substrings by appending the characters at the beginning, or by deleting characters from the beginning or the end.\n\n### Compressing a string\n\nGiven a string $s$ of length $n$.\nWe want to find the shortest \"compressed\" representation of the string, i.e. we want to find a string $t$ of smallest length such that $s$ can be represented as a concatenation of one or more copies of $t$.\n\nIt is clear, that we only need to find the length of $t$. Knowing the length, the answer to the problem will be the prefix of $s$ with this length.\n\nLet us compute the prefix function for $s$.\nUsing the last value of it we define the value $k = n - \\pi[n - 1]$.\nWe will show, that if $k$ divides $n$, then $k$ will be the answer, otherwise there is no effective compression and the answer is $n$.\n\nLet $n$ be divisible by $k$.\nThen the string can be partitioned into blocks of the length $k$.\nBy definition of the prefix function, the prefix of length $n - k$ will be equal with its suffix.\nBut this means that the last block is equal to the block before.\nAnd the block before has to be equal to the block before it.\nAnd so on.\nAs a result, it turns out that all blocks are equal, therefore we can compress the string $s$ to length $k$.\n\nOf course we still need to show that this is actually the optimum.\nIndeed, if there was a smaller compression than $k$, than the prefix function at the end would be greater than $n - k$.\nTherefore $k$ is really the answer.\n\nNow let us assume that $n$ is not divisible by $k$.\nWe show that this implies that the length of the answer is $n$.\nWe prove it by contradiction.\nAssuming there exists an answer, and the compression has length $p$ ($p$ divides $n$).\nThen the last value of the prefix function has to be greater than $n - p$, i.e. the suffix will partially cover the first block.\nNow consider the second block of the string.\nSince the prefix is equal with the suffix, and both the prefix and the suffix cover this block and their displacement relative to each other $k$ does not divide the block length $p$ (otherwise $k$ divides $n$), then all the characters of the block have to be identical.\nBut then the string consists of only one character repeated over and over, hence we can compress it to a string of size $1$, which gives $k = 1$, and $k$ divides $n$.\nContradiction.\n\n$$\\overbrace{s_0 ~ s_1 ~ s_2 ~ s_3}^p ~ \\overbrace{s_4 ~ s_5 ~ s_6 ~ s_7}^p$$\n\n$$s_0 ~ s_1 ~ s_2 ~ \\underbrace{\\overbrace{s_3 ~ s_4 ~ s_5 ~ s_6}^p ~ s_7}_{\\pi[7] = 5}$$\n\n$$s_4 = s_3, ~ s_5 = s_4, ~ s_6 = s_5, ~ s_7 = s_6 ~ \\Rightarrow ~ s_0 = s_1 = s_2 = s_3$$\n\n### Building an automaton according to the prefix function\n\nLet's return to the concatenation to the two strings through a separator, i.e. for the strings $s$ and $t$ we compute the prefix function for the string $s + \\# + t$.\nObviously, since $\\#$ is a separator, the value of the prefix function will never exceed $|s|$.\nIt follows, that it is sufficient to only store the string $s + \\#$ and the values of the prefix function for it, and we can compute the prefix function for all subsequent character on the fly:\n\n$$\\underbrace{s_0 ~ s_1 ~ \\dots ~ s_{n-1} ~ \\#}_{\\text{need to store}} ~ \\underbrace{t_0 ~ t_1 ~ \\dots ~ t_{m-1}}_{\\text{do not need to store}}$$\n\nIndeed, in such a situation, knowing the next character $c \\in t$ and the value of the prefix function of the previous position is enough information to compute the next value of the prefix function, without using any previous characters of the string $t$ and the value of the prefix function in them.\n\nIn other words, we can construct an **automaton** (a finite state machine): the state in it is the current value of the prefix function, and the transition from one state to another will be performed via the next character.\n\nThus, even without having the string $t$, we can construct such a transition table $(\\text{old}_\\pi, c) \\rightarrow \\text{new}_\\pi$ using the same algorithm as for calculating the transition table:\n\n```{.cpp file=prefix_automaton_slow}\nvoid compute_automaton(string s, vector<vector<int>>& aut) {\n    s += '#';\n    int n = s.size();\n    vector<int> pi = prefix_function(s);\n    aut.assign(n, vector<int>(26));\n    for (int i = 0; i < n; i++) {\n        for (int c = 0; c < 26; c++) {\n            int j = i;\n            while (j > 0 && 'a' + c != s[j])\n                j = pi[j-1];\n            if ('a' + c == s[j])\n                j++;\n            aut[i][c] = j;\n        }\n    }\n}\n```\n\nHowever in this form the algorithm runs in $O(n^2 26)$ time for the lowercase letters of the alphabet.\nNote that we can apply dynamic programming and use the already calculated parts of the table.\nWhenever we go from the value $j$ to the value $\\pi[j-1]$, we actually mean that the transition $(j, c)$ leads to the same state as the transition as $(\\pi[j-1], c)$, and this answer is already accurately computed.\n\n```{.cpp file=prefix_automaton_fast}\nvoid compute_automaton(string s, vector<vector<int>>& aut) {\n    s += '#';\n    int n = s.size();\n    vector<int> pi = prefix_function(s);\n    aut.assign(n, vector<int>(26));\n    for (int i = 0; i < n; i++) {\n        for (int c = 0; c < 26; c++) {\n            if (i > 0 && 'a' + c != s[i])\n                aut[i][c] = aut[pi[i-1]][c];\n            else\n                aut[i][c] = i + ('a' + c == s[i]);\n        }\n    }\n}\n```\n\nAs a result we construct the automaton in $O(26 n)$ time.\n\nWhen is such a automaton useful?\nTo begin with, remember that we use the prefix function for the string $s + \\# + t$ and its values mostly for a single purpose: find all occurrences of the string $s$ in the string $t$.\n\nTherefore the most obvious benefit of this automaton is the **acceleration of calculating the prefix function** for the string $s + \\# + t$.\nBy building the automaton for $s + \\#$, we no longer need to store the string $s$ or the values of the prefix function in it.\nAll transitions are already computed in the table.\n\nBut there is a second, less obvious, application.\nWe can use the automaton when the string $t$ is a **gigantic string constructed using some rules**.\nThis can for instance be the Gray strings, or a string formed by a recursive combination of several short strings from the input.\n\nFor completeness we will solve such a problem:\ngiven a number $k \\le 10^5$ and a string $s$ of length $\\le 10^5$.\nWe have to compute the number of occurrences of $s$ in the $k$-th Gray string.\nRecall that Gray's strings are define in the following way:\n\n$$\\begin{align}\ng_1 &= \\text{\"a\"}\\\\\ng_2 &= \\text{\"aba\"}\\\\\ng_3 &= \\text{\"abacaba\"}\\\\\ng_4 &= \\text{\"abacabadabacaba\"}\n\\end{align}$$\n\nIn such cases even constructing the string $t$ will be impossible, because of its astronomical length.\nThe $k$-th Gray string is $2^k-1$ characters long.\nHowever we can calculate the value of the prefix function at the end of the string effectively, by only knowing the value of the prefix function at the start.\n\nIn addition to the automaton itself, we also compute values $G[i][j]$ - the value of the automaton after processing the string $g_i$ starting with the state $j$.\nAnd additionally we compute values $K[i][j]$ - the number of occurrences of $s$ in $g_i$, before during the processing of $g_i$ starting with the state $j$.\nActually $K[i][j]$ is the number of times that the prefix function took the value $|s|$ while performing the operations.\nThe answer to the problem will then be $K[k][0]$.\n\nHow can we compute these values?\nFirst the basic values are $G[0][j] = j$ and $K[0][j] = 0$.\nAnd all subsequent values can be calculated from the previous values and using the automaton.\nTo calculate the value for some $i$ we remember that the string $g_i$ consists of $g_{i-1}$, the $i$ character of the alphabet, and $g_{i-1}$.\nThus the automaton will go into the state:\n\n$$\\text{mid} = \\text{aut}[G[i-1][j]][i]$$\n\n$$G[i][j] = G[i-1][\\text{mid}]$$\n\nThe values for $K[i][j]$ can also be easily counted.\n\n$$K[i][j] = K[i-1][j] + (\\text{mid} == |s|) + K[i-1][\\text{mid}]$$\n\nSo we can solve the problem for Gray strings, and similarly also a huge number of other similar problems.\nFor example the exact same method also solves the following problem:\nwe are given a string $s$ and some patterns $t_i$, each of which is specified as follows:\nit is a string of ordinary characters, and there might be some recursive insertions of the previous strings of the form $t_k^{\\text{cnt}}$, which means that at this place we have to insert the string $t_k$ $\\text{cnt}$ times.\nAn example of such patterns:\n\n$$\\begin{align}\nt_1 &= \\text{\"abdeca\"}\\\\\nt_2 &= \\text{\"abc\"} + t_1^{30} + \\text{\"abd\"}\\\\\nt_3 &= t_2^{50} + t_1^{100}\\\\\nt_4 &= t_2^{10} + t_3^{100}\n\\end{align}$$\n\nThe recursive substitutions blow the string up, so that their lengths can reach the order of $100^{100}$.\n\nWe have to find the number of times the string $s$ appears in each of the strings.\n\nThe problem can be solved in the same way by constructing the automaton of the prefix function, and then we calculate the transitions in for each pattern by using the previous results.\n\n## Practice Problems\n\n* [UVA # 455 \"Periodic Strings\"](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=396)\n* [UVA # 11022 \"String Factoring\"](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1963)\n* [UVA # 11452 \"Dancing the Cheeky-Cheeky\"](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2447)\n* [UVA 12604 - Caesar Cipher](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4282)\n* [UVA 12467 - Secret Word](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3911)\n* [UVA 11019 - Matrix Matcher](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1960)\n* [SPOJ - Pattern Find](http://www.spoj.com/problems/NAJPF/)\n* [SPOJ - A Needle in the Haystack](https://www.spoj.com/problems/NHAY/)\n* [Codeforces - Anthem of Berland](http://codeforces.com/contest/808/problem/G)\n* [Codeforces - MUH and Cube Walls](http://codeforces.com/problemset/problem/471/D)\n* [Codeforces - Prefixes and Suffixes](https://codeforces.com/contest/432/problem/D)\n", "problem_ids": ["808_G", "471_D", "432_D"], "title": "Prefix function. Knuth\u2013Morris\u2013Pratt algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: duval_algorithm\n---\n\n# Lyndon factorization\n\n## Lyndon factorization\n\nFirst let us define the notion of the Lyndon factorization.\n\nA string is called **simple** (or a Lyndon word), if it is strictly **smaller than** any of its own nontrivial **suffixes**.\nExamples of simple strings are: $a$, $b$, $ab$, $aab$, $abb$, $ababb$, $abcd$.\nIt can be shown that a string is simple, if and only if it is strictly **smaller than** all its nontrivial **cyclic shifts**.\n\nNext, let there be a given string $s$.\nThe **Lyndon factorization** of the string $s$ is a factorization $s = w_1 w_2 \\dots w_k$, where all strings $w_i$ are simple, and they are in non-increasing order $w_1 \\ge w_2 \\ge \\dots \\ge w_k$.\n\nIt can be shown, that for any string such a factorization exists and that it is unique.\n\n## Duval algorithm\n\nThe Duval algorithm constructs the Lyndon factorization in $O(n)$ time using $O(1)$ additional memory.\n\nFirst let us introduce another notion:\na string $t$ is called **pre-simple**, if it has the form $t = w w \\dots w \\overline{w}$, where $w$ is a simple string and $\\overline{w}$ is a prefix of $w$ (possibly empty).\nA simple string is also pre-simple.\n\nThe Duval algorithm is greedy.\nAt any point during its execution, the string $s$ will actually be divided into three strings $s = s_1 s_2 s_3$, where the Lyndon factorization for $s_1$ is already found and finalized, the string $s_2$ is pre-simple (and we know the length of the simple string in it), and $s_3$ is completely untouched.\nIn each iteration the Duval algorithm takes the first character of the string $s_3$ and tries to append it to the string $s_2$.\nIt $s_2$ is no longer pre-simple, then the Lyndon factorization for some part of $s_2$ becomes known, and this part goes to $s_1$.\n\nLet's describe the algorithm in more detail.\nThe pointer $i$ will always point to the beginning of the string $s_2$.\nThe outer loop will be executed as long as $i < n$.\nInside the loop we use two additional pointers, $j$ which points to the beginning of $s_3$, and $k$ which points to the current character that we are currently comparing to.\nWe want to add the character $s[j]$ to the string $s_2$, which requires a comparison with the character $s[k]$.\nThere can be three different cases:\n\n- $s[j] = s[k]$: if this is the case, then adding the symbol $s[j]$ to $s_2$ doesn't violate its pre-simplicity.\n  So we simply increment the pointers $j$ and $k$.\n- $s[j] > s[k]$: here, the string $s_2 + s[j]$ becomes simple.\n  We can increment $j$ and reset $k$ back to the beginning of $s_2$, so that the next character can be compared with the beginning of the simple word.\n- $s[j] < s[k]$: the string $s_2 + s[j]$ is no longer pre-simple.\n  Therefore we will split the pre-simple string $s_2$ into its simple strings and the remainder, possibly empty.\n  The simple string will have the length $j - k$.\n  In the next iteration we start again with the remaining $s_2$.\n\n### Implementation\n\nHere we present the implementation of the Duval algorithm, which will return the desired Lyndon factorization of a given string $s$.\n\n```{.cpp file=duval_algorithm}\nvector<string> duval(string const& s) {\n    int n = s.size();\n    int i = 0;\n    vector<string> factorization;\n    while (i < n) {\n        int j = i + 1, k = i;\n        while (j < n && s[k] <= s[j]) {\n            if (s[k] < s[j])\n                k = i;\n            else\n                k++;\n            j++;\n        }\n        while (i <= k) {\n            factorization.push_back(s.substr(i, j - k));\n            i += j - k;\n        }\n    }\n    return factorization;\n}\n```\n\n### Complexity\n\nLet us estimate the running time of this algorithm.\n\nThe **outer while loop** does not exceed $n$ iterations, since at the end of each iteration $i$ increases.\nAlso the second inner while loop runs in $O(n)$, since is only outputs the final factorization.\n\nSo we are only interested in the **first inner while loop**.\nHow many iterations does it perform in the worst case?\nIt's easy to see that the simple words that we identify in each iteration of the outer loop are longer than the remainder that we additionally compared.\nTherefore also the sum of the remainders will be smaller than $n$, which means that we only perform at most $O(n)$ iterations of the first inner while loop.\nIn fact the total number of character comparisons will not exceed $4n - 3$.\n\n## Finding the smallest cyclic shift\n\nLet there be a string $s$.\nWe construct the Lyndon factorization for the string $s + s$ (in $O(n)$ time).\nWe will look for a simple string in the factorization, which starts at a position less than $n$ (i.e. it starts in the first instance of $s$), and ends in a position greater than or equal to $n$ (i.e. in the second instance) of $s$).\nIt is stated, that the position of the start of this simple string will be the beginning of the desired smallest cyclic shift.\nThis can be easily verified using the definition of the Lyndon decomposition.\n\nThe beginning of the simple block can be found easily - just remember the pointer $i$ at the beginning of each iteration of the outer loop, which indicated the beginning of the current pre-simple string.\n\nSo we get the following implementation:\n\n```{.cpp file=smallest_cyclic_string}\nstring min_cyclic_string(string s) {\n    s += s;\n    int n = s.size();\n    int i = 0, ans = 0;\n    while (i < n / 2) {\n        ans = i;\n        int j = i + 1, k = i;\n        while (j < n && s[k] <= s[j]) {\n            if (s[k] < s[j])\n                k = i;\n            else\n                k++;\n            j++;\n        }\n        while (i <= k)\n            i += j - k;\n    }\n    return s.substr(ans, n / 2);\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: duval_algorithm\n---\n\n# Lyndon factorization\n\n## Lyndon factorization\n\nFirst let us define the notion of the Lyndon factorization.\n\nA string is called **simple** (or a Lyndon word), if it is strictly **smaller than** any of its own nontrivial **suffixes**.\nExamples of simple strings are: $a$, $b$, $ab$, $aab$, $abb$, $ababb$, $abcd$.\nIt can be shown that a string is simple, if and only if it is strictly **smaller than** all its nontrivial **cyclic shifts**.\n\nNext, let there be a given string $s$.\nThe **Lyndon factorization** of the string $s$ is a factorization $s = w_1 w_2 \\dots w_k$, where all strings $w_i$ are simple, and they are in non-increasing order $w_1 \\ge w_2 \\ge \\dots \\ge w_k$.\n\nIt can be shown, that for any string such a factorization exists and that it is unique.\n\n## Duval algorithm\n\nThe Duval algorithm constructs the Lyndon factorization in $O(n)$ time using $O(1)$ additional memory.\n\nFirst let us introduce another notion:\na string $t$ is called **pre-simple**, if it has the form $t = w w \\dots w \\overline{w}$, where $w$ is a simple string and $\\overline{w}$ is a prefix of $w$ (possibly empty).\nA simple string is also pre-simple.\n\nThe Duval algorithm is greedy.\nAt any point during its execution, the string $s$ will actually be divided into three strings $s = s_1 s_2 s_3$, where the Lyndon factorization for $s_1$ is already found and finalized, the string $s_2$ is pre-simple (and we know the length of the simple string in it), and $s_3$ is completely untouched.\nIn each iteration the Duval algorithm takes the first character of the string $s_3$ and tries to append it to the string $s_2$.\nIt $s_2$ is no longer pre-simple, then the Lyndon factorization for some part of $s_2$ becomes known, and this part goes to $s_1$.\n\nLet's describe the algorithm in more detail.\nThe pointer $i$ will always point to the beginning of the string $s_2$.\nThe outer loop will be executed as long as $i < n$.\nInside the loop we use two additional pointers, $j$ which points to the beginning of $s_3$, and $k$ which points to the current character that we are currently comparing to.\nWe want to add the character $s[j]$ to the string $s_2$, which requires a comparison with the character $s[k]$.\nThere can be three different cases:\n\n- $s[j] = s[k]$: if this is the case, then adding the symbol $s[j]$ to $s_2$ doesn't violate its pre-simplicity.\n  So we simply increment the pointers $j$ and $k$.\n- $s[j] > s[k]$: here, the string $s_2 + s[j]$ becomes simple.\n  We can increment $j$ and reset $k$ back to the beginning of $s_2$, so that the next character can be compared with the beginning of the simple word.\n- $s[j] < s[k]$: the string $s_2 + s[j]$ is no longer pre-simple.\n  Therefore we will split the pre-simple string $s_2$ into its simple strings and the remainder, possibly empty.\n  The simple string will have the length $j - k$.\n  In the next iteration we start again with the remaining $s_2$.\n\n### Implementation\n\nHere we present the implementation of the Duval algorithm, which will return the desired Lyndon factorization of a given string $s$.\n\n```{.cpp file=duval_algorithm}\nvector<string> duval(string const& s) {\n    int n = s.size();\n    int i = 0;\n    vector<string> factorization;\n    while (i < n) {\n        int j = i + 1, k = i;\n        while (j < n && s[k] <= s[j]) {\n            if (s[k] < s[j])\n                k = i;\n            else\n                k++;\n            j++;\n        }\n        while (i <= k) {\n            factorization.push_back(s.substr(i, j - k));\n            i += j - k;\n        }\n    }\n    return factorization;\n}\n```\n\n### Complexity\n\nLet us estimate the running time of this algorithm.\n\nThe **outer while loop** does not exceed $n$ iterations, since at the end of each iteration $i$ increases.\nAlso the second inner while loop runs in $O(n)$, since is only outputs the final factorization.\n\nSo we are only interested in the **first inner while loop**.\nHow many iterations does it perform in the worst case?\nIt's easy to see that the simple words that we identify in each iteration of the outer loop are longer than the remainder that we additionally compared.\nTherefore also the sum of the remainders will be smaller than $n$, which means that we only perform at most $O(n)$ iterations of the first inner while loop.\nIn fact the total number of character comparisons will not exceed $4n - 3$.\n\n## Finding the smallest cyclic shift\n\nLet there be a string $s$.\nWe construct the Lyndon factorization for the string $s + s$ (in $O(n)$ time).\nWe will look for a simple string in the factorization, which starts at a position less than $n$ (i.e. it starts in the first instance of $s$), and ends in a position greater than or equal to $n$ (i.e. in the second instance) of $s$).\nIt is stated, that the position of the start of this simple string will be the beginning of the desired smallest cyclic shift.\nThis can be easily verified using the definition of the Lyndon decomposition.\n\nThe beginning of the simple block can be found easily - just remember the pointer $i$ at the beginning of each iteration of the outer loop, which indicated the beginning of the current pre-simple string.\n\nSo we get the following implementation:\n\n```{.cpp file=smallest_cyclic_string}\nstring min_cyclic_string(string s) {\n    s += s;\n    int n = s.size();\n    int i = 0, ans = 0;\n    while (i < n / 2) {\n        ans = i;\n        int j = i + 1, k = i;\n        while (j < n && s[k] <= s[j]) {\n            if (s[k] < s[j])\n                k = i;\n            else\n                k++;\n            j++;\n        }\n        while (i <= k)\n            i += j - k;\n    }\n    return s.substr(ans, n / 2);\n}\n```\n\n## Problems\n\n- [UVA #719 - Glass Beads](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=660)\n", "problem_ids": [], "title": "Lyndon factorization"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: string_hashes\n---\n\n# String Hashing\n\nHashing algorithms are helpful in solving a lot of problems.\n\nWe want to solve the problem of comparing strings efficiently.\nThe brute force way of doing so is just to compare the letters of both strings, which has a time complexity of $O(\\min(n_1, n_2))$ if $n_1$ and $n_2$ are the sizes of the two strings.\nWe want to do better.\nThe idea behind the string hashing is the following: we map each string into an integer and compare those instead of the strings.\nDoing this allows us to reduce the execution time of the string comparison to $O(1)$.\n\nFor the conversion, we need a so-called **hash function**.\nThe goal of it is to convert a string into an integer, the so-called **hash** of the string.\nThe following condition has to hold: if two strings $s$ and $t$ are equal ($s = t$), then also their hashes have to be equal ($\\text{hash}(s) = \\text{hash}(t)$).\nOtherwise, we will not be able to compare strings.\n\nNotice, the opposite direction doesn't have to hold.\nIf the hashes are equal ($\\text{hash}(s) = \\text{hash}(t)$), then the strings do not necessarily have to be equal.\nE.g. a valid hash function would be simply $\\text{hash}(s) = 0$ for each $s$.\nNow, this is just a stupid example, because this function will be completely useless, but it is a valid hash function.\nThe reason why the opposite direction doesn't have to hold, is because there are exponentially many strings.\nIf we only want this hash function to distinguish between all strings consisting of lowercase characters of length smaller than 15, then already the hash wouldn't fit into a 64-bit integer (e.g. unsigned long long) any more, because there are so many of them.\nAnd of course, we don't want to compare arbitrary long integers, because this will also have the complexity $O(n)$.\n\nSo usually we want the hash function to map strings onto numbers of a fixed range $[0, m)$, then comparing strings is just a comparison of two integers with a fixed length.\nAnd of course, we want $\\text{hash}(s) \\neq \\text{hash}(t)$ to be very likely if $s \\neq t$.\n\nThat's the important part that you have to keep in mind.\nUsing hashing will not be 100% deterministically correct, because two complete different strings might have the same hash (the hashes collide).\nHowever, in a wide majority of tasks, this can be safely ignored as the probability of the hashes of two different strings colliding is still very small.\nAnd we will discuss some techniques in this article how to keep the probability of collisions very low.\n\n## Calculation of the hash of a string\n\nThe good and widely used way to define the hash of a string $s$ of length $n$ is\n\n$$\\begin{align}\n\\text{hash}(s) &= s[0] + s[1] \\cdot p + s[2] \\cdot p^2 + ... + s[n-1] \\cdot p^{n-1} \\mod m \\\\\n&= \\sum_{i=0}^{n-1} s[i] \\cdot p^i \\mod m,\n\\end{align}$$\n\nwhere $p$ and $m$ are some chosen, positive numbers.\nIt is called a **polynomial rolling hash function**.\n\nIt is reasonable to make $p$ a prime number roughly equal to the number of characters in the input alphabet.\nFor example, if the input is composed of only lowercase letters of the English alphabet, $p = 31$ is a good choice.\nIf the input may contain both uppercase and lowercase letters, then $p = 53$ is a possible choice.\nThe code in this article will use $p = 31$.\n\nObviously $m$ should be a large number since the probability of two random strings colliding is about $\\approx \\frac{1}{m}$.\nSometimes $m = 2^{64}$ is chosen, since then the integer overflows of 64-bit integers work exactly like the modulo operation.\nHowever, there exists a method, which generates colliding strings (which work independently from the choice of $p$).\nSo in practice, $m = 2^{64}$ is not recommended.\nA good choice for $m$ is some large prime number.\nThe code in this article will just use $m = 10^9+9$.\nThis is a large number, but still small enough so that we can perform multiplication of two values using 64-bit integers.\n\nHere is an example of calculating the hash of a string $s$, which contains only lowercase letters.\nWe convert each character of $s$ to an integer.\nHere we use the conversion $a \\rightarrow 1$, $b \\rightarrow 2$, $\\dots$, $z \\rightarrow 26$.\nConverting $a \\rightarrow 0$ is not a good idea, because then the hashes of the strings $a$, $aa$, $aaa$, $\\dots$ all evaluate to $0$.\n\n```{.cpp file=hashing_function}\nlong long compute_hash(string const& s) {\n    const int p = 31;\n    const int m = 1e9 + 9;\n    long long hash_value = 0;\n    long long p_pow = 1;\n    for (char c : s) {\n        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;\n        p_pow = (p_pow * p) % m;\n    }\n    return hash_value;\n}\n```\n\nPrecomputing the powers of $p$ might give a performance boost.\n\n## Example tasks\n\n### Search for duplicate strings in an array of strings\n\nProblem: Given a list of $n$ strings $s_i$, each no longer than $m$ characters, find all the duplicate strings and divide them into groups.\n\nFrom the obvious algorithm involving sorting the strings, we would get a time complexity of $O(n m \\log n)$ where the sorting requires $O(n \\log n)$ comparisons and each comparison take $O(m)$ time.\nHowever, by using hashes, we reduce the comparison time to $O(1)$, giving us an algorithm that runs in $O(n m + n \\log n)$ time.\n\nWe calculate the hash for each string, sort the hashes together with the indices, and then group the indices by identical hashes.\n\n```{.cpp file=hashing_group_identical_strings}\nvector<vector<int>> group_identical_strings(vector<string> const& s) {\n    int n = s.size();\n    vector<pair<long long, int>> hashes(n);\n    for (int i = 0; i < n; i++)\n        hashes[i] = {compute_hash(s[i]), i};\n\n    sort(hashes.begin(), hashes.end());\n\n    vector<vector<int>> groups;\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || hashes[i].first != hashes[i-1].first)\n            groups.emplace_back();\n        groups.back().push_back(hashes[i].second);\n    }\n    return groups;\n}\n```\n\n### Fast hash calculation of substrings of given string\n\nProblem: Given a string $s$ and indices $i$ and $j$, find the hash of the substring $s [i \\dots j]$.\n\nBy definition, we have:\n\n$$\\text{hash}(s[i \\dots j]) = \\sum_{k = i}^j s[k] \\cdot p^{k-i} \\mod m$$\n\nMultiplying by $p^i$ gives:\n\n$$\\begin{align}\n\\text{hash}(s[i \\dots j]) \\cdot p^i &= \\sum_{k = i}^j s[k] \\cdot p^k \\mod m \\\\\n&= \\text{hash}(s[0 \\dots j]) - \\text{hash}(s[0 \\dots i-1]) \\mod m\n\\end{align}$$\n\nSo by knowing the hash value of each prefix of the string $s$, we can compute the hash of any substring directly using this formula.\nThe only problem that we face in calculating it is that we must be able to divide $\\text{hash}(s[0 \\dots j]) - \\text{hash}(s[0 \\dots i-1])$ by $p^i$.\nTherefore we need to find the [modular multiplicative inverse](../algebra/module-inverse.md) of $p^i$ and then perform multiplication with this inverse.\nWe can precompute the inverse of every $p^i$, which allows computing the hash of any substring of $s$ in $O(1)$ time.\n\nHowever, there does exist an easier way.\nIn most cases, rather than calculating the hashes of substring exactly, it is enough to compute the hash multiplied by some power of $p$.\nSuppose we have two hashes of two substrings, one multiplied by $p^i$ and the other by $p^j$.\nIf $i < j$ then we multiply the first hash by $p^{j-i}$, otherwise, we multiply the second hash by $p^{i-j}$.\nBy doing this, we get both the hashes multiplied by the same power of $p$ (which is the maximum of $i$ and $j$) and now these hashes can be compared easily with no need for any division.\n\n## Applications of Hashing\n\nHere are some typical applications of Hashing:\n\n* [Rabin-Karp algorithm](rabin-karp.md) for pattern matching in a string in $O(n)$ time\n* Calculating the number of different substrings of a string in $O(n^2)$ (see below)\n* Calculating the number of palindromic substrings in a string.\n\n### Determine the number of different substrings in a string\n\nProblem: Given a string $s$ of length $n$, consisting only of lowercase English letters, find the number of different substrings in this string.\n\nTo solve this problem, we iterate over all substring lengths $l = 1 \\dots n$.\nFor every substring length $l$ we construct an array of hashes of all substrings of length $l$ multiplied by the same power of $p$.\nThe number of different elements in the array is equal to the number of distinct substrings of length $l$ in the string.\nThis number is added to the final answer.\n\nFor convenience, we will use $h[i]$ as the hash of the prefix with $i$ characters, and define $h[0] = 0$.\n\n```{.cpp file=hashing_count_unique_substrings}\nint count_unique_substrings(string const& s) {\n    int n = s.size();\n    \n    const int p = 31;\n    const int m = 1e9 + 9;\n    vector<long long> p_pow(n);\n    p_pow[0] = 1;\n    for (int i = 1; i < n; i++)\n        p_pow[i] = (p_pow[i-1] * p) % m;\n\n    vector<long long> h(n + 1, 0);\n    for (int i = 0; i < n; i++)\n        h[i+1] = (h[i] + (s[i] - 'a' + 1) * p_pow[i]) % m;\n\n    int cnt = 0;\n    for (int l = 1; l <= n; l++) {\n        unordered_set<long long> hs;\n        for (int i = 0; i <= n - l; i++) {\n            long long cur_h = (h[i + l] + m - h[i]) % m;\n            cur_h = (cur_h * p_pow[n-i-1]) % m;\n            hs.insert(cur_h);\n        }\n        cnt += hs.size();\n    }\n    return cnt;\n}\n```\n\nNotice, that $O(n^2)$ is not the best possible time complexity for this problem.\nA solution with $O(n \\log n)$ is described in the article about [Suffix Arrays](suffix-array.md), and it's even possible to compute it in $O(n)$ using a [Suffix Tree](./suffix-tree-ukkonen.md) or a [Suffix Automaton](./suffix-automaton.md).\n\n## Improve no-collision probability\n\nQuite often the above mentioned polynomial hash is good enough, and no collisions will happen during tests.\nRemember, the probability that collision happens is only $\\approx \\frac{1}{m}$.\nFor $m = 10^9 + 9$ the probability is $\\approx 10^{-9}$ which is quite low.\nBut notice, that we only did one comparison.\nWhat if we compared a string $s$ with $10^6$ different strings.\nThe probability that at least one collision happens is now $\\approx 10^{-3}$.\nAnd if we want to compare $10^6$ different strings with each other (e.g. by counting how many unique strings exists), then the probability of at least one collision happening is already $\\approx 1$.\nIt is pretty much guaranteed that this task will end with a collision and returns the wrong result.\n\nThere is a really easy trick to get better probabilities.\nWe can just compute two different hashes for each string (by using two different $p$, and/or different $m$, and compare these pairs instead.\nIf $m$ is about $10^9$ for each of the two hash functions than this is more or less equivalent as having one hash function with $m \\approx 10^{18}$.\nWhen comparing $10^6$ strings with each other, the probability that at least one collision happens is now reduced to $\\approx 10^{-6}$.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: string_hashes\n---\n\n# String Hashing\n\nHashing algorithms are helpful in solving a lot of problems.\n\nWe want to solve the problem of comparing strings efficiently.\nThe brute force way of doing so is just to compare the letters of both strings, which has a time complexity of $O(\\min(n_1, n_2))$ if $n_1$ and $n_2$ are the sizes of the two strings.\nWe want to do better.\nThe idea behind the string hashing is the following: we map each string into an integer and compare those instead of the strings.\nDoing this allows us to reduce the execution time of the string comparison to $O(1)$.\n\nFor the conversion, we need a so-called **hash function**.\nThe goal of it is to convert a string into an integer, the so-called **hash** of the string.\nThe following condition has to hold: if two strings $s$ and $t$ are equal ($s = t$), then also their hashes have to be equal ($\\text{hash}(s) = \\text{hash}(t)$).\nOtherwise, we will not be able to compare strings.\n\nNotice, the opposite direction doesn't have to hold.\nIf the hashes are equal ($\\text{hash}(s) = \\text{hash}(t)$), then the strings do not necessarily have to be equal.\nE.g. a valid hash function would be simply $\\text{hash}(s) = 0$ for each $s$.\nNow, this is just a stupid example, because this function will be completely useless, but it is a valid hash function.\nThe reason why the opposite direction doesn't have to hold, is because there are exponentially many strings.\nIf we only want this hash function to distinguish between all strings consisting of lowercase characters of length smaller than 15, then already the hash wouldn't fit into a 64-bit integer (e.g. unsigned long long) any more, because there are so many of them.\nAnd of course, we don't want to compare arbitrary long integers, because this will also have the complexity $O(n)$.\n\nSo usually we want the hash function to map strings onto numbers of a fixed range $[0, m)$, then comparing strings is just a comparison of two integers with a fixed length.\nAnd of course, we want $\\text{hash}(s) \\neq \\text{hash}(t)$ to be very likely if $s \\neq t$.\n\nThat's the important part that you have to keep in mind.\nUsing hashing will not be 100% deterministically correct, because two complete different strings might have the same hash (the hashes collide).\nHowever, in a wide majority of tasks, this can be safely ignored as the probability of the hashes of two different strings colliding is still very small.\nAnd we will discuss some techniques in this article how to keep the probability of collisions very low.\n\n## Calculation of the hash of a string\n\nThe good and widely used way to define the hash of a string $s$ of length $n$ is\n\n$$\\begin{align}\n\\text{hash}(s) &= s[0] + s[1] \\cdot p + s[2] \\cdot p^2 + ... + s[n-1] \\cdot p^{n-1} \\mod m \\\\\n&= \\sum_{i=0}^{n-1} s[i] \\cdot p^i \\mod m,\n\\end{align}$$\n\nwhere $p$ and $m$ are some chosen, positive numbers.\nIt is called a **polynomial rolling hash function**.\n\nIt is reasonable to make $p$ a prime number roughly equal to the number of characters in the input alphabet.\nFor example, if the input is composed of only lowercase letters of the English alphabet, $p = 31$ is a good choice.\nIf the input may contain both uppercase and lowercase letters, then $p = 53$ is a possible choice.\nThe code in this article will use $p = 31$.\n\nObviously $m$ should be a large number since the probability of two random strings colliding is about $\\approx \\frac{1}{m}$.\nSometimes $m = 2^{64}$ is chosen, since then the integer overflows of 64-bit integers work exactly like the modulo operation.\nHowever, there exists a method, which generates colliding strings (which work independently from the choice of $p$).\nSo in practice, $m = 2^{64}$ is not recommended.\nA good choice for $m$ is some large prime number.\nThe code in this article will just use $m = 10^9+9$.\nThis is a large number, but still small enough so that we can perform multiplication of two values using 64-bit integers.\n\nHere is an example of calculating the hash of a string $s$, which contains only lowercase letters.\nWe convert each character of $s$ to an integer.\nHere we use the conversion $a \\rightarrow 1$, $b \\rightarrow 2$, $\\dots$, $z \\rightarrow 26$.\nConverting $a \\rightarrow 0$ is not a good idea, because then the hashes of the strings $a$, $aa$, $aaa$, $\\dots$ all evaluate to $0$.\n\n```{.cpp file=hashing_function}\nlong long compute_hash(string const& s) {\n    const int p = 31;\n    const int m = 1e9 + 9;\n    long long hash_value = 0;\n    long long p_pow = 1;\n    for (char c : s) {\n        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;\n        p_pow = (p_pow * p) % m;\n    }\n    return hash_value;\n}\n```\n\nPrecomputing the powers of $p$ might give a performance boost.\n\n## Example tasks\n\n### Search for duplicate strings in an array of strings\n\nProblem: Given a list of $n$ strings $s_i$, each no longer than $m$ characters, find all the duplicate strings and divide them into groups.\n\nFrom the obvious algorithm involving sorting the strings, we would get a time complexity of $O(n m \\log n)$ where the sorting requires $O(n \\log n)$ comparisons and each comparison take $O(m)$ time.\nHowever, by using hashes, we reduce the comparison time to $O(1)$, giving us an algorithm that runs in $O(n m + n \\log n)$ time.\n\nWe calculate the hash for each string, sort the hashes together with the indices, and then group the indices by identical hashes.\n\n```{.cpp file=hashing_group_identical_strings}\nvector<vector<int>> group_identical_strings(vector<string> const& s) {\n    int n = s.size();\n    vector<pair<long long, int>> hashes(n);\n    for (int i = 0; i < n; i++)\n        hashes[i] = {compute_hash(s[i]), i};\n\n    sort(hashes.begin(), hashes.end());\n\n    vector<vector<int>> groups;\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || hashes[i].first != hashes[i-1].first)\n            groups.emplace_back();\n        groups.back().push_back(hashes[i].second);\n    }\n    return groups;\n}\n```\n\n### Fast hash calculation of substrings of given string\n\nProblem: Given a string $s$ and indices $i$ and $j$, find the hash of the substring $s [i \\dots j]$.\n\nBy definition, we have:\n\n$$\\text{hash}(s[i \\dots j]) = \\sum_{k = i}^j s[k] \\cdot p^{k-i} \\mod m$$\n\nMultiplying by $p^i$ gives:\n\n$$\\begin{align}\n\\text{hash}(s[i \\dots j]) \\cdot p^i &= \\sum_{k = i}^j s[k] \\cdot p^k \\mod m \\\\\n&= \\text{hash}(s[0 \\dots j]) - \\text{hash}(s[0 \\dots i-1]) \\mod m\n\\end{align}$$\n\nSo by knowing the hash value of each prefix of the string $s$, we can compute the hash of any substring directly using this formula.\nThe only problem that we face in calculating it is that we must be able to divide $\\text{hash}(s[0 \\dots j]) - \\text{hash}(s[0 \\dots i-1])$ by $p^i$.\nTherefore we need to find the [modular multiplicative inverse](../algebra/module-inverse.md) of $p^i$ and then perform multiplication with this inverse.\nWe can precompute the inverse of every $p^i$, which allows computing the hash of any substring of $s$ in $O(1)$ time.\n\nHowever, there does exist an easier way.\nIn most cases, rather than calculating the hashes of substring exactly, it is enough to compute the hash multiplied by some power of $p$.\nSuppose we have two hashes of two substrings, one multiplied by $p^i$ and the other by $p^j$.\nIf $i < j$ then we multiply the first hash by $p^{j-i}$, otherwise, we multiply the second hash by $p^{i-j}$.\nBy doing this, we get both the hashes multiplied by the same power of $p$ (which is the maximum of $i$ and $j$) and now these hashes can be compared easily with no need for any division.\n\n## Applications of Hashing\n\nHere are some typical applications of Hashing:\n\n* [Rabin-Karp algorithm](rabin-karp.md) for pattern matching in a string in $O(n)$ time\n* Calculating the number of different substrings of a string in $O(n^2)$ (see below)\n* Calculating the number of palindromic substrings in a string.\n\n### Determine the number of different substrings in a string\n\nProblem: Given a string $s$ of length $n$, consisting only of lowercase English letters, find the number of different substrings in this string.\n\nTo solve this problem, we iterate over all substring lengths $l = 1 \\dots n$.\nFor every substring length $l$ we construct an array of hashes of all substrings of length $l$ multiplied by the same power of $p$.\nThe number of different elements in the array is equal to the number of distinct substrings of length $l$ in the string.\nThis number is added to the final answer.\n\nFor convenience, we will use $h[i]$ as the hash of the prefix with $i$ characters, and define $h[0] = 0$.\n\n```{.cpp file=hashing_count_unique_substrings}\nint count_unique_substrings(string const& s) {\n    int n = s.size();\n    \n    const int p = 31;\n    const int m = 1e9 + 9;\n    vector<long long> p_pow(n);\n    p_pow[0] = 1;\n    for (int i = 1; i < n; i++)\n        p_pow[i] = (p_pow[i-1] * p) % m;\n\n    vector<long long> h(n + 1, 0);\n    for (int i = 0; i < n; i++)\n        h[i+1] = (h[i] + (s[i] - 'a' + 1) * p_pow[i]) % m;\n\n    int cnt = 0;\n    for (int l = 1; l <= n; l++) {\n        unordered_set<long long> hs;\n        for (int i = 0; i <= n - l; i++) {\n            long long cur_h = (h[i + l] + m - h[i]) % m;\n            cur_h = (cur_h * p_pow[n-i-1]) % m;\n            hs.insert(cur_h);\n        }\n        cnt += hs.size();\n    }\n    return cnt;\n}\n```\n\nNotice, that $O(n^2)$ is not the best possible time complexity for this problem.\nA solution with $O(n \\log n)$ is described in the article about [Suffix Arrays](suffix-array.md), and it's even possible to compute it in $O(n)$ using a [Suffix Tree](./suffix-tree-ukkonen.md) or a [Suffix Automaton](./suffix-automaton.md).\n\n## Improve no-collision probability\n\nQuite often the above mentioned polynomial hash is good enough, and no collisions will happen during tests.\nRemember, the probability that collision happens is only $\\approx \\frac{1}{m}$.\nFor $m = 10^9 + 9$ the probability is $\\approx 10^{-9}$ which is quite low.\nBut notice, that we only did one comparison.\nWhat if we compared a string $s$ with $10^6$ different strings.\nThe probability that at least one collision happens is now $\\approx 10^{-3}$.\nAnd if we want to compare $10^6$ different strings with each other (e.g. by counting how many unique strings exists), then the probability of at least one collision happening is already $\\approx 1$.\nIt is pretty much guaranteed that this task will end with a collision and returns the wrong result.\n\nThere is a really easy trick to get better probabilities.\nWe can just compute two different hashes for each string (by using two different $p$, and/or different $m$, and compare these pairs instead.\nIf $m$ is about $10^9$ for each of the two hash functions than this is more or less equivalent as having one hash function with $m \\approx 10^{18}$.\nWhen comparing $10^6$ strings with each other, the probability that at least one collision happens is now reduced to $\\approx 10^{-6}$.\n\n## Practice Problems\n* [Good Substrings - Codeforces](https://codeforces.com/contest/271/problem/D)\n* [A Needle in the Haystack - SPOJ](http://www.spoj.com/problems/NHAY/)\n* [String Hashing - Kattis](https://open.kattis.com/problems/hashing)\n* [Double Profiles - Codeforces](http://codeforces.com/problemset/problem/154/C)\n* [Password - Codeforces](http://codeforces.com/problemset/problem/126/B)\n* [SUB_PROB - SPOJ](http://www.spoj.com/problems/SUB_PROB/)\n* [INSQ15_A](https://www.codechef.com/problems/INSQ15_A)\n* [SPOJ - Ada and Spring Cleaning](http://www.spoj.com/problems/ADACLEAN/)\n* [GYM - Text Editor](http://codeforces.com/gym/101466/problem/E)\n* [12012 - Detection of Extraterrestrial](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3163)\n* [Codeforces - Games on a CD](http://codeforces.com/contest/727/problem/E)\n* [UVA 11855 - Buzzwords](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2955)\n* [Codeforces - Santa Claus and a Palindrome](http://codeforces.com/contest/752/problem/D)\n* [Codeforces - String Compression](http://codeforces.com/contest/825/problem/F)\n* [Codeforces - Palindromic Characteristics](http://codeforces.com/contest/835/problem/D)\n* [SPOJ - Test](http://www.spoj.com/problems/CF25E/)\n* [Codeforces - Palindrome Degree](http://codeforces.com/contest/7/problem/D)\n* [Codeforces - Deletion of Repeats](http://codeforces.com/contest/19/problem/C)\n* [HackerRank - Gift Boxes](https://www.hackerrank.com/contests/womens-codesprint-5/challenges/gift-boxes)\n\n\n", "problem_ids": ["727_E", "825_F", "7_D", "19_C"], "title": "String Hashing"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: ukkonen\n---\n\n# Suffix Tree. Ukkonen's Algorithm\n\n*This article is a stub and doesn't contain any descriptions. For a description of the algorithm, refer to other sources, such as [Algorithms on Strings, Trees, and Sequences](https://www.cs.cmu.edu/afs/cs/project/pscico-guyb/realworld/www/slidesF06/cmuonly/gusfield.pdf) by Dan Gusfield.*\n\nThis algorithm builds a suffix tree for a given string $s$ of length $n$ in $O(n\\log(k))$) time, where $k$ is the size of the alphabet (if $k$ is considered to be a constant, the asymptotic behavior is linear).\n\nThe input to the algorithm are the string $s$ and its length $n$, which are passed as global variables.\n\nThe main function `build_tree` builds a suffix tree. It is stored as an array of structures `node`, where `node[0]` is the root of the tree.\n\nIn order to simplify the code, the edges are stored in the same structures: for each vertex its structure `node` stores the information about the edge between it and its parent. Overall each `node` stores the following information: \n\n* `(l, r)` - left and right boundaries of the substring `s[l..r-1]` which correspond to the edge to this node,\n* `par` - the parent node,\n* `link` - the suffix link,\n* `next` - the list of edges going out from this node.\n\n```cpp\nstring s;\nint n;\n \nstruct node {\n\tint l, r, par, link;\n\tmap<char,int> next;\n \n\tnode (int l=0, int r=0, int par=-1)\n\t\t: l(l), r(r), par(par), link(-1) {}\n\tint len()  {  return r - l;  }\n\tint &get (char c) {\n\t\tif (!next.count(c))  next[c] = -1;\n\t\treturn next[c];\n\t}\n};\nnode t[MAXN];\nint sz;\n \nstruct state {\n\tint v, pos;\n\tstate (int v, int pos) : v(v), pos(pos)  {}\n};\nstate ptr (0, 0);\n \nstate go (state st, int l, int r) {\n\twhile (l < r)\n\t\tif (st.pos == t[st.v].len()) {\n\t\t\tst = state (t[st.v].get( s[l] ), 0);\n\t\t\tif (st.v == -1)  return st;\n\t\t}\n\t\telse {\n\t\t\tif (s[ t[st.v].l + st.pos ] != s[l])\n\t\t\t\treturn state (-1, -1);\n\t\t\tif (r-l < t[st.v].len() - st.pos)\n\t\t\t\treturn state (st.v, st.pos + r-l);\n\t\t\tl += t[st.v].len() - st.pos;\n\t\t\tst.pos = t[st.v].len();\n\t\t}\n\treturn st;\n}\n \nint split (state st) {\n\tif (st.pos == t[st.v].len())\n\t\treturn st.v;\n\tif (st.pos == 0)\n\t\treturn t[st.v].par;\n\tnode v = t[st.v];\n\tint id = sz++;\n\tt[id] = node (v.l, v.l+st.pos, v.par);\n\tt[v.par].get( s[v.l] ) = id;\n\tt[id].get( s[v.l+st.pos] ) = st.v;\n\tt[st.v].par = id;\n\tt[st.v].l += st.pos;\n\treturn id;\n}\n \nint get_link (int v) {\n\tif (t[v].link != -1)  return t[v].link;\n\tif (t[v].par == -1)  return 0;\n\tint to = get_link (t[v].par);\n\treturn t[v].link = split (go (state(to,t[to].len()), t[v].l + (t[v].par==0), t[v].r));\n}\n \nvoid tree_extend (int pos) {\n\tfor(;;) {\n\t\tstate nptr = go (ptr, pos, pos+1);\n\t\tif (nptr.v != -1) {\n\t\t\tptr = nptr;\n\t\t\treturn;\n\t\t}\n \n\t\tint mid = split (ptr);\n\t\tint leaf = sz++;\n\t\tt[leaf] = node (pos, n, mid);\n\t\tt[mid].get( s[pos] ) = leaf;\n \n\t\tptr.v = get_link (mid);\n\t\tptr.pos = t[ptr.v].len();\n\t\tif (!mid)  break;\n\t}\n}\n \nvoid build_tree() {\n\tsz = 1;\n\tfor (int i=0; i<n; ++i)\n\t\ttree_extend (i);\n}\n```\n\n## Compressed Implementation\n\nThis compressed implementation was proposed by [freopen](http://codeforces.com/profile/freopen).\n\n```cpp\nconst int N=1000000,INF=1000000000;\nstring a;\nint t[N][26],l[N],r[N],p[N],s[N],tv,tp,ts,la;\n \nvoid ukkadd (int c) {\n\tsuff:;\n\tif (r[tv]<tp) {\n\t\tif (t[tv][c]==-1) { t[tv][c]=ts;  l[ts]=la;\n\t\t\tp[ts++]=tv;  tv=s[tv];  tp=r[tv]+1;  goto suff; }\n\t\ttv=t[tv][c]; tp=l[tv];\n\t}\n\tif (tp==-1 || c==a[tp]-'a') tp++; else {\n\t\tl[ts+1]=la;  p[ts+1]=ts;\n\t\tl[ts]=l[tv];  r[ts]=tp-1;  p[ts]=p[tv];  t[ts][c]=ts+1;  t[ts][a[tp]-'a']=tv;\n\t\tl[tv]=tp;  p[tv]=ts;  t[p[ts]][a[l[ts]]-'a']=ts;  ts+=2;\n\t\ttv=s[p[ts-2]];  tp=l[ts-2];\n\t\twhile (tp<=r[ts-2]) {  tv=t[tv][a[tp]-'a'];  tp+=r[tv]-l[tv]+1;}\n\t\tif (tp==r[ts-2]+1)  s[ts-2]=tv;  else s[ts-2]=ts; \n\t\ttp=r[tv]-(tp-r[ts-2])+2;  goto suff;\n\t}\n}\n \nvoid build() {\n\tts=2;\n\ttv=0;\n\ttp=0;\n\tfill(r,r+N,(int)a.size()-1);\n\ts[0]=1;\n\tl[0]=-1;\n\tr[0]=-1;\n\tl[1]=-1;\n\tr[1]=-1;\n\tmemset (t, -1, sizeof t);\n\tfill(t[1],t[1]+26,0);\n\tfor (la=0; la<(int)a.size(); ++la)\n\t\tukkadd (a[la]-'a');\n}\n```\n\nSame code with comments:\n\n```cpp\nconst int N=1000000,    // maximum possible number of nodes in suffix tree\n\tINF=1000000000; // infinity constant\nstring a;       // input string for which the suffix tree is being built\nint t[N][26],   // array of transitions (state, letter)\n\tl[N],   // left...\n\tr[N],   // ...and right boundaries of the substring of a which correspond to incoming edge\n\tp[N],   // parent of the node\n\ts[N],   // suffix link\n\ttv,     // the node of the current suffix (if we're mid-edge, the lower node of the edge)\n\ttp,     // position in the string which corresponds to the position on the edge (between l[tv] and r[tv], inclusive)\n\tts,     // the number of nodes\n\tla;     // the current character in the string\n \nvoid ukkadd(int c) { // add character s to the tree\n\tsuff:;      // we'll return here after each transition to the suffix (and will add character again)\n\tif (r[tv]<tp) { // check whether we're still within the boundaries of the current edge\n\t\t// if we're not, find the next edge. If it doesn't exist, create a leaf and add it to the tree\n\t\tif (t[tv][c]==-1) {t[tv][c]=ts;l[ts]=la;p[ts++]=tv;tv=s[tv];tp=r[tv]+1;goto suff;}\n\t\ttv=t[tv][c];tp=l[tv];\n\t} // otherwise just proceed to the next edge\n\tif (tp==-1 || c==a[tp]-'a')\n\t\ttp++; // if the letter on the edge equal c, go down that edge\n\telse { \n\t\t// otherwise split the edge in two with middle in node ts\n\t\tl[ts]=l[tv];r[ts]=tp-1;p[ts]=p[tv];t[ts][a[tp]-'a']=tv;\n\t\t// add leaf ts+1. It corresponds to transition through c.\n\t\tt[ts][c]=ts+1;l[ts+1]=la;p[ts+1]=ts;\n\t\t// update info for the current node - remember to mark ts as parent of tv\n\t\tl[tv]=tp;p[tv]=ts;t[p[ts]][a[l[ts]]-'a']=ts;ts+=2;\n\t\t// prepare for descent\n\t\t// tp will mark where are we in the current suffix\n\t\ttv=s[p[ts-2]];tp=l[ts-2];\n\t\t// while the current suffix is not over, descend\n\t\twhile (tp<=r[ts-2]) {tv=t[tv][a[tp]-'a'];tp+=r[tv]-l[tv]+1;}\n\t\t// if we're in a node, add a suffix link to it, otherwise add the link to ts\n\t\t// (we'll create ts on next iteration).\n\t\tif (tp==r[ts-2]+1) s[ts-2]=tv; else s[ts-2]=ts; \n\t\t// add tp to the new edge and return to add letter to suffix\n\t\ttp=r[tv]-(tp-r[ts-2])+2;goto suff;\n\t}\n}\n \nvoid build() {\n\tts=2;\n\ttv=0;\n\ttp=0;\n\tfill(r,r+N,(int)a.size()-1);\n\t// initialize data for the root of the tree\n\ts[0]=1;\n\tl[0]=-1;\n\tr[0]=-1;\n\tl[1]=-1;\n\tr[1]=-1;\n\tmemset (t, -1, sizeof t);\n\tfill(t[1],t[1]+26,0);\n\t// add the text to the tree, letter by letter\n\tfor (la=0; la<(int)a.size(); ++la)\n\t\tukkadd (a[la]-'a');\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: ukkonen\n---\n\n# Suffix Tree. Ukkonen's Algorithm\n\n*This article is a stub and doesn't contain any descriptions. For a description of the algorithm, refer to other sources, such as [Algorithms on Strings, Trees, and Sequences](https://www.cs.cmu.edu/afs/cs/project/pscico-guyb/realworld/www/slidesF06/cmuonly/gusfield.pdf) by Dan Gusfield.*\n\nThis algorithm builds a suffix tree for a given string $s$ of length $n$ in $O(n\\log(k))$) time, where $k$ is the size of the alphabet (if $k$ is considered to be a constant, the asymptotic behavior is linear).\n\nThe input to the algorithm are the string $s$ and its length $n$, which are passed as global variables.\n\nThe main function `build_tree` builds a suffix tree. It is stored as an array of structures `node`, where `node[0]` is the root of the tree.\n\nIn order to simplify the code, the edges are stored in the same structures: for each vertex its structure `node` stores the information about the edge between it and its parent. Overall each `node` stores the following information: \n\n* `(l, r)` - left and right boundaries of the substring `s[l..r-1]` which correspond to the edge to this node,\n* `par` - the parent node,\n* `link` - the suffix link,\n* `next` - the list of edges going out from this node.\n\n```cpp\nstring s;\nint n;\n \nstruct node {\n\tint l, r, par, link;\n\tmap<char,int> next;\n \n\tnode (int l=0, int r=0, int par=-1)\n\t\t: l(l), r(r), par(par), link(-1) {}\n\tint len()  {  return r - l;  }\n\tint &get (char c) {\n\t\tif (!next.count(c))  next[c] = -1;\n\t\treturn next[c];\n\t}\n};\nnode t[MAXN];\nint sz;\n \nstruct state {\n\tint v, pos;\n\tstate (int v, int pos) : v(v), pos(pos)  {}\n};\nstate ptr (0, 0);\n \nstate go (state st, int l, int r) {\n\twhile (l < r)\n\t\tif (st.pos == t[st.v].len()) {\n\t\t\tst = state (t[st.v].get( s[l] ), 0);\n\t\t\tif (st.v == -1)  return st;\n\t\t}\n\t\telse {\n\t\t\tif (s[ t[st.v].l + st.pos ] != s[l])\n\t\t\t\treturn state (-1, -1);\n\t\t\tif (r-l < t[st.v].len() - st.pos)\n\t\t\t\treturn state (st.v, st.pos + r-l);\n\t\t\tl += t[st.v].len() - st.pos;\n\t\t\tst.pos = t[st.v].len();\n\t\t}\n\treturn st;\n}\n \nint split (state st) {\n\tif (st.pos == t[st.v].len())\n\t\treturn st.v;\n\tif (st.pos == 0)\n\t\treturn t[st.v].par;\n\tnode v = t[st.v];\n\tint id = sz++;\n\tt[id] = node (v.l, v.l+st.pos, v.par);\n\tt[v.par].get( s[v.l] ) = id;\n\tt[id].get( s[v.l+st.pos] ) = st.v;\n\tt[st.v].par = id;\n\tt[st.v].l += st.pos;\n\treturn id;\n}\n \nint get_link (int v) {\n\tif (t[v].link != -1)  return t[v].link;\n\tif (t[v].par == -1)  return 0;\n\tint to = get_link (t[v].par);\n\treturn t[v].link = split (go (state(to,t[to].len()), t[v].l + (t[v].par==0), t[v].r));\n}\n \nvoid tree_extend (int pos) {\n\tfor(;;) {\n\t\tstate nptr = go (ptr, pos, pos+1);\n\t\tif (nptr.v != -1) {\n\t\t\tptr = nptr;\n\t\t\treturn;\n\t\t}\n \n\t\tint mid = split (ptr);\n\t\tint leaf = sz++;\n\t\tt[leaf] = node (pos, n, mid);\n\t\tt[mid].get( s[pos] ) = leaf;\n \n\t\tptr.v = get_link (mid);\n\t\tptr.pos = t[ptr.v].len();\n\t\tif (!mid)  break;\n\t}\n}\n \nvoid build_tree() {\n\tsz = 1;\n\tfor (int i=0; i<n; ++i)\n\t\ttree_extend (i);\n}\n```\n\n## Compressed Implementation\n\nThis compressed implementation was proposed by [freopen](http://codeforces.com/profile/freopen).\n\n```cpp\nconst int N=1000000,INF=1000000000;\nstring a;\nint t[N][26],l[N],r[N],p[N],s[N],tv,tp,ts,la;\n \nvoid ukkadd (int c) {\n\tsuff:;\n\tif (r[tv]<tp) {\n\t\tif (t[tv][c]==-1) { t[tv][c]=ts;  l[ts]=la;\n\t\t\tp[ts++]=tv;  tv=s[tv];  tp=r[tv]+1;  goto suff; }\n\t\ttv=t[tv][c]; tp=l[tv];\n\t}\n\tif (tp==-1 || c==a[tp]-'a') tp++; else {\n\t\tl[ts+1]=la;  p[ts+1]=ts;\n\t\tl[ts]=l[tv];  r[ts]=tp-1;  p[ts]=p[tv];  t[ts][c]=ts+1;  t[ts][a[tp]-'a']=tv;\n\t\tl[tv]=tp;  p[tv]=ts;  t[p[ts]][a[l[ts]]-'a']=ts;  ts+=2;\n\t\ttv=s[p[ts-2]];  tp=l[ts-2];\n\t\twhile (tp<=r[ts-2]) {  tv=t[tv][a[tp]-'a'];  tp+=r[tv]-l[tv]+1;}\n\t\tif (tp==r[ts-2]+1)  s[ts-2]=tv;  else s[ts-2]=ts; \n\t\ttp=r[tv]-(tp-r[ts-2])+2;  goto suff;\n\t}\n}\n \nvoid build() {\n\tts=2;\n\ttv=0;\n\ttp=0;\n\tfill(r,r+N,(int)a.size()-1);\n\ts[0]=1;\n\tl[0]=-1;\n\tr[0]=-1;\n\tl[1]=-1;\n\tr[1]=-1;\n\tmemset (t, -1, sizeof t);\n\tfill(t[1],t[1]+26,0);\n\tfor (la=0; la<(int)a.size(); ++la)\n\t\tukkadd (a[la]-'a');\n}\n```\n\nSame code with comments:\n\n```cpp\nconst int N=1000000,    // maximum possible number of nodes in suffix tree\n\tINF=1000000000; // infinity constant\nstring a;       // input string for which the suffix tree is being built\nint t[N][26],   // array of transitions (state, letter)\n\tl[N],   // left...\n\tr[N],   // ...and right boundaries of the substring of a which correspond to incoming edge\n\tp[N],   // parent of the node\n\ts[N],   // suffix link\n\ttv,     // the node of the current suffix (if we're mid-edge, the lower node of the edge)\n\ttp,     // position in the string which corresponds to the position on the edge (between l[tv] and r[tv], inclusive)\n\tts,     // the number of nodes\n\tla;     // the current character in the string\n \nvoid ukkadd(int c) { // add character s to the tree\n\tsuff:;      // we'll return here after each transition to the suffix (and will add character again)\n\tif (r[tv]<tp) { // check whether we're still within the boundaries of the current edge\n\t\t// if we're not, find the next edge. If it doesn't exist, create a leaf and add it to the tree\n\t\tif (t[tv][c]==-1) {t[tv][c]=ts;l[ts]=la;p[ts++]=tv;tv=s[tv];tp=r[tv]+1;goto suff;}\n\t\ttv=t[tv][c];tp=l[tv];\n\t} // otherwise just proceed to the next edge\n\tif (tp==-1 || c==a[tp]-'a')\n\t\ttp++; // if the letter on the edge equal c, go down that edge\n\telse { \n\t\t// otherwise split the edge in two with middle in node ts\n\t\tl[ts]=l[tv];r[ts]=tp-1;p[ts]=p[tv];t[ts][a[tp]-'a']=tv;\n\t\t// add leaf ts+1. It corresponds to transition through c.\n\t\tt[ts][c]=ts+1;l[ts+1]=la;p[ts+1]=ts;\n\t\t// update info for the current node - remember to mark ts as parent of tv\n\t\tl[tv]=tp;p[tv]=ts;t[p[ts]][a[l[ts]]-'a']=ts;ts+=2;\n\t\t// prepare for descent\n\t\t// tp will mark where are we in the current suffix\n\t\ttv=s[p[ts-2]];tp=l[ts-2];\n\t\t// while the current suffix is not over, descend\n\t\twhile (tp<=r[ts-2]) {tv=t[tv][a[tp]-'a'];tp+=r[tv]-l[tv]+1;}\n\t\t// if we're in a node, add a suffix link to it, otherwise add the link to ts\n\t\t// (we'll create ts on next iteration).\n\t\tif (tp==r[ts-2]+1) s[ts-2]=tv; else s[ts-2]=ts; \n\t\t// add tp to the new edge and return to add letter to suffix\n\t\ttp=r[tv]-(tp-r[ts-2])+2;goto suff;\n\t}\n}\n \nvoid build() {\n\tts=2;\n\ttv=0;\n\ttp=0;\n\tfill(r,r+N,(int)a.size()-1);\n\t// initialize data for the root of the tree\n\ts[0]=1;\n\tl[0]=-1;\n\tr[0]=-1;\n\tl[1]=-1;\n\tr[1]=-1;\n\tmemset (t, -1, sizeof t);\n\tfill(t[1],t[1]+26,0);\n\t// add the text to the tree, letter by letter\n\tfor (la=0; la<(int)a.size(); ++la)\n\t\tukkadd (a[la]-'a');\n}\n```\n\n## Practice Problems\n\n* [UVA 10679 - I Love Strings!!!](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1620)\n", "problem_ids": [], "title": "Suffix Tree. Ukkonen's Algorithm"}, {"article": "---\ntitle: Manacher's Algorithm - Finding all sub-palindromes in O(N)\ntags:\n  - Translated\ne_maxx_link: palindromes_count\n---\n# Manacher's Algorithm - Finding all sub-palindromes in $O(N)$\n\n## Statement\n\nGiven string $s$ with length $n$. Find all the pairs $(i, j)$ such that substring $s[i\\dots j]$ is a palindrome. String $t$ is a palindrome when $t = t_{rev}$ ($t_{rev}$ is a reversed string for $t$).\n\n## More precise statement\n\nIn the worst case string might have up to $O(n^2)$ palindromic substrings, and at the first glance it seems that there is no linear algorithm for this problem.\n\nBut the information about the palindromes can be kept **in a compact way**: for each position $i$ we will find the number of non-empty palindromes centered at this position.\n\nPalindromes with a common center form a contiguous chain, that is if we have a palindrome of length $l$ centered in $i$, we also have palindromes of lengths $l-2$, $l-4$ and so on also centered in $i$. Therefore, we will collect the information about all palindromic substrings in this way.\n\nPalindromes of odd and even lengths are accounted for separately as $d_{odd}[i]$ and $d_{even}[i]$. For the palindromes of even length we assume that they're centered in the position $i$ if their two central characters are $s[i]$ and $s[i-1]$.\n\nFor instance, string $s = abababc$ has three palindromes with odd length with centers in the position $s[3] = b$, i. e. $d_{odd}[3] = 3$:\n\n$$a\\ \\overbrace{b\\ a\\ \\underbrace{b}_{s_3}\\ a\\ b}^{d_{odd}[3]=3} c$$\n\nAnd string $s = cbaabd$ has two palindromes with even length with centers in the position $s[3] = a$, i. e. $d_{even}[3] = 2$:\n\n$$c\\ \\overbrace{b\\ a\\ \\underbrace{a}_{s_3}\\ b}^{d_{even}[3]=2} d$$\n\nIt's a surprising fact that there is an algorithm, which is simple enough, that calculates these \"palindromity arrays\" $d_{odd}[]$ and $d_{even}[]$ in linear time. The algorithm is described in this article.\n\n## Solution\n\nIn general, this problem has many solutions: with [String Hashing](/string/string-hashing.html) it can be solved in $O(n\\cdot \\log n)$, and with [Suffix Trees](/string/suffix-tree-ukkonen.html) and fast LCA this problem can be solved in $O(n)$.\n\nBut the method described here is **sufficiently** simpler and has less hidden constant in time and memory complexity. This algorithm was discovered by **Glenn K. Manacher** in 1975.\n\nAnother modern way to solve this problem and to deal with palindromes in general is through the so-called palindromic tree, or eertree.\n\n## Trivial algorithm\n\nTo avoid ambiguities in the further description we denote what \"trivial algorithm\" is.\n\nIt's the algorithm that does the following. For each center position $i$ it tries to increase the answer by one as long as it's possible, comparing a pair of corresponding characters each time.\n\nSuch an algorithm is slow, it can calculate the answer only in $O(n^2)$.\n\nThe implementation of the trivial algorithm is:\n\n```cpp\nvector<int> manacher_odd(string s) {\n    int n = s.size();\n    s = \"$\" + s + \"^\";\n    vector<int> p(n + 2);\n    for(int i = 1; i <= n; i++) {\n        while(s[i - p[i]] == s[i + p[i]]) {\n            p[i]++;\n        }\n    }\n    return vector<int>(begin(p) + 1, end(p) - 1);\n}\n```\n\nTerminal characters `$` and `^` were used to avoid dealing with ends of the string separately.\n\n## Manacher's algorithm\n\nWe describe the algorithm to find all the sub-palindromes with odd length, i. e. to calculate $d_{odd}[]$.\n\nFor fast calculation we'll maintain the **borders $(l, r)$** of the rightmost found (sub-)palindrome (i. e. the current rightmost (sub-)palindrome is $s[l+1] s[l+2] \\dots s[r-1]$). Initially we set $l = 0, r = 1$, which corresponds to the empty string.\n\nSo, we want to calculate $d_{odd}[i]$ for the next $i$, and all the previous values in $d_{odd}[]$ have been already calculated. We do the following:\n\n* If $i$ is outside the current sub-palindrome, i. e. $i \\geq r$, we'll just launch the trivial algorithm.\n    \n    So we'll increase $d_{odd}[i]$ consecutively and check each time if the current rightmost substring $[i - d_{odd}[i]\\dots i + d_{odd}[i]]$ is a palindrome. When we find the first mismatch or meet the boundaries of $s$, we'll stop. In this case we've finally calculated $d_{odd}[i]$. After this, we must not forget to update $(l, r)$. $r$ should be updated in such a way that it represents the last index of the current rightmost sub-palindrome.\n\n* Now consider the case when $i \\le r$. We'll try to extract some information from the already calculated values in $d_{odd}[]$. So, let's find the \"mirror\" position of $i$ in the sub-palindrome $(l, r)$, i.e. we'll get the position $j = l + (r - i)$, and we check the value of $d_{odd}[j]$. Because $j$ is the position symmetrical to $i$ with respect to $(l+r)/2$, we can **almost always** assign $d_{odd}[i] = d_{odd}[j]$. Illustration of this (palindrome around $j$ is actually \"copied\" into the palindrome around $i$):\n    \n    $$\n    \\ldots\\ \n    \\overbrace{\n        s_{l+1}\\ \\ldots\\ \n        \\underbrace{\n            s_{j-d_{odd}[j]+1}\\ \\ldots\\ s_j\\ \\ldots\\ s_{j+d_{odd}[j]-1}\\ \n        }_\\text{palindrome}\\ \n        \\ldots\\ \n        \\underbrace{\n            s_{i-d_{odd}[j]+1}\\ \\ldots\\ s_i\\ \\ldots\\ s_{i+d_{odd}[j]-1}\\ \n        }_\\text{palindrome}\\ \n        \\ldots\\ s_{r-1}\\ \n    }^\\text{palindrome}\\ \n    \\ldots\n    $$\n    \n    But there is a **tricky case** to be handled correctly: when the \"inner\" palindrome reaches the borders of the \"outer\" one, i. e. $j - d_{odd}[j] \\le l$ (or, which is the same, $i + d_{odd}[j] \\ge r$). Because the symmetry outside the \"outer\" palindrome is not guaranteed, just assigning $d_{odd}[i] = d_{odd}[j]$ will be incorrect: we do not have enough data to state that the palindrome in the position $i$ has the same length.\n    \n    Actually, we should restrict the length of our palindrome for now, i. e. assign $d_{odd}[i] = r - i$, to handle such situations correctly. After this we'll run the trivial algorithm which will try to increase $d_{odd}[i]$ while it's possible.\n    \n    Illustration of this case (the palindrome with center $j$ is restricted to fit the \"outer\" palindrome):\n    \n    $$\n    \\ldots\\ \n    \\overbrace{\n        \\underbrace{\n            s_{l+1}\\ \\ldots\\ s_j\\ \\ldots\\ s_{j+(j-l)-1}\\ \n        }_\\text{palindrome}\\ \n        \\ldots\\ \n        \\underbrace{\n            s_{i-(r-i)+1}\\ \\ldots\\ s_i\\ \\ldots\\ s_{r-1}\n        }_\\text{palindrome}\\ \n    }^\\text{palindrome}\\ \n    \\underbrace{\n        \\ldots \\ldots \\ldots \\ldots \\ldots\n    }_\\text{try moving here}\n    $$\n    \n    It is shown in the illustration that though the palindrome with center $j$ could be larger and go outside the \"outer\" palindrome, but with $i$ as the center we can use only the part that entirely fits into the \"outer\" palindrome. But the answer for the position $i$ ($d_{odd}[i]$) can be much bigger than this part, so next we'll run our trivial algorithm that will try to grow it outside our \"outer\" palindrome, i. e. to the region \"try moving here\".\n\nAgain, we should not forget to update the values $(l, r)$ after calculating each $d_{odd}[i]$.\n\n## Complexity of Manacher's algorithm\n\nAt the first glance it's not obvious that this algorithm has linear time complexity, because we often run the naive algorithm while searching the answer for a particular position.\n\nHowever, a more careful analysis shows that the algorithm is linear. In fact, [Z-function building algorithm](/string/z-function.html), which looks similar to this algorithm, also works in linear time.\n\nWe can notice that every iteration of trivial algorithm increases $r$ by one. Also $r$ cannot be decreased during the algorithm. So, trivial algorithm will make $O(n)$ iterations in total.\n\nOther parts of Manacher's algorithm work obviously in linear time. Thus, we get $O(n)$ time complexity.\n\n## Implementation of Manacher's algorithm\n\nFor calculating $d_{odd}[]$, we get the following code. Things to note:\n\n - $i$ is the index of the center letter of the current palindrome.\n - If $i$ exceeds $r$, $d_{odd}[i]$ is initialized to 0.\n - If $i$ does not exceed $r$, $d_{odd}[i]$ is either initialized to the $d_{odd}[j]$, where $j$ is the mirror position of $i$ in $(l,r)$, or $d_{odd}[i]$ is restricted to the size of the \"outer\" palindrome.\n - The while loop denotes the trivial algorithm. We launch it irrespective of the value of $k$.\n - If the size of palindrome centered at $i$ is $x$, then $d_{odd}[i]$ stores $\\frac{x+1}{2}$.\n\n```cpp\nvector<int> manacher_odd(string s) {\n    int n = s.size();\n    s = \"$\" + s + \"^\";\n    vector<int> p(n + 2);\n    int l = 1, r = 1;\n    for(int i = 1; i <= n; i++) {\n        p[i] = max(0, min(r - i, p[l + (r - i)]));\n        while(s[i - p[i]] == s[i + p[i]]) {\n            p[i]++;\n        }\n        if(i + p[i] > r) {\n            l = i - p[i], r = i + p[i];\n        }\n    }\n    return vector<int>(begin(p) + 1, end(p) - 1);\n}\n```\n\n## Working with parities\n\nAlthough it is possible to implement Manacher's algorithm for odd and even lengths separately, the implementation of the version for even lengths is often deemed more difficult, as it is less natural and easily leads to off-by-one errors.\n\nTo mitigate this, it is possible to reduce the whole problem to the case when we only deal with the palindromes of odd length. To do this, we can put an additional `#` character between each letter in the string and also in the beginning and the end of the string:\n\n$$abcbcba \\to \\#a\\#b\\#c\\#b\\#c\\#b\\#a\\#,$$\n\n$$d = [1,2,1,2,1,4,1,8,1,4,1,2,1,2,1].$$\n\nAs you can see, $d[2i]=2 d_{even}[i]+1$ and $d[2i+1]=2 d_{odd}[i]$ where $d$ denotes the Manacher array for odd-length palindromes in `#`-joined string, while $d_{odd}$ and $d_{even}$ correspond to the arrays defined above in the initial string.\n\nIndeed, `#` characters do not affect the odd-length palindromes, which are still centered in the initial string's characters, but now even-length palindromes of the initial string are odd-length palindromes of the new string centered in `#` characters.\n\nNote that $d[2i]$ and $d[2i+1]$ are essentially the increased by $1$ lengths of the largest odd- and even-length palindromes centered in $i$ correspondingly.\n\nThe reduction is implemented in the following way:\n\n```cpp\nvector<int> manacher(string s) {\n    string t;\n    for(auto c: s) {\n        t += string(\"#\") + c;\n    }\n    auto res = manacher_odd(t + \"#\");\n    return vector<int>(begin(res) + 1, end(res) - 1);\n}\n```\n\nFor simplicity, splitting the array into $d_{odd}$ and $d_{even}$ as well as their explicit calculation is omitted.\n\n", "full_article": "---\ntitle: Manacher's Algorithm - Finding all sub-palindromes in O(N)\ntags:\n  - Translated\ne_maxx_link: palindromes_count\n---\n# Manacher's Algorithm - Finding all sub-palindromes in $O(N)$\n\n## Statement\n\nGiven string $s$ with length $n$. Find all the pairs $(i, j)$ such that substring $s[i\\dots j]$ is a palindrome. String $t$ is a palindrome when $t = t_{rev}$ ($t_{rev}$ is a reversed string for $t$).\n\n## More precise statement\n\nIn the worst case string might have up to $O(n^2)$ palindromic substrings, and at the first glance it seems that there is no linear algorithm for this problem.\n\nBut the information about the palindromes can be kept **in a compact way**: for each position $i$ we will find the number of non-empty palindromes centered at this position.\n\nPalindromes with a common center form a contiguous chain, that is if we have a palindrome of length $l$ centered in $i$, we also have palindromes of lengths $l-2$, $l-4$ and so on also centered in $i$. Therefore, we will collect the information about all palindromic substrings in this way.\n\nPalindromes of odd and even lengths are accounted for separately as $d_{odd}[i]$ and $d_{even}[i]$. For the palindromes of even length we assume that they're centered in the position $i$ if their two central characters are $s[i]$ and $s[i-1]$.\n\nFor instance, string $s = abababc$ has three palindromes with odd length with centers in the position $s[3] = b$, i. e. $d_{odd}[3] = 3$:\n\n$$a\\ \\overbrace{b\\ a\\ \\underbrace{b}_{s_3}\\ a\\ b}^{d_{odd}[3]=3} c$$\n\nAnd string $s = cbaabd$ has two palindromes with even length with centers in the position $s[3] = a$, i. e. $d_{even}[3] = 2$:\n\n$$c\\ \\overbrace{b\\ a\\ \\underbrace{a}_{s_3}\\ b}^{d_{even}[3]=2} d$$\n\nIt's a surprising fact that there is an algorithm, which is simple enough, that calculates these \"palindromity arrays\" $d_{odd}[]$ and $d_{even}[]$ in linear time. The algorithm is described in this article.\n\n## Solution\n\nIn general, this problem has many solutions: with [String Hashing](/string/string-hashing.html) it can be solved in $O(n\\cdot \\log n)$, and with [Suffix Trees](/string/suffix-tree-ukkonen.html) and fast LCA this problem can be solved in $O(n)$.\n\nBut the method described here is **sufficiently** simpler and has less hidden constant in time and memory complexity. This algorithm was discovered by **Glenn K. Manacher** in 1975.\n\nAnother modern way to solve this problem and to deal with palindromes in general is through the so-called palindromic tree, or eertree.\n\n## Trivial algorithm\n\nTo avoid ambiguities in the further description we denote what \"trivial algorithm\" is.\n\nIt's the algorithm that does the following. For each center position $i$ it tries to increase the answer by one as long as it's possible, comparing a pair of corresponding characters each time.\n\nSuch an algorithm is slow, it can calculate the answer only in $O(n^2)$.\n\nThe implementation of the trivial algorithm is:\n\n```cpp\nvector<int> manacher_odd(string s) {\n    int n = s.size();\n    s = \"$\" + s + \"^\";\n    vector<int> p(n + 2);\n    for(int i = 1; i <= n; i++) {\n        while(s[i - p[i]] == s[i + p[i]]) {\n            p[i]++;\n        }\n    }\n    return vector<int>(begin(p) + 1, end(p) - 1);\n}\n```\n\nTerminal characters `$` and `^` were used to avoid dealing with ends of the string separately.\n\n## Manacher's algorithm\n\nWe describe the algorithm to find all the sub-palindromes with odd length, i. e. to calculate $d_{odd}[]$.\n\nFor fast calculation we'll maintain the **borders $(l, r)$** of the rightmost found (sub-)palindrome (i. e. the current rightmost (sub-)palindrome is $s[l+1] s[l+2] \\dots s[r-1]$). Initially we set $l = 0, r = 1$, which corresponds to the empty string.\n\nSo, we want to calculate $d_{odd}[i]$ for the next $i$, and all the previous values in $d_{odd}[]$ have been already calculated. We do the following:\n\n* If $i$ is outside the current sub-palindrome, i. e. $i \\geq r$, we'll just launch the trivial algorithm.\n    \n    So we'll increase $d_{odd}[i]$ consecutively and check each time if the current rightmost substring $[i - d_{odd}[i]\\dots i + d_{odd}[i]]$ is a palindrome. When we find the first mismatch or meet the boundaries of $s$, we'll stop. In this case we've finally calculated $d_{odd}[i]$. After this, we must not forget to update $(l, r)$. $r$ should be updated in such a way that it represents the last index of the current rightmost sub-palindrome.\n\n* Now consider the case when $i \\le r$. We'll try to extract some information from the already calculated values in $d_{odd}[]$. So, let's find the \"mirror\" position of $i$ in the sub-palindrome $(l, r)$, i.e. we'll get the position $j = l + (r - i)$, and we check the value of $d_{odd}[j]$. Because $j$ is the position symmetrical to $i$ with respect to $(l+r)/2$, we can **almost always** assign $d_{odd}[i] = d_{odd}[j]$. Illustration of this (palindrome around $j$ is actually \"copied\" into the palindrome around $i$):\n    \n    $$\n    \\ldots\\ \n    \\overbrace{\n        s_{l+1}\\ \\ldots\\ \n        \\underbrace{\n            s_{j-d_{odd}[j]+1}\\ \\ldots\\ s_j\\ \\ldots\\ s_{j+d_{odd}[j]-1}\\ \n        }_\\text{palindrome}\\ \n        \\ldots\\ \n        \\underbrace{\n            s_{i-d_{odd}[j]+1}\\ \\ldots\\ s_i\\ \\ldots\\ s_{i+d_{odd}[j]-1}\\ \n        }_\\text{palindrome}\\ \n        \\ldots\\ s_{r-1}\\ \n    }^\\text{palindrome}\\ \n    \\ldots\n    $$\n    \n    But there is a **tricky case** to be handled correctly: when the \"inner\" palindrome reaches the borders of the \"outer\" one, i. e. $j - d_{odd}[j] \\le l$ (or, which is the same, $i + d_{odd}[j] \\ge r$). Because the symmetry outside the \"outer\" palindrome is not guaranteed, just assigning $d_{odd}[i] = d_{odd}[j]$ will be incorrect: we do not have enough data to state that the palindrome in the position $i$ has the same length.\n    \n    Actually, we should restrict the length of our palindrome for now, i. e. assign $d_{odd}[i] = r - i$, to handle such situations correctly. After this we'll run the trivial algorithm which will try to increase $d_{odd}[i]$ while it's possible.\n    \n    Illustration of this case (the palindrome with center $j$ is restricted to fit the \"outer\" palindrome):\n    \n    $$\n    \\ldots\\ \n    \\overbrace{\n        \\underbrace{\n            s_{l+1}\\ \\ldots\\ s_j\\ \\ldots\\ s_{j+(j-l)-1}\\ \n        }_\\text{palindrome}\\ \n        \\ldots\\ \n        \\underbrace{\n            s_{i-(r-i)+1}\\ \\ldots\\ s_i\\ \\ldots\\ s_{r-1}\n        }_\\text{palindrome}\\ \n    }^\\text{palindrome}\\ \n    \\underbrace{\n        \\ldots \\ldots \\ldots \\ldots \\ldots\n    }_\\text{try moving here}\n    $$\n    \n    It is shown in the illustration that though the palindrome with center $j$ could be larger and go outside the \"outer\" palindrome, but with $i$ as the center we can use only the part that entirely fits into the \"outer\" palindrome. But the answer for the position $i$ ($d_{odd}[i]$) can be much bigger than this part, so next we'll run our trivial algorithm that will try to grow it outside our \"outer\" palindrome, i. e. to the region \"try moving here\".\n\nAgain, we should not forget to update the values $(l, r)$ after calculating each $d_{odd}[i]$.\n\n## Complexity of Manacher's algorithm\n\nAt the first glance it's not obvious that this algorithm has linear time complexity, because we often run the naive algorithm while searching the answer for a particular position.\n\nHowever, a more careful analysis shows that the algorithm is linear. In fact, [Z-function building algorithm](/string/z-function.html), which looks similar to this algorithm, also works in linear time.\n\nWe can notice that every iteration of trivial algorithm increases $r$ by one. Also $r$ cannot be decreased during the algorithm. So, trivial algorithm will make $O(n)$ iterations in total.\n\nOther parts of Manacher's algorithm work obviously in linear time. Thus, we get $O(n)$ time complexity.\n\n## Implementation of Manacher's algorithm\n\nFor calculating $d_{odd}[]$, we get the following code. Things to note:\n\n - $i$ is the index of the center letter of the current palindrome.\n - If $i$ exceeds $r$, $d_{odd}[i]$ is initialized to 0.\n - If $i$ does not exceed $r$, $d_{odd}[i]$ is either initialized to the $d_{odd}[j]$, where $j$ is the mirror position of $i$ in $(l,r)$, or $d_{odd}[i]$ is restricted to the size of the \"outer\" palindrome.\n - The while loop denotes the trivial algorithm. We launch it irrespective of the value of $k$.\n - If the size of palindrome centered at $i$ is $x$, then $d_{odd}[i]$ stores $\\frac{x+1}{2}$.\n\n```cpp\nvector<int> manacher_odd(string s) {\n    int n = s.size();\n    s = \"$\" + s + \"^\";\n    vector<int> p(n + 2);\n    int l = 1, r = 1;\n    for(int i = 1; i <= n; i++) {\n        p[i] = max(0, min(r - i, p[l + (r - i)]));\n        while(s[i - p[i]] == s[i + p[i]]) {\n            p[i]++;\n        }\n        if(i + p[i] > r) {\n            l = i - p[i], r = i + p[i];\n        }\n    }\n    return vector<int>(begin(p) + 1, end(p) - 1);\n}\n```\n\n## Working with parities\n\nAlthough it is possible to implement Manacher's algorithm for odd and even lengths separately, the implementation of the version for even lengths is often deemed more difficult, as it is less natural and easily leads to off-by-one errors.\n\nTo mitigate this, it is possible to reduce the whole problem to the case when we only deal with the palindromes of odd length. To do this, we can put an additional `#` character between each letter in the string and also in the beginning and the end of the string:\n\n$$abcbcba \\to \\#a\\#b\\#c\\#b\\#c\\#b\\#a\\#,$$\n\n$$d = [1,2,1,2,1,4,1,8,1,4,1,2,1,2,1].$$\n\nAs you can see, $d[2i]=2 d_{even}[i]+1$ and $d[2i+1]=2 d_{odd}[i]$ where $d$ denotes the Manacher array for odd-length palindromes in `#`-joined string, while $d_{odd}$ and $d_{even}$ correspond to the arrays defined above in the initial string.\n\nIndeed, `#` characters do not affect the odd-length palindromes, which are still centered in the initial string's characters, but now even-length palindromes of the initial string are odd-length palindromes of the new string centered in `#` characters.\n\nNote that $d[2i]$ and $d[2i+1]$ are essentially the increased by $1$ lengths of the largest odd- and even-length palindromes centered in $i$ correspondingly.\n\nThe reduction is implemented in the following way:\n\n```cpp\nvector<int> manacher(string s) {\n    string t;\n    for(auto c: s) {\n        t += string(\"#\") + c;\n    }\n    auto res = manacher_odd(t + \"#\");\n    return vector<int>(begin(res) + 1, end(res) - 1);\n}\n```\n\nFor simplicity, splitting the array into $d_{odd}$ and $d_{even}$ as well as their explicit calculation is omitted.\n\n## Problems\n\n- [Library Checker - Enumerate Palindromes](https://judge.yosupo.jp/problem/enumerate_palindromes)\n- [Longest Palindrome](https://cses.fi/problemset/task/1111)\n- [UVA 11475 - Extend to Palindrome](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=26&page=show_problem&problem=2470)\n- [GYM - (Q) QueryreuQ](https://codeforces.com/gym/101806/problem/Q)\n- [CF - Prefix-Suffix Palindrome](https://codeforces.com/contest/1326/problem/D2)\n- [SPOJ - Number of Palindromes](https://www.spoj.com/problems/NUMOFPAL/)\n- [Kattis - Palindromes](https://open.kattis.com/problems/palindromes)\n\n", "problem_ids": [], "title": "Manacher's Algorithm - Finding all sub-palindromes in $O(N)$"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: string_tandems\n---\n\n# Finding repetitions\n\nGiven a string $s$ of length $n$.\n\nA **repetition** is two occurrences of a string in a row.\nIn other words a repetition can be described by a pair of indices $i < j$ such that the substring $s[i \\dots j]$ consists of two identical strings written after each other.\n\nThe challenge is to **find all repetitions** in a given string $s$.\nOr a simplified task: find **any** repetition or find the **longest** repetition.\n\nThe algorithm described here was published in 1982 by Main and Lorentz.\n\n## Example\n\nConsider the repetitions in the following example string:\n\n$$acababaee$$\n\nThe string contains the following three repetitions:\n\n- $s[2 \\dots 5] = abab$\n- $s[3 \\dots 6] = baba$\n- $s[7 \\dots 7] = ee$\n\nAnother example:\n\n$$abaaba$$\n\nHere there are only two repetitions\n\n- $s[0 \\dots 5] = abaaba$\n- $s[2 \\dots 3] = aa$\n\n## Number of repetitions\n\nIn general there can be up to $O(n^2)$ repetitions in a string of length $n$.\nAn obvious example is a string consisting of $n$ times the same letter, in this case any substring of even length is a repetition.\nIn general any periodic string with a short period will contain a lot of repetitions.\n\nOn the other hand this fact does not prevent computing the number of repetitions in $O(n \\log n)$ time, because the algorithm can give the repetitions in compressed form, in groups of several pieces at once.\n\nThere is even the concept, that describes groups of periodic substrings with tuples of size four.\nIt has been proven that we the number of such groups is at most linear with respect to the string length.\n\nAlso, here are some more interesting results related to the number of repetitions:\n\n  - The number of primitive repetitions (those whose halves are not repetitions) is at most $O(n \\log n)$.\n  - If we encode repetitions with tuples of numbers (called Crochemore triples) $(i,~ p,~ r)$ (where $i$ is the position of the beginning, $p$ the length of the repeating substring, and $r$ the number of repetitions), then all repetitions can be described with $O(n \\log n)$ such triples.\n  - Fibonacci strings, defined as \n    \n    \\[\\begin{align}\n    t_0 &= a, \\\\\\\\\n    t_1 &= b, \\\\\\\\\n    t_i &= t_{i-1} + t_{i-2},\n    \\end{align}\\]\n    \n    are \"strongly\" periodic.\n    The number of repetitions in the Fibonacci string $f_i$, even in the compressed with Crochemore triples, is $O(f_n \\log f_n)$.\n    The number of primitive repetitions is also $O(f_n \\log f_n)$.\n\n## Main-Lorentz algorithm\n\nThe idea behind the Main-Lorentz algorithm is **divide-and-conquer**.\n\nIt splits the initial string into halves, and computes the number of repetitions that lie completely in each halve by two recursive calls.\nThen comes the difficult part.\nThe algorithm finds all repetitions starting in the first half and ending in the second half (which we will call **crossing repetitions**).\nThis is the essential part of the Main-Lorentz algorithm, and we will discuss it in detail here.\n\nThe complexity of divide-and-conquer algorithms is well researched.\nThe [master theorem](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)) says, that we will end up with an $O(n \\log n)$ algorithm, if we can compute the crossing repetitions in $O(n)$ time.\n\n### Search for crossing repetitions\n\nSo we want to find all such repetitions that start in the first half of the string, let's call it $u$, and end in the second half, let's call it $v$:\n\n$$s = u + v$$\n\nTheir lengths are approximately equal to the length of $s$ divided by two.\n\nConsider an arbitrary repetition and look at the middle character (more precisely the first character of the second half of the repetition).\nI.e. if the repetition is a substring $s[i \\dots j]$, then the middle character is $(i + j + 1) / 2$.\n\nWe call a repetition **left** or **right** depending on which string this character is located - in the string $u$ or in the string $v$.\nIn other words a string is called left, if the majority of it lies in $u$, otherwise we call it right.\n\nWe will now discuss how to find **all left repetitions**.\nFinding all right repetitions can be done in the same way.\n\nLet us denote the length of the left repetition by $2l$ (i.e. each half of the repetition has length $l$).\nConsider the first character of the repetition falling into the string $v$ (it is at position $|u|$ in the string $s$).\nIt coincides with the character $l$ positions before it, let's denote this position $cntr$.\n\nWe will fixate this position $cntr$, and **look for all repetitions at this position** $cntr$.\n\nFor example:\n\n$$c ~ \\underset{cntr}{a} ~ c ~ | ~ a ~ d ~ a$$\n\nThe vertical lines divides the two halves.\nHere we fixated the position $cntr = 1$, and at this position we find the repetition $caca$.\n\nIt is clear, that if we fixate the position $cntr$, we simultaneously fixate the length of the possible repetitions: $l = |u| - cntr$.\nOnce we know how to find these repetitions, we will iterate over all possible values for $cntr$ from $0$ to $|u|-1$, and find all left crossover repetitions of length $l = |u|,~ |u|-1,~ \\dots, 1$.\n\n### Criterion for left crossing repetitions\n\nNow, how can we find all such repetitions for a fixated $cntr$?\nKeep in mind that there still can be multiple such repetitions.\n\nLet's again look at a visualization, this time for the repetition $abcabc$:\n\n$$\\overbrace{a}^{l_1} ~ \\overbrace{\\underset{cntr}{b} ~ c}^{l_2} ~ \\overbrace{a}^{l_1} ~ | ~ \\overbrace{b ~ c}^{l_2}$$\n\nHere we denoted the lengths of the two pieces of the repetition with $l_1$ and $l_2$:\n$l_1$ is the length of the repetition up to the position $cntr-1$, and $l_2$ is the length of the repetition from $cntr$ to the end of the half of the repetition.\nWe have $2l = l_1 + l_2 + l_1 + l_2$ as the total length of the repetition.\n\nLet us generate **necessary and sufficient** conditions for such a repetition at position $cntr$ of length $2l = 2(l_1 + l_2) = 2(|u| - cntr)$:\n\n- Let $k_1$ be the largest number such that the first $k_1$ characters before the position $cntr$ coincide with the last $k_1$ characters in the string $u$:\n  \n$$\nu[cntr - k_1 \\dots cntr - 1] = u[|u| - k_1 \\dots |u| - 1]\n$$\n  \n- Let $k_2$ be the largest number such that the $k_2$ characters starting at position $cntr$ coincide with the first $k_2$ characters in the string $v$:\n\n$$  \n  u[cntr \\dots cntr + k_2 - 1] = v[0 \\dots k_2 - 1]\n$$\n  \n- Then we have a repetition exactly for any pair $(l_1,~ l_2)$ with\n\n$$\n  \\begin{align}\n  l_1 &\\le k_1, \\\\\\\\\n  l_2 &\\le k_2. \\\\\\\\\n  \\end{align}\n$$\n\nTo summarize:\n\n- We fixate a specific position $cntr$.\n- All repetition which we will find now have length $2l = 2(|u| - cntr)$.\n  There might be multiple such repetitions, they depend on the lengths $l_1$ and $l_2 = l - l_1$.\n- We find $k_1$ and $k_2$ as described above.\n- Then all suitable repetitions are the ones for which the lengths of the pieces $l_1$ and $l_2$ satisfy the conditions:\n\n$$\n  \\begin{align}\n  l_1 + l_2 &= l = |u| - cntr \\\\\\\\\n  l_1 &\\le k_1, \\\\\\\\\n  l_2 &\\le k_2. \\\\\\\\\n  \\end{align}\n$$\n\nTherefore the only remaining part is how we can compute the values $k_1$ and $k_2$ quickly for every position $cntr$.\nLuckily we can compute them in $O(1)$ using the [Z-function](../string/z-function.md):\n\n- To can find the value $k_1$ for each position by calculating the Z-function for the string $\\overline{u}$ (i.e. the reversed string $u$).\n  Then the value $k_1$ for a particular $cntr$ will be equal to the corresponding value of the array of the Z-function.\n- To precompute all values $k_2$, we calculate the Z-function for the string $v + \\# + u$ (i.e. the string $u$ concatenated with the separator character $\\#$ and the string $v$).\n  Again we just need to look up the corresponding value in the Z-function to get the $k_2$ value.\n\nSo this is enough to find all left crossing repetitions.\n\n### Right crossing repetitions\n\nFor computing the right crossing repetitions we act similarly:\nwe define the center $cntr$ as the character corresponding to the last character in the string $u$.\n\nThen the length $k_1$ will be defined as the largest number of characters before the position $cntr$ (inclusive) that coincide with the last characters of the string $u$.\nAnd the length $k_2$ will be defined as the largest number of characters starting at $cntr + 1$ that coincide with the characters of the string $v$.\n\nThus we can find the values $k_1$ and $k_2$ by computing the Z-function for the strings $\\overline{u} + \\# + \\overline{v}$ and $v$.\n\nAfter that we can find the repetitions by looking at all positions $cntr$, and use the same criterion as we had for left crossing repetitions.\n\n### Implementation\n\nThe implementation of the Main-Lorentz algorithm finds all repetitions in form of peculiar tuples of size four: $(cntr,~ l,~ k_1,~ k_2)$ in $O(n \\log n)$ time.\nIf you only want to find the number of repetitions in a string, or only want to find the longest repetition in a string, this information is enough and the runtime will still be $O(n \\log n)$.\n\nNotice that if you want to expand these tuples to get the starting and end position of each repetition, then the runtime will be the runtime will be $O(n^2)$ (remember that there can be $O(n^2)$ repetitions).\nIn this implementation we will do so, and store all found repetition in a vector of pairs of start and end indices.\n\n```{.cpp file=main_lorentz}\nvector<int> z_function(string const& s) {\n    int n = s.size();\n    vector<int> z(n);\n    for (int i = 1, l = 0, r = 0; i < n; i++) {\n        if (i <= r)\n            z[i] = min(r-i+1, z[i-l]);\n        while (i + z[i] < n && s[z[i]] == s[i+z[i]])\n            z[i]++;\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\nint get_z(vector<int> const& z, int i) {\n    if (0 <= i && i < (int)z.size())\n        return z[i];\n    else\n        return 0;\n}\n\nvector<pair<int, int>> repetitions;\n\nvoid convert_to_repetitions(int shift, bool left, int cntr, int l, int k1, int k2) {\n    for (int l1 = max(1, l - k2); l1 <= min(l, k1); l1++) {\n        if (left && l1 == l) break;\n        int l2 = l - l1;\n        int pos = shift + (left ? cntr - l1 : cntr - l - l1 + 1);\n        repetitions.emplace_back(pos, pos + 2*l - 1);\n    }\n}\n\nvoid find_repetitions(string s, int shift = 0) {\n    int n = s.size();\n    if (n == 1)\n        return;\n\n    int nu = n / 2;\n    int nv = n - nu;\n    string u = s.substr(0, nu);\n    string v = s.substr(nu);\n    string ru(u.rbegin(), u.rend());\n    string rv(v.rbegin(), v.rend());\n\n    find_repetitions(u, shift);\n    find_repetitions(v, shift + nu);\n\n    vector<int> z1 = z_function(ru);\n    vector<int> z2 = z_function(v + '#' + u);\n    vector<int> z3 = z_function(ru + '#' + rv);\n    vector<int> z4 = z_function(v);\n\n    for (int cntr = 0; cntr < n; cntr++) {\n        int l, k1, k2;\n        if (cntr < nu) {\n            l = nu - cntr;\n            k1 = get_z(z1, nu - cntr);\n            k2 = get_z(z2, nv + 1 + cntr);\n        } else {\n            l = cntr - nu + 1;\n            k1 = get_z(z3, nu + 1 + nv - 1 - (cntr - nu));\n            k2 = get_z(z4, (cntr - nu) + 1);\n        }\n        if (k1 + k2 >= l)\n            convert_to_repetitions(shift, cntr < nu, cntr, l, k1, k2);\n    }\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: string_tandems\n---\n\n# Finding repetitions\n\nGiven a string $s$ of length $n$.\n\nA **repetition** is two occurrences of a string in a row.\nIn other words a repetition can be described by a pair of indices $i < j$ such that the substring $s[i \\dots j]$ consists of two identical strings written after each other.\n\nThe challenge is to **find all repetitions** in a given string $s$.\nOr a simplified task: find **any** repetition or find the **longest** repetition.\n\nThe algorithm described here was published in 1982 by Main and Lorentz.\n\n## Example\n\nConsider the repetitions in the following example string:\n\n$$acababaee$$\n\nThe string contains the following three repetitions:\n\n- $s[2 \\dots 5] = abab$\n- $s[3 \\dots 6] = baba$\n- $s[7 \\dots 7] = ee$\n\nAnother example:\n\n$$abaaba$$\n\nHere there are only two repetitions\n\n- $s[0 \\dots 5] = abaaba$\n- $s[2 \\dots 3] = aa$\n\n## Number of repetitions\n\nIn general there can be up to $O(n^2)$ repetitions in a string of length $n$.\nAn obvious example is a string consisting of $n$ times the same letter, in this case any substring of even length is a repetition.\nIn general any periodic string with a short period will contain a lot of repetitions.\n\nOn the other hand this fact does not prevent computing the number of repetitions in $O(n \\log n)$ time, because the algorithm can give the repetitions in compressed form, in groups of several pieces at once.\n\nThere is even the concept, that describes groups of periodic substrings with tuples of size four.\nIt has been proven that we the number of such groups is at most linear with respect to the string length.\n\nAlso, here are some more interesting results related to the number of repetitions:\n\n  - The number of primitive repetitions (those whose halves are not repetitions) is at most $O(n \\log n)$.\n  - If we encode repetitions with tuples of numbers (called Crochemore triples) $(i,~ p,~ r)$ (where $i$ is the position of the beginning, $p$ the length of the repeating substring, and $r$ the number of repetitions), then all repetitions can be described with $O(n \\log n)$ such triples.\n  - Fibonacci strings, defined as \n    \n    \\[\\begin{align}\n    t_0 &= a, \\\\\\\\\n    t_1 &= b, \\\\\\\\\n    t_i &= t_{i-1} + t_{i-2},\n    \\end{align}\\]\n    \n    are \"strongly\" periodic.\n    The number of repetitions in the Fibonacci string $f_i$, even in the compressed with Crochemore triples, is $O(f_n \\log f_n)$.\n    The number of primitive repetitions is also $O(f_n \\log f_n)$.\n\n## Main-Lorentz algorithm\n\nThe idea behind the Main-Lorentz algorithm is **divide-and-conquer**.\n\nIt splits the initial string into halves, and computes the number of repetitions that lie completely in each halve by two recursive calls.\nThen comes the difficult part.\nThe algorithm finds all repetitions starting in the first half and ending in the second half (which we will call **crossing repetitions**).\nThis is the essential part of the Main-Lorentz algorithm, and we will discuss it in detail here.\n\nThe complexity of divide-and-conquer algorithms is well researched.\nThe [master theorem](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)) says, that we will end up with an $O(n \\log n)$ algorithm, if we can compute the crossing repetitions in $O(n)$ time.\n\n### Search for crossing repetitions\n\nSo we want to find all such repetitions that start in the first half of the string, let's call it $u$, and end in the second half, let's call it $v$:\n\n$$s = u + v$$\n\nTheir lengths are approximately equal to the length of $s$ divided by two.\n\nConsider an arbitrary repetition and look at the middle character (more precisely the first character of the second half of the repetition).\nI.e. if the repetition is a substring $s[i \\dots j]$, then the middle character is $(i + j + 1) / 2$.\n\nWe call a repetition **left** or **right** depending on which string this character is located - in the string $u$ or in the string $v$.\nIn other words a string is called left, if the majority of it lies in $u$, otherwise we call it right.\n\nWe will now discuss how to find **all left repetitions**.\nFinding all right repetitions can be done in the same way.\n\nLet us denote the length of the left repetition by $2l$ (i.e. each half of the repetition has length $l$).\nConsider the first character of the repetition falling into the string $v$ (it is at position $|u|$ in the string $s$).\nIt coincides with the character $l$ positions before it, let's denote this position $cntr$.\n\nWe will fixate this position $cntr$, and **look for all repetitions at this position** $cntr$.\n\nFor example:\n\n$$c ~ \\underset{cntr}{a} ~ c ~ | ~ a ~ d ~ a$$\n\nThe vertical lines divides the two halves.\nHere we fixated the position $cntr = 1$, and at this position we find the repetition $caca$.\n\nIt is clear, that if we fixate the position $cntr$, we simultaneously fixate the length of the possible repetitions: $l = |u| - cntr$.\nOnce we know how to find these repetitions, we will iterate over all possible values for $cntr$ from $0$ to $|u|-1$, and find all left crossover repetitions of length $l = |u|,~ |u|-1,~ \\dots, 1$.\n\n### Criterion for left crossing repetitions\n\nNow, how can we find all such repetitions for a fixated $cntr$?\nKeep in mind that there still can be multiple such repetitions.\n\nLet's again look at a visualization, this time for the repetition $abcabc$:\n\n$$\\overbrace{a}^{l_1} ~ \\overbrace{\\underset{cntr}{b} ~ c}^{l_2} ~ \\overbrace{a}^{l_1} ~ | ~ \\overbrace{b ~ c}^{l_2}$$\n\nHere we denoted the lengths of the two pieces of the repetition with $l_1$ and $l_2$:\n$l_1$ is the length of the repetition up to the position $cntr-1$, and $l_2$ is the length of the repetition from $cntr$ to the end of the half of the repetition.\nWe have $2l = l_1 + l_2 + l_1 + l_2$ as the total length of the repetition.\n\nLet us generate **necessary and sufficient** conditions for such a repetition at position $cntr$ of length $2l = 2(l_1 + l_2) = 2(|u| - cntr)$:\n\n- Let $k_1$ be the largest number such that the first $k_1$ characters before the position $cntr$ coincide with the last $k_1$ characters in the string $u$:\n  \n$$\nu[cntr - k_1 \\dots cntr - 1] = u[|u| - k_1 \\dots |u| - 1]\n$$\n  \n- Let $k_2$ be the largest number such that the $k_2$ characters starting at position $cntr$ coincide with the first $k_2$ characters in the string $v$:\n\n$$  \n  u[cntr \\dots cntr + k_2 - 1] = v[0 \\dots k_2 - 1]\n$$\n  \n- Then we have a repetition exactly for any pair $(l_1,~ l_2)$ with\n\n$$\n  \\begin{align}\n  l_1 &\\le k_1, \\\\\\\\\n  l_2 &\\le k_2. \\\\\\\\\n  \\end{align}\n$$\n\nTo summarize:\n\n- We fixate a specific position $cntr$.\n- All repetition which we will find now have length $2l = 2(|u| - cntr)$.\n  There might be multiple such repetitions, they depend on the lengths $l_1$ and $l_2 = l - l_1$.\n- We find $k_1$ and $k_2$ as described above.\n- Then all suitable repetitions are the ones for which the lengths of the pieces $l_1$ and $l_2$ satisfy the conditions:\n\n$$\n  \\begin{align}\n  l_1 + l_2 &= l = |u| - cntr \\\\\\\\\n  l_1 &\\le k_1, \\\\\\\\\n  l_2 &\\le k_2. \\\\\\\\\n  \\end{align}\n$$\n\nTherefore the only remaining part is how we can compute the values $k_1$ and $k_2$ quickly for every position $cntr$.\nLuckily we can compute them in $O(1)$ using the [Z-function](../string/z-function.md):\n\n- To can find the value $k_1$ for each position by calculating the Z-function for the string $\\overline{u}$ (i.e. the reversed string $u$).\n  Then the value $k_1$ for a particular $cntr$ will be equal to the corresponding value of the array of the Z-function.\n- To precompute all values $k_2$, we calculate the Z-function for the string $v + \\# + u$ (i.e. the string $u$ concatenated with the separator character $\\#$ and the string $v$).\n  Again we just need to look up the corresponding value in the Z-function to get the $k_2$ value.\n\nSo this is enough to find all left crossing repetitions.\n\n### Right crossing repetitions\n\nFor computing the right crossing repetitions we act similarly:\nwe define the center $cntr$ as the character corresponding to the last character in the string $u$.\n\nThen the length $k_1$ will be defined as the largest number of characters before the position $cntr$ (inclusive) that coincide with the last characters of the string $u$.\nAnd the length $k_2$ will be defined as the largest number of characters starting at $cntr + 1$ that coincide with the characters of the string $v$.\n\nThus we can find the values $k_1$ and $k_2$ by computing the Z-function for the strings $\\overline{u} + \\# + \\overline{v}$ and $v$.\n\nAfter that we can find the repetitions by looking at all positions $cntr$, and use the same criterion as we had for left crossing repetitions.\n\n### Implementation\n\nThe implementation of the Main-Lorentz algorithm finds all repetitions in form of peculiar tuples of size four: $(cntr,~ l,~ k_1,~ k_2)$ in $O(n \\log n)$ time.\nIf you only want to find the number of repetitions in a string, or only want to find the longest repetition in a string, this information is enough and the runtime will still be $O(n \\log n)$.\n\nNotice that if you want to expand these tuples to get the starting and end position of each repetition, then the runtime will be the runtime will be $O(n^2)$ (remember that there can be $O(n^2)$ repetitions).\nIn this implementation we will do so, and store all found repetition in a vector of pairs of start and end indices.\n\n```{.cpp file=main_lorentz}\nvector<int> z_function(string const& s) {\n    int n = s.size();\n    vector<int> z(n);\n    for (int i = 1, l = 0, r = 0; i < n; i++) {\n        if (i <= r)\n            z[i] = min(r-i+1, z[i-l]);\n        while (i + z[i] < n && s[z[i]] == s[i+z[i]])\n            z[i]++;\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\nint get_z(vector<int> const& z, int i) {\n    if (0 <= i && i < (int)z.size())\n        return z[i];\n    else\n        return 0;\n}\n\nvector<pair<int, int>> repetitions;\n\nvoid convert_to_repetitions(int shift, bool left, int cntr, int l, int k1, int k2) {\n    for (int l1 = max(1, l - k2); l1 <= min(l, k1); l1++) {\n        if (left && l1 == l) break;\n        int l2 = l - l1;\n        int pos = shift + (left ? cntr - l1 : cntr - l - l1 + 1);\n        repetitions.emplace_back(pos, pos + 2*l - 1);\n    }\n}\n\nvoid find_repetitions(string s, int shift = 0) {\n    int n = s.size();\n    if (n == 1)\n        return;\n\n    int nu = n / 2;\n    int nv = n - nu;\n    string u = s.substr(0, nu);\n    string v = s.substr(nu);\n    string ru(u.rbegin(), u.rend());\n    string rv(v.rbegin(), v.rend());\n\n    find_repetitions(u, shift);\n    find_repetitions(v, shift + nu);\n\n    vector<int> z1 = z_function(ru);\n    vector<int> z2 = z_function(v + '#' + u);\n    vector<int> z3 = z_function(ru + '#' + rv);\n    vector<int> z4 = z_function(v);\n\n    for (int cntr = 0; cntr < n; cntr++) {\n        int l, k1, k2;\n        if (cntr < nu) {\n            l = nu - cntr;\n            k1 = get_z(z1, nu - cntr);\n            k2 = get_z(z2, nv + 1 + cntr);\n        } else {\n            l = cntr - nu + 1;\n            k1 = get_z(z3, nu + 1 + nv - 1 - (cntr - nu));\n            k2 = get_z(z4, (cntr - nu) + 1);\n        }\n        if (k1 + k2 >= l)\n            convert_to_repetitions(shift, cntr < nu, cntr, l, k1, k2);\n    }\n}\n```\n", "problem_ids": [], "title": "Finding repetitions"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: suffix_array\n---\n\n# Suffix Array\n\n## Definition\n\nLet $s$ be a string of length $n$. The $i$-th suffix of $s$ is the substring $s[i \\ldots n - 1]$.\n\nA **suffix array** will contain integers that represent the **starting indexes** of the all the suffixes of a given string, after the aforementioned suffixes are sorted.\n\nAs an example look at the string $s = abaab$.\nAll suffixes are as follows\n\n$$\\begin{array}{ll}\n0. & abaab \\\\\n1. & baab \\\\\n2. & aab \\\\\n3. & ab \\\\\n4. & b\n\\end{array}$$\n\nAfter sorting these strings:\n\n$$\\begin{array}{ll}\n2. & aab \\\\\n3. & ab \\\\\n0. & abaab \\\\\n4. & b \\\\\n1. & baab\n\\end{array}$$\n\nTherefore the suffix array for $s$ will be $(2,~ 3,~ 0,~ 4,~ 1)$.\n\nAs a data structure it is widely used in areas such as data compression, bioinformatics and, in general, in any area that deals with strings and string matching problems.\n\n## Construction\n\n### $O(n^2 \\log n)$ approach {data-toc-label=\"O(n^2 log n) approach\"}\n\nThis is the most naive approach.\nGet all the suffixes and sort them using quicksort or mergesort and simultaneously retain their original indices.\nSorting uses $O(n \\log n)$ comparisons, and since comparing two strings will additionally take $O(n)$ time, we get the final complexity of $O(n^2 \\log n)$.\n\n### $O(n \\log n)$ approach {data-toc-label=\"O(n log n) approach\"}\n\nStrictly speaking the following algorithm will not sort the suffixes, but rather the cyclic shifts of a string.\nHowever we can very easily derive an algorithm for sorting suffixes from it:\nit is enough to append an arbitrary character to the end of the string which is smaller than any character from the string.\nIt is common to use the symbol \\$.\nThen the order of the sorted cyclic shifts is equivalent to the order of the sorted suffixes, as demonstrated here with the string $dabbb$.\n\n$$\\begin{array}{lll}\n1. & abbb\\$d & abbb \\\\\n4. & b\\$dabb & b \\\\\n3. & bb\\$dab & bb \\\\\n2. & bbb\\$da & bbb \\\\\n0. & dabbb\\$ & dabbb\n\\end{array}$$\n\nSince we are going to sort cyclic shifts, we will consider **cyclic substrings**.\nWe will use the notation $s[i \\dots j]$ for the substring of $s$ even if $i > j$.\nIn this case we actually mean the string $s[i \\dots n-1] + s[0 \\dots j]$.\nIn addition we will take all indices modulo the length of $s$, and will omit the modulo operation for simplicity.\n\nThe algorithm we discuss will perform $\\lceil \\log n \\rceil + 1$ iterations.\nIn the $k$-th iteration ($k = 0 \\dots \\lceil \\log n \\rceil$) we sort the $n$ cyclic substrings of $s$ of length $2^k$.\nAfter the $\\lceil \\log n \\rceil$-th iteration the substrings of length $2^{\\lceil \\log n \\rceil} \\ge n$ will be sorted, so this is equivalent to sorting the cyclic shifts altogether.\n\nIn each iteration of the algorithm, in addition to the permutation $p[0 \\dots n-1]$, where $p[i]$ is the index of the $i$-th substring (starting at $i$ and with length $2^k$) in the sorted order, we will also maintain an array $c[0 \\dots n-1]$, where $c[i]$ corresponds to the **equivalence class** to which the substring belongs.\nBecause some of the substrings will be identical, and the algorithm needs to treat them equally.\nFor convenience the classes will be labeled by numbers started from zero.\nIn addition the numbers $c[i]$ will be assigned in such a way that they preserve information about the order:\nif one substring is smaller than the other, then it should also have a smaller class label.\nThe number of equivalence classes will be stored in a variable $\\text{classes}$.\n\nLet's look at an example.\nConsider the string $s = aaba$.\nThe cyclic substrings and the corresponding arrays $p[]$ and $c[]$ are given for each iteration:\n\n$$\\begin{array}{cccc}\n0: & (a,~ a,~ b,~ a) & p = (0,~ 1,~ 3,~ 2) & c = (0,~ 0,~ 1,~ 0)\\\\\n1: & (aa,~ ab,~ ba,~ aa) & p = (0,~ 3,~ 1,~ 2) & c = (0,~ 1,~ 2,~ 0)\\\\\n2: & (aaba,~ abaa,~ baaa,~ aaab) & p = (3,~ 0,~ 1,~ 2) & c = (1,~ 2,~ 3,~ 0)\\\\\n\\end{array}$$\n\nIt is worth noting that the values of $p[]$ can be different.\nFor example in the $0$-th iteration the array could also be $p = (3,~ 1,~ 0,~ 2)$ or $p = (3,~ 0,~ 1,~ 2)$.\nAll these options permutation the substrings into a sorted order.\nSo they are all valid.\nAt the same time the array $c[]$ is fixed, there can be no ambiguities.\n\nLet us now focus on the implementation of the algorithm.\nWe will write a function that takes a string $s$ and returns the permutations of the sorted cyclic shifts.\n\n```{.cpp file=suffix_array_sort_cyclic1}\nvector<int> sort_cyclic_shifts(string const& s) {\n    int n = s.size();\n    const int alphabet = 256;\n```\n\nAt the beginning (in the **$0$-th iteration**) we must sort the cyclic substrings of length $1$, that is we have to sort all characters of the string and divide them into equivalence classes (same symbols get assigned to the same class).\nThis can be done trivially, for example, by using **counting sort**.\nFor each character we count how many times it appears in the string, and then use this information to create the array $p[]$.\nAfter that we go through the array $p[]$ and construct $c[]$ by comparing adjacent characters.\n\n```{.cpp file=suffix_array_sort_cyclic2}\n    vector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n    for (int i = 0; i < n; i++)\n        cnt[s[i]]++;\n    for (int i = 1; i < alphabet; i++)\n        cnt[i] += cnt[i-1];\n    for (int i = 0; i < n; i++)\n        p[--cnt[s[i]]] = i;\n    c[p[0]] = 0;\n    int classes = 1;\n    for (int i = 1; i < n; i++) {\n        if (s[p[i]] != s[p[i-1]])\n            classes++;\n        c[p[i]] = classes - 1;\n    }\n```\n\nNow we have to talk about the iteration step.\nLet's assume we have already performed the $k-1$-th step and computed the values of the arrays $p[]$ and $c[]$ for it.\nWe want to compute the values for the $k$-th step in $O(n)$ time.\nSince we perform this step $O(\\log n)$ times, the complete algorithm will have a time complexity of $O(n \\log n)$.\n\nTo do this, note that the cyclic substrings of length $2^k$ consists of two substrings of length $2^{k-1}$ which we can compare with each other in $O(1)$ using the information from the previous phase - the values of the equivalence classes $c[]$.\nThus, for two substrings of length $2^k$ starting at position $i$ and $j$, all necessary information to compare them is contained in the pairs $(c[i],~ c[i + 2^{k-1}])$ and $(c[j],~ c[j + 2^{k-1}])$.\n\n$$\\dots\n\\overbrace{\n\\underbrace{s_i \\dots s_{i+2^{k-1}-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[i]}\n\\quad\n\\underbrace{s_{i+2^{k-1}} \\dots s_{i+2^k-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[i + 2^{k-1}]}\n}^{\\text{length} = 2^k}\n\\dots\n\\overbrace{\n\\underbrace{s_j \\dots s_{j+2^{k-1}-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[j]}\n\\quad\n\\underbrace{s_{j+2^{k-1}} \\dots s_{j+2^k-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[j + 2^{k-1}]}\n}^{\\text{length} = 2^k}\n\\dots\n$$\n\nThis gives us a very simple solution:\n**sort** the substrings of length $2^k$ **by these pairs of numbers**.\nThis will give us the required order $p[]$.\nHowever a normal sort runs in $O(n \\log n)$ time, with which we are not satisfied.\nThis will only give us an algorithm for constructing a suffix array in $O(n \\log^2 n)$ times.\n\nHow do we quickly perform such a sorting of the pairs?\nSince the elements of the pairs do not exceed $n$, we can use counting sort again.\nHowever sorting pairs with counting sort is not the most efficient.\nTo achieve a better hidden constant in the complexity, we will use another trick.\n\nWe use here the technique on which **radix sort** is based: to sort the pairs we first sort them by the second element, and then by the first element (with a stable sort, i.e. sorting without breaking the relative order of equal elements).\nHowever the second elements were already sorted in the previous iteration.\nThus, in order to sort the pairs by the second elements, we just need to subtract $2^{k-1}$ from the indices in $p[]$ (e.g. if the smallest substring of length $2^{k-1}$ starts at position $i$, then the substring of length $2^k$ with the smallest second half starts at $i - 2^{k-1}$).\n\nSo only by simple subtractions we can sort the second elements of the pairs in $p[]$.\nNow we need to perform a stable sort by the first elements.\nAs already mentioned, this can be accomplished with counting sort.\n\nThe only thing left is to compute the equivalence classes $c[]$, but as before this can be done by simply iterating over the sorted permutation $p[]$ and comparing neighboring pairs.\n\nHere is the remaining implementation.\nWe use temporary arrays $pn[]$ and $cn[]$ to store the permutation by the second elements and the new equivalent class indices.\n\n```{.cpp file=suffix_array_sort_cyclic3}\n    vector<int> pn(n), cn(n);\n    for (int h = 0; (1 << h) < n; ++h) {\n        for (int i = 0; i < n; i++) {\n            pn[i] = p[i] - (1 << h);\n            if (pn[i] < 0)\n                pn[i] += n;\n        }\n        fill(cnt.begin(), cnt.begin() + classes, 0);\n        for (int i = 0; i < n; i++)\n            cnt[c[pn[i]]]++;\n        for (int i = 1; i < classes; i++)\n            cnt[i] += cnt[i-1];\n        for (int i = n-1; i >= 0; i--)\n            p[--cnt[c[pn[i]]]] = pn[i];\n        cn[p[0]] = 0;\n        classes = 1;\n        for (int i = 1; i < n; i++) {\n            pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n            pair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};\n            if (cur != prev)\n                ++classes;\n            cn[p[i]] = classes - 1;\n        }\n        c.swap(cn);\n    }\n    return p;\n}\n```\nThe algorithm requires $O(n \\log n)$ time and $O(n)$ memory. For simplicity we used the complete ASCII range as alphabet.\n\nIf it is known that the string only contains a subset of characters, e.g. only lowercase letters, then the implementation can be optimized, but the optimization factor would likely be insignificant, as the size of the alphabet only matters on the first iteration. Every other iteration depends on the number of equivalence classes, which may quickly reach $O(n)$ even if initially it was a string over the alphabet of size $2$.\n\nAlso note, that this algorithm only sorts the cycle shifts.\nAs mentioned at the beginning of this section we can generate the sorted order of the suffixes by appending a character that is smaller than all other characters of the string, and sorting this resulting string by cycle shifts, e.g. by sorting the cycle shifts of $s + $\\$.\nThis will obviously give the suffix array of $s$, however prepended with $|s|$.\n\n```{.cpp file=suffix_array_construction}\nvector<int> suffix_array_construction(string s) {\n    s += \"$\";\n    vector<int> sorted_shifts = sort_cyclic_shifts(s);\n    sorted_shifts.erase(sorted_shifts.begin());\n    return sorted_shifts;\n}\n```\n\n## Applications\n\n### Finding the smallest cyclic shift\n\nThe algorithm above sorts all cyclic shifts (without appending a character to the string), and therefore $p[0]$ gives the position of the smallest cyclic shift. \n\n### Finding a substring in a string\n\nThe task is to find a string $s$ inside some text $t$ online - we know the text $t$ beforehand, but not the string $s$.\nWe can create the suffix array for the text $t$ in $O(|t| \\log |t|)$ time.\nNow we can look for the substring $s$ in the following way.\nThe occurrence of $s$ must be a prefix of some suffix from $t$.\nSince we sorted all the suffixes we can perform a binary search for $s$ in $p$.\nComparing the current suffix and the substring $s$ within the binary search can be done in $O(|s|)$ time, therefore the complexity for finding the substring is $O(|s| \\log |t|)$.\nAlso notice that if the substring occurs multiple times in $t$, then all occurrences will be next to each other in $p$.\nTherefore the number of occurrences can be found with a second binary search, and all occurrences can be printed easily.\n\n### Comparing two substrings of a string\n\nWe want to be able to compare two substrings of the same length of a given string $s$ in $O(1)$ time, i.e. checking if the first substring is smaller than the second one.\n\nFor this we construct the suffix array in $O(|s| \\log |s|)$ time and store all the intermediate results of the equivalence classes $c[]$.\n\nUsing this information we can compare any two substring whose length is equal to a power of two in O(1):\nfor this it is sufficient to compare the equivalence classes of both substrings.\nNow we want to generalize this method to substrings of arbitrary length.\n\nLet's compare two substrings of length $l$ with the starting indices $i$ and $j$.\nWe find the largest length of a block that is placed inside a substring of this length: the greatest $k$ such that $2^k \\le l$.\nThen comparing the two substrings can be replaced by comparing two overlapping blocks of length $2^k$:\nfirst you need to compare the two blocks starting at $i$ and $j$, and if these are equal then compare the two blocks ending in positions $i + l - 1$ and $j + l - 1$:\n\n$$\\dots\n\\overbrace{\\underbrace{s_i \\dots s_{i+l-2^k} \\dots s_{i+2^k-1}}_{2^k} \\dots s_{i+l-1}}^{\\text{first}}\n\\dots\n\\overbrace{\\underbrace{s_j \\dots s_{j+l-2^k} \\dots s_{j+2^k-1}}_{2^k} \\dots s_{j+l-1}}^{\\text{second}}\n\\dots$$\n\n$$\\dots\n\\overbrace{s_i \\dots \\underbrace{s_{i+l-2^k} \\dots s_{i+2^k-1} \\dots s_{i+l-1}}_{2^k}}^{\\text{first}}\n\\dots\n\\overbrace{s_j \\dots \\underbrace{s_{j+l-2^k} \\dots s_{j+2^k-1} \\dots s_{j+l-1}}_{2^k}}^{\\text{second}}\n\\dots$$\n\nHere is the implementation of the comparison.\nNote that it is assumed that the function gets called with the already calculated $k$.\n$k$ can be computed with $\\lfloor \\log l \\rfloor$, but it is more efficient to precompute all $k$ values for every $l$.\nSee for instance the article about the [Sparse Table](../data_structures/sparse-table.md), which uses a similar idea and computes all $\\log$ values.\n\n```cpp\nint compare(int i, int j, int l, int k) {\n    pair<int, int> a = {c[k][i], c[k][(i+l-(1 << k))%n]};\n    pair<int, int> b = {c[k][j], c[k][(j+l-(1 << k))%n]};\n    return a == b ? 0 : a < b ? -1 : 1;\n}\n```\n\n### Longest common prefix of two substrings with additional memory\n\nFor a given string $s$ we want to compute the longest common prefix (**LCP**)  of two arbitrary suffixes with position $i$ and $j$.\n\nThe method described here uses $O(|s| \\log |s|)$ additional memory.\nA completely different approach that will only use a linear amount of memory is described in the next section.\n\nWe construct the suffix array in $O(|s| \\log |s|)$ time, and remember the intermediate results of the arrays $c[]$ from each iteration.\n\nLet's compute the LCP for two suffixes starting at $i$ and $j$.\nWe can compare any two substrings with a length equal to a power of two in $O(1)$.\nTo do this, we compare the strings by power of twos (from highest to lowest power) and if the substrings of this length are the same, then we add the equal length to the answer and continue checking for the LCP to the right of the equal part, i.e. $i$ and $j$ get added by the current power of two.\n\n```cpp\nint lcp(int i, int j) {\n    int ans = 0;\n    for (int k = log_n; k >= 0; k--) {\n        if (c[k][i % n] == c[k][j % n]) {\n            ans += 1 << k;\n            i += 1 << k;\n            j += 1 << k;\n        }\n    }\n    return ans;\n}\n```\n\nHere `log_n` denotes a constant that is equal to the logarithm of $n$ in base $2$ rounded down.\n\n### Longest common prefix of two substrings without additional memory\n\nWe have the same task as in the previous section.\nWe have compute the longest common prefix (**LCP**) for two suffixes of a string $s$.\n\nUnlike the previous method this one will only use $O(|s|)$ memory.\nThe result of the preprocessing will be an array (which itself is an important source of information about the string, and therefore also used to solve other tasks).\nLCP queries can be answered by performing RMQ queries (range minimum queries) in this array, so for different implementations it is possible to achieve logarithmic and even constant query time. \n\nThe basis for this algorithm is the following idea:\nwe will compute the longest common prefix for each **pair of adjacent suffixes in the sorted order**.\nIn other words we construct an array $\\text{lcp}[0 \\dots n-2]$, where $\\text{lcp}[i]$ is equal to the length of the longest common prefix of the suffixes starting at $p[i]$ and $p[i+1]$.\nThis array will give us an answer for any two adjacent suffixes of the string.\nThen the answer for arbitrary two suffixes, not necessarily neighboring ones, can be obtained from this array.\nIn fact, let the request be to compute the LCP of the suffixes $p[i]$ and $p[j]$.\nThen the answer to this query will be $\\min(lcp[i],~ lcp[i+1],~ \\dots,~ lcp[j-1])$.\n\nThus if we have such an array $\\text{lcp}$, then the problem is reduced to the [RMQ](../sequences/rmq.md), which has many wide number of different solutions with different complexities.\n\nSo the main task is to **build** this array $\\text{lcp}$.\nWe will use **Kasai's algorithm**, which can compute this array in $O(n)$ time.\n\nLet's look at two adjacent suffixes in the sorted order (order of the suffix array).\nLet their starting positions be $i$ and $j$ and their $\\text{lcp}$ equal to $k > 0$.\nIf we remove the first letter of both suffixes - i.e. we take the suffixes $i+1$ and $j+1$ - then it should be obvious that the $\\text{lcp}$ of these two is $k - 1$.\nHowever we cannot use this value and write it in the $\\text{lcp}$ array, because these two suffixes might not be next to each other in the sorted order.\nThe suffix $i+1$ will of course be smaller than the suffix $j+1$, but there might be some suffixes between them.\nHowever, since we know that the LCP between two suffixes is the minimum value of all transitions, we also know that the LCP between any two pairs in that interval has to be at least $k-1$, especially also between $i+1$ and the next suffix.\nAnd possibly it can be bigger.\n\nNow we already can implement the algorithm.\nWe will iterate over the suffixes in order of their length. This way we can reuse the last value $k$, since going from suffix $i$ to the suffix $i+1$ is exactly the same as removing the first letter.\nWe will need an additional array $\\text{rank}$, which will give us the position of a suffix in the sorted list of suffixes.\n\n```{.cpp file=suffix_array_lcp_construction}\nvector<int> lcp_construction(string const& s, vector<int> const& p) {\n    int n = s.size();\n    vector<int> rank(n, 0);\n    for (int i = 0; i < n; i++)\n        rank[p[i]] = i;\n\n    int k = 0;\n    vector<int> lcp(n-1, 0);\n    for (int i = 0; i < n; i++) {\n        if (rank[i] == n - 1) {\n            k = 0;\n            continue;\n        }\n        int j = p[rank[i] + 1];\n        while (i + k < n && j + k < n && s[i+k] == s[j+k])\n            k++;\n        lcp[rank[i]] = k;\n        if (k)\n            k--;\n    }\n    return lcp;\n}\n```\n\nIt is easy to see, that we decrease $k$ at most $O(n)$ times (each iteration at most once, except for $\\text{rank}[i] == n-1$, where we directly reset it to $0$), and the LCP between two strings is at most $n-1$, we will also increase $k$ only $O(n)$ times.\nTherefore the algorithm runs in $O(n)$ time.\n\n### Number of different substrings\n\nWe preprocess the string $s$ by computing the suffix array and the LCP array.\nUsing this information we can compute the number of different substrings in the string.\n\nTo do this, we will think about which **new** substrings begin at position $p[0]$, then at $p[1]$, etc.\nIn fact we take the suffixes in sorted order and see what prefixes give new substrings.\nThus we will not overlook any by accident.\n\nBecause the suffixes are sorted, it is clear that the current suffix $p[i]$ will give new substrings for all its prefixes, except for the prefixes that coincide with the suffix $p[i-1]$.\nThus, all its prefixes except the first $\\text{lcp}[i-1]$ one.\nSince the length of the current suffix is $n - p[i]$, $n - p[i] - \\text{lcp}[i-1]$ new prefixes start at $p[i]$.\nSumming over all the suffixes, we get the final answer:\n\n$$\\sum_{i=0}^{n-1} (n - p[i]) - \\sum_{i=0}^{n-2} \\text{lcp}[i] = \\frac{n^2 + n}{2} - \\sum_{i=0}^{n-2} \\text{lcp}[i]$$\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: suffix_array\n---\n\n# Suffix Array\n\n## Definition\n\nLet $s$ be a string of length $n$. The $i$-th suffix of $s$ is the substring $s[i \\ldots n - 1]$.\n\nA **suffix array** will contain integers that represent the **starting indexes** of the all the suffixes of a given string, after the aforementioned suffixes are sorted.\n\nAs an example look at the string $s = abaab$.\nAll suffixes are as follows\n\n$$\\begin{array}{ll}\n0. & abaab \\\\\n1. & baab \\\\\n2. & aab \\\\\n3. & ab \\\\\n4. & b\n\\end{array}$$\n\nAfter sorting these strings:\n\n$$\\begin{array}{ll}\n2. & aab \\\\\n3. & ab \\\\\n0. & abaab \\\\\n4. & b \\\\\n1. & baab\n\\end{array}$$\n\nTherefore the suffix array for $s$ will be $(2,~ 3,~ 0,~ 4,~ 1)$.\n\nAs a data structure it is widely used in areas such as data compression, bioinformatics and, in general, in any area that deals with strings and string matching problems.\n\n## Construction\n\n### $O(n^2 \\log n)$ approach {data-toc-label=\"O(n^2 log n) approach\"}\n\nThis is the most naive approach.\nGet all the suffixes and sort them using quicksort or mergesort and simultaneously retain their original indices.\nSorting uses $O(n \\log n)$ comparisons, and since comparing two strings will additionally take $O(n)$ time, we get the final complexity of $O(n^2 \\log n)$.\n\n### $O(n \\log n)$ approach {data-toc-label=\"O(n log n) approach\"}\n\nStrictly speaking the following algorithm will not sort the suffixes, but rather the cyclic shifts of a string.\nHowever we can very easily derive an algorithm for sorting suffixes from it:\nit is enough to append an arbitrary character to the end of the string which is smaller than any character from the string.\nIt is common to use the symbol \\$.\nThen the order of the sorted cyclic shifts is equivalent to the order of the sorted suffixes, as demonstrated here with the string $dabbb$.\n\n$$\\begin{array}{lll}\n1. & abbb\\$d & abbb \\\\\n4. & b\\$dabb & b \\\\\n3. & bb\\$dab & bb \\\\\n2. & bbb\\$da & bbb \\\\\n0. & dabbb\\$ & dabbb\n\\end{array}$$\n\nSince we are going to sort cyclic shifts, we will consider **cyclic substrings**.\nWe will use the notation $s[i \\dots j]$ for the substring of $s$ even if $i > j$.\nIn this case we actually mean the string $s[i \\dots n-1] + s[0 \\dots j]$.\nIn addition we will take all indices modulo the length of $s$, and will omit the modulo operation for simplicity.\n\nThe algorithm we discuss will perform $\\lceil \\log n \\rceil + 1$ iterations.\nIn the $k$-th iteration ($k = 0 \\dots \\lceil \\log n \\rceil$) we sort the $n$ cyclic substrings of $s$ of length $2^k$.\nAfter the $\\lceil \\log n \\rceil$-th iteration the substrings of length $2^{\\lceil \\log n \\rceil} \\ge n$ will be sorted, so this is equivalent to sorting the cyclic shifts altogether.\n\nIn each iteration of the algorithm, in addition to the permutation $p[0 \\dots n-1]$, where $p[i]$ is the index of the $i$-th substring (starting at $i$ and with length $2^k$) in the sorted order, we will also maintain an array $c[0 \\dots n-1]$, where $c[i]$ corresponds to the **equivalence class** to which the substring belongs.\nBecause some of the substrings will be identical, and the algorithm needs to treat them equally.\nFor convenience the classes will be labeled by numbers started from zero.\nIn addition the numbers $c[i]$ will be assigned in such a way that they preserve information about the order:\nif one substring is smaller than the other, then it should also have a smaller class label.\nThe number of equivalence classes will be stored in a variable $\\text{classes}$.\n\nLet's look at an example.\nConsider the string $s = aaba$.\nThe cyclic substrings and the corresponding arrays $p[]$ and $c[]$ are given for each iteration:\n\n$$\\begin{array}{cccc}\n0: & (a,~ a,~ b,~ a) & p = (0,~ 1,~ 3,~ 2) & c = (0,~ 0,~ 1,~ 0)\\\\\n1: & (aa,~ ab,~ ba,~ aa) & p = (0,~ 3,~ 1,~ 2) & c = (0,~ 1,~ 2,~ 0)\\\\\n2: & (aaba,~ abaa,~ baaa,~ aaab) & p = (3,~ 0,~ 1,~ 2) & c = (1,~ 2,~ 3,~ 0)\\\\\n\\end{array}$$\n\nIt is worth noting that the values of $p[]$ can be different.\nFor example in the $0$-th iteration the array could also be $p = (3,~ 1,~ 0,~ 2)$ or $p = (3,~ 0,~ 1,~ 2)$.\nAll these options permutation the substrings into a sorted order.\nSo they are all valid.\nAt the same time the array $c[]$ is fixed, there can be no ambiguities.\n\nLet us now focus on the implementation of the algorithm.\nWe will write a function that takes a string $s$ and returns the permutations of the sorted cyclic shifts.\n\n```{.cpp file=suffix_array_sort_cyclic1}\nvector<int> sort_cyclic_shifts(string const& s) {\n    int n = s.size();\n    const int alphabet = 256;\n```\n\nAt the beginning (in the **$0$-th iteration**) we must sort the cyclic substrings of length $1$, that is we have to sort all characters of the string and divide them into equivalence classes (same symbols get assigned to the same class).\nThis can be done trivially, for example, by using **counting sort**.\nFor each character we count how many times it appears in the string, and then use this information to create the array $p[]$.\nAfter that we go through the array $p[]$ and construct $c[]$ by comparing adjacent characters.\n\n```{.cpp file=suffix_array_sort_cyclic2}\n    vector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n    for (int i = 0; i < n; i++)\n        cnt[s[i]]++;\n    for (int i = 1; i < alphabet; i++)\n        cnt[i] += cnt[i-1];\n    for (int i = 0; i < n; i++)\n        p[--cnt[s[i]]] = i;\n    c[p[0]] = 0;\n    int classes = 1;\n    for (int i = 1; i < n; i++) {\n        if (s[p[i]] != s[p[i-1]])\n            classes++;\n        c[p[i]] = classes - 1;\n    }\n```\n\nNow we have to talk about the iteration step.\nLet's assume we have already performed the $k-1$-th step and computed the values of the arrays $p[]$ and $c[]$ for it.\nWe want to compute the values for the $k$-th step in $O(n)$ time.\nSince we perform this step $O(\\log n)$ times, the complete algorithm will have a time complexity of $O(n \\log n)$.\n\nTo do this, note that the cyclic substrings of length $2^k$ consists of two substrings of length $2^{k-1}$ which we can compare with each other in $O(1)$ using the information from the previous phase - the values of the equivalence classes $c[]$.\nThus, for two substrings of length $2^k$ starting at position $i$ and $j$, all necessary information to compare them is contained in the pairs $(c[i],~ c[i + 2^{k-1}])$ and $(c[j],~ c[j + 2^{k-1}])$.\n\n$$\\dots\n\\overbrace{\n\\underbrace{s_i \\dots s_{i+2^{k-1}-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[i]}\n\\quad\n\\underbrace{s_{i+2^{k-1}} \\dots s_{i+2^k-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[i + 2^{k-1}]}\n}^{\\text{length} = 2^k}\n\\dots\n\\overbrace{\n\\underbrace{s_j \\dots s_{j+2^{k-1}-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[j]}\n\\quad\n\\underbrace{s_{j+2^{k-1}} \\dots s_{j+2^k-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[j + 2^{k-1}]}\n}^{\\text{length} = 2^k}\n\\dots\n$$\n\nThis gives us a very simple solution:\n**sort** the substrings of length $2^k$ **by these pairs of numbers**.\nThis will give us the required order $p[]$.\nHowever a normal sort runs in $O(n \\log n)$ time, with which we are not satisfied.\nThis will only give us an algorithm for constructing a suffix array in $O(n \\log^2 n)$ times.\n\nHow do we quickly perform such a sorting of the pairs?\nSince the elements of the pairs do not exceed $n$, we can use counting sort again.\nHowever sorting pairs with counting sort is not the most efficient.\nTo achieve a better hidden constant in the complexity, we will use another trick.\n\nWe use here the technique on which **radix sort** is based: to sort the pairs we first sort them by the second element, and then by the first element (with a stable sort, i.e. sorting without breaking the relative order of equal elements).\nHowever the second elements were already sorted in the previous iteration.\nThus, in order to sort the pairs by the second elements, we just need to subtract $2^{k-1}$ from the indices in $p[]$ (e.g. if the smallest substring of length $2^{k-1}$ starts at position $i$, then the substring of length $2^k$ with the smallest second half starts at $i - 2^{k-1}$).\n\nSo only by simple subtractions we can sort the second elements of the pairs in $p[]$.\nNow we need to perform a stable sort by the first elements.\nAs already mentioned, this can be accomplished with counting sort.\n\nThe only thing left is to compute the equivalence classes $c[]$, but as before this can be done by simply iterating over the sorted permutation $p[]$ and comparing neighboring pairs.\n\nHere is the remaining implementation.\nWe use temporary arrays $pn[]$ and $cn[]$ to store the permutation by the second elements and the new equivalent class indices.\n\n```{.cpp file=suffix_array_sort_cyclic3}\n    vector<int> pn(n), cn(n);\n    for (int h = 0; (1 << h) < n; ++h) {\n        for (int i = 0; i < n; i++) {\n            pn[i] = p[i] - (1 << h);\n            if (pn[i] < 0)\n                pn[i] += n;\n        }\n        fill(cnt.begin(), cnt.begin() + classes, 0);\n        for (int i = 0; i < n; i++)\n            cnt[c[pn[i]]]++;\n        for (int i = 1; i < classes; i++)\n            cnt[i] += cnt[i-1];\n        for (int i = n-1; i >= 0; i--)\n            p[--cnt[c[pn[i]]]] = pn[i];\n        cn[p[0]] = 0;\n        classes = 1;\n        for (int i = 1; i < n; i++) {\n            pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n            pair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};\n            if (cur != prev)\n                ++classes;\n            cn[p[i]] = classes - 1;\n        }\n        c.swap(cn);\n    }\n    return p;\n}\n```\nThe algorithm requires $O(n \\log n)$ time and $O(n)$ memory. For simplicity we used the complete ASCII range as alphabet.\n\nIf it is known that the string only contains a subset of characters, e.g. only lowercase letters, then the implementation can be optimized, but the optimization factor would likely be insignificant, as the size of the alphabet only matters on the first iteration. Every other iteration depends on the number of equivalence classes, which may quickly reach $O(n)$ even if initially it was a string over the alphabet of size $2$.\n\nAlso note, that this algorithm only sorts the cycle shifts.\nAs mentioned at the beginning of this section we can generate the sorted order of the suffixes by appending a character that is smaller than all other characters of the string, and sorting this resulting string by cycle shifts, e.g. by sorting the cycle shifts of $s + $\\$.\nThis will obviously give the suffix array of $s$, however prepended with $|s|$.\n\n```{.cpp file=suffix_array_construction}\nvector<int> suffix_array_construction(string s) {\n    s += \"$\";\n    vector<int> sorted_shifts = sort_cyclic_shifts(s);\n    sorted_shifts.erase(sorted_shifts.begin());\n    return sorted_shifts;\n}\n```\n\n## Applications\n\n### Finding the smallest cyclic shift\n\nThe algorithm above sorts all cyclic shifts (without appending a character to the string), and therefore $p[0]$ gives the position of the smallest cyclic shift. \n\n### Finding a substring in a string\n\nThe task is to find a string $s$ inside some text $t$ online - we know the text $t$ beforehand, but not the string $s$.\nWe can create the suffix array for the text $t$ in $O(|t| \\log |t|)$ time.\nNow we can look for the substring $s$ in the following way.\nThe occurrence of $s$ must be a prefix of some suffix from $t$.\nSince we sorted all the suffixes we can perform a binary search for $s$ in $p$.\nComparing the current suffix and the substring $s$ within the binary search can be done in $O(|s|)$ time, therefore the complexity for finding the substring is $O(|s| \\log |t|)$.\nAlso notice that if the substring occurs multiple times in $t$, then all occurrences will be next to each other in $p$.\nTherefore the number of occurrences can be found with a second binary search, and all occurrences can be printed easily.\n\n### Comparing two substrings of a string\n\nWe want to be able to compare two substrings of the same length of a given string $s$ in $O(1)$ time, i.e. checking if the first substring is smaller than the second one.\n\nFor this we construct the suffix array in $O(|s| \\log |s|)$ time and store all the intermediate results of the equivalence classes $c[]$.\n\nUsing this information we can compare any two substring whose length is equal to a power of two in O(1):\nfor this it is sufficient to compare the equivalence classes of both substrings.\nNow we want to generalize this method to substrings of arbitrary length.\n\nLet's compare two substrings of length $l$ with the starting indices $i$ and $j$.\nWe find the largest length of a block that is placed inside a substring of this length: the greatest $k$ such that $2^k \\le l$.\nThen comparing the two substrings can be replaced by comparing two overlapping blocks of length $2^k$:\nfirst you need to compare the two blocks starting at $i$ and $j$, and if these are equal then compare the two blocks ending in positions $i + l - 1$ and $j + l - 1$:\n\n$$\\dots\n\\overbrace{\\underbrace{s_i \\dots s_{i+l-2^k} \\dots s_{i+2^k-1}}_{2^k} \\dots s_{i+l-1}}^{\\text{first}}\n\\dots\n\\overbrace{\\underbrace{s_j \\dots s_{j+l-2^k} \\dots s_{j+2^k-1}}_{2^k} \\dots s_{j+l-1}}^{\\text{second}}\n\\dots$$\n\n$$\\dots\n\\overbrace{s_i \\dots \\underbrace{s_{i+l-2^k} \\dots s_{i+2^k-1} \\dots s_{i+l-1}}_{2^k}}^{\\text{first}}\n\\dots\n\\overbrace{s_j \\dots \\underbrace{s_{j+l-2^k} \\dots s_{j+2^k-1} \\dots s_{j+l-1}}_{2^k}}^{\\text{second}}\n\\dots$$\n\nHere is the implementation of the comparison.\nNote that it is assumed that the function gets called with the already calculated $k$.\n$k$ can be computed with $\\lfloor \\log l \\rfloor$, but it is more efficient to precompute all $k$ values for every $l$.\nSee for instance the article about the [Sparse Table](../data_structures/sparse-table.md), which uses a similar idea and computes all $\\log$ values.\n\n```cpp\nint compare(int i, int j, int l, int k) {\n    pair<int, int> a = {c[k][i], c[k][(i+l-(1 << k))%n]};\n    pair<int, int> b = {c[k][j], c[k][(j+l-(1 << k))%n]};\n    return a == b ? 0 : a < b ? -1 : 1;\n}\n```\n\n### Longest common prefix of two substrings with additional memory\n\nFor a given string $s$ we want to compute the longest common prefix (**LCP**)  of two arbitrary suffixes with position $i$ and $j$.\n\nThe method described here uses $O(|s| \\log |s|)$ additional memory.\nA completely different approach that will only use a linear amount of memory is described in the next section.\n\nWe construct the suffix array in $O(|s| \\log |s|)$ time, and remember the intermediate results of the arrays $c[]$ from each iteration.\n\nLet's compute the LCP for two suffixes starting at $i$ and $j$.\nWe can compare any two substrings with a length equal to a power of two in $O(1)$.\nTo do this, we compare the strings by power of twos (from highest to lowest power) and if the substrings of this length are the same, then we add the equal length to the answer and continue checking for the LCP to the right of the equal part, i.e. $i$ and $j$ get added by the current power of two.\n\n```cpp\nint lcp(int i, int j) {\n    int ans = 0;\n    for (int k = log_n; k >= 0; k--) {\n        if (c[k][i % n] == c[k][j % n]) {\n            ans += 1 << k;\n            i += 1 << k;\n            j += 1 << k;\n        }\n    }\n    return ans;\n}\n```\n\nHere `log_n` denotes a constant that is equal to the logarithm of $n$ in base $2$ rounded down.\n\n### Longest common prefix of two substrings without additional memory\n\nWe have the same task as in the previous section.\nWe have compute the longest common prefix (**LCP**) for two suffixes of a string $s$.\n\nUnlike the previous method this one will only use $O(|s|)$ memory.\nThe result of the preprocessing will be an array (which itself is an important source of information about the string, and therefore also used to solve other tasks).\nLCP queries can be answered by performing RMQ queries (range minimum queries) in this array, so for different implementations it is possible to achieve logarithmic and even constant query time. \n\nThe basis for this algorithm is the following idea:\nwe will compute the longest common prefix for each **pair of adjacent suffixes in the sorted order**.\nIn other words we construct an array $\\text{lcp}[0 \\dots n-2]$, where $\\text{lcp}[i]$ is equal to the length of the longest common prefix of the suffixes starting at $p[i]$ and $p[i+1]$.\nThis array will give us an answer for any two adjacent suffixes of the string.\nThen the answer for arbitrary two suffixes, not necessarily neighboring ones, can be obtained from this array.\nIn fact, let the request be to compute the LCP of the suffixes $p[i]$ and $p[j]$.\nThen the answer to this query will be $\\min(lcp[i],~ lcp[i+1],~ \\dots,~ lcp[j-1])$.\n\nThus if we have such an array $\\text{lcp}$, then the problem is reduced to the [RMQ](../sequences/rmq.md), which has many wide number of different solutions with different complexities.\n\nSo the main task is to **build** this array $\\text{lcp}$.\nWe will use **Kasai's algorithm**, which can compute this array in $O(n)$ time.\n\nLet's look at two adjacent suffixes in the sorted order (order of the suffix array).\nLet their starting positions be $i$ and $j$ and their $\\text{lcp}$ equal to $k > 0$.\nIf we remove the first letter of both suffixes - i.e. we take the suffixes $i+1$ and $j+1$ - then it should be obvious that the $\\text{lcp}$ of these two is $k - 1$.\nHowever we cannot use this value and write it in the $\\text{lcp}$ array, because these two suffixes might not be next to each other in the sorted order.\nThe suffix $i+1$ will of course be smaller than the suffix $j+1$, but there might be some suffixes between them.\nHowever, since we know that the LCP between two suffixes is the minimum value of all transitions, we also know that the LCP between any two pairs in that interval has to be at least $k-1$, especially also between $i+1$ and the next suffix.\nAnd possibly it can be bigger.\n\nNow we already can implement the algorithm.\nWe will iterate over the suffixes in order of their length. This way we can reuse the last value $k$, since going from suffix $i$ to the suffix $i+1$ is exactly the same as removing the first letter.\nWe will need an additional array $\\text{rank}$, which will give us the position of a suffix in the sorted list of suffixes.\n\n```{.cpp file=suffix_array_lcp_construction}\nvector<int> lcp_construction(string const& s, vector<int> const& p) {\n    int n = s.size();\n    vector<int> rank(n, 0);\n    for (int i = 0; i < n; i++)\n        rank[p[i]] = i;\n\n    int k = 0;\n    vector<int> lcp(n-1, 0);\n    for (int i = 0; i < n; i++) {\n        if (rank[i] == n - 1) {\n            k = 0;\n            continue;\n        }\n        int j = p[rank[i] + 1];\n        while (i + k < n && j + k < n && s[i+k] == s[j+k])\n            k++;\n        lcp[rank[i]] = k;\n        if (k)\n            k--;\n    }\n    return lcp;\n}\n```\n\nIt is easy to see, that we decrease $k$ at most $O(n)$ times (each iteration at most once, except for $\\text{rank}[i] == n-1$, where we directly reset it to $0$), and the LCP between two strings is at most $n-1$, we will also increase $k$ only $O(n)$ times.\nTherefore the algorithm runs in $O(n)$ time.\n\n### Number of different substrings\n\nWe preprocess the string $s$ by computing the suffix array and the LCP array.\nUsing this information we can compute the number of different substrings in the string.\n\nTo do this, we will think about which **new** substrings begin at position $p[0]$, then at $p[1]$, etc.\nIn fact we take the suffixes in sorted order and see what prefixes give new substrings.\nThus we will not overlook any by accident.\n\nBecause the suffixes are sorted, it is clear that the current suffix $p[i]$ will give new substrings for all its prefixes, except for the prefixes that coincide with the suffix $p[i-1]$.\nThus, all its prefixes except the first $\\text{lcp}[i-1]$ one.\nSince the length of the current suffix is $n - p[i]$, $n - p[i] - \\text{lcp}[i-1]$ new prefixes start at $p[i]$.\nSumming over all the suffixes, we get the final answer:\n\n$$\\sum_{i=0}^{n-1} (n - p[i]) - \\sum_{i=0}^{n-2} \\text{lcp}[i] = \\frac{n^2 + n}{2} - \\sum_{i=0}^{n-2} \\text{lcp}[i]$$\n\n## Practice Problems\n\n* [Uva 760 - DNA Sequencing](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=701)\n* [Uva 1223 - Editor](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3664)\n* [Codechef - Tandem](https://www.codechef.com/problems/TANDEM)\n* [Codechef - Substrings and Repetitions](https://www.codechef.com/problems/ANUSAR)\n* [Codechef - Entangled Strings](https://www.codechef.com/problems/TANGLED)\n* [Codeforces - Martian Strings](http://codeforces.com/problemset/problem/149/E)\n* [Codeforces - Little Elephant and Strings](http://codeforces.com/problemset/problem/204/E)\n* [SPOJ - Ada and Terramorphing](http://www.spoj.com/problems/ADAPHOTO/)\n* [SPOJ - Ada and Substring](http://www.spoj.com/problems/ADASTRNG/)\n* [UVA - 1227 - The longest constant gene](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3668)\n* [SPOJ - Longest Common Substring](http://www.spoj.com/problems/LCS/en/)\n* [UVA 11512 - GATTACA](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2507)\n* [LA 7502 - Suffixes and Palindromes](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&category=720&page=show_problem&problem=5524)\n* [GYM - Por Costel and the Censorship Committee](http://codeforces.com/gym/100923/problem/D)\n* [UVA 1254 - Top 10](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3695)\n* [UVA 12191 - File Recover](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3343)\n* [UVA 12206 - Stammering Aliens](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3358)\n* [Codechef - Jarvis and LCP](https://www.codechef.com/problems/INSQ16F)\n* [LA 3943 - Liking's Letter](https://icpcarchive.ecs.baylor.edu/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1944)\n* [UVA 11107 - Life Forms](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2048)\n* [UVA 12974 - Exquisite Strings](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=862&page=show_problem&problem=4853)\n* [UVA 10526 - Intellectual Property](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1467)\n* [UVA 12338 - Anti-Rhyme Pairs](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3760)\n* [DevSkills Reconstructing Blue Print of Life (archived)](http://web.archive.org/web/20210126015936/https://devskill.com/CodingProblems/ViewProblem/328)\n* [UVA 12191 - File Recover](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3343)\n* [SPOJ - Suffix Array](http://www.spoj.com/problems/SARRAY/)\n* [LA 4513 - Stammering Aliens](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2514)\n* [SPOJ - LCS2](http://www.spoj.com/problems/LCS2/)\n* [Codeforces - Fake News (hard)](http://codeforces.com/contest/802/problem/I)\n* [SPOJ - Longest Commong Substring](http://www.spoj.com/problems/LONGCS/)\n* [SPOJ - Lexicographical Substring Search](http://www.spoj.com/problems/SUBLEX/)\n* [Codeforces - Forbidden Indices](http://codeforces.com/contest/873/problem/F)\n* [Codeforces - Tricky and Clever Password](http://codeforces.com/contest/30/problem/E)\n* [LA 6856 - Circle of digits](https://icpcarchive.ecs.baylor.edu/index.php?option=onlinejudge&page=show_problem&problem=4868)\n", "problem_ids": ["149_E", "204_E", "802_I", "873_F", "30_E"], "title": "Suffix Array"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: z_function\n---\n\n# Z-function and its calculation\n\nSuppose we are given a string $s$ of length $n$. The **Z-function** for this string is an array of length $n$ where the $i$-th element is equal to the greatest number of characters starting from the position $i$ that coincide with the first characters of $s$.\n\nIn other words, $z[i]$ is the length of the longest string that is, at the same time, a prefix of $s$ and a prefix of the suffix of $s$ starting at $i$.\n\n**Note.** In this article, to avoid ambiguity, we assume $0$-based indexes; that is: the first character of $s$ has index $0$ and the last one has index $n-1$.\n\nThe first element of Z-function, $z[0]$, is generally not well defined. In this article we will assume it is zero (although it doesn't change anything in the algorithm implementation).\n\nThis article presents an algorithm for calculating the Z-function in $O(n)$ time, as well as various of its applications.\n\n## Examples\n\nFor example, here are the values of the Z-function computed for different strings:\n\n* \"aaaaa\" - $[0, 4, 3, 2, 1]$\n* \"aaabaab\" - $[0, 2, 1, 0, 2, 1, 0]$\n* \"abacaba\" - $[0, 0, 1, 0, 3, 0, 1]$\n\n## Trivial algorithm\n\nFormal definition can be represented in the following elementary $O(n^2)$ implementation.\n\n```cpp\nvector<int> z_function_trivial(string s) {\n\tint n = s.size();\n\tvector<int> z(n);\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n\t\t\tz[i]++;\n\t\t}\n\t}\n\treturn z;\n}\n```\n\nWe just iterate through every position $i$ and update $z[i]$ for each one of them, starting from $z[i] = 0$ and incrementing it as long as we don't find a mismatch (and as long as we don't reach the end of the line).\n\nOf course, this is not an efficient implementation. We will now show the construction of an efficient implementation.\n\n## Efficient algorithm to compute the Z-function\n\nTo obtain an efficient algorithm we will compute the values of $z[i]$ in turn from $i = 1$ to $n - 1$ but at the same time, when computing a new value, we'll try to make the best use possible of the previously computed values.\n\nFor the sake of brevity, let's call **segment matches** those substrings that coincide with a prefix of $s$. For example, the value of the desired Z-function $z[i]$ is the length of the segment match starting at position $i$ (and that ends at position $i + z[i] - 1$).\n\nTo do this, we will keep **the $[l, r)$ indices of the rightmost segment match**. That is, among all detected segments we will keep the one that ends rightmost. In a way, the index $r$ can be seen as the \"boundary\" to which our string $s$ has been scanned by the algorithm; everything beyond that point is not yet known.\n\nThen, if the current index (for which we have to compute the next value of the Z-function) is $i$, we have one of two options:\n\n*   $i \\geq r$ -- the current position is **outside** of what we have already processed.\n\n    We will then compute $z[i]$ with the **trivial algorithm** (that is, just comparing values one by one). Note that in the end, if $z[i] > 0$, we'll have to update the indices of the rightmost segment, because it's guaranteed that the new $r = i + z[i]$ is better than the previous $r$.\n\n*   $i < r$ -- the current position is inside the current segment match $[l, r)$.\n\n    Then we can use the already calculated Z-values to \"initialize\" the value of $z[i]$ to something (it sure is better than \"starting from zero\"), maybe even some big number.\n\n    For this, we observe that the substrings $s[l \\dots r)$ and $s[0 \\dots r-l)$ **match**. This means that as an initial approximation for $z[i]$ we can take the value already computed for the corresponding segment $s[0 \\dots r-l)$, and that is $z[i-l]$.\n\n    However, the value $z[i-l]$ could be too large: when applied to position $i$ it could exceed the index $r$. This is not allowed because we know nothing about the characters to the right of $r$: they may differ from those required.\n\n    Here is **an example** of a similar scenario:\n\n    $$ s = \"aaaabaa\" $$\n\n    When we get to the last position ($i = 6$), the current match segment will be $[5, 7)$. Position $6$ will then match position $6 - 5 = 1$, for which the value of the Z-function is $z[1] = 3$. Obviously, we cannot initialize $z[6]$ to $3$, it would be completely incorrect. The maximum value we could initialize it to is $1$ -- because it's the largest value that doesn't bring us beyond the index $r$ of the match segment $[l, r)$.\n\n    Thus, as an **initial approximation** for $z[i]$ we can safely take:\n\n    $$ z_0[i] = \\min(r - i,\\; z[i-l]) $$\n\n    After having $z[i]$ initialized to $z_0[i]$, we try to increment $z[i]$ by running the **trivial algorithm** -- because in general, after the border $r$, we cannot know if the segment will continue to match or not.\n\nThus, the whole algorithm is split in two cases, which differ only in **the initial value** of $z[i]$: in the first case it's assumed to be zero, in the second case it is determined by the previously computed values (using the above formula). After that, both branches of this algorithm can be reduced to the implementation of **the trivial algorithm**, which starts immediately after we specify the initial value.\n\nThe algorithm turns out to be very simple. Despite the fact that on each iteration the trivial algorithm is run, we have made significant progress, having an algorithm that runs in linear time. Later on we will prove that the running time is linear.\n\n## Implementation\n\nImplementation turns out to be rather concise:\n\n```cpp\nvector<int> z_function(string s) {\n    int n = s.size();\n    vector<int> z(n);\n    int l = 0, r = 0;\n    for(int i = 1; i < n; i++) {\n        if(i < r) {\n            z[i] = min(r - i, z[i - l]);\n        }\n        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n        if(i + z[i] > r) {\n            l = i;\n            r = i + z[i];\n        }\n    }\n    return z;\n}\n```\n\n### Comments on this implementation\n\nThe whole solution is given as a function which returns an array of length $n$ -- the Z-function of $s$.\n\nArray $z$ is initially filled with zeros. The current rightmost match segment is assumed to be $[0; 0)$ (that is, a deliberately small segment which doesn't contain any $i$).\n\nInside the loop for $i = 1 \\dots n - 1$ we first determine the initial value $z[i]$ -- it will either remain zero or be computed using the above formula.\n\nThereafter, the trivial algorithm attempts to increase the value of $z[i]$ as much as possible.\n\nIn the end, if it's required (that is, if $i + z[i] > r$), we update the rightmost match segment $[l, r)$.\n\n## Asymptotic behavior of the algorithm\n\nWe will prove that the above algorithm has a running time that is linear in the length of the string -- thus, it's $O(n)$.\n\nThe proof is very simple.\n\nWe are interested in the nested `while` loop, since everything else is just a bunch of constant operations which sums up to $O(n)$.\n\nWe will show that **each iteration** of the `while` loop will increase the right border $r$ of the match segment.\n\nTo do that, we will consider both branches of the algorithm:\n\n*   $i \\geq r$\n\n    In this case, either the `while` loop won't make any iteration (if $s[0] \\ne s[i]$), or it will take a few iterations, starting at position $i$, each time moving one character to the right. After that, the right border $r$ will necessarily be updated.\n\n    So we have found that, when $i \\geq r$, each iteration of the `while` loop increases the value of the new $r$ index.\n\n*   $i < r$\n\n    In this case, we initialize $z[i]$ to a certain value $z_0$ given by the above formula. Let's compare this initial value $z_0$ to the value $r - i$. We will have three cases:\n\n      *   $z_0 < r - i$\n\n          We prove that in this case no iteration of the `while` loop will take place.\n\n          It's easy to prove, for example, by contradiction: if the `while` loop made at least one iteration, it would mean that initial approximation $z[i] = z_0$ was inaccurate (less than the match's actual length). But since $s[l \\dots r)$ and $s[0 \\dots r-l)$ are the same, this would imply that $z[i-l]$ holds the wrong value (less than it should be).\n\n          Thus, since $z[i-l]$ is correct and it is less than $r - i$, it follows that this value coincides with the required value $z[i]$.\n\n      *   $z_0 = r - i$\n\n          In this case, the `while` loop can make a few iterations, but each of them will lead to an increase in the value of the $r$ index because we will start comparing from $s[r]$, which will climb beyond the $[l, r)$ interval.\n\n      *   $z_0 > r - i$\n\n          This option is impossible, by definition of $z_0$.\n\nSo, we have proved that each iteration of the inner loop make the $r$ pointer advance to the right. Since $r$ can't be more than $n-1$, this means that the inner loop won't make more than $n-1$ iterations.\n\nAs the rest of the algorithm obviously works in $O(n)$, we have proved that the whole algorithm for computing Z-functions runs in linear time.\n\n## Applications\n\nWe will now consider some uses of Z-functions for specific tasks.\n\nThese applications will be largely similar to applications of [prefix function](prefix-function.md).\n\n### Search the substring\n\nTo avoid confusion, we call $t$ the **string of text**, and $p$ the **pattern**. The problem is: find all occurrences of the pattern $p$ inside the text $t$.\n\nTo solve this problem, we create a new string $s = p + \\diamond + t$, that is, we apply string concatenation to $p$ and $t$ but we also put a separator character $\\diamond$ in the middle (we'll choose $\\diamond$ so that it will certainly not be present anywhere in the strings $p$ or $t$).\n\nCompute the Z-function for $s$. Then, for any $i$ in the interval $[0; \\; \\operatorname{length}(t) - 1]$, we will consider the corresponding value $k = z[i + \\operatorname{length}(p) + 1]$. If $k$ is equal to $\\operatorname{length}(p)$ then we know there is one occurrence of $p$ in the $i$-th position of $t$, otherwise there is no occurrence of $p$ in the $i$-th position of $t$.\n\nThe running time (and memory consumption) is $O(\\operatorname{length}(t) + \\operatorname{length}(p))$.\n\n### Number of distinct substrings in a string\n\nGiven a string $s$ of length $n$, count the number of distinct substrings of $s$.\n\nWe'll solve this problem iteratively. That is: knowing the current number of different substrings, recalculate this amount after adding to the end of $s$ one character.\n\nSo, let $k$ be the current number of distinct substrings of $s$. We append a new character $c$ to $s$. Obviously, there can be some new substrings ending in this new character $c$ (namely, all those strings that end with this symbol and that we haven't encountered yet).\n\nTake a string $t = s + c$ and invert it (write its characters in reverse order). Our task is now to count how many prefixes of $t$ are not found anywhere else in $t$. Let's compute the Z-function of $t$ and find its maximum value $z_{max}$. Obviously, $t$'s prefix of length $z_{max}$ occurs also somewhere in the middle of $t$. Clearly, shorter prefixes also occur.\n\nSo, we have found that the number of new substrings that appear when symbol $c$ is appended to $s$ is equal to $\\operatorname{length}(t) - z_{max}$.\n\nConsequently, the running time of this solution is $O(n^2)$ for a string of length $n$.\n\nIt's worth noting that in exactly the same way we can recalculate, still in $O(n)$ time, the number of distinct substrings when appending a character in the beginning of the string, as well as when removing it (from the end or the beginning).\n\n### String compression\n\nGiven a string $s$ of length $n$. Find its shortest \"compressed\" representation, that is: find a string $t$ of shortest length such that $s$ can be represented as a concatenation of one or more copies of $t$.\n\nA solution is: compute the Z-function of $s$, loop through all $i$ such that $i$ divides $n$. Stop at the first $i$ such that $i + z[i] = n$. Then, the string $s$ can be compressed to the length $i$.\n\nThe proof for this fact is the same as the solution which uses the [prefix function](prefix-function.md).\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: z_function\n---\n\n# Z-function and its calculation\n\nSuppose we are given a string $s$ of length $n$. The **Z-function** for this string is an array of length $n$ where the $i$-th element is equal to the greatest number of characters starting from the position $i$ that coincide with the first characters of $s$.\n\nIn other words, $z[i]$ is the length of the longest string that is, at the same time, a prefix of $s$ and a prefix of the suffix of $s$ starting at $i$.\n\n**Note.** In this article, to avoid ambiguity, we assume $0$-based indexes; that is: the first character of $s$ has index $0$ and the last one has index $n-1$.\n\nThe first element of Z-function, $z[0]$, is generally not well defined. In this article we will assume it is zero (although it doesn't change anything in the algorithm implementation).\n\nThis article presents an algorithm for calculating the Z-function in $O(n)$ time, as well as various of its applications.\n\n## Examples\n\nFor example, here are the values of the Z-function computed for different strings:\n\n* \"aaaaa\" - $[0, 4, 3, 2, 1]$\n* \"aaabaab\" - $[0, 2, 1, 0, 2, 1, 0]$\n* \"abacaba\" - $[0, 0, 1, 0, 3, 0, 1]$\n\n## Trivial algorithm\n\nFormal definition can be represented in the following elementary $O(n^2)$ implementation.\n\n```cpp\nvector<int> z_function_trivial(string s) {\n\tint n = s.size();\n\tvector<int> z(n);\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n\t\t\tz[i]++;\n\t\t}\n\t}\n\treturn z;\n}\n```\n\nWe just iterate through every position $i$ and update $z[i]$ for each one of them, starting from $z[i] = 0$ and incrementing it as long as we don't find a mismatch (and as long as we don't reach the end of the line).\n\nOf course, this is not an efficient implementation. We will now show the construction of an efficient implementation.\n\n## Efficient algorithm to compute the Z-function\n\nTo obtain an efficient algorithm we will compute the values of $z[i]$ in turn from $i = 1$ to $n - 1$ but at the same time, when computing a new value, we'll try to make the best use possible of the previously computed values.\n\nFor the sake of brevity, let's call **segment matches** those substrings that coincide with a prefix of $s$. For example, the value of the desired Z-function $z[i]$ is the length of the segment match starting at position $i$ (and that ends at position $i + z[i] - 1$).\n\nTo do this, we will keep **the $[l, r)$ indices of the rightmost segment match**. That is, among all detected segments we will keep the one that ends rightmost. In a way, the index $r$ can be seen as the \"boundary\" to which our string $s$ has been scanned by the algorithm; everything beyond that point is not yet known.\n\nThen, if the current index (for which we have to compute the next value of the Z-function) is $i$, we have one of two options:\n\n*   $i \\geq r$ -- the current position is **outside** of what we have already processed.\n\n    We will then compute $z[i]$ with the **trivial algorithm** (that is, just comparing values one by one). Note that in the end, if $z[i] > 0$, we'll have to update the indices of the rightmost segment, because it's guaranteed that the new $r = i + z[i]$ is better than the previous $r$.\n\n*   $i < r$ -- the current position is inside the current segment match $[l, r)$.\n\n    Then we can use the already calculated Z-values to \"initialize\" the value of $z[i]$ to something (it sure is better than \"starting from zero\"), maybe even some big number.\n\n    For this, we observe that the substrings $s[l \\dots r)$ and $s[0 \\dots r-l)$ **match**. This means that as an initial approximation for $z[i]$ we can take the value already computed for the corresponding segment $s[0 \\dots r-l)$, and that is $z[i-l]$.\n\n    However, the value $z[i-l]$ could be too large: when applied to position $i$ it could exceed the index $r$. This is not allowed because we know nothing about the characters to the right of $r$: they may differ from those required.\n\n    Here is **an example** of a similar scenario:\n\n    $$ s = \"aaaabaa\" $$\n\n    When we get to the last position ($i = 6$), the current match segment will be $[5, 7)$. Position $6$ will then match position $6 - 5 = 1$, for which the value of the Z-function is $z[1] = 3$. Obviously, we cannot initialize $z[6]$ to $3$, it would be completely incorrect. The maximum value we could initialize it to is $1$ -- because it's the largest value that doesn't bring us beyond the index $r$ of the match segment $[l, r)$.\n\n    Thus, as an **initial approximation** for $z[i]$ we can safely take:\n\n    $$ z_0[i] = \\min(r - i,\\; z[i-l]) $$\n\n    After having $z[i]$ initialized to $z_0[i]$, we try to increment $z[i]$ by running the **trivial algorithm** -- because in general, after the border $r$, we cannot know if the segment will continue to match or not.\n\nThus, the whole algorithm is split in two cases, which differ only in **the initial value** of $z[i]$: in the first case it's assumed to be zero, in the second case it is determined by the previously computed values (using the above formula). After that, both branches of this algorithm can be reduced to the implementation of **the trivial algorithm**, which starts immediately after we specify the initial value.\n\nThe algorithm turns out to be very simple. Despite the fact that on each iteration the trivial algorithm is run, we have made significant progress, having an algorithm that runs in linear time. Later on we will prove that the running time is linear.\n\n## Implementation\n\nImplementation turns out to be rather concise:\n\n```cpp\nvector<int> z_function(string s) {\n    int n = s.size();\n    vector<int> z(n);\n    int l = 0, r = 0;\n    for(int i = 1; i < n; i++) {\n        if(i < r) {\n            z[i] = min(r - i, z[i - l]);\n        }\n        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n        if(i + z[i] > r) {\n            l = i;\n            r = i + z[i];\n        }\n    }\n    return z;\n}\n```\n\n### Comments on this implementation\n\nThe whole solution is given as a function which returns an array of length $n$ -- the Z-function of $s$.\n\nArray $z$ is initially filled with zeros. The current rightmost match segment is assumed to be $[0; 0)$ (that is, a deliberately small segment which doesn't contain any $i$).\n\nInside the loop for $i = 1 \\dots n - 1$ we first determine the initial value $z[i]$ -- it will either remain zero or be computed using the above formula.\n\nThereafter, the trivial algorithm attempts to increase the value of $z[i]$ as much as possible.\n\nIn the end, if it's required (that is, if $i + z[i] > r$), we update the rightmost match segment $[l, r)$.\n\n## Asymptotic behavior of the algorithm\n\nWe will prove that the above algorithm has a running time that is linear in the length of the string -- thus, it's $O(n)$.\n\nThe proof is very simple.\n\nWe are interested in the nested `while` loop, since everything else is just a bunch of constant operations which sums up to $O(n)$.\n\nWe will show that **each iteration** of the `while` loop will increase the right border $r$ of the match segment.\n\nTo do that, we will consider both branches of the algorithm:\n\n*   $i \\geq r$\n\n    In this case, either the `while` loop won't make any iteration (if $s[0] \\ne s[i]$), or it will take a few iterations, starting at position $i$, each time moving one character to the right. After that, the right border $r$ will necessarily be updated.\n\n    So we have found that, when $i \\geq r$, each iteration of the `while` loop increases the value of the new $r$ index.\n\n*   $i < r$\n\n    In this case, we initialize $z[i]$ to a certain value $z_0$ given by the above formula. Let's compare this initial value $z_0$ to the value $r - i$. We will have three cases:\n\n      *   $z_0 < r - i$\n\n          We prove that in this case no iteration of the `while` loop will take place.\n\n          It's easy to prove, for example, by contradiction: if the `while` loop made at least one iteration, it would mean that initial approximation $z[i] = z_0$ was inaccurate (less than the match's actual length). But since $s[l \\dots r)$ and $s[0 \\dots r-l)$ are the same, this would imply that $z[i-l]$ holds the wrong value (less than it should be).\n\n          Thus, since $z[i-l]$ is correct and it is less than $r - i$, it follows that this value coincides with the required value $z[i]$.\n\n      *   $z_0 = r - i$\n\n          In this case, the `while` loop can make a few iterations, but each of them will lead to an increase in the value of the $r$ index because we will start comparing from $s[r]$, which will climb beyond the $[l, r)$ interval.\n\n      *   $z_0 > r - i$\n\n          This option is impossible, by definition of $z_0$.\n\nSo, we have proved that each iteration of the inner loop make the $r$ pointer advance to the right. Since $r$ can't be more than $n-1$, this means that the inner loop won't make more than $n-1$ iterations.\n\nAs the rest of the algorithm obviously works in $O(n)$, we have proved that the whole algorithm for computing Z-functions runs in linear time.\n\n## Applications\n\nWe will now consider some uses of Z-functions for specific tasks.\n\nThese applications will be largely similar to applications of [prefix function](prefix-function.md).\n\n### Search the substring\n\nTo avoid confusion, we call $t$ the **string of text**, and $p$ the **pattern**. The problem is: find all occurrences of the pattern $p$ inside the text $t$.\n\nTo solve this problem, we create a new string $s = p + \\diamond + t$, that is, we apply string concatenation to $p$ and $t$ but we also put a separator character $\\diamond$ in the middle (we'll choose $\\diamond$ so that it will certainly not be present anywhere in the strings $p$ or $t$).\n\nCompute the Z-function for $s$. Then, for any $i$ in the interval $[0; \\; \\operatorname{length}(t) - 1]$, we will consider the corresponding value $k = z[i + \\operatorname{length}(p) + 1]$. If $k$ is equal to $\\operatorname{length}(p)$ then we know there is one occurrence of $p$ in the $i$-th position of $t$, otherwise there is no occurrence of $p$ in the $i$-th position of $t$.\n\nThe running time (and memory consumption) is $O(\\operatorname{length}(t) + \\operatorname{length}(p))$.\n\n### Number of distinct substrings in a string\n\nGiven a string $s$ of length $n$, count the number of distinct substrings of $s$.\n\nWe'll solve this problem iteratively. That is: knowing the current number of different substrings, recalculate this amount after adding to the end of $s$ one character.\n\nSo, let $k$ be the current number of distinct substrings of $s$. We append a new character $c$ to $s$. Obviously, there can be some new substrings ending in this new character $c$ (namely, all those strings that end with this symbol and that we haven't encountered yet).\n\nTake a string $t = s + c$ and invert it (write its characters in reverse order). Our task is now to count how many prefixes of $t$ are not found anywhere else in $t$. Let's compute the Z-function of $t$ and find its maximum value $z_{max}$. Obviously, $t$'s prefix of length $z_{max}$ occurs also somewhere in the middle of $t$. Clearly, shorter prefixes also occur.\n\nSo, we have found that the number of new substrings that appear when symbol $c$ is appended to $s$ is equal to $\\operatorname{length}(t) - z_{max}$.\n\nConsequently, the running time of this solution is $O(n^2)$ for a string of length $n$.\n\nIt's worth noting that in exactly the same way we can recalculate, still in $O(n)$ time, the number of distinct substrings when appending a character in the beginning of the string, as well as when removing it (from the end or the beginning).\n\n### String compression\n\nGiven a string $s$ of length $n$. Find its shortest \"compressed\" representation, that is: find a string $t$ of shortest length such that $s$ can be represented as a concatenation of one or more copies of $t$.\n\nA solution is: compute the Z-function of $s$, loop through all $i$ such that $i$ divides $n$. Stop at the first $i$ such that $i + z[i] = n$. Then, the string $s$ can be compressed to the length $i$.\n\nThe proof for this fact is the same as the solution which uses the [prefix function](prefix-function.md).\n\n## Practice Problems\n\n* [eolymp - Blocks of string](https://www.eolymp.com/en/problems/1309)\n* [Codeforces - Password [Difficulty: Easy]](http://codeforces.com/problemset/problem/126/B)\n* [UVA # 455 \"Periodic Strings\" [Difficulty: Medium]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=396)\n* [UVA # 11022 \"String Factoring\" [Difficulty: Medium]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1963)\n* [UVa 11475 - Extend to Palindrome](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=2470)\n* [LA 6439 - Pasti Pas!](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&category=588&page=show_problem&problem=4450)\n* [Codechef - Chef and Strings](https://www.codechef.com/problems/CHSTR)\n* [Codeforces - Prefixes and Suffixes](http://codeforces.com/problemset/problem/432/D)\n", "problem_ids": ["432_D"], "title": "Z-function and its calculation"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: rabin_karp\n---\n\n# Rabin-Karp Algorithm for string matching\n\nThis algorithm is based on the concept of hashing, so if you are not familiar with string hashing, refer to the [string hashing](string-hashing.md) article.\n \nThis algorithm was authored by Rabin and Karp in 1987.\n\nProblem: Given two strings - a pattern $s$ and a text $t$, determine if the pattern appears in the text and if it does, enumerate all its occurrences in $O(|s| + |t|)$ time.\n\nAlgorithm: Calculate the hash for the pattern $s$.\nCalculate hash values for all the prefixes of the text $t$.\nNow, we can compare a substring of length $|s|$ with $s$ in constant time using the calculated hashes.\nSo, compare each substring of length $|s|$ with the pattern. This will take a total of $O(|t|)$ time.\nHence the final complexity of the algorithm is $O(|t| + |s|)$: $O(|s|)$ is required for calculating the hash of the pattern and $O(|t|)$ for comparing each substring of length $|s|$ with the pattern.\n\n## Implementation\n```{.cpp file=rabin_karp}\nvector<int> rabin_karp(string const& s, string const& t) {\n    const int p = 31; \n    const int m = 1e9 + 9;\n    int S = s.size(), T = t.size();\n\n    vector<long long> p_pow(max(S, T)); \n    p_pow[0] = 1; \n    for (int i = 1; i < (int)p_pow.size(); i++) \n        p_pow[i] = (p_pow[i-1] * p) % m;\n\n    vector<long long> h(T + 1, 0); \n    for (int i = 0; i < T; i++)\n        h[i+1] = (h[i] + (t[i] - 'a' + 1) * p_pow[i]) % m; \n    long long h_s = 0; \n    for (int i = 0; i < S; i++) \n        h_s = (h_s + (s[i] - 'a' + 1) * p_pow[i]) % m; \n\n    vector<int> occurrences;\n    for (int i = 0; i + S - 1 < T; i++) {\n        long long cur_h = (h[i+S] + m - h[i]) % m;\n        if (cur_h == h_s * p_pow[i] % m)\n            occurrences.push_back(i);\n    }\n    return occurrences;\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: rabin_karp\n---\n\n# Rabin-Karp Algorithm for string matching\n\nThis algorithm is based on the concept of hashing, so if you are not familiar with string hashing, refer to the [string hashing](string-hashing.md) article.\n \nThis algorithm was authored by Rabin and Karp in 1987.\n\nProblem: Given two strings - a pattern $s$ and a text $t$, determine if the pattern appears in the text and if it does, enumerate all its occurrences in $O(|s| + |t|)$ time.\n\nAlgorithm: Calculate the hash for the pattern $s$.\nCalculate hash values for all the prefixes of the text $t$.\nNow, we can compare a substring of length $|s|$ with $s$ in constant time using the calculated hashes.\nSo, compare each substring of length $|s|$ with the pattern. This will take a total of $O(|t|)$ time.\nHence the final complexity of the algorithm is $O(|t| + |s|)$: $O(|s|)$ is required for calculating the hash of the pattern and $O(|t|)$ for comparing each substring of length $|s|$ with the pattern.\n\n## Implementation\n```{.cpp file=rabin_karp}\nvector<int> rabin_karp(string const& s, string const& t) {\n    const int p = 31; \n    const int m = 1e9 + 9;\n    int S = s.size(), T = t.size();\n\n    vector<long long> p_pow(max(S, T)); \n    p_pow[0] = 1; \n    for (int i = 1; i < (int)p_pow.size(); i++) \n        p_pow[i] = (p_pow[i-1] * p) % m;\n\n    vector<long long> h(T + 1, 0); \n    for (int i = 0; i < T; i++)\n        h[i+1] = (h[i] + (t[i] - 'a' + 1) * p_pow[i]) % m; \n    long long h_s = 0; \n    for (int i = 0; i < S; i++) \n        h_s = (h_s + (s[i] - 'a' + 1) * p_pow[i]) % m; \n\n    vector<int> occurrences;\n    for (int i = 0; i + S - 1 < T; i++) {\n        long long cur_h = (h[i+S] + m - h[i]) % m;\n        if (cur_h == h_s * p_pow[i] % m)\n            occurrences.push_back(i);\n    }\n    return occurrences;\n}\n```\n\n## Practice Problems\n\n* [SPOJ - Pattern Find](http://www.spoj.com/problems/NAJPF/)\n* [Codeforces - Good Substrings](http://codeforces.com/problemset/problem/271/D)\n* [Codeforces - Palindromic characteristics](https://codeforces.com/problemset/problem/835/D)\n* [Leetcode - Longest Duplicate Substring](https://leetcode.com/problems/longest-duplicate-substring/)\n\n", "problem_ids": ["271_D", "835_D"], "title": "Rabin-Karp Algorithm for string matching"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: aho_corasick\n---\n\n# Aho-Corasick algorithm\n\nThe Aho-Corasick algorithm allows us to quickly search for multiple patterns in a text.\nThe set of pattern strings is also called a _dictionary_.\nWe will denote the total length of its constituent strings by $m$ and the size of the alphabet by $k$.\nThe algorithm constructs a finite state automaton based on a trie in $O(m k)$ time and then uses it to process the text.\n\nThe algorithm was proposed by Alfred Aho and Margaret Corasick in 1975.\n\n## Construction of the trie\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e2/Trie.svg\" width=\"400px\">\n<br>\n<i>A trie based on words \"Java\", \"Rad\", \"Rand\", \"Rau\", \"Raum\" and \"Rose\".</i>\n<br>\n<i>The <a href=\"https://commons.wikimedia.org/wiki/File:Trie.svg\">image</a> by [nd](https://de.wikipedia.org/wiki/Benutzer:Nd) is distributed under <a href=\"https://creativecommons.org/licenses/by-sa/3.0/deed.en\">CC BY-SA 3.0</a> license.</i>\n</center>\n\nFormally, a trie is a rooted tree, where each edge of the tree is labeled with some letter\nand outgoing edges of a vertex have distinct labels.\n\nWe will identify each vertex in the trie with the string formed by the labels on the path from the root to that vertex.\n\nEach vertex will also have a flag $\\text{output}$ which will be set\nif the vertex corresponds to a pattern in the dictionary.\n\nAccordingly, a trie for a set of strings is a trie such that each $\\text{output}$ vertex corresponds to one string from the set, and conversely, each string of the set corresponds to one $\\text{output}$ vertex.\n\nWe now describe how to construct a trie for a given set of strings in linear time with respect to their total length.\n\nWe introduce a structure for the vertices of the tree:\n```{.cpp file=aho_corasick_trie_definition}\nconst int K = 26;\n\nstruct Vertex {\n    int next[K];\n    bool output = false;\n\n    Vertex() {\n        fill(begin(next), end(next), -1);\n    }\n};\n\nvector<Vertex> trie(1);\n```\n\nHere, we store the trie as an array of $\\text{Vertex}$.\nEach $\\text{Vertex}$ contains the flag $\\text{output}$ and the edges in the form of an array $\\text{next}[]$, where $\\text{next}[i]$ is the index of the vertex that we reach by following the character $i$, or $-1$ if there is no such edge.\nInitially, the trie consists of only one vertex - the root - with the index $0$.\n\nNow we implement a function that will add a string $s$ to the trie.\nThe implementation is simple:\nwe start at the root node, and as long as there are edges corresponding to the characters of $s$ we follow them.\nIf there is no edge for one character, we generate a new vertex and connect it with an edge.\nAt the end of the process we mark the last vertex with the flag $\\text{output}$.\n\n```{.cpp file=aho_corasick_trie_add}\nvoid add_string(string const& s) {\n    int v = 0;\n    for (char ch : s) {\n        int c = ch - 'a';\n        if (trie[v].next[c] == -1) {\n            trie[v].next[c] = trie.size();\n            trie.emplace_back();\n        }\n        v = trie[v].next[c];\n    }\n    trie[v].output = true;\n}\n```\n\nThis implementation obviously runs in linear time,\nand since every vertex stores $k$ links, it will use $O(m k)$ memory.\n\nIt is possible to decrease the memory consumption to $O(m)$ by using a map instead of an array in each vertex.\nHowever, this will increase the time complexity to $O(m \\log k)$.\n\n## Construction of an automaton\n\nSuppose we have built a trie for the given set of strings.\nNow let's look at it from a different side.\nIf we look at any vertex,\nthe string that corresponds to it is a prefix of one or more strings in the set, thus each vertex of the trie can be interpreted as a position in one or more strings from the set.\n\nIn fact, the trie vertices can be interpreted as states in a **finite deterministic automaton**.\nFrom any state we can transition - using some input letter - to other states, i.e., to another position in the set of strings.\nFor example, if there is only one string $abc$ in the dictionary, and we are standing at vertex $ab$, then using the letter $c$ we can go to the vertex $abc$.\n\nThus we can understand the edges of the trie as transitions in an automaton according to the corresponding letter.\nHowever, in an automaton we need to have transitions for each combination of a state and a letter.\nIf we try to perform a transition using a letter, and there is no corresponding edge in the trie, then we nevertheless must go into some state.\n\nMore precisely, suppose we are in a state corresponding to a string $t$, and we want to transition to a different state using the character $c$.\nIf there is an edge labeled with this letter $c$, then we can simply go over this edge, and get the vertex corresponding to $t + c$.\nIf there is no such edge, since we want to maintain the invariant that the current state is the longest partial match in the processed string, we must find the longest string in the trie that's a proper suffix of the string $t$, and try to perform a transition from there.\n\nFor example, let the trie be constructed by the strings $ab$ and $bc$, and we are currently at the vertex corresponding to $ab$, which is a $\\text{output}$.\nTo transition with the letter $c$, we are forced to go to the state corresponding to the string $b$, and from there follow the edge with the letter $c$.\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/9/90/A_diagram_of_the_Aho-Corasick_string_search_algorithm.svg\" width=\"300px\">\n<br>\n<i>An Aho-Corasick automaton based on words \"a\", \"ab\", \"bc\", \"bca\", \"c\" and \"caa\".</i>\n<br>\n<i>Blue arrows are suffix links, green arrows are terminal links.</i>\n</center>\n\nA **suffix link** for a vertex $p$ is an edge that points to the longest proper suffix of the string corresponding to the vertex $p$.\nThe only special case is the root of the trie, whose suffix link will point to itself.\nNow we can reformulate the statement about the transitions in the automaton like this:\nwhile there is no transition from the current vertex of the trie using the current letter (or until we reach the root), we follow the suffix link.\n\nThus we reduced the problem of constructing an automaton to the problem of finding suffix links for all vertices of the trie.\nHowever, we will build these suffix links, oddly enough, using the transitions constructed in the automaton.\n\nThe suffix links of the root vertex and all its immediate children point to the root vertex.\nFor any vertex $v$ deeper in the tree, we can calculate the suffix link as follows:\nif $p$ is the ancestor of $v$ with $c$ being the letter labeling the edge from $p$ to $v$,\ngo to $p$,\nthen follow its suffix link, and perform the transition with the letter $c$ from there.\n\nThus, the problem of finding the transitions has been reduced to the problem of finding suffix links, and the problem of finding suffix links has been reduced to the problem of finding a suffix link and a transition, except for vertices closer to the root.\nSo we have a recursive dependence that we can resolve in linear time.\n\nLet's move to the implementation.\nNote that we now will store the ancestor $p$ and the character $pch$ of the edge from $p$ to $v$ for each vertex $v$.\nAlso, at each vertex we will store the suffix link $\\text{link}$ (or $-1$ if it hasn't been calculated yet), and in the array $\\text{go}[k]$ the transitions in the machine for each symbol (again $-1$ if it hasn't been calculated yet).\n\n```{.cpp file=aho_corasick_automaton}\nconst int K = 26;\n\nstruct Vertex {\n    int next[K];\n    bool output = false;\n    int p = -1;\n    char pch;\n    int link = -1;\n    int go[K];\n\n    Vertex(int p=-1, char ch='$') : p(p), pch(ch) {\n        fill(begin(next), end(next), -1);\n        fill(begin(go), end(go), -1);\n    }\n};\n\nvector<Vertex> t(1);\n\nvoid add_string(string const& s) {\n    int v = 0;\n    for (char ch : s) {\n        int c = ch - 'a';\n        if (t[v].next[c] == -1) {\n            t[v].next[c] = t.size();\n            t.emplace_back(v, ch);\n        }\n        v = t[v].next[c];\n    }\n    t[v].output = true;\n}\n\nint go(int v, char ch);\n\nint get_link(int v) {\n    if (t[v].link == -1) {\n        if (v == 0 || t[v].p == 0)\n            t[v].link = 0;\n        else\n            t[v].link = go(get_link(t[v].p), t[v].pch);\n    }\n    return t[v].link;\n}\n\nint go(int v, char ch) {\n    int c = ch - 'a';\n    if (t[v].go[c] == -1) {\n        if (t[v].next[c] != -1)\n            t[v].go[c] = t[v].next[c];\n        else\n            t[v].go[c] = v == 0 ? 0 : go(get_link(v), ch);\n    }\n    return t[v].go[c];\n} \n```\n\nIt is easy to see that thanks to memoization of the suffix links and transitions,\nthe total time for finding all suffix links and transitions will be linear.\n\nFor an illustration of the concept refer to slide number 103 of the [Stanford slides](http://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/02/Slides02.pdf).\n\n### BFS-based construction\n\nInstead of computing transitions and suffix links with recursive calls to `go` and `get_link`, it is possible to compute them bottom-up starting from the root.\n(In fact, when the dictionary consists of only one string, we obtain the familiar Knuth-Morris-Pratt algorithm.)\n\nThis approach will have some advantages over the one described above as, instead of the total length $m$, its running time depends only on the number of vertices $n$ in the trie. Moreover, it is possible to adapt it for large alphabets using a persistent array data structure, thus making the construction time $O(n \\log k)$ instead of $O(mk)$, which is a significant improvement granted that $m$ may go up to $n^2$.\n\nWe can reason inductively using the fact that BFS from the root traverses vertices in order of increasing length.\nWe may assume that when we're in a vertex $v$, its suffix link $u = link[v]$ is already successfully computed, and for all vertices with shorter length transitions from them are also fully computed.\n\nAssume that at the moment we stand in a vertex $v$ and consider a character $c$. We essentially have two cases:\n\n1. $go[v][c] = -1$. In this case, we may assign $go[v][c] = go[u][c]$, which is already known by the induction hypothesis;\n2. $go[v][c] = w \\neq -1$. In this case, we may assign $link[w] = go[u][c]$.\n\nIn this way, we spend $O(1)$ time per each pair of a vertex and a character, making the running time $O(mk)$. The major overhead here is that we copy a lot of transitions from $u$ in the first case, while the transitions of the second case form the trie and sum up to $m$ over all vertices. To avoid the copying of $go[u][c]$, we may use a persistent array data structure, using which we initially copy $go[u]$ into $go[v]$ and then only update values for characters in which the transition would differ. This leads to the $O(m \\log k)$ algorithm.\n\n## Applications\n\n### Find all strings from a given set in a text\n\nWe are given a set of strings and a text.\nWe have to print all occurrences of all strings from the set in the given text in $O(\\text{len} + \\text{ans})$, where $\\text{len}$ is the length of the text and $\\text{ans}$ is the size of the answer.\n\nWe construct an automaton for this set of strings.\nWe will now process the text letter by letter using the automaton,\nstarting at the root of the trie.\nIf we are at any time at state $v$, and the next letter is $c$, then we transition to the next state with $\\text{go}(v, c)$, thereby either increasing the length of the current match substring by $1$, or decreasing it by following a suffix link.\n\nHow can we find out for a state $v$, if there are any matches with strings for the set?\nFirst, it is clear that if we stand on a $\\text{output}$ vertex, then the string corresponding to the vertex ends at this position in the text.\nHowever this is by no means the only possible case of achieving a match:\nif we can reach one or more  $\\text{output}$ vertices by moving along the suffix links, then there will be also a match corresponding to each found $\\text{output}$ vertex.\nA simple example demonstrating this situation can be creating using the set of strings $\\{dabce, abc, bc\\}$ and the text $dabc$.\n\nThus if we store in each $\\text{output}$ vertex the index of the string corresponding to it (or the list of indices if duplicate strings appear in the set), then we can find in $O(n)$ time the indices of all strings which match the current state, by simply following the suffix links from the current vertex to the root.\nThis is not the most efficient solution, since this results in $O(n ~ \\text{len})$ complexity overall.\nHowever, this can be optimized by computing and storing the nearest $\\text{output}$ vertex that is reachable using suffix links (this is sometimes called the **exit link**).\nThis value we can compute lazily in linear time.\nThus for each vertex we can advance in $O(1)$ time to the next marked vertex in the suffix link path, i.e. to the next match.\nThus for each match we spend $O(1)$ time, and therefore we reach the complexity $O(\\text{len} + \\text{ans})$.\n\nIf you only want to count the occurrences and not find the indices themselves, you can calculate the number of marked vertices in the suffix link path for each vertex $v$.\nThis can be calculated in $O(n)$ time in total.\nThus we can sum up all matches in $O(\\text{len})$.\n\n### Finding the lexicographically smallest string of a given length that doesn't match any given strings\n\nA set of strings and a length $L$ is given.\nWe have to find a string of length $L$, which does not contain any of the strings, and derive the lexicographically smallest of such strings.\n\nWe can construct the automaton for the set of strings.\nRecall that $\\text{output}$ vertices are the states where we have a match with a string from the set.\nSince in this task we have to avoid matches, we are not allowed to enter such states.\nOn the other hand we can enter all other vertices.\nThus we delete all \"bad\" vertices from the machine, and in the remaining graph of the automaton we find the lexicographically smallest path of length $L$.\nThis task can be solved in $O(L)$ for example by [depth first search](../graph/depth-first-search.md).\n\n### Finding the shortest string containing all given strings\n\nHere we use the same ideas.\nFor each vertex we store a mask that denotes the strings which match at this state.\nThen the problem can be reformulated as follows:\ninitially being in the state $(v = \\text{root},~ \\text{mask} = 0)$, we want to reach the state $(v,~ \\text{mask} = 2^n - 1)$, where $n$ is the number of strings in the set.\nWhen we transition from one state to another using a letter, we update the mask accordingly.\nBy running a [breadth first search](../graph/breadth-first-search.md) we can find a path to the state $(v,~ \\text{mask} = 2^n - 1)$ with the smallest length.\n\n### Finding the lexicographically smallest string of length $L$ containing $k$ strings {data-toc-label=\"Finding the lexicographically smallest string of length L containing k strings\"}\n\nAs in the previous problem, we calculate for each vertex the number of matches that correspond to it (that is the number of marked vertices reachable using suffix links).\nWe reformulate the problem: the current state is determined by a triple of numbers $(v,~ \\text{len},~ \\text{cnt})$, and we want to reach from the state $(\\text{root},~ 0,~ 0)$ the state $(v,~ L,~ k)$, where $v$ can be any vertex.\nThus we can find such a path  using depth first search (and if the search looks at the edges in their natural order, then the found path will automatically be the lexicographically smallest).\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: aho_corasick\n---\n\n# Aho-Corasick algorithm\n\nThe Aho-Corasick algorithm allows us to quickly search for multiple patterns in a text.\nThe set of pattern strings is also called a _dictionary_.\nWe will denote the total length of its constituent strings by $m$ and the size of the alphabet by $k$.\nThe algorithm constructs a finite state automaton based on a trie in $O(m k)$ time and then uses it to process the text.\n\nThe algorithm was proposed by Alfred Aho and Margaret Corasick in 1975.\n\n## Construction of the trie\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e2/Trie.svg\" width=\"400px\">\n<br>\n<i>A trie based on words \"Java\", \"Rad\", \"Rand\", \"Rau\", \"Raum\" and \"Rose\".</i>\n<br>\n<i>The <a href=\"https://commons.wikimedia.org/wiki/File:Trie.svg\">image</a> by [nd](https://de.wikipedia.org/wiki/Benutzer:Nd) is distributed under <a href=\"https://creativecommons.org/licenses/by-sa/3.0/deed.en\">CC BY-SA 3.0</a> license.</i>\n</center>\n\nFormally, a trie is a rooted tree, where each edge of the tree is labeled with some letter\nand outgoing edges of a vertex have distinct labels.\n\nWe will identify each vertex in the trie with the string formed by the labels on the path from the root to that vertex.\n\nEach vertex will also have a flag $\\text{output}$ which will be set\nif the vertex corresponds to a pattern in the dictionary.\n\nAccordingly, a trie for a set of strings is a trie such that each $\\text{output}$ vertex corresponds to one string from the set, and conversely, each string of the set corresponds to one $\\text{output}$ vertex.\n\nWe now describe how to construct a trie for a given set of strings in linear time with respect to their total length.\n\nWe introduce a structure for the vertices of the tree:\n```{.cpp file=aho_corasick_trie_definition}\nconst int K = 26;\n\nstruct Vertex {\n    int next[K];\n    bool output = false;\n\n    Vertex() {\n        fill(begin(next), end(next), -1);\n    }\n};\n\nvector<Vertex> trie(1);\n```\n\nHere, we store the trie as an array of $\\text{Vertex}$.\nEach $\\text{Vertex}$ contains the flag $\\text{output}$ and the edges in the form of an array $\\text{next}[]$, where $\\text{next}[i]$ is the index of the vertex that we reach by following the character $i$, or $-1$ if there is no such edge.\nInitially, the trie consists of only one vertex - the root - with the index $0$.\n\nNow we implement a function that will add a string $s$ to the trie.\nThe implementation is simple:\nwe start at the root node, and as long as there are edges corresponding to the characters of $s$ we follow them.\nIf there is no edge for one character, we generate a new vertex and connect it with an edge.\nAt the end of the process we mark the last vertex with the flag $\\text{output}$.\n\n```{.cpp file=aho_corasick_trie_add}\nvoid add_string(string const& s) {\n    int v = 0;\n    for (char ch : s) {\n        int c = ch - 'a';\n        if (trie[v].next[c] == -1) {\n            trie[v].next[c] = trie.size();\n            trie.emplace_back();\n        }\n        v = trie[v].next[c];\n    }\n    trie[v].output = true;\n}\n```\n\nThis implementation obviously runs in linear time,\nand since every vertex stores $k$ links, it will use $O(m k)$ memory.\n\nIt is possible to decrease the memory consumption to $O(m)$ by using a map instead of an array in each vertex.\nHowever, this will increase the time complexity to $O(m \\log k)$.\n\n## Construction of an automaton\n\nSuppose we have built a trie for the given set of strings.\nNow let's look at it from a different side.\nIf we look at any vertex,\nthe string that corresponds to it is a prefix of one or more strings in the set, thus each vertex of the trie can be interpreted as a position in one or more strings from the set.\n\nIn fact, the trie vertices can be interpreted as states in a **finite deterministic automaton**.\nFrom any state we can transition - using some input letter - to other states, i.e., to another position in the set of strings.\nFor example, if there is only one string $abc$ in the dictionary, and we are standing at vertex $ab$, then using the letter $c$ we can go to the vertex $abc$.\n\nThus we can understand the edges of the trie as transitions in an automaton according to the corresponding letter.\nHowever, in an automaton we need to have transitions for each combination of a state and a letter.\nIf we try to perform a transition using a letter, and there is no corresponding edge in the trie, then we nevertheless must go into some state.\n\nMore precisely, suppose we are in a state corresponding to a string $t$, and we want to transition to a different state using the character $c$.\nIf there is an edge labeled with this letter $c$, then we can simply go over this edge, and get the vertex corresponding to $t + c$.\nIf there is no such edge, since we want to maintain the invariant that the current state is the longest partial match in the processed string, we must find the longest string in the trie that's a proper suffix of the string $t$, and try to perform a transition from there.\n\nFor example, let the trie be constructed by the strings $ab$ and $bc$, and we are currently at the vertex corresponding to $ab$, which is a $\\text{output}$.\nTo transition with the letter $c$, we are forced to go to the state corresponding to the string $b$, and from there follow the edge with the letter $c$.\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/9/90/A_diagram_of_the_Aho-Corasick_string_search_algorithm.svg\" width=\"300px\">\n<br>\n<i>An Aho-Corasick automaton based on words \"a\", \"ab\", \"bc\", \"bca\", \"c\" and \"caa\".</i>\n<br>\n<i>Blue arrows are suffix links, green arrows are terminal links.</i>\n</center>\n\nA **suffix link** for a vertex $p$ is an edge that points to the longest proper suffix of the string corresponding to the vertex $p$.\nThe only special case is the root of the trie, whose suffix link will point to itself.\nNow we can reformulate the statement about the transitions in the automaton like this:\nwhile there is no transition from the current vertex of the trie using the current letter (or until we reach the root), we follow the suffix link.\n\nThus we reduced the problem of constructing an automaton to the problem of finding suffix links for all vertices of the trie.\nHowever, we will build these suffix links, oddly enough, using the transitions constructed in the automaton.\n\nThe suffix links of the root vertex and all its immediate children point to the root vertex.\nFor any vertex $v$ deeper in the tree, we can calculate the suffix link as follows:\nif $p$ is the ancestor of $v$ with $c$ being the letter labeling the edge from $p$ to $v$,\ngo to $p$,\nthen follow its suffix link, and perform the transition with the letter $c$ from there.\n\nThus, the problem of finding the transitions has been reduced to the problem of finding suffix links, and the problem of finding suffix links has been reduced to the problem of finding a suffix link and a transition, except for vertices closer to the root.\nSo we have a recursive dependence that we can resolve in linear time.\n\nLet's move to the implementation.\nNote that we now will store the ancestor $p$ and the character $pch$ of the edge from $p$ to $v$ for each vertex $v$.\nAlso, at each vertex we will store the suffix link $\\text{link}$ (or $-1$ if it hasn't been calculated yet), and in the array $\\text{go}[k]$ the transitions in the machine for each symbol (again $-1$ if it hasn't been calculated yet).\n\n```{.cpp file=aho_corasick_automaton}\nconst int K = 26;\n\nstruct Vertex {\n    int next[K];\n    bool output = false;\n    int p = -1;\n    char pch;\n    int link = -1;\n    int go[K];\n\n    Vertex(int p=-1, char ch='$') : p(p), pch(ch) {\n        fill(begin(next), end(next), -1);\n        fill(begin(go), end(go), -1);\n    }\n};\n\nvector<Vertex> t(1);\n\nvoid add_string(string const& s) {\n    int v = 0;\n    for (char ch : s) {\n        int c = ch - 'a';\n        if (t[v].next[c] == -1) {\n            t[v].next[c] = t.size();\n            t.emplace_back(v, ch);\n        }\n        v = t[v].next[c];\n    }\n    t[v].output = true;\n}\n\nint go(int v, char ch);\n\nint get_link(int v) {\n    if (t[v].link == -1) {\n        if (v == 0 || t[v].p == 0)\n            t[v].link = 0;\n        else\n            t[v].link = go(get_link(t[v].p), t[v].pch);\n    }\n    return t[v].link;\n}\n\nint go(int v, char ch) {\n    int c = ch - 'a';\n    if (t[v].go[c] == -1) {\n        if (t[v].next[c] != -1)\n            t[v].go[c] = t[v].next[c];\n        else\n            t[v].go[c] = v == 0 ? 0 : go(get_link(v), ch);\n    }\n    return t[v].go[c];\n} \n```\n\nIt is easy to see that thanks to memoization of the suffix links and transitions,\nthe total time for finding all suffix links and transitions will be linear.\n\nFor an illustration of the concept refer to slide number 103 of the [Stanford slides](http://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/02/Slides02.pdf).\n\n### BFS-based construction\n\nInstead of computing transitions and suffix links with recursive calls to `go` and `get_link`, it is possible to compute them bottom-up starting from the root.\n(In fact, when the dictionary consists of only one string, we obtain the familiar Knuth-Morris-Pratt algorithm.)\n\nThis approach will have some advantages over the one described above as, instead of the total length $m$, its running time depends only on the number of vertices $n$ in the trie. Moreover, it is possible to adapt it for large alphabets using a persistent array data structure, thus making the construction time $O(n \\log k)$ instead of $O(mk)$, which is a significant improvement granted that $m$ may go up to $n^2$.\n\nWe can reason inductively using the fact that BFS from the root traverses vertices in order of increasing length.\nWe may assume that when we're in a vertex $v$, its suffix link $u = link[v]$ is already successfully computed, and for all vertices with shorter length transitions from them are also fully computed.\n\nAssume that at the moment we stand in a vertex $v$ and consider a character $c$. We essentially have two cases:\n\n1. $go[v][c] = -1$. In this case, we may assign $go[v][c] = go[u][c]$, which is already known by the induction hypothesis;\n2. $go[v][c] = w \\neq -1$. In this case, we may assign $link[w] = go[u][c]$.\n\nIn this way, we spend $O(1)$ time per each pair of a vertex and a character, making the running time $O(mk)$. The major overhead here is that we copy a lot of transitions from $u$ in the first case, while the transitions of the second case form the trie and sum up to $m$ over all vertices. To avoid the copying of $go[u][c]$, we may use a persistent array data structure, using which we initially copy $go[u]$ into $go[v]$ and then only update values for characters in which the transition would differ. This leads to the $O(m \\log k)$ algorithm.\n\n## Applications\n\n### Find all strings from a given set in a text\n\nWe are given a set of strings and a text.\nWe have to print all occurrences of all strings from the set in the given text in $O(\\text{len} + \\text{ans})$, where $\\text{len}$ is the length of the text and $\\text{ans}$ is the size of the answer.\n\nWe construct an automaton for this set of strings.\nWe will now process the text letter by letter using the automaton,\nstarting at the root of the trie.\nIf we are at any time at state $v$, and the next letter is $c$, then we transition to the next state with $\\text{go}(v, c)$, thereby either increasing the length of the current match substring by $1$, or decreasing it by following a suffix link.\n\nHow can we find out for a state $v$, if there are any matches with strings for the set?\nFirst, it is clear that if we stand on a $\\text{output}$ vertex, then the string corresponding to the vertex ends at this position in the text.\nHowever this is by no means the only possible case of achieving a match:\nif we can reach one or more  $\\text{output}$ vertices by moving along the suffix links, then there will be also a match corresponding to each found $\\text{output}$ vertex.\nA simple example demonstrating this situation can be creating using the set of strings $\\{dabce, abc, bc\\}$ and the text $dabc$.\n\nThus if we store in each $\\text{output}$ vertex the index of the string corresponding to it (or the list of indices if duplicate strings appear in the set), then we can find in $O(n)$ time the indices of all strings which match the current state, by simply following the suffix links from the current vertex to the root.\nThis is not the most efficient solution, since this results in $O(n ~ \\text{len})$ complexity overall.\nHowever, this can be optimized by computing and storing the nearest $\\text{output}$ vertex that is reachable using suffix links (this is sometimes called the **exit link**).\nThis value we can compute lazily in linear time.\nThus for each vertex we can advance in $O(1)$ time to the next marked vertex in the suffix link path, i.e. to the next match.\nThus for each match we spend $O(1)$ time, and therefore we reach the complexity $O(\\text{len} + \\text{ans})$.\n\nIf you only want to count the occurrences and not find the indices themselves, you can calculate the number of marked vertices in the suffix link path for each vertex $v$.\nThis can be calculated in $O(n)$ time in total.\nThus we can sum up all matches in $O(\\text{len})$.\n\n### Finding the lexicographically smallest string of a given length that doesn't match any given strings\n\nA set of strings and a length $L$ is given.\nWe have to find a string of length $L$, which does not contain any of the strings, and derive the lexicographically smallest of such strings.\n\nWe can construct the automaton for the set of strings.\nRecall that $\\text{output}$ vertices are the states where we have a match with a string from the set.\nSince in this task we have to avoid matches, we are not allowed to enter such states.\nOn the other hand we can enter all other vertices.\nThus we delete all \"bad\" vertices from the machine, and in the remaining graph of the automaton we find the lexicographically smallest path of length $L$.\nThis task can be solved in $O(L)$ for example by [depth first search](../graph/depth-first-search.md).\n\n### Finding the shortest string containing all given strings\n\nHere we use the same ideas.\nFor each vertex we store a mask that denotes the strings which match at this state.\nThen the problem can be reformulated as follows:\ninitially being in the state $(v = \\text{root},~ \\text{mask} = 0)$, we want to reach the state $(v,~ \\text{mask} = 2^n - 1)$, where $n$ is the number of strings in the set.\nWhen we transition from one state to another using a letter, we update the mask accordingly.\nBy running a [breadth first search](../graph/breadth-first-search.md) we can find a path to the state $(v,~ \\text{mask} = 2^n - 1)$ with the smallest length.\n\n### Finding the lexicographically smallest string of length $L$ containing $k$ strings {data-toc-label=\"Finding the lexicographically smallest string of length L containing k strings\"}\n\nAs in the previous problem, we calculate for each vertex the number of matches that correspond to it (that is the number of marked vertices reachable using suffix links).\nWe reformulate the problem: the current state is determined by a triple of numbers $(v,~ \\text{len},~ \\text{cnt})$, and we want to reach from the state $(\\text{root},~ 0,~ 0)$ the state $(v,~ L,~ k)$, where $v$ can be any vertex.\nThus we can find such a path  using depth first search (and if the search looks at the edges in their natural order, then the found path will automatically be the lexicographically smallest).\n\n## Problems\n\n- [UVA #11590 - Prefix Lookup](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2637)\n- [UVA #11171 - SMS](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2112)\n- [UVA #10679 - I Love Strings!!](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1620)\n- [Codeforces - x-prime Substrings](https://codeforces.com/problemset/problem/1400/F)\n- [Codeforces - Frequency of String](http://codeforces.com/problemset/problem/963/D)\n- [CodeChef - TWOSTRS](https://www.codechef.com/MAY20A/problems/TWOSTRS)\n\n## References\n- [Stanford's CS166 - Aho-Corasick Automata](http://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/02/Slides02.pdf) ([Condensed](http://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/02/Small02.pdf))\n", "problem_ids": ["1400_F", "963_D"], "title": "Aho-Corasick algorithm"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: matrix_rank\n---\n\n# Finding the rank of a matrix\n\n**The rank of a matrix** is the largest number of linearly independent rows/columns of the matrix. The rank is not only defined  for square matrices.\n\nThe rank of a matrix can also be defined as the largest order of any non-zero minor in the matrix.\n\nLet the matrix be rectangular and have size $N \\times M$.\nNote that if the matrix is square and its determinant is non-zero, then the rank is $N$ ($=M$); otherwise it will be less. Generally, the rank of a matrix does not exceed $\\min (N, M)$.\n\n## Algorithm\n\nYou can search for the rank using [Gaussian elimination](linear-system-gauss.md). We will perform the same operations as when solving the system or finding its determinant. But if at any step in the $i$-th column there are no rows with an non-empty entry among those that we didn't selected already, then we skip this step.\nOtherwise, if we have found a row with a non-zero element in the $i$-th column during the $i$-th step, then we mark this row as a selected one, increase the rank by one (initially the rank is set equal to $0$), and perform the usual operations of taking this row away from the rest.\n\n## Complexity\n\nThis algorithm runs in $\\mathcal{O}(n^3)$.\n\n## Implementation\n\n```{.cpp file=matrix-rank}\nconst double EPS = 1E-9;\n\nint compute_rank(vector<vector<double>> A) {\n    int n = A.size();\n    int m = A[0].size();\n\n    int rank = 0;\n    vector<bool> row_selected(n, false);\n    for (int i = 0; i < m; ++i) {\n        int j;\n        for (j = 0; j < n; ++j) {\n            if (!row_selected[j] && abs(A[j][i]) > EPS)\n                break;\n        }\n\n        if (j != n) {\n            ++rank;\n            row_selected[j] = true;\n            for (int p = i + 1; p < m; ++p)\n                A[j][p] /= A[j][i];\n            for (int k = 0; k < n; ++k) {\n                if (k != j && abs(A[k][i]) > EPS) {\n                    for (int p = i + 1; p < m; ++p)\n                        A[k][p] -= A[j][p] * A[k][i];\n                }\n            }\n        }\n    }\n    return rank;\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: matrix_rank\n---\n\n# Finding the rank of a matrix\n\n**The rank of a matrix** is the largest number of linearly independent rows/columns of the matrix. The rank is not only defined  for square matrices.\n\nThe rank of a matrix can also be defined as the largest order of any non-zero minor in the matrix.\n\nLet the matrix be rectangular and have size $N \\times M$.\nNote that if the matrix is square and its determinant is non-zero, then the rank is $N$ ($=M$); otherwise it will be less. Generally, the rank of a matrix does not exceed $\\min (N, M)$.\n\n## Algorithm\n\nYou can search for the rank using [Gaussian elimination](linear-system-gauss.md). We will perform the same operations as when solving the system or finding its determinant. But if at any step in the $i$-th column there are no rows with an non-empty entry among those that we didn't selected already, then we skip this step.\nOtherwise, if we have found a row with a non-zero element in the $i$-th column during the $i$-th step, then we mark this row as a selected one, increase the rank by one (initially the rank is set equal to $0$), and perform the usual operations of taking this row away from the rest.\n\n## Complexity\n\nThis algorithm runs in $\\mathcal{O}(n^3)$.\n\n## Implementation\n\n```{.cpp file=matrix-rank}\nconst double EPS = 1E-9;\n\nint compute_rank(vector<vector<double>> A) {\n    int n = A.size();\n    int m = A[0].size();\n\n    int rank = 0;\n    vector<bool> row_selected(n, false);\n    for (int i = 0; i < m; ++i) {\n        int j;\n        for (j = 0; j < n; ++j) {\n            if (!row_selected[j] && abs(A[j][i]) > EPS)\n                break;\n        }\n\n        if (j != n) {\n            ++rank;\n            row_selected[j] = true;\n            for (int p = i + 1; p < m; ++p)\n                A[j][p] /= A[j][i];\n            for (int k = 0; k < n; ++k) {\n                if (k != j && abs(A[k][i]) > EPS) {\n                    for (int p = i + 1; p < m; ++p)\n                        A[k][p] -= A[j][p] * A[k][i];\n                }\n            }\n        }\n    }\n    return rank;\n}\n```\n## Problems\n * [TIMUS1041 Nikifor](http://acm.timus.ru/problem.aspx?space=1&num=1041)\n", "problem_ids": [], "title": "Finding the rank of a matrix"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: determinant_gauss\n---\n\n# Calculating the determinant of a matrix by Gauss\n\nProblem: Given a matrix $A$ of size $N \\times N$. Compute its determinant.\n\n## Algorithm\n\nWe use the ideas of [Gauss method for solving systems of linear equations](linear-system-gauss.md)\n\nWe will perform the same steps as in the solution of systems of linear equations, excluding only the division of the current line to $a_{ij}$. These operations will not change the absolute value of the determinant of the matrix. When we exchange two lines of the matrix, however, the sign of the determinant can change.\n\nAfter applying Gauss on the matrix, we receive a diagonal matrix, whose determinant is just the product of the elements on the diagonal. The sign, as previously mentioned, can be determined by the number of exchanged rows (if odd, then the sign of the determinant should be reversed). Thus, we can use the Gauss algorithm to compute the determinant of the matrix in complexity $O(N^3)$.\n\nIt should be noted that if at some point, we do not find non-zero cell in current column, the algorithm should stop and returns 0.\n\n## Implementation\n\n```cpp\nconst double EPS = 1E-9;\nint n;\nvector < vector<double> > a (n, vector<double> (n));\n\ndouble det = 1;\nfor (int i=0; i<n; ++i) {\n\tint k = i;\n\tfor (int j=i+1; j<n; ++j)\n\t\tif (abs (a[j][i]) > abs (a[k][i]))\n\t\t\tk = j;\n\tif (abs (a[k][i]) < EPS) {\n\t\tdet = 0;\n\t\tbreak;\n\t}\n\tswap (a[i], a[k]);\n\tif (i != k)\n\t\tdet = -det;\n\tdet *= a[i][i];\n\tfor (int j=i+1; j<n; ++j)\n\t\ta[i][j] /= a[i][i];\n\tfor (int j=0; j<n; ++j)\n\t\tif (j != i && abs (a[j][i]) > EPS)\n\t\t\tfor (int k=i+1; k<n; ++k)\n\t\t\t\ta[j][k] -= a[i][k] * a[j][i];\n}\n\ncout << det;\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: determinant_gauss\n---\n\n# Calculating the determinant of a matrix by Gauss\n\nProblem: Given a matrix $A$ of size $N \\times N$. Compute its determinant.\n\n## Algorithm\n\nWe use the ideas of [Gauss method for solving systems of linear equations](linear-system-gauss.md)\n\nWe will perform the same steps as in the solution of systems of linear equations, excluding only the division of the current line to $a_{ij}$. These operations will not change the absolute value of the determinant of the matrix. When we exchange two lines of the matrix, however, the sign of the determinant can change.\n\nAfter applying Gauss on the matrix, we receive a diagonal matrix, whose determinant is just the product of the elements on the diagonal. The sign, as previously mentioned, can be determined by the number of exchanged rows (if odd, then the sign of the determinant should be reversed). Thus, we can use the Gauss algorithm to compute the determinant of the matrix in complexity $O(N^3)$.\n\nIt should be noted that if at some point, we do not find non-zero cell in current column, the algorithm should stop and returns 0.\n\n## Implementation\n\n```cpp\nconst double EPS = 1E-9;\nint n;\nvector < vector<double> > a (n, vector<double> (n));\n\ndouble det = 1;\nfor (int i=0; i<n; ++i) {\n\tint k = i;\n\tfor (int j=i+1; j<n; ++j)\n\t\tif (abs (a[j][i]) > abs (a[k][i]))\n\t\t\tk = j;\n\tif (abs (a[k][i]) < EPS) {\n\t\tdet = 0;\n\t\tbreak;\n\t}\n\tswap (a[i], a[k]);\n\tif (i != k)\n\t\tdet = -det;\n\tdet *= a[i][i];\n\tfor (int j=i+1; j<n; ++j)\n\t\ta[i][j] /= a[i][i];\n\tfor (int j=0; j<n; ++j)\n\t\tif (j != i && abs (a[j][i]) > EPS)\n\t\t\tfor (int k=i+1; k<n; ++k)\n\t\t\t\ta[j][k] -= a[i][k] * a[j][i];\n}\n\ncout << det;\n```\n\n## Practice Problems\n* [Codeforces - Wizards and Bets](http://codeforces.com/contest/167/problem/E)\n", "problem_ids": ["167_E"], "title": "Calculating the determinant of a matrix by Gauss"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: linear_systems_gauss\n---\n\n# Gauss method for solving system of linear equations\n\nGiven a system of $n$ linear algebraic equations (SLAE) with $m$ unknowns. You are asked to solve the system: to determine if it has no solution, exactly one solution or infinite number of solutions. And in case it has at least one solution, find any of them.\n\nFormally, the problem is formulated as follows: solve the system:\n\n$$\\begin{align}\na_{11} x_1 + a_{12} x_2 + &\\dots + a_{1m} x_m = b_1 \\\\\na_{21} x_1 + a_{22} x_2 + &\\dots + a_{2m} x_m = b_2\\\\\n&\\vdots \\\\\na_{n1} x_1 + a_{n2} x_2 + &\\dots + a_{nm} x_m = b_n\n\\end{align}$$\n\nwhere the coefficients $a_{ij}$ (for $i$ from 1 to $n$, $j$ from 1 to $m$) and $b_i$ ($i$ from 1 to $n$ are known and variables $x_i$ ($i$ from 1 to $m$) are unknowns.\n\nThis problem also has a simple matrix representation:\n\n$$Ax = b,$$\n\nwhere $A$ is a matrix of size $n \\times m$ of coefficients $a_{ij}$ and $b$ is the column vector of size $n$.\n\nIt is worth noting that the method presented in this article can also be used to solve the equation modulo any number p, i.e.:\n\n$$\\begin{align}\na_{11} x_1 + a_{12} x_2 + &\\dots + a_{1m} x_m \\equiv b_1 \\pmod p \\\\\na_{21} x_1 + a_{22} x_2 + &\\dots + a_{2m} x_m \\equiv b_2 \\pmod p \\\\\n&\\vdots \\\\\na_{n1} x_1 + a_{n2} x_2 + &\\dots + a_{nm} x_m \\equiv b_n \\pmod p\n\\end{align}$$\n\n## Gauss\n\nStrictly speaking, the method described below should be called \"Gauss-Jordan\", or Gauss-Jordan elimination, because it is a variation of the Gauss method, described by Jordan in 1887.\n\n## Overview\n\nThe algorithm is a `sequential elimination` of the variables in each equation, until each equation will have only one remaining variable. If $n = m$, you can think of it as transforming the matrix $A$ to identity matrix, and solve the equation in this obvious case, where solution is unique and is equal to coefficient $b_i$.\n\nGaussian elimination is based on two simple transformation:   \n\n* It is possible to exchange two equations\n* Any equation can be replaced by a linear combination of that row (with non-zero coefficient), and some other rows (with arbitrary coefficients).\n\nIn the first step, Gauss-Jordan algorithm divides the first row by $a_{11}$. Then, the algorithm adds the first row to the remaining rows such that the coefficients in the first column becomes all zeros. To achieve this, on the i-th row, we must add the first row multiplied by $- a_{i1}$. Note that, this operation must also be performed on vector $b$. In a sense, it behaves as if vector $b$ was the $m+1$-th column of matrix $A$.\n\nAs a result, after the first step, the first column of matrix $A$ will consists of $1$ on the first row, and $0$ in other rows.\n\nSimilarly, we perform the second step of the algorithm, where we consider the second column of second row. First, the row is divided by $a_{22}$, then it is subtracted from other rows so that all the second column becomes $0$ (except for the second row).\n\nWe continue this process for all columns of matrix $A$. If $n = m$, then $A$ will become identity matrix.\n\n## Search for the pivoting element\n\nThe described scheme left out many details. At the $i$th step, if $a_{ii}$ is zero, we cannot apply directly the described method. Instead, we must first `select a pivoting row`: find one row of the matrix where the $i$th column is non-zero, and then swap the two rows.\n\nNote that, here we swap rows but not columns. This is because if you swap columns, then when you find a solution, you must remember to swap back to correct places. Thus, swapping rows is much easier to do.\n\nIn many implementations, when $a_{ii} \\neq 0$, you can see people still swap the $i$th row with some pivoting row, using some heuristics such as choosing the pivoting row with maximum absolute value of $a_{ji}$. This heuristic is used to reduce the value range of the matrix in later steps. Without this heuristic, even for matrices of size about $20$, the error will be too big and can cause overflow for floating points data types of C++.\n\n## Degenerate cases\n\nIn the case where $m = n$ and the system is non-degenerate (i.e. it has non-zero determinant, and has unique solution), the algorithm described above will transform $A$ into identity matrix.\n\nNow we consider the `general case`, where $n$ and $m$ are not necessarily equal, and the system can be degenerate. In these cases, the pivoting element in $i$th step may not be found. This means that on the $i$th column, starting from the current line, all contains zeros. In this case, either there is no possible value of variable $x_i$ (meaning the SLAE has no solution), or $x_i$ is an independent variable and can take arbitrary value. When implementing Gauss-Jordan, you should continue the work for subsequent variables and just skip the $i$th column (this is equivalent to removing the $i$th column of the matrix).\n\nSo, some of the variables in the process can be found to be independent. When the number of variables, $m$ is greater than the number of equations, $n$, then at least $m - n$ independent variables will be found.\n\nIn general, if you find at least one independent variable, it can take any arbitrary value, while the other (dependent) variables are expressed through it.  This means that when we work in the field of real numbers, the system potentially has infinitely many solutions. But you should remember that when there are independent variables, SLAE can have no solution at all. This happens when the remaining untreated equations have at least one non-zero constant term. You can check this by assigning zeros to all independent variables, calculate other variables, and then plug in to the original SLAE to check if they satisfy it.\n\n## Implementation\n\nFollowing is an implementation of Gauss-Jordan. Choosing the pivot row is done with heuristic: choosing maximum value in the current column.\n\nThe input to the function `gauss` is the system matrix $a$. The last column of this matrix is vector $b$.\n\nThe function returns the number of solutions of the system $(0, 1,\\textrm{or } \\infty)$. If at least one solution exists, then it is returned in the vector $ans$.\n\n```{.cpp file=gauss}\nconst double EPS = 1e-9;\nconst int INF = 2; // it doesn't actually have to be infinity or a big number\n\nint gauss (vector < vector<double> > a, vector<double> & ans) {\n\tint n = (int) a.size();\n\tint m = (int) a[0].size() - 1;\n\n\tvector<int> where (m, -1);\n\tfor (int col=0, row=0; col<m && row<n; ++col) {\n\t\tint sel = row;\n\t\tfor (int i=row; i<n; ++i)\n\t\t\tif (abs (a[i][col]) > abs (a[sel][col]))\n\t\t\t\tsel = i;\n\t\tif (abs (a[sel][col]) < EPS)\n\t\t\tcontinue;\n\t\tfor (int i=col; i<=m; ++i)\n\t\t\tswap (a[sel][i], a[row][i]);\n\t\twhere[col] = row;\n\n\t\tfor (int i=0; i<n; ++i)\n\t\t\tif (i != row) {\n\t\t\t\tdouble c = a[i][col] / a[row][col];\n\t\t\t\tfor (int j=col; j<=m; ++j)\n\t\t\t\t\ta[i][j] -= a[row][j] * c;\n\t\t\t}\n\t\t++row;\n\t}\n\n\tans.assign (m, 0);\n\tfor (int i=0; i<m; ++i)\n\t\tif (where[i] != -1)\n\t\t\tans[i] = a[where[i]][m] / a[where[i]][i];\n\tfor (int i=0; i<n; ++i) {\n\t\tdouble sum = 0;\n\t\tfor (int j=0; j<m; ++j)\n\t\t\tsum += ans[j] * a[i][j];\n\t\tif (abs (sum - a[i][m]) > EPS)\n\t\t\treturn 0;\n\t}\n\n\tfor (int i=0; i<m; ++i)\n\t\tif (where[i] == -1)\n\t\t\treturn INF;\n\treturn 1;\n}\n```\n\nImplementation notes:\n\n* The function uses two pointers - the current column $col$ and the current row $row$.\n* For each variable $x_i$, the value $where(i)$ is the line where this column is not zero. This vector is needed because some variables can be independent.\n* In this implementation, the current $i$th line is not divided by $a_{ii}$ as described above, so in the end the matrix is not identity matrix (though apparently dividing the $i$th line can help reducing errors).\n* After finding a solution, it is inserted back into the matrix - to check whether the system has at least one solution or not. If the test solution is successful, then the function returns 1 or $\\inf$, depending on whether there is at least one independent variable.\n\n## Complexity\n\nNow we should estimate the complexity of this algorithm. The algorithm consists of $m$ phases, in each phase:\n\n* Search and reshuffle the pivoting row. This takes $O(n + m)$ when using heuristic mentioned above.\n* If the pivot element in the current column is found - then we must add this equation to all other equations, which takes time $O(nm)$.\n\nSo, the final complexity of the algorithm is $O(\\min (n, m) . nm)$.\nIn case $n = m$, the complexity is simply $O(n^3)$.\n\nNote that when the SLAE is not on real numbers, but is in the modulo two, then the system can be solved much faster, which is described below.\n\n## Acceleration of the algorithm\n\nThe previous implementation can be sped up by two times, by dividing the algorithm into two phases: forward and reverse:\n\n* Forward phase: Similar to the previous implementation, but the current row is only added to the rows after it. As a result, we obtain a triangular matrix instead of diagonal.\n* Reverse phase: When the matrix is triangular, we first calculate the value of the last variable. Then plug this value to find the value of next variable. Then plug these two values to find the next variables...\n\nReverse phase only takes $O(nm)$, which is much faster than forward phase. In forward phase, we reduce the number of operations by half, thus reducing the running time of the implementation.\n\n## Solving modular SLAE\n\nFor solving SLAE in some module, we can still use the described algorithm. However, in case the module is equal to two, we can perform Gauss-Jordan elimination much more effectively using bitwise operations and C++ bitset data types:\n\n```cpp\nint gauss (vector < bitset<N> > a, int n, int m, bitset<N> & ans) {\n\tvector<int> where (m, -1);\n\tfor (int col=0, row=0; col<m && row<n; ++col) {\n\t\tfor (int i=row; i<n; ++i)\n\t\t\tif (a[i][col]) {\n\t\t\t\tswap (a[i], a[row]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (! a[row][col])\n\t\t\tcontinue;\n\t\twhere[col] = row;\n\n\t\tfor (int i=0; i<n; ++i)\n\t\t\tif (i != row && a[i][col])\n\t\t\t\ta[i] ^= a[row];\n\t\t++row;\n\t}\n        // The rest of implementation is the same as above\n}\n```\n\nSince we use bit compress, the implementation is not only shorter, but also 32 times faster.\n\n## A little note about different heuristics of choosing pivoting row\n\nThere is no general rule for what heuristics to use.\n\nThe heuristics used in previous implementation works quite well in practice. It also turns out to give almost the same answers as \"full pivoting\" - where the pivoting row is search amongst all elements of the whose submatrix (from the current row and current column).\n\nThough, you should note that both heuristics is dependent on how much the original equations was scaled. For example, if one of the equation was multiplied by $10^6$, then this equation is almost certain to be chosen as pivot in first step. This seems rather strange, so it seems logical to change to a more complicated heuristics, called `implicit pivoting`.\n\nImplicit pivoting compares elements as if both lines were normalized, so that the maximum element would be unity. To implement this technique, one need to maintain maximum in each row (or maintain each line so that maximum is unity, but this can lead to increase in the accumulated error).\n\n## Improve the solution\n\nDespite various heuristics, Gauss-Jordan algorithm can still lead to large errors in special matrices even of size $50 - 100$.\n\nTherefore, the resulting Gauss-Jordan solution must sometimes be improved by applying a simple numerical method - for example, the method of simple iteration.\n\nThus, the solution turns into two-step: First, Gauss-Jordan algorithm is applied, and then a numerical method taking initial solution as solution in the first step.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: linear_systems_gauss\n---\n\n# Gauss method for solving system of linear equations\n\nGiven a system of $n$ linear algebraic equations (SLAE) with $m$ unknowns. You are asked to solve the system: to determine if it has no solution, exactly one solution or infinite number of solutions. And in case it has at least one solution, find any of them.\n\nFormally, the problem is formulated as follows: solve the system:\n\n$$\\begin{align}\na_{11} x_1 + a_{12} x_2 + &\\dots + a_{1m} x_m = b_1 \\\\\na_{21} x_1 + a_{22} x_2 + &\\dots + a_{2m} x_m = b_2\\\\\n&\\vdots \\\\\na_{n1} x_1 + a_{n2} x_2 + &\\dots + a_{nm} x_m = b_n\n\\end{align}$$\n\nwhere the coefficients $a_{ij}$ (for $i$ from 1 to $n$, $j$ from 1 to $m$) and $b_i$ ($i$ from 1 to $n$ are known and variables $x_i$ ($i$ from 1 to $m$) are unknowns.\n\nThis problem also has a simple matrix representation:\n\n$$Ax = b,$$\n\nwhere $A$ is a matrix of size $n \\times m$ of coefficients $a_{ij}$ and $b$ is the column vector of size $n$.\n\nIt is worth noting that the method presented in this article can also be used to solve the equation modulo any number p, i.e.:\n\n$$\\begin{align}\na_{11} x_1 + a_{12} x_2 + &\\dots + a_{1m} x_m \\equiv b_1 \\pmod p \\\\\na_{21} x_1 + a_{22} x_2 + &\\dots + a_{2m} x_m \\equiv b_2 \\pmod p \\\\\n&\\vdots \\\\\na_{n1} x_1 + a_{n2} x_2 + &\\dots + a_{nm} x_m \\equiv b_n \\pmod p\n\\end{align}$$\n\n## Gauss\n\nStrictly speaking, the method described below should be called \"Gauss-Jordan\", or Gauss-Jordan elimination, because it is a variation of the Gauss method, described by Jordan in 1887.\n\n## Overview\n\nThe algorithm is a `sequential elimination` of the variables in each equation, until each equation will have only one remaining variable. If $n = m$, you can think of it as transforming the matrix $A$ to identity matrix, and solve the equation in this obvious case, where solution is unique and is equal to coefficient $b_i$.\n\nGaussian elimination is based on two simple transformation:   \n\n* It is possible to exchange two equations\n* Any equation can be replaced by a linear combination of that row (with non-zero coefficient), and some other rows (with arbitrary coefficients).\n\nIn the first step, Gauss-Jordan algorithm divides the first row by $a_{11}$. Then, the algorithm adds the first row to the remaining rows such that the coefficients in the first column becomes all zeros. To achieve this, on the i-th row, we must add the first row multiplied by $- a_{i1}$. Note that, this operation must also be performed on vector $b$. In a sense, it behaves as if vector $b$ was the $m+1$-th column of matrix $A$.\n\nAs a result, after the first step, the first column of matrix $A$ will consists of $1$ on the first row, and $0$ in other rows.\n\nSimilarly, we perform the second step of the algorithm, where we consider the second column of second row. First, the row is divided by $a_{22}$, then it is subtracted from other rows so that all the second column becomes $0$ (except for the second row).\n\nWe continue this process for all columns of matrix $A$. If $n = m$, then $A$ will become identity matrix.\n\n## Search for the pivoting element\n\nThe described scheme left out many details. At the $i$th step, if $a_{ii}$ is zero, we cannot apply directly the described method. Instead, we must first `select a pivoting row`: find one row of the matrix where the $i$th column is non-zero, and then swap the two rows.\n\nNote that, here we swap rows but not columns. This is because if you swap columns, then when you find a solution, you must remember to swap back to correct places. Thus, swapping rows is much easier to do.\n\nIn many implementations, when $a_{ii} \\neq 0$, you can see people still swap the $i$th row with some pivoting row, using some heuristics such as choosing the pivoting row with maximum absolute value of $a_{ji}$. This heuristic is used to reduce the value range of the matrix in later steps. Without this heuristic, even for matrices of size about $20$, the error will be too big and can cause overflow for floating points data types of C++.\n\n## Degenerate cases\n\nIn the case where $m = n$ and the system is non-degenerate (i.e. it has non-zero determinant, and has unique solution), the algorithm described above will transform $A$ into identity matrix.\n\nNow we consider the `general case`, where $n$ and $m$ are not necessarily equal, and the system can be degenerate. In these cases, the pivoting element in $i$th step may not be found. This means that on the $i$th column, starting from the current line, all contains zeros. In this case, either there is no possible value of variable $x_i$ (meaning the SLAE has no solution), or $x_i$ is an independent variable and can take arbitrary value. When implementing Gauss-Jordan, you should continue the work for subsequent variables and just skip the $i$th column (this is equivalent to removing the $i$th column of the matrix).\n\nSo, some of the variables in the process can be found to be independent. When the number of variables, $m$ is greater than the number of equations, $n$, then at least $m - n$ independent variables will be found.\n\nIn general, if you find at least one independent variable, it can take any arbitrary value, while the other (dependent) variables are expressed through it.  This means that when we work in the field of real numbers, the system potentially has infinitely many solutions. But you should remember that when there are independent variables, SLAE can have no solution at all. This happens when the remaining untreated equations have at least one non-zero constant term. You can check this by assigning zeros to all independent variables, calculate other variables, and then plug in to the original SLAE to check if they satisfy it.\n\n## Implementation\n\nFollowing is an implementation of Gauss-Jordan. Choosing the pivot row is done with heuristic: choosing maximum value in the current column.\n\nThe input to the function `gauss` is the system matrix $a$. The last column of this matrix is vector $b$.\n\nThe function returns the number of solutions of the system $(0, 1,\\textrm{or } \\infty)$. If at least one solution exists, then it is returned in the vector $ans$.\n\n```{.cpp file=gauss}\nconst double EPS = 1e-9;\nconst int INF = 2; // it doesn't actually have to be infinity or a big number\n\nint gauss (vector < vector<double> > a, vector<double> & ans) {\n\tint n = (int) a.size();\n\tint m = (int) a[0].size() - 1;\n\n\tvector<int> where (m, -1);\n\tfor (int col=0, row=0; col<m && row<n; ++col) {\n\t\tint sel = row;\n\t\tfor (int i=row; i<n; ++i)\n\t\t\tif (abs (a[i][col]) > abs (a[sel][col]))\n\t\t\t\tsel = i;\n\t\tif (abs (a[sel][col]) < EPS)\n\t\t\tcontinue;\n\t\tfor (int i=col; i<=m; ++i)\n\t\t\tswap (a[sel][i], a[row][i]);\n\t\twhere[col] = row;\n\n\t\tfor (int i=0; i<n; ++i)\n\t\t\tif (i != row) {\n\t\t\t\tdouble c = a[i][col] / a[row][col];\n\t\t\t\tfor (int j=col; j<=m; ++j)\n\t\t\t\t\ta[i][j] -= a[row][j] * c;\n\t\t\t}\n\t\t++row;\n\t}\n\n\tans.assign (m, 0);\n\tfor (int i=0; i<m; ++i)\n\t\tif (where[i] != -1)\n\t\t\tans[i] = a[where[i]][m] / a[where[i]][i];\n\tfor (int i=0; i<n; ++i) {\n\t\tdouble sum = 0;\n\t\tfor (int j=0; j<m; ++j)\n\t\t\tsum += ans[j] * a[i][j];\n\t\tif (abs (sum - a[i][m]) > EPS)\n\t\t\treturn 0;\n\t}\n\n\tfor (int i=0; i<m; ++i)\n\t\tif (where[i] == -1)\n\t\t\treturn INF;\n\treturn 1;\n}\n```\n\nImplementation notes:\n\n* The function uses two pointers - the current column $col$ and the current row $row$.\n* For each variable $x_i$, the value $where(i)$ is the line where this column is not zero. This vector is needed because some variables can be independent.\n* In this implementation, the current $i$th line is not divided by $a_{ii}$ as described above, so in the end the matrix is not identity matrix (though apparently dividing the $i$th line can help reducing errors).\n* After finding a solution, it is inserted back into the matrix - to check whether the system has at least one solution or not. If the test solution is successful, then the function returns 1 or $\\inf$, depending on whether there is at least one independent variable.\n\n## Complexity\n\nNow we should estimate the complexity of this algorithm. The algorithm consists of $m$ phases, in each phase:\n\n* Search and reshuffle the pivoting row. This takes $O(n + m)$ when using heuristic mentioned above.\n* If the pivot element in the current column is found - then we must add this equation to all other equations, which takes time $O(nm)$.\n\nSo, the final complexity of the algorithm is $O(\\min (n, m) . nm)$.\nIn case $n = m$, the complexity is simply $O(n^3)$.\n\nNote that when the SLAE is not on real numbers, but is in the modulo two, then the system can be solved much faster, which is described below.\n\n## Acceleration of the algorithm\n\nThe previous implementation can be sped up by two times, by dividing the algorithm into two phases: forward and reverse:\n\n* Forward phase: Similar to the previous implementation, but the current row is only added to the rows after it. As a result, we obtain a triangular matrix instead of diagonal.\n* Reverse phase: When the matrix is triangular, we first calculate the value of the last variable. Then plug this value to find the value of next variable. Then plug these two values to find the next variables...\n\nReverse phase only takes $O(nm)$, which is much faster than forward phase. In forward phase, we reduce the number of operations by half, thus reducing the running time of the implementation.\n\n## Solving modular SLAE\n\nFor solving SLAE in some module, we can still use the described algorithm. However, in case the module is equal to two, we can perform Gauss-Jordan elimination much more effectively using bitwise operations and C++ bitset data types:\n\n```cpp\nint gauss (vector < bitset<N> > a, int n, int m, bitset<N> & ans) {\n\tvector<int> where (m, -1);\n\tfor (int col=0, row=0; col<m && row<n; ++col) {\n\t\tfor (int i=row; i<n; ++i)\n\t\t\tif (a[i][col]) {\n\t\t\t\tswap (a[i], a[row]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (! a[row][col])\n\t\t\tcontinue;\n\t\twhere[col] = row;\n\n\t\tfor (int i=0; i<n; ++i)\n\t\t\tif (i != row && a[i][col])\n\t\t\t\ta[i] ^= a[row];\n\t\t++row;\n\t}\n        // The rest of implementation is the same as above\n}\n```\n\nSince we use bit compress, the implementation is not only shorter, but also 32 times faster.\n\n## A little note about different heuristics of choosing pivoting row\n\nThere is no general rule for what heuristics to use.\n\nThe heuristics used in previous implementation works quite well in practice. It also turns out to give almost the same answers as \"full pivoting\" - where the pivoting row is search amongst all elements of the whose submatrix (from the current row and current column).\n\nThough, you should note that both heuristics is dependent on how much the original equations was scaled. For example, if one of the equation was multiplied by $10^6$, then this equation is almost certain to be chosen as pivot in first step. This seems rather strange, so it seems logical to change to a more complicated heuristics, called `implicit pivoting`.\n\nImplicit pivoting compares elements as if both lines were normalized, so that the maximum element would be unity. To implement this technique, one need to maintain maximum in each row (or maintain each line so that maximum is unity, but this can lead to increase in the accumulated error).\n\n## Improve the solution\n\nDespite various heuristics, Gauss-Jordan algorithm can still lead to large errors in special matrices even of size $50 - 100$.\n\nTherefore, the resulting Gauss-Jordan solution must sometimes be improved by applying a simple numerical method - for example, the method of simple iteration.\n\nThus, the solution turns into two-step: First, Gauss-Jordan algorithm is applied, and then a numerical method taking initial solution as solution in the first step.\n\n## Practice Problems\n* [Spoj - Xor Maximization](http://www.spoj.com/problems/XMAX/)\n* [Codechef - Knight Moving](https://www.codechef.com/SEP12/problems/KNGHTMOV)\n* [Lightoj - Graph Coloring](http://lightoj.com/volume_showproblem.php?problem=1279)\n* [UVA 12910 - Snakes and Ladders](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4775)\n* [TIMUS1042 Central Heating](http://acm.timus.ru/problem.aspx?space=1&num=1042)\n* [TIMUS1766 Humpty Dumpty](http://acm.timus.ru/problem.aspx?space=1&num=1766)\n* [TIMUS1266 Kirchhoff's Law](http://acm.timus.ru/problem.aspx?space=1&num=1266)\n* [Codeforces - No game no life](https://codeforces.com/problemset/problem/1411/G)\n", "problem_ids": [], "title": "Gauss method for solving system of linear equations"}, {"article": "---\ntitle: Calculating the determinant using Kraut method\ntags:\n  - Original\n---\n# Calculating the determinant using Kraut method in $O(N^3)$\n\nIn this article, we'll describe how to find the determinant of the matrix using Kraut method, which works in $O(N^3)$.\n\nThe Kraut algorithm finds decomposition of matrix $A$ as $A = L U$ where $L$ is lower triangular and $U$ is upper triangular matrix. Without loss of generality, we can assume that all the diagonal elements of $L$ are equal to 1. Once we know these matrices, it is easy to calculate the determinant of $A$: it is equal to the product of all the elements on the main diagonal of the matrix $U$.\n\nThere is a theorem stating that any invertible matrix has a LU-decomposition, and it is unique, if and only if all its principle minors are non-zero. We consider only such decomposition in which the diagonal of matrix $L$ consists of ones.\n\nLet $A$ be the matrix and $N$ - its size. We will find the elements of the matrices $L$ and $U$ using the following steps:\n\n 1. Let $L_{i i} = 1$ for $i = 1, 2, ..., N$.\n 2. For each $j = 1, 2, ..., N$ perform:\n      - For $i = 1, 2, ..., j$ find values \n        \n        \\[U_{ij} = A_{ij} - \\sum_{k=1}^{i-1} L_{ik} \\cdot U_{kj}\\]\n \n      - Next, for $i = j+1, j+2, ..., N$ find values\n \n        \\[L_{ij} = \\frac{1}{U_{jj}} \\left(A_{ij} - \\sum_{k=1}^{j-1} L_{ik} \\cdot U_{kj} \\right).\\]\n\n## Implementation\n\n```java\nstatic BigInteger det (BigDecimal a [][], int n) {\n\ttry {\n\n\tfor (int i=0; i<n; i++) {\n\t\tboolean nonzero = false;\n\t\tfor (int j=0; j<n; j++)\n\t\t\tif (a[i][j].compareTo (new BigDecimal (BigInteger.ZERO)) > 0)\n\t\t\t\tnonzero = true;\n\t\tif (!nonzero)\n\t\t\treturn BigInteger.ZERO;\n\t}\n\n\tBigDecimal scaling [] = new BigDecimal [n];\n\tfor (int i=0; i<n; i++) {\n\t\tBigDecimal big = new BigDecimal (BigInteger.ZERO);\n\t\tfor (int j=0; j<n; j++)\n\t\t\tif (a[i][j].abs().compareTo (big) > 0)\n\t\t\t\tbig = a[i][j].abs();\n\t\tscaling[i] = (new BigDecimal (BigInteger.ONE)) .divide\n\t\t\t(big, 100, BigDecimal.ROUND_HALF_EVEN);\n\t}\n\n\tint sign = 1;\n\n\tfor (int j=0; j<n; j++) {\n\t\tfor (int i=0; i<j; i++) {\n\t\t\tBigDecimal sum = a[i][j];\n\t\t\tfor (int k=0; k<i; k++)\n\t\t\t\tsum = sum.subtract (a[i][k].multiply (a[k][j]));\n\t\t\ta[i][j] = sum;\n\t\t}\n\n\t\tBigDecimal big = new BigDecimal (BigInteger.ZERO);\n\t\tint imax = -1;\n\t\tfor (int i=j; i<n; i++) {\n\t\t\tBigDecimal sum = a[i][j];\n\t\t\tfor (int k=0; k<j; k++)\n\t\t\t\tsum = sum.subtract (a[i][k].multiply (a[k][j]));\n\t\t\ta[i][j] = sum;\n\t\t\tBigDecimal cur = sum.abs();\n\t\t\tcur = cur.multiply (scaling[i]);\n\t\t\tif (cur.compareTo (big) >= 0) {\n\t\t\t\tbig = cur;\n\t\t\t\timax = i;\n\t\t\t}\n\t\t}\n\n\t\tif (j != imax) {\n\t\t\tfor (int k=0; k<n; k++) {\n\t\t\t\tBigDecimal t = a[j][k];\n\t\t\t\ta[j][k] = a[imax][k];\n\t\t\t\ta[imax][k] = t;\n\t\t\t}\n\n\t\t\tBigDecimal t = scaling[imax];\n\t\t\tscaling[imax] = scaling[j];\n\t\t\tscaling[j] = t;\n\n\t\t\tsign = -sign;\n\t\t}\n\n\t\tif (j != n-1)\n\t\t\tfor (int i=j+1; i<n; i++)\n\t\t\t\ta[i][j] = a[i][j].divide\n\t\t\t\t\t(a[j][j], 100, BigDecimal.ROUND_HALF_EVEN);\n\n\t}\n\n\tBigDecimal result = new BigDecimal (1);\n\tif (sign == -1)\n\t\tresult = result.negate();\n\tfor (int i=0; i<n; i++)\n\t\tresult = result.multiply (a[i][i]);\n\n\treturn result.divide\n\t\t(BigDecimal.valueOf(1), 0, BigDecimal.ROUND_HALF_EVEN).toBigInteger();\n\t}\n\tcatch (Exception e) {\n\t\treturn BigInteger.ZERO;\n\t}\n}\n```\n", "full_article": "---\ntitle: Calculating the determinant using Kraut method\ntags:\n  - Original\n---\n# Calculating the determinant using Kraut method in $O(N^3)$\n\nIn this article, we'll describe how to find the determinant of the matrix using Kraut method, which works in $O(N^3)$.\n\nThe Kraut algorithm finds decomposition of matrix $A$ as $A = L U$ where $L$ is lower triangular and $U$ is upper triangular matrix. Without loss of generality, we can assume that all the diagonal elements of $L$ are equal to 1. Once we know these matrices, it is easy to calculate the determinant of $A$: it is equal to the product of all the elements on the main diagonal of the matrix $U$.\n\nThere is a theorem stating that any invertible matrix has a LU-decomposition, and it is unique, if and only if all its principle minors are non-zero. We consider only such decomposition in which the diagonal of matrix $L$ consists of ones.\n\nLet $A$ be the matrix and $N$ - its size. We will find the elements of the matrices $L$ and $U$ using the following steps:\n\n 1. Let $L_{i i} = 1$ for $i = 1, 2, ..., N$.\n 2. For each $j = 1, 2, ..., N$ perform:\n      - For $i = 1, 2, ..., j$ find values \n        \n        \\[U_{ij} = A_{ij} - \\sum_{k=1}^{i-1} L_{ik} \\cdot U_{kj}\\]\n \n      - Next, for $i = j+1, j+2, ..., N$ find values\n \n        \\[L_{ij} = \\frac{1}{U_{jj}} \\left(A_{ij} - \\sum_{k=1}^{j-1} L_{ik} \\cdot U_{kj} \\right).\\]\n\n## Implementation\n\n```java\nstatic BigInteger det (BigDecimal a [][], int n) {\n\ttry {\n\n\tfor (int i=0; i<n; i++) {\n\t\tboolean nonzero = false;\n\t\tfor (int j=0; j<n; j++)\n\t\t\tif (a[i][j].compareTo (new BigDecimal (BigInteger.ZERO)) > 0)\n\t\t\t\tnonzero = true;\n\t\tif (!nonzero)\n\t\t\treturn BigInteger.ZERO;\n\t}\n\n\tBigDecimal scaling [] = new BigDecimal [n];\n\tfor (int i=0; i<n; i++) {\n\t\tBigDecimal big = new BigDecimal (BigInteger.ZERO);\n\t\tfor (int j=0; j<n; j++)\n\t\t\tif (a[i][j].abs().compareTo (big) > 0)\n\t\t\t\tbig = a[i][j].abs();\n\t\tscaling[i] = (new BigDecimal (BigInteger.ONE)) .divide\n\t\t\t(big, 100, BigDecimal.ROUND_HALF_EVEN);\n\t}\n\n\tint sign = 1;\n\n\tfor (int j=0; j<n; j++) {\n\t\tfor (int i=0; i<j; i++) {\n\t\t\tBigDecimal sum = a[i][j];\n\t\t\tfor (int k=0; k<i; k++)\n\t\t\t\tsum = sum.subtract (a[i][k].multiply (a[k][j]));\n\t\t\ta[i][j] = sum;\n\t\t}\n\n\t\tBigDecimal big = new BigDecimal (BigInteger.ZERO);\n\t\tint imax = -1;\n\t\tfor (int i=j; i<n; i++) {\n\t\t\tBigDecimal sum = a[i][j];\n\t\t\tfor (int k=0; k<j; k++)\n\t\t\t\tsum = sum.subtract (a[i][k].multiply (a[k][j]));\n\t\t\ta[i][j] = sum;\n\t\t\tBigDecimal cur = sum.abs();\n\t\t\tcur = cur.multiply (scaling[i]);\n\t\t\tif (cur.compareTo (big) >= 0) {\n\t\t\t\tbig = cur;\n\t\t\t\timax = i;\n\t\t\t}\n\t\t}\n\n\t\tif (j != imax) {\n\t\t\tfor (int k=0; k<n; k++) {\n\t\t\t\tBigDecimal t = a[j][k];\n\t\t\t\ta[j][k] = a[imax][k];\n\t\t\t\ta[imax][k] = t;\n\t\t\t}\n\n\t\t\tBigDecimal t = scaling[imax];\n\t\t\tscaling[imax] = scaling[j];\n\t\t\tscaling[j] = t;\n\n\t\t\tsign = -sign;\n\t\t}\n\n\t\tif (j != n-1)\n\t\t\tfor (int i=j+1; i<n; i++)\n\t\t\t\ta[i][j] = a[i][j].divide\n\t\t\t\t\t(a[j][j], 100, BigDecimal.ROUND_HALF_EVEN);\n\n\t}\n\n\tBigDecimal result = new BigDecimal (1);\n\tif (sign == -1)\n\t\tresult = result.negate();\n\tfor (int i=0; i<n; i++)\n\t\tresult = result.multiply (a[i][i]);\n\n\treturn result.divide\n\t\t(BigDecimal.valueOf(1), 0, BigDecimal.ROUND_HALF_EVEN).toBigInteger();\n\t}\n\tcatch (Exception e) {\n\t\treturn BigInteger.ZERO;\n\t}\n}\n```\n", "problem_ids": [], "title": "Calculating the determinant using Kraut method in $O(N^3)$"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: sprague_grundy\n---\n\n# Sprague-Grundy theorem. Nim\n\n## Introduction\n\nThis theorem describes the so-called **impartial** two-player game,\ni.e. those in which the available moves and winning/losing depends only on the state of the game.\nIn other words, the only difference between the two players is that one of them moves first.\n\nAdditionally, we assume that the game has **perfect information**, i.e. no information is hidden from the players (they know the rules and the possible moves).\n\nIt is assumed that the game is **finite**, i.e. after a certain number of moves, one of the players will end up in a losing position \u2014 from which they can't move to another position.\nOn the other side, the player who set up this position for the opponent wins.\nUnderstandably, there are no draws in this game.\n\nSuch games can be completely described by a *directed acyclic graph*: the vertices are game states and the edges are transitions (moves).\nA vertex without outgoing edges is a losing vertex (a player who must make a move from this vertex loses).\n\nSince there are no draws, we can classify all game states as either **winning** or **losing**.\nWinning states are those from which there is a move that causes inevitable defeat of the other player, even with their best response.\nLosing states are those from which all moves lead to winning states for the other player.\nSummarizing, a state is winning if there is at least one transition to a losing state and is losing if there isn't at least one transition to a losing state.\n\nOur task is to classify the states of a given game.\n\nThe theory of such games was independently developed by Roland Sprague in 1935 and Patrick Michael Grundy in 1939.\n\n## Nim\n\nThis game obeys the restrictions described above.\nMoreover, *any* perfect-information impartial two-player game can be reduced to the game of Nim.\nStudying this game will allow us to solve all other similar games, but more on that later.\n\nHistorically this game was popular in ancient times.\nIts origin is probably in China \u2014 or at least the game *Jianshizi* is very similar to it.\nIn Europe the earliest references to it are from the 16th century.\nThe name was given by Charles Bouton, who in 1901 published a full analysis of this game.\n\n### Game description\n\nThere are several piles, each with several stones.\nIn a move a player can take any positive number of stones from any one pile and throw them away.\nA player loses if they can't make a move, which happens when all the piles are empty.\n\nThe game state is unambiguously described by a multiset of positive integers.\nA move consists of strictly decreasing a chosen integer (if it becomes zero, it is removed from the set).\n\n### The solution\n\nThe solution by Charles L. Bouton looks like this:\n\n**Theorem.**\nThe current player has a winning strategy if and only if the xor-sum of the pile sizes is non-zero.\nThe xor-sum of a sequence $a$ is $a_1 \\oplus a_2 \\oplus \\ldots \\oplus  a_n$, where $\\oplus$ is the *bitwise exclusive or*.\n\n**Proof.**\nThe key to the proof is the presence of a **symmetric strategy for the opponent**.\nWe show that a once in a position with the xor-sum equal to zero, the player won't be able to make it non-zero in the long term \u2014\nif they transition to a position with a non-zero xor-sum, the opponent will always have a move returning the xor-sum back to zero.\n\nWe will prove the theorem by mathematical induction.\n\nFor an empty Nim (where all the piles are empty i.e. the multiset is empty) the xor-sum is zero and the theorem is true.\n\nNow suppose we are in a non-empty state.\nUsing the assumption of induction (and the acyclicity of the game) we assume that the theorem is proven for all states reachable from the current one.\n\nThen the proof splits into two parts:\nif for the current position the xor-sum $s = 0$, we have to prove that this state is losing, i.e. all reachable states have xor-sum $t \\neq 0$.\nIf $s \\neq 0$, we have to prove that there is a move leading to a state with $t = 0$.\n\n*   Let $s = 0$ and let's consider any move.\n    This move reduces the size of a pile $x$ to a size $y$.\n    Using elementary properties of $\\oplus$, we have\n    \n    \\[ t = s \\oplus x \\oplus y = 0 \\oplus x \\oplus y = x \\oplus y \\]\n    \n    Since $y < x$, $y \\oplus x$ can't be zero, so $t \\neq 0$.\n    That means any reachable state is a winning one (by the assumption of induction), so we are in a losing position.\n\n*   Let $s \\neq 0$.\n    Consider the binary representation of the number $s$.\n    Let $d$ be the index of its leading (biggest value) non-zero bit.\n    Our move will be on a pile whose size's bit number $d$ is set (it must exist, otherwise the bit wouldn't be set in $s$).\n    We will reduce its size $x$ to $y = x \\oplus s$.\n    All bits at positions greater than $d$ in $x$ and $y$ match and bit $d$ is set in $x$ but not set in $y$.\n    Therefore, $y < x$, which is all we need for a move to be legal.\n    Now we have:\n    \n    \\[ t = s \\oplus x \\oplus y = s \\oplus x \\oplus (s \\oplus x) = 0 \\]\n    \n    This means we found a reachable losing state (by the assumption of induction) and the current state is winning.\n\n**Corollary.**\nAny state of Nim can be replaced by an equivalent state as long as the xor-sum doesn't change.\nMoreover, when analyzing a Nim with several piles, we can replace it with a single pile of size $s$.\n\n## The equivalence of impartial games and Nim (Sprague-Grundy theorem)\n\nNow we will learn how to find, for any game state of any impartial game, a corresponding state of Nim.\n\n### Lemma about Nim with increases\n\nWe consider the following modification to Nim: we also allow **adding stones to a chosen pile**.\nThe exact rules about how and when increasing is allowed **do not interest us**, however the rules should keep our game **acyclic**. In later sections, example games are considered.\n\n**Lemma.**\nThe addition of increasing to Nim doesn't change how winning and losing states are determined.\nIn other words, increases are useless, and we don't have to use them in a winning strategy.\n\n**Proof.**\nSuppose a player added stones to a pile. Then his opponent can simply undo his move \u2014 decrease the number back to the previous value.\nSince the game is acyclic, sooner or later the current player won't be able to use an increase move and will have to do the usual Nim move.\n\n### Sprague-Grundy theorem\n\nLet's consider a state $v$ of a two-player impartial game and let $v_i$ be the states reachable from it (where $i \\in \\{ 1, 2, \\dots, k \\} , k \\ge 0$).\nTo this state, we can assign a fully equivalent game of Nim with one pile of size $x$.\nThe number $x$ is called the Grundy value or nim-value of state $v$.\n\nMoreover, this number can be found in the following recursive way:\n\n$$ x = \\text{mex}\\ \\{ x_1, \\ldots, x_k \\}, $$\n\nwhere $x_i$ is the Grundy value for state $v_i$ and the function $\\text{mex}$ (*minimum excludant*) is the smallest non-negative integer not found in the given set.\n\nViewing the game as a graph, we can gradually calculate the Grundy values starting from vertices without outgoing edges.\nGrundy value being equal to zero means a state is losing.\n\n**Proof.**\nWe will use a proof by induction.\n\nFor vertices without a move, the value $x$ is the $\\text{mex}$ of an empty set, which is zero.\nThat is correct, since an empty Nim is losing.\n\nNow consider any other vertex $v$.\nBy induction, we assume the values $x_i$ corresponding to its reachable vertices are already calculated.\n\nLet $p = \\text{mex}\\ \\{ x_1, \\ldots, x_k \\}$.\nThen we know that for any integer $i \\in [0, p)$ there exists a reachable vertex with Grundy value $i$.\nThis means $v$ is **equivalent to a state of the game of Nim with increases with one pile of size $p$**.\nIn such a game we have transitions to piles of every size smaller than $p$ and possibly transitions to piles with sizes greater than $p$.\nTherefore, $p$ is indeed the desired Grundy value for the currently considered state.\n\n## Application of the theorem\n\nFinally, we describe an algorithm to determine the win/loss outcome of a game, which is applicable to any impartial two-player game.\n\nTo calculate the Grundy value of a given state you need to:\n\n* Get all possible transitions from this state\n\n* Each transition can lead to a **sum of independent games** (one game in the degenerate case).\nCalculate the Grundy value for each independent game and xor-sum them.\nOf course xor does nothing if there is just one game.\n\n* After we calculated Grundy values for each transition we find the state's value as the $\\text{mex}$ of these numbers.\n\n* If the value is zero, then the current state is losing, otherwise it is winning.\n\nIn comparison to the previous section, we take into account the fact that there can be transitions to combined games.\nWe consider them a Nim with pile sizes equal to the independent games' Grundy values.\nWe can xor-sum them just like usual Nim according to Bouton's theorem.\n\n## Patterns in Grundy values\n\nVery often when solving specific tasks using Grundy values, it may be beneficial to **study the table of the values** in search of patterns.\n\nIn many games, which may seem rather difficult for theoretical analysis,\nthe Grundy values turn out to be periodic or of an easily understandable form.\nIn the overwhelming majority of cases the observed pattern turns out to be true and can be proved by induction if desired.\n\nHowever, Grundy values are far from *always* containing such regularities and even for some very simple games, the problem asking if those regularities exist is still open (e.g. \"Grundy's game\").\n\n## Example games\n\n### Crosses-crosses\n\n**The rules.**\nConsider a checkered strip of size $1 \\times n$. In one move, the player must put one cross, but it is forbidden to put two crosses next to each other (in adjacent cells). As usual, the player without a valid move loses.\n\n**The solution.**\nWhen a player puts a cross in any cell, we can think of the strip being split into two independent parts:\nto the left of the cross and to the right of it.\nIn this case, the cell with a cross, as well as its left and right neighbours are destroyed \u2014 nothing more can be put in them.\nTherefore, if we number the cells from $1$ to $n$ then putting the cross in position $1 < i < n$ breaks the strip\ninto two strips of length $i-2$ and $n-i-1$ i.e. we go to the sum of games $i-2$ and $n-i-1$.\nFor the edge case of the cross being marked on position $1$ or $n$, we go to the game $n-2$.\n\nThus, the Grundy value $g(n)$ has the form:\n\n$$g(n) = \\text{mex} \\Bigl( \\{ g(n-2) \\} \\cup \\{g(i-2) \\oplus g(n-i-1) \\mid 2 \\leq i \\leq n-1\\} \\Bigr) .$$\n\nSo we've got a $O(n^2)$ solution.\n\nIn fact, $g(n)$ has a period of length 34 starting with $n=52$.\n\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: sprague_grundy\n---\n\n# Sprague-Grundy theorem. Nim\n\n## Introduction\n\nThis theorem describes the so-called **impartial** two-player game,\ni.e. those in which the available moves and winning/losing depends only on the state of the game.\nIn other words, the only difference between the two players is that one of them moves first.\n\nAdditionally, we assume that the game has **perfect information**, i.e. no information is hidden from the players (they know the rules and the possible moves).\n\nIt is assumed that the game is **finite**, i.e. after a certain number of moves, one of the players will end up in a losing position \u2014 from which they can't move to another position.\nOn the other side, the player who set up this position for the opponent wins.\nUnderstandably, there are no draws in this game.\n\nSuch games can be completely described by a *directed acyclic graph*: the vertices are game states and the edges are transitions (moves).\nA vertex without outgoing edges is a losing vertex (a player who must make a move from this vertex loses).\n\nSince there are no draws, we can classify all game states as either **winning** or **losing**.\nWinning states are those from which there is a move that causes inevitable defeat of the other player, even with their best response.\nLosing states are those from which all moves lead to winning states for the other player.\nSummarizing, a state is winning if there is at least one transition to a losing state and is losing if there isn't at least one transition to a losing state.\n\nOur task is to classify the states of a given game.\n\nThe theory of such games was independently developed by Roland Sprague in 1935 and Patrick Michael Grundy in 1939.\n\n## Nim\n\nThis game obeys the restrictions described above.\nMoreover, *any* perfect-information impartial two-player game can be reduced to the game of Nim.\nStudying this game will allow us to solve all other similar games, but more on that later.\n\nHistorically this game was popular in ancient times.\nIts origin is probably in China \u2014 or at least the game *Jianshizi* is very similar to it.\nIn Europe the earliest references to it are from the 16th century.\nThe name was given by Charles Bouton, who in 1901 published a full analysis of this game.\n\n### Game description\n\nThere are several piles, each with several stones.\nIn a move a player can take any positive number of stones from any one pile and throw them away.\nA player loses if they can't make a move, which happens when all the piles are empty.\n\nThe game state is unambiguously described by a multiset of positive integers.\nA move consists of strictly decreasing a chosen integer (if it becomes zero, it is removed from the set).\n\n### The solution\n\nThe solution by Charles L. Bouton looks like this:\n\n**Theorem.**\nThe current player has a winning strategy if and only if the xor-sum of the pile sizes is non-zero.\nThe xor-sum of a sequence $a$ is $a_1 \\oplus a_2 \\oplus \\ldots \\oplus  a_n$, where $\\oplus$ is the *bitwise exclusive or*.\n\n**Proof.**\nThe key to the proof is the presence of a **symmetric strategy for the opponent**.\nWe show that a once in a position with the xor-sum equal to zero, the player won't be able to make it non-zero in the long term \u2014\nif they transition to a position with a non-zero xor-sum, the opponent will always have a move returning the xor-sum back to zero.\n\nWe will prove the theorem by mathematical induction.\n\nFor an empty Nim (where all the piles are empty i.e. the multiset is empty) the xor-sum is zero and the theorem is true.\n\nNow suppose we are in a non-empty state.\nUsing the assumption of induction (and the acyclicity of the game) we assume that the theorem is proven for all states reachable from the current one.\n\nThen the proof splits into two parts:\nif for the current position the xor-sum $s = 0$, we have to prove that this state is losing, i.e. all reachable states have xor-sum $t \\neq 0$.\nIf $s \\neq 0$, we have to prove that there is a move leading to a state with $t = 0$.\n\n*   Let $s = 0$ and let's consider any move.\n    This move reduces the size of a pile $x$ to a size $y$.\n    Using elementary properties of $\\oplus$, we have\n    \n    \\[ t = s \\oplus x \\oplus y = 0 \\oplus x \\oplus y = x \\oplus y \\]\n    \n    Since $y < x$, $y \\oplus x$ can't be zero, so $t \\neq 0$.\n    That means any reachable state is a winning one (by the assumption of induction), so we are in a losing position.\n\n*   Let $s \\neq 0$.\n    Consider the binary representation of the number $s$.\n    Let $d$ be the index of its leading (biggest value) non-zero bit.\n    Our move will be on a pile whose size's bit number $d$ is set (it must exist, otherwise the bit wouldn't be set in $s$).\n    We will reduce its size $x$ to $y = x \\oplus s$.\n    All bits at positions greater than $d$ in $x$ and $y$ match and bit $d$ is set in $x$ but not set in $y$.\n    Therefore, $y < x$, which is all we need for a move to be legal.\n    Now we have:\n    \n    \\[ t = s \\oplus x \\oplus y = s \\oplus x \\oplus (s \\oplus x) = 0 \\]\n    \n    This means we found a reachable losing state (by the assumption of induction) and the current state is winning.\n\n**Corollary.**\nAny state of Nim can be replaced by an equivalent state as long as the xor-sum doesn't change.\nMoreover, when analyzing a Nim with several piles, we can replace it with a single pile of size $s$.\n\n## The equivalence of impartial games and Nim (Sprague-Grundy theorem)\n\nNow we will learn how to find, for any game state of any impartial game, a corresponding state of Nim.\n\n### Lemma about Nim with increases\n\nWe consider the following modification to Nim: we also allow **adding stones to a chosen pile**.\nThe exact rules about how and when increasing is allowed **do not interest us**, however the rules should keep our game **acyclic**. In later sections, example games are considered.\n\n**Lemma.**\nThe addition of increasing to Nim doesn't change how winning and losing states are determined.\nIn other words, increases are useless, and we don't have to use them in a winning strategy.\n\n**Proof.**\nSuppose a player added stones to a pile. Then his opponent can simply undo his move \u2014 decrease the number back to the previous value.\nSince the game is acyclic, sooner or later the current player won't be able to use an increase move and will have to do the usual Nim move.\n\n### Sprague-Grundy theorem\n\nLet's consider a state $v$ of a two-player impartial game and let $v_i$ be the states reachable from it (where $i \\in \\{ 1, 2, \\dots, k \\} , k \\ge 0$).\nTo this state, we can assign a fully equivalent game of Nim with one pile of size $x$.\nThe number $x$ is called the Grundy value or nim-value of state $v$.\n\nMoreover, this number can be found in the following recursive way:\n\n$$ x = \\text{mex}\\ \\{ x_1, \\ldots, x_k \\}, $$\n\nwhere $x_i$ is the Grundy value for state $v_i$ and the function $\\text{mex}$ (*minimum excludant*) is the smallest non-negative integer not found in the given set.\n\nViewing the game as a graph, we can gradually calculate the Grundy values starting from vertices without outgoing edges.\nGrundy value being equal to zero means a state is losing.\n\n**Proof.**\nWe will use a proof by induction.\n\nFor vertices without a move, the value $x$ is the $\\text{mex}$ of an empty set, which is zero.\nThat is correct, since an empty Nim is losing.\n\nNow consider any other vertex $v$.\nBy induction, we assume the values $x_i$ corresponding to its reachable vertices are already calculated.\n\nLet $p = \\text{mex}\\ \\{ x_1, \\ldots, x_k \\}$.\nThen we know that for any integer $i \\in [0, p)$ there exists a reachable vertex with Grundy value $i$.\nThis means $v$ is **equivalent to a state of the game of Nim with increases with one pile of size $p$**.\nIn such a game we have transitions to piles of every size smaller than $p$ and possibly transitions to piles with sizes greater than $p$.\nTherefore, $p$ is indeed the desired Grundy value for the currently considered state.\n\n## Application of the theorem\n\nFinally, we describe an algorithm to determine the win/loss outcome of a game, which is applicable to any impartial two-player game.\n\nTo calculate the Grundy value of a given state you need to:\n\n* Get all possible transitions from this state\n\n* Each transition can lead to a **sum of independent games** (one game in the degenerate case).\nCalculate the Grundy value for each independent game and xor-sum them.\nOf course xor does nothing if there is just one game.\n\n* After we calculated Grundy values for each transition we find the state's value as the $\\text{mex}$ of these numbers.\n\n* If the value is zero, then the current state is losing, otherwise it is winning.\n\nIn comparison to the previous section, we take into account the fact that there can be transitions to combined games.\nWe consider them a Nim with pile sizes equal to the independent games' Grundy values.\nWe can xor-sum them just like usual Nim according to Bouton's theorem.\n\n## Patterns in Grundy values\n\nVery often when solving specific tasks using Grundy values, it may be beneficial to **study the table of the values** in search of patterns.\n\nIn many games, which may seem rather difficult for theoretical analysis,\nthe Grundy values turn out to be periodic or of an easily understandable form.\nIn the overwhelming majority of cases the observed pattern turns out to be true and can be proved by induction if desired.\n\nHowever, Grundy values are far from *always* containing such regularities and even for some very simple games, the problem asking if those regularities exist is still open (e.g. \"Grundy's game\").\n\n## Example games\n\n### Crosses-crosses\n\n**The rules.**\nConsider a checkered strip of size $1 \\times n$. In one move, the player must put one cross, but it is forbidden to put two crosses next to each other (in adjacent cells). As usual, the player without a valid move loses.\n\n**The solution.**\nWhen a player puts a cross in any cell, we can think of the strip being split into two independent parts:\nto the left of the cross and to the right of it.\nIn this case, the cell with a cross, as well as its left and right neighbours are destroyed \u2014 nothing more can be put in them.\nTherefore, if we number the cells from $1$ to $n$ then putting the cross in position $1 < i < n$ breaks the strip\ninto two strips of length $i-2$ and $n-i-1$ i.e. we go to the sum of games $i-2$ and $n-i-1$.\nFor the edge case of the cross being marked on position $1$ or $n$, we go to the game $n-2$.\n\nThus, the Grundy value $g(n)$ has the form:\n\n$$g(n) = \\text{mex} \\Bigl( \\{ g(n-2) \\} \\cup \\{g(i-2) \\oplus g(n-i-1) \\mid 2 \\leq i \\leq n-1\\} \\Bigr) .$$\n\nSo we've got a $O(n^2)$ solution.\n\nIn fact, $g(n)$ has a period of length 34 starting with $n=52$.\n\n\n## Practice Problems\n\n- [KATTIS S-Nim](https://open.kattis.com/problems/snim)\n- [CodeForces - Marbles (2018-2019 ACM-ICPC Brazil Subregional)](https://codeforces.com/gym/101908/problem/B)\n- [KATTIS - Cuboid Slicing Game](https://open.kattis.com/problems/cuboidslicinggame)\n- [HackerRank - Tower Breakers, Revisited!](https://www.hackerrank.com/contests/5-days-of-game-theory/challenges/tower-breakers-2)\n- [HackerRank - Tower Breakers, Again!](https://www.hackerrank.com/contests/5-days-of-game-theory/challenges/tower-breakers-3/problem)\n- [HackerRank - Chessboard Game, Again!](https://www.hackerrank.com/contests/5-days-of-game-theory/challenges/a-chessboard-game)\n", "problem_ids": [], "title": "Sprague-Grundy theorem. Nim"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: games_on_graphs\n---\n\n# Games on arbitrary graphs\n\nLet a game be played by two players on an arbitrary graph $G$.\nI.e. the current state of the game is a certain vertex.\nThe players perform moves by turns, and move from the current vertex to an adjacent vertex using a connecting edge.\nDepending on the game, the person that is unable to move will either lose or win the game.\n\nWe consider the most general case, the case of an arbitrary directed graph with cycles.\nIt is our task to determine, given an initial state, who will win the game if both players play with optimal strategies or determine that the result of the game will be a draw.\n\nWe will solve this problem very efficiently.\nWe will find the solution for all possible starting vertices of the graph in linear time with respect to the number of edges: $O(m)$.\n\n## Description of the algorithm\n\nWe will call a vertex a winning vertex, if the player starting at this state will win the game, if they play optimally (regardless of what turns the other player makes).\nSimilarly, we will call a vertex a losing vertex, if the player starting at this vertex will lose the game, if the opponent plays optimally.\n\nFor some of the vertices of the graph, we already know in advance that they are winning or losing vertices: namely all vertices that have no outgoing edges.\n\nAlso we have the following **rules**:\n\n- if a vertex has an outgoing edge that leads to a losing vertex, then the vertex itself is a winning vertex.\n- if all outgoing edges of a certain vertex lead to winning vertices, then the vertex itself is a losing vertex.\n- if at some point there are still undefined vertices, and neither will fit the first or the second rule, then each of these vertices, when used as a starting vertex, will lead to a draw if both player play optimally.\n\nThus, we can define an algorithm which runs in $O(n m)$ time immediately.\nWe go through all vertices and try to apply the first or second rule, and repeat.\n\nHowever, we can accelerate this procedure, and get the complexity down to $O(m)$.\n\nWe will go over all the vertices, for which we initially know if they are winning or losing states.\nFor each of them, we start a [depth first search](../graph/depth-first-search.md).\nThis DFS will move back over the reversed edges.\nFirst of all, it will not enter vertices which already are defined as winning or losing vertices.\nAnd further, if the search goes from a losing vertex to an undefined vertex, then we mark this one as a winning vertex, and continue the DFS using this new vertex.\nIf we go from a winning vertex to an undefined vertex, then we must check whether all edges from this one leads to winning vertices.\nWe can perform this test in $O(1)$ by storing the number of edges that lead to a winning vertex for each vertex.\nSo if we go from a winning vertex to an undefined one, then we increase the counter, and check if this number is equal to the number of outgoing edges.\nIf this is the case, we can mark this vertex as a losing vertex, and continue the DFS from this vertex.\nOtherwise we don't know yet, if this vertex is a winning or losing vertex, and therefore it doesn't make sense to keep continuing the DFS using it.\n\nIn total we visit every winning and every losing vertex exactly once (undefined vertices are not visited), and we go over each edge also at most one time.\nHence the complexity is $O(m)$.\n\n## Implementation\n\nHere is the implementation of such a DFS.\nWe assume that the variable `adj_rev` stores the adjacency list for the graph in **reversed** form, i.e. instead of storing the edge $(i, j)$ of the graph, we store $(j, i)$.\nAlso for each vertex we assume that the outgoing degree is already computed.\n\n```cpp \nvector<vector<int>> adj_rev;\n\nvector<bool> winning;\nvector<bool> losing;\nvector<bool> visited;\nvector<int> degree;\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int u : adj_rev[v]) {\n        if (!visited[u]) {\n            if (losing[v])\n                winning[u] = true;\n            else if (--degree[u] == 0)\n                losing[u] = true;\n            else\n                continue;\n            dfs(u);\n        }\n    }\n}\n```\n\n## Example: \"Policeman and thief\"\n\nHere is a concrete example of such a game.\n\nThere is $m \\times n$ board.\nSome of the cells cannot be entered.\nThe initial coordinates of the police officer and of the thief are known.\nOne of the cells is the exit.\nIf the policeman and the thief are located at the same cell at any moment, the policeman wins.\nIf the thief is at the exit cell (without the policeman also being on the cell), then the thief wins.\nThe policeman can walk in all 8 directions, the thief only in 4 (along the coordinate axis).\nBoth the policeman and the thief will take turns moving.\nHowever they also can skip a turn if they want to.\nThe first move is made by the policeman.\n\nWe will now **construct the graph**.\nFor this we must formalize the rules of the game.\nThe current state of the game is determined by the coordinates of the police offices $P$, the coordinates of the thief $T$, and also by whose turn it is, let's call this variable $P_{\\text{turn}}$ (which is true when it is the policeman's turn).\nTherefore a vertex of the graph is determined by the triple $(P, T, P_{\\text{turn}})$\nThe graph then can be easily constructed, simply by following the rules of the game.\n\nNext we need to determine which vertices are winning and which are losing ones initially.\nThere is a **subtle point** here.\nThe winning / losing vertices depend, in addition to the coordinates, also on $P_{\\text{turn}}$ - whose turn it.\nIf it is the policeman's turn, then the vertex is a winning vertex, if the coordinates of the policeman and the thief coincide, and the vertex is a losing one if it is not a winning one and the thief is on the exit vertex.\nIf it is the thief's turn, then a vertex is a losing vertex, if the coordinates of the two players coincide, and it is a winning vertex if it is not a losing one, and the thief is at the exit vertex.\n\nThe only point before implementing is not, that you need to decide if you want to build the graph **explicitly** or just construct it **on the fly**.\nOn one hand, building the graph explicitly will be a lot easier and there is less chance of making mistakes.\nOn the other hand, it will increase the amount of code and the running time will be slower than if you build the graph on the fly.\n\nThe following implementation will construct the graph explicitly:\n\n```cpp\nstruct State {\n    int P, T;\n    bool Pstep;\n};\n\nvector<State> adj_rev[100][100][2]; // [P][T][Pstep]\nbool winning[100][100][2];\nbool losing[100][100][2];\nbool visited[100][100][2];\nint degree[100][100][2];\n\nvoid dfs(State v) {\n    visited[v.P][v.T][v.Pstep] = true;\n    for (State u : adj_rev[v.P][v.T][v.Pstep]) {\n        if (!visited[u.P][u.T][u.Pstep]) {\n            if (losing[v.P][v.T][v.Pstep])\n                winning[u.P][u.T][u.Pstep] = true;\n            else if (--degree[u.P][u.T][u.Pstep] == 0)\n                losing[u.P][u.T][u.Pstep] = true;\n            else\n                continue;\n            dfs(u);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<string> a(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n\n    for (int P = 0; P < n*m; P++) {\n        for (int T = 0; T < n*m; T++) {\n            for (int Pstep = 0; Pstep <= 1; Pstep++) {\n                int Px = P/m, Py = P%m, Tx = T/m, Ty = T%m;\n                if (a[Px][Py]=='*' || a[Tx][Ty]=='*')\n                    continue;\n                \n                bool& win = winning[P][T][Pstep];\n                bool& lose = losing[P][T][Pstep];\n                if (Pstep) {\n                    win = Px==Tx && Py==Ty;\n                    lose = !win && a[Tx][Ty] == 'E';\n                } else {\n                    lose = Px==Tx && Py==Ty;\n                    win = !lose && a[Tx][Ty] == 'E';\n                }\n                if (win || lose)\n                    continue;\n\n                State st = {P,T,!Pstep};\n                adj_rev[P][T][Pstep].push_back(st);\n                st.Pstep = Pstep;\n                degree[P][T][Pstep]++;\n                \n                const int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\n                const int dy[] = {0, 1, 0, -1, -1, 1, -1, 1};\n                for (int d = 0; d < (Pstep ? 8 : 4); d++) {\n                    int PPx = Px, PPy = Py, TTx = Tx, TTy = Ty;\n                    if (Pstep) {\n                        PPx += dx[d];\n                        PPy += dy[d];\n                    } else {\n                        TTx += dx[d];\n                        TTy += dy[d];\n                    }\n\n                    if (PPx >= 0 && PPx < n && PPy >= 0 && PPy < m && a[PPx][PPy] != '*' &&\n                        TTx >= 0 && TTx < n && TTy >= 0 && TTy < m && a[TTx][TTy] != '*')\n                    {\n                        adj_rev[PPx*m+PPy][TTx*m+TTy][!Pstep].push_back(st);\n                        ++degree[P][T][Pstep];\n                    }\n                }\n            }\n        }\n    }\n\n    for (int P = 0; P < n*m; P++) {\n        for (int T = 0; T < n*m; T++) {\n            for (int Pstep = 0; Pstep <= 1; Pstep++) {\n                if ((winning[P][T][Pstep] || losing[P][T][Pstep]) && !visited[P][T][Pstep])\n                    dfs({P, T, (bool)Pstep});\n            }\n        }\n    }\n\n    int P_st, T_st;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (a[i][j] == 'P')\n                P_st = i*m+j;\n            else if (a[i][j] == 'T')\n                T_st = i*m+j;\n        }\n    }\n\n    if (winning[P_st][T_st][true]) {\n        cout << \"Police catches the thief\"  << endl;\n    } else if (losing[P_st][T_st][true]) {\n        cout << \"The thief escapes\" << endl;\n    } else {\n        cout << \"Draw\" << endl;\n    }\n}\n```\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: games_on_graphs\n---\n\n# Games on arbitrary graphs\n\nLet a game be played by two players on an arbitrary graph $G$.\nI.e. the current state of the game is a certain vertex.\nThe players perform moves by turns, and move from the current vertex to an adjacent vertex using a connecting edge.\nDepending on the game, the person that is unable to move will either lose or win the game.\n\nWe consider the most general case, the case of an arbitrary directed graph with cycles.\nIt is our task to determine, given an initial state, who will win the game if both players play with optimal strategies or determine that the result of the game will be a draw.\n\nWe will solve this problem very efficiently.\nWe will find the solution for all possible starting vertices of the graph in linear time with respect to the number of edges: $O(m)$.\n\n## Description of the algorithm\n\nWe will call a vertex a winning vertex, if the player starting at this state will win the game, if they play optimally (regardless of what turns the other player makes).\nSimilarly, we will call a vertex a losing vertex, if the player starting at this vertex will lose the game, if the opponent plays optimally.\n\nFor some of the vertices of the graph, we already know in advance that they are winning or losing vertices: namely all vertices that have no outgoing edges.\n\nAlso we have the following **rules**:\n\n- if a vertex has an outgoing edge that leads to a losing vertex, then the vertex itself is a winning vertex.\n- if all outgoing edges of a certain vertex lead to winning vertices, then the vertex itself is a losing vertex.\n- if at some point there are still undefined vertices, and neither will fit the first or the second rule, then each of these vertices, when used as a starting vertex, will lead to a draw if both player play optimally.\n\nThus, we can define an algorithm which runs in $O(n m)$ time immediately.\nWe go through all vertices and try to apply the first or second rule, and repeat.\n\nHowever, we can accelerate this procedure, and get the complexity down to $O(m)$.\n\nWe will go over all the vertices, for which we initially know if they are winning or losing states.\nFor each of them, we start a [depth first search](../graph/depth-first-search.md).\nThis DFS will move back over the reversed edges.\nFirst of all, it will not enter vertices which already are defined as winning or losing vertices.\nAnd further, if the search goes from a losing vertex to an undefined vertex, then we mark this one as a winning vertex, and continue the DFS using this new vertex.\nIf we go from a winning vertex to an undefined vertex, then we must check whether all edges from this one leads to winning vertices.\nWe can perform this test in $O(1)$ by storing the number of edges that lead to a winning vertex for each vertex.\nSo if we go from a winning vertex to an undefined one, then we increase the counter, and check if this number is equal to the number of outgoing edges.\nIf this is the case, we can mark this vertex as a losing vertex, and continue the DFS from this vertex.\nOtherwise we don't know yet, if this vertex is a winning or losing vertex, and therefore it doesn't make sense to keep continuing the DFS using it.\n\nIn total we visit every winning and every losing vertex exactly once (undefined vertices are not visited), and we go over each edge also at most one time.\nHence the complexity is $O(m)$.\n\n## Implementation\n\nHere is the implementation of such a DFS.\nWe assume that the variable `adj_rev` stores the adjacency list for the graph in **reversed** form, i.e. instead of storing the edge $(i, j)$ of the graph, we store $(j, i)$.\nAlso for each vertex we assume that the outgoing degree is already computed.\n\n```cpp \nvector<vector<int>> adj_rev;\n\nvector<bool> winning;\nvector<bool> losing;\nvector<bool> visited;\nvector<int> degree;\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int u : adj_rev[v]) {\n        if (!visited[u]) {\n            if (losing[v])\n                winning[u] = true;\n            else if (--degree[u] == 0)\n                losing[u] = true;\n            else\n                continue;\n            dfs(u);\n        }\n    }\n}\n```\n\n## Example: \"Policeman and thief\"\n\nHere is a concrete example of such a game.\n\nThere is $m \\times n$ board.\nSome of the cells cannot be entered.\nThe initial coordinates of the police officer and of the thief are known.\nOne of the cells is the exit.\nIf the policeman and the thief are located at the same cell at any moment, the policeman wins.\nIf the thief is at the exit cell (without the policeman also being on the cell), then the thief wins.\nThe policeman can walk in all 8 directions, the thief only in 4 (along the coordinate axis).\nBoth the policeman and the thief will take turns moving.\nHowever they also can skip a turn if they want to.\nThe first move is made by the policeman.\n\nWe will now **construct the graph**.\nFor this we must formalize the rules of the game.\nThe current state of the game is determined by the coordinates of the police offices $P$, the coordinates of the thief $T$, and also by whose turn it is, let's call this variable $P_{\\text{turn}}$ (which is true when it is the policeman's turn).\nTherefore a vertex of the graph is determined by the triple $(P, T, P_{\\text{turn}})$\nThe graph then can be easily constructed, simply by following the rules of the game.\n\nNext we need to determine which vertices are winning and which are losing ones initially.\nThere is a **subtle point** here.\nThe winning / losing vertices depend, in addition to the coordinates, also on $P_{\\text{turn}}$ - whose turn it.\nIf it is the policeman's turn, then the vertex is a winning vertex, if the coordinates of the policeman and the thief coincide, and the vertex is a losing one if it is not a winning one and the thief is on the exit vertex.\nIf it is the thief's turn, then a vertex is a losing vertex, if the coordinates of the two players coincide, and it is a winning vertex if it is not a losing one, and the thief is at the exit vertex.\n\nThe only point before implementing is not, that you need to decide if you want to build the graph **explicitly** or just construct it **on the fly**.\nOn one hand, building the graph explicitly will be a lot easier and there is less chance of making mistakes.\nOn the other hand, it will increase the amount of code and the running time will be slower than if you build the graph on the fly.\n\nThe following implementation will construct the graph explicitly:\n\n```cpp\nstruct State {\n    int P, T;\n    bool Pstep;\n};\n\nvector<State> adj_rev[100][100][2]; // [P][T][Pstep]\nbool winning[100][100][2];\nbool losing[100][100][2];\nbool visited[100][100][2];\nint degree[100][100][2];\n\nvoid dfs(State v) {\n    visited[v.P][v.T][v.Pstep] = true;\n    for (State u : adj_rev[v.P][v.T][v.Pstep]) {\n        if (!visited[u.P][u.T][u.Pstep]) {\n            if (losing[v.P][v.T][v.Pstep])\n                winning[u.P][u.T][u.Pstep] = true;\n            else if (--degree[u.P][u.T][u.Pstep] == 0)\n                losing[u.P][u.T][u.Pstep] = true;\n            else\n                continue;\n            dfs(u);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<string> a(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n\n    for (int P = 0; P < n*m; P++) {\n        for (int T = 0; T < n*m; T++) {\n            for (int Pstep = 0; Pstep <= 1; Pstep++) {\n                int Px = P/m, Py = P%m, Tx = T/m, Ty = T%m;\n                if (a[Px][Py]=='*' || a[Tx][Ty]=='*')\n                    continue;\n                \n                bool& win = winning[P][T][Pstep];\n                bool& lose = losing[P][T][Pstep];\n                if (Pstep) {\n                    win = Px==Tx && Py==Ty;\n                    lose = !win && a[Tx][Ty] == 'E';\n                } else {\n                    lose = Px==Tx && Py==Ty;\n                    win = !lose && a[Tx][Ty] == 'E';\n                }\n                if (win || lose)\n                    continue;\n\n                State st = {P,T,!Pstep};\n                adj_rev[P][T][Pstep].push_back(st);\n                st.Pstep = Pstep;\n                degree[P][T][Pstep]++;\n                \n                const int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\n                const int dy[] = {0, 1, 0, -1, -1, 1, -1, 1};\n                for (int d = 0; d < (Pstep ? 8 : 4); d++) {\n                    int PPx = Px, PPy = Py, TTx = Tx, TTy = Ty;\n                    if (Pstep) {\n                        PPx += dx[d];\n                        PPy += dy[d];\n                    } else {\n                        TTx += dx[d];\n                        TTy += dy[d];\n                    }\n\n                    if (PPx >= 0 && PPx < n && PPy >= 0 && PPy < m && a[PPx][PPy] != '*' &&\n                        TTx >= 0 && TTx < n && TTy >= 0 && TTy < m && a[TTx][TTy] != '*')\n                    {\n                        adj_rev[PPx*m+PPy][TTx*m+TTy][!Pstep].push_back(st);\n                        ++degree[P][T][Pstep];\n                    }\n                }\n            }\n        }\n    }\n\n    for (int P = 0; P < n*m; P++) {\n        for (int T = 0; T < n*m; T++) {\n            for (int Pstep = 0; Pstep <= 1; Pstep++) {\n                if ((winning[P][T][Pstep] || losing[P][T][Pstep]) && !visited[P][T][Pstep])\n                    dfs({P, T, (bool)Pstep});\n            }\n        }\n    }\n\n    int P_st, T_st;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (a[i][j] == 'P')\n                P_st = i*m+j;\n            else if (a[i][j] == 'T')\n                T_st = i*m+j;\n        }\n    }\n\n    if (winning[P_st][T_st][true]) {\n        cout << \"Police catches the thief\"  << endl;\n    } else if (losing[P_st][T_st][true]) {\n        cout << \"The thief escapes\" << endl;\n    } else {\n        cout << \"Draw\" << endl;\n    }\n}\n```\n", "problem_ids": [], "title": "Games on arbitrary graphs"}, {"article": "---\ntags:\n    - Original\n---\n\n# Binary search\n\n**Binary search** is a method that allows for quicker search of something by splitting the search interval into two. Its most common application is searching values in sorted arrays, however the splitting idea is crucial in many other typical tasks.\n\n## Search in sorted arrays\n\nThe most typical problem that leads to the binary search is as follows. You're given a sorted array $A_0 \\leq A_1 \\leq \\dots \\leq A_{n-1}$, check if $k$ is present within the sequence. The simplest solution would be to check every element one by one and compare it with $k$ (a so-called linear search). This approach works in $O(n)$, but doesn't utilize the fact that the array is sorted.\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg\" width=\"800px\">\n<br>\n<i>Binary search of the value $7$ in an array</i>.\n<br>\n<i>The <a href=\"https://commons.wikimedia.org/wiki/File:Binary_Search_Depiction.svg\">image</a> by [AlwaysAngry](https://commons.wikimedia.org/wiki/User:AlwaysAngry) is distributed under <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.en\">CC BY-SA 4.0</a></i> license.\n</center>\n\nNow assume that we know two indices $L < R$ such that $A_L \\leq k \\leq A_R$. Because the array is sorted, we can deduce that $k$ either occurs among $A_L, A_{L+1}, \\dots, A_R$ or doesn't occur in the array at all. If we pick an arbitrary index $M$ such that $L < M < R$ and check whether $k$ is less or greater than $A_M$. We have two possible cases:\n\n1. $A_L \\leq k \\leq A_M$. In this case, we reduce the problem from $[L, R]$ to $[L, M]$;\n1. $A_M \\leq k \\leq A_R$. In this case, we reduce the problem from $[L, R]$ to $[M, R]$.\n\nWhen it is impossible to pick  $M$, that is, when $R = L + 1$, we directly compare $k$ with $A_L$ and $A_R$. Otherwise we would want to pick $M$ in such manner that it reduces the active segment to a single element as quickly as possible _in the worst case_.\n\nSince in the worst case we will always reduce to larger segment of $[L, M]$ and $[M, R]$. Thus, in the worst case scenario the reduction would be from $R-L$ to $\\max(M-L, R-M)$. To minimize this value, we should pick $M \\approx \\frac{L+R}{2}$, then\n\n$$\nM-L \\approx \\frac{R-L}{2} \\approx R-M.\n$$\n\nIn other words, from the worst-case scenario perspective it is optimal to always pick $M$ in the middle of $[L, R]$ and split it in half. Thus, the active segment halves on each step until it becomes of size $1$. So, if the process needs $h$ steps, in the end it reduces the difference between $R$ and $L$ from $R-L$ to $\\frac{R-L}{2^h} \\approx 1$, giving us the equation $2^h \\approx R-L$.\n\nTaking $\\log_2$ on both sides, we get $h \\approx \\log_2(R-L) \\in O(\\log n)$.\n\nLogarithmic number of steps is drastically better than that of linear search. For example, for $n \\approx 2^{20} \\approx 10^6$ you'd need to make approximately a million operations for linear search, but only around $20$ operations with the binary search.\n\n### Lower bound and upper bound\n\nIt is often convenient to find the position of the first element that is not less than $k$ (called the lower bound of $k$ in the array) or the position of the first element that is greater than $k$ (called the upper bound of $k$) rather than the exact position of the element.\n\nTogether, lower and upper bounds produce a possibly empty half-interval of the array elements that are equal to $k$. To check whether $k$ is present in the array it's enough to find its lower bound and check if the corresponding element equates to $k$.\n\n### Implementation\n\nThe explanation above provides a rough description of the algorithm. For the implementation details, we'd need to be more precise.\n\nWe will maintain a pair $L < R$ such that $A_L \\leq k < A_R$. Meaning that the active search interval is $[L, R)$. We use half-interval here instead of a segment $[L, R]$ as it turns out to require less corner case work.\n\nWhen $R = L+1$, we can deduce from definitions above that $R$ is the upper bound of $k$. It is convenient to initialize $R$ with past-the-end index, that is $R=n$ and $L$ with before-the-beginning index, that is $L=-1$. It is fine as long as we never evaluate $A_L$ and $A_R$ in our algorithm directly, formally treating it as $A_L = -\\infty$ and $A_R = +\\infty$.\n\nFinally, to be specific about the value of $M$ we pick, we will stick with $M = \\lfloor \\frac{L+R}{2} \\rfloor$.\n\nThen the implementation could look like this:\n\n```cpp\n... // a sorted array is stored as a[0], a[1], ..., a[n-1]\nint l = -1, r = n;\nwhile(r - l > 1) {\n    int m = (l + r) / 2;\n    if(k < a[m]) {\n        r = m; // a[l] <= k < a[m] <= a[r]\n    } else {\n        l = m; // a[l] <= a[m] <= k < a[r]\n    }\n}\n```\n\nDuring the execution of the algorithm, we never evaluate neither $A_L$ nor $A_R$, as $L < M < R$. In the end, $L$ will be the index of the last element that is not greater than $k$ (or $-1$ if there is no such element) and $R$ will be the index of the first element larger than $k$ (or $n$ if there is no such element).\n\n## Search on arbitrary predicate\n\nLet $f : \\{0,1,\\dots, n-1\\} \\to \\{0, 1\\}$ be a boolean function defined on $0,1,\\dots,n-1$ such that it is monotonous, that is\n\n$$\nf(0) \\leq f(1) \\leq \\dots \\leq f(n-1).\n$$\n\nThe binary search, the way it is described above, finds the partition of the array by the predicate $f(M)$, holding the boolean value of $k < A_M$ expression. In other words, binary search finds the unique index $L$ such that $f(L) = 0$ and $f(R)=f(L+1)=1$.\n\nIt is possible to use arbitrary monotonous predicate instead of $k < A_M$. It is particularly useful when the computation of $f(k)$ is requires too much time to actually compute it for every possible value.\n\n```cpp\n... // f(i) is a boolean function such that f(0) <= ... <= f(n-1)\nint l = -1, r = n;\nwhile(r - l > 1) {\n    int m = (l + r) / 2;\n    if(f(m)) {\n        r = m; // 0 = f(l) < f(m) = 1\n    } else {\n        l = m; // 0 = f(m) < f(r) = 1\n    }\n}\n```\n\n### Binary search on the answer\n\nSuch situation often occurs when we're asked to compute some value, but we're only capable of checking whether this value is at least $i$. For example, you're given an array $a_1,\\dots,a_n$ and you're asked to find the maximum floored average sum\n\n$$\n\\left \\lfloor \\frac{a_l + a_{l+1} + \\dots + a_r}{r-l+1} \\right\\rfloor\n$$\n\namong all possible pairs of $l,r$ such that $r-l \\geq x$. One of simple ways to solve this problem is to check whether the answer is at least $\\lambda$, that is if there is a pair $l, r$ such that the following is true:\n\n$$\n\\frac{a_l + a_{l+1} + \\dots + a_r}{r-l+1} \\geq \\lambda.\n$$\n\nEquivalently, it rewrites as\n\n$$\n(a_l - \\lambda) + (a_{l+1} - \\lambda) + \\dots + (a_r - \\lambda) \\geq 0,\n$$\n\nso now we need to check whether there is a subarray of a new array $a_i - \\lambda$ of length at least $x+1$ with non-negative sum, which is doable with some prefix sums.\n\n## Continuous search\n\nLet $f : \\mathbb R \\to \\mathbb R$ be a real-valued function that is continuous on a segment $[L, R]$.\n\nWithout loss of generality assume that $f(L) \\leq f(R)$. From [intermediate value theorem](https://en.wikipedia.org/wiki/Intermediate_value_theorem) it follows that for any $y \\in [f(L), f(R)]$ there is $x \\in [L, R]$ such that $f(x) = y$. Note that, unlike previous paragraphs, the function is _not_ required to be monotonous.\n\nThe value $x$ could be approximated up to $\\pm\\delta$ in $O\\left(\\log \\frac{R-L}{\\delta}\\right)$ time for any specific value of $\\delta$. The idea is essentially the same, if we take $M \\in (L, R)$ then we would be able to reduce the search interval to either $[L, M]$ or $[M, R]$ depending on whether $f(M)$ is larger than $y$. One common example here would be finding roots of odd-degree polynomials.\n\nFor example, let $f(x)=x^3 + ax^2 + bx + c$. Then $f(L) \\to -\\infty$ and $f(R) \\to +\\infty$ with $L \\to -\\infty$ and $R \\to +\\infty$. Which means that it is always possible to find sufficiently small $L$ and sufficiently large $R$ such that $f(L) < 0$ and $f(R) > 0$. Then, it is possible to find with binary search arbitrarily small interval containing $x$ such that $f(x)=0$.\n\n## Search with powers of 2\n\nAnother noteworthy way to do binary search is, instead of maintaining an active segment, to maintain the current pointer $i$ and the current power $k$. The pointer starts at $i=L$ and then on each iteration one tests the predicate at point $i+2^k$. If the predicate is still $0$, the pointer is advanced from $i$ to $i+2^k$, otherwise it stays the same, then the power $k$ is decreased by $1$.\n\nThis paradigm is widely used in tasks around trees, such as finding lowest common ancestor of two vertices or finding an ancestor of a specific vertex that has a certain height. It could also be adapted to e.g. find the $k$-th non-zero element in a Fenwick tree.\n\n", "full_article": "---\ntags:\n    - Original\n---\n\n# Binary search\n\n**Binary search** is a method that allows for quicker search of something by splitting the search interval into two. Its most common application is searching values in sorted arrays, however the splitting idea is crucial in many other typical tasks.\n\n## Search in sorted arrays\n\nThe most typical problem that leads to the binary search is as follows. You're given a sorted array $A_0 \\leq A_1 \\leq \\dots \\leq A_{n-1}$, check if $k$ is present within the sequence. The simplest solution would be to check every element one by one and compare it with $k$ (a so-called linear search). This approach works in $O(n)$, but doesn't utilize the fact that the array is sorted.\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg\" width=\"800px\">\n<br>\n<i>Binary search of the value $7$ in an array</i>.\n<br>\n<i>The <a href=\"https://commons.wikimedia.org/wiki/File:Binary_Search_Depiction.svg\">image</a> by [AlwaysAngry](https://commons.wikimedia.org/wiki/User:AlwaysAngry) is distributed under <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.en\">CC BY-SA 4.0</a></i> license.\n</center>\n\nNow assume that we know two indices $L < R$ such that $A_L \\leq k \\leq A_R$. Because the array is sorted, we can deduce that $k$ either occurs among $A_L, A_{L+1}, \\dots, A_R$ or doesn't occur in the array at all. If we pick an arbitrary index $M$ such that $L < M < R$ and check whether $k$ is less or greater than $A_M$. We have two possible cases:\n\n1. $A_L \\leq k \\leq A_M$. In this case, we reduce the problem from $[L, R]$ to $[L, M]$;\n1. $A_M \\leq k \\leq A_R$. In this case, we reduce the problem from $[L, R]$ to $[M, R]$.\n\nWhen it is impossible to pick  $M$, that is, when $R = L + 1$, we directly compare $k$ with $A_L$ and $A_R$. Otherwise we would want to pick $M$ in such manner that it reduces the active segment to a single element as quickly as possible _in the worst case_.\n\nSince in the worst case we will always reduce to larger segment of $[L, M]$ and $[M, R]$. Thus, in the worst case scenario the reduction would be from $R-L$ to $\\max(M-L, R-M)$. To minimize this value, we should pick $M \\approx \\frac{L+R}{2}$, then\n\n$$\nM-L \\approx \\frac{R-L}{2} \\approx R-M.\n$$\n\nIn other words, from the worst-case scenario perspective it is optimal to always pick $M$ in the middle of $[L, R]$ and split it in half. Thus, the active segment halves on each step until it becomes of size $1$. So, if the process needs $h$ steps, in the end it reduces the difference between $R$ and $L$ from $R-L$ to $\\frac{R-L}{2^h} \\approx 1$, giving us the equation $2^h \\approx R-L$.\n\nTaking $\\log_2$ on both sides, we get $h \\approx \\log_2(R-L) \\in O(\\log n)$.\n\nLogarithmic number of steps is drastically better than that of linear search. For example, for $n \\approx 2^{20} \\approx 10^6$ you'd need to make approximately a million operations for linear search, but only around $20$ operations with the binary search.\n\n### Lower bound and upper bound\n\nIt is often convenient to find the position of the first element that is not less than $k$ (called the lower bound of $k$ in the array) or the position of the first element that is greater than $k$ (called the upper bound of $k$) rather than the exact position of the element.\n\nTogether, lower and upper bounds produce a possibly empty half-interval of the array elements that are equal to $k$. To check whether $k$ is present in the array it's enough to find its lower bound and check if the corresponding element equates to $k$.\n\n### Implementation\n\nThe explanation above provides a rough description of the algorithm. For the implementation details, we'd need to be more precise.\n\nWe will maintain a pair $L < R$ such that $A_L \\leq k < A_R$. Meaning that the active search interval is $[L, R)$. We use half-interval here instead of a segment $[L, R]$ as it turns out to require less corner case work.\n\nWhen $R = L+1$, we can deduce from definitions above that $R$ is the upper bound of $k$. It is convenient to initialize $R$ with past-the-end index, that is $R=n$ and $L$ with before-the-beginning index, that is $L=-1$. It is fine as long as we never evaluate $A_L$ and $A_R$ in our algorithm directly, formally treating it as $A_L = -\\infty$ and $A_R = +\\infty$.\n\nFinally, to be specific about the value of $M$ we pick, we will stick with $M = \\lfloor \\frac{L+R}{2} \\rfloor$.\n\nThen the implementation could look like this:\n\n```cpp\n... // a sorted array is stored as a[0], a[1], ..., a[n-1]\nint l = -1, r = n;\nwhile(r - l > 1) {\n    int m = (l + r) / 2;\n    if(k < a[m]) {\n        r = m; // a[l] <= k < a[m] <= a[r]\n    } else {\n        l = m; // a[l] <= a[m] <= k < a[r]\n    }\n}\n```\n\nDuring the execution of the algorithm, we never evaluate neither $A_L$ nor $A_R$, as $L < M < R$. In the end, $L$ will be the index of the last element that is not greater than $k$ (or $-1$ if there is no such element) and $R$ will be the index of the first element larger than $k$ (or $n$ if there is no such element).\n\n## Search on arbitrary predicate\n\nLet $f : \\{0,1,\\dots, n-1\\} \\to \\{0, 1\\}$ be a boolean function defined on $0,1,\\dots,n-1$ such that it is monotonous, that is\n\n$$\nf(0) \\leq f(1) \\leq \\dots \\leq f(n-1).\n$$\n\nThe binary search, the way it is described above, finds the partition of the array by the predicate $f(M)$, holding the boolean value of $k < A_M$ expression. In other words, binary search finds the unique index $L$ such that $f(L) = 0$ and $f(R)=f(L+1)=1$.\n\nIt is possible to use arbitrary monotonous predicate instead of $k < A_M$. It is particularly useful when the computation of $f(k)$ is requires too much time to actually compute it for every possible value.\n\n```cpp\n... // f(i) is a boolean function such that f(0) <= ... <= f(n-1)\nint l = -1, r = n;\nwhile(r - l > 1) {\n    int m = (l + r) / 2;\n    if(f(m)) {\n        r = m; // 0 = f(l) < f(m) = 1\n    } else {\n        l = m; // 0 = f(m) < f(r) = 1\n    }\n}\n```\n\n### Binary search on the answer\n\nSuch situation often occurs when we're asked to compute some value, but we're only capable of checking whether this value is at least $i$. For example, you're given an array $a_1,\\dots,a_n$ and you're asked to find the maximum floored average sum\n\n$$\n\\left \\lfloor \\frac{a_l + a_{l+1} + \\dots + a_r}{r-l+1} \\right\\rfloor\n$$\n\namong all possible pairs of $l,r$ such that $r-l \\geq x$. One of simple ways to solve this problem is to check whether the answer is at least $\\lambda$, that is if there is a pair $l, r$ such that the following is true:\n\n$$\n\\frac{a_l + a_{l+1} + \\dots + a_r}{r-l+1} \\geq \\lambda.\n$$\n\nEquivalently, it rewrites as\n\n$$\n(a_l - \\lambda) + (a_{l+1} - \\lambda) + \\dots + (a_r - \\lambda) \\geq 0,\n$$\n\nso now we need to check whether there is a subarray of a new array $a_i - \\lambda$ of length at least $x+1$ with non-negative sum, which is doable with some prefix sums.\n\n## Continuous search\n\nLet $f : \\mathbb R \\to \\mathbb R$ be a real-valued function that is continuous on a segment $[L, R]$.\n\nWithout loss of generality assume that $f(L) \\leq f(R)$. From [intermediate value theorem](https://en.wikipedia.org/wiki/Intermediate_value_theorem) it follows that for any $y \\in [f(L), f(R)]$ there is $x \\in [L, R]$ such that $f(x) = y$. Note that, unlike previous paragraphs, the function is _not_ required to be monotonous.\n\nThe value $x$ could be approximated up to $\\pm\\delta$ in $O\\left(\\log \\frac{R-L}{\\delta}\\right)$ time for any specific value of $\\delta$. The idea is essentially the same, if we take $M \\in (L, R)$ then we would be able to reduce the search interval to either $[L, M]$ or $[M, R]$ depending on whether $f(M)$ is larger than $y$. One common example here would be finding roots of odd-degree polynomials.\n\nFor example, let $f(x)=x^3 + ax^2 + bx + c$. Then $f(L) \\to -\\infty$ and $f(R) \\to +\\infty$ with $L \\to -\\infty$ and $R \\to +\\infty$. Which means that it is always possible to find sufficiently small $L$ and sufficiently large $R$ such that $f(L) < 0$ and $f(R) > 0$. Then, it is possible to find with binary search arbitrarily small interval containing $x$ such that $f(x)=0$.\n\n## Search with powers of 2\n\nAnother noteworthy way to do binary search is, instead of maintaining an active segment, to maintain the current pointer $i$ and the current power $k$. The pointer starts at $i=L$ and then on each iteration one tests the predicate at point $i+2^k$. If the predicate is still $0$, the pointer is advanced from $i$ to $i+2^k$, otherwise it stays the same, then the power $k$ is decreased by $1$.\n\nThis paradigm is widely used in tasks around trees, such as finding lowest common ancestor of two vertices or finding an ancestor of a specific vertex that has a certain height. It could also be adapted to e.g. find the $k$-th non-zero element in a Fenwick tree.\n\n## Practice Problems\n\n* [LeetCode -  Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n* [LeetCode -  Search Insert Position](https://leetcode.com/problems/search-insert-position/)\n* [LeetCode -  Sqrt(x)](https://leetcode.com/problems/sqrtx/)\n* [LeetCode -  First Bad Version](https://leetcode.com/problems/first-bad-version/)\n* [LeetCode -  Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square/)\n* [LeetCode -  Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/)\n* [LeetCode -  Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/)\n* [Codeforces - Interesting Drink](https://codeforces.com/problemset/problem/706/B/)\n* [Codeforces - Magic Powder - 1](https://codeforces.com/problemset/problem/670/D1)\n* [Codeforces - Another Problem on Strings](https://codeforces.com/problemset/problem/165/C)\n* [Codeforces - Frodo and pillows](https://codeforces.com/problemset/problem/760/B)\n* [Codeforces - GukiZ hates Boxes](https://codeforces.com/problemset/problem/551/C)\n* [Codeforces - Enduring Exodus](https://codeforces.com/problemset/problem/645/C)\n* [Codeforces - Chip 'n Dale Rescue Rangers](https://codeforces.com/problemset/problem/590/B)\n", "problem_ids": ["670_D1", "165_C", "760_B", "551_C", "645_C", "590_B"], "title": "Binary search"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: ternary_search\n---\t\n\n# Ternary Search\n\nWe are given a function $f(x)$ which is unimodal on an interval $[l, r]$. By unimodal function, we mean one of two behaviors of the function: \n\n1. The function strictly increases first, reaches a maximum (at a single point or over an interval), and then strictly decreases.\n\n2. The function strictly decreases first, reaches a minimum, and then strictly increases.\n\nIn this article, we will assume the first scenario.\nThe second scenario is completely symmetrical to the first.\n\nThe task is to find the maximum of function $f(x)$ on the interval $[l, r]$.\n\n## Algorithm\n\nConsider any 2 points $m_1$, and $m_2$ in this interval: $l < m_1 < m_2 < r$. We evaluate the function at $m_1$ and $m_2$, i.e. find the values of $f(m_1)$ and $f(m_2)$. Now, we get one of three options:\n\n-   $f(m_1) < f(m_2)$\n\n    The desired maximum can not be located on the left side of $m_1$, i.e. on the interval $[l, m_1]$, since either both points $m_1$ and $m_2$ or just $m_1$ belong to the area where the function increases. In either case, this means that we have to search for the maximum in the segment $[m_1, r]$.\n\n-   $f(m_1) > f(m_2)$\n\n    This situation is symmetrical to the previous one: the maximum can not be located on the right side of $m_2$, i.e. on the interval $[m_2, r]$, and the search space is reduced to the segment $[l, m_2]$.\n\n-   $f(m_1) = f(m_2)$\n\n    We can see that either both of these points belong to the area where the value of the function is maximized, or $m_1$ is in the area of increasing values and $m_2$ is in the area of descending values (here we used the strictness of function increasing/decreasing). Thus, the search space is reduced to $[m_1, m_2]$. To simplify the code, this case can be combined with any of the previous cases.\n\nThus, based on the comparison of the values in the two inner points, we can replace the current interval $[l, r]$ with a new, shorter interval $[l^\\prime, r^\\prime]$. Repeatedly applying the described procedure to the interval, we can get an arbitrarily short interval. Eventually, its length will be less than a certain pre-defined constant (accuracy), and the process can be stopped. This is a numerical method, so we can assume that after that the function reaches its maximum at all points of the last interval $[l, r]$. Without loss of generality, we can take $f(l)$ as the return value.\n\nWe didn't impose any restrictions on the choice of points $m_1$ and $m_2$. This choice will define the convergence rate and the accuracy of the implementation. The most common way is to choose the points so that they divide the interval $[l, r]$ into three equal parts. Thus, we have\n\n$$m_1 = l + \\frac{(r - l)}{3}$$\n\n$$m_2 = r - \\frac{(r - l)}{3}$$ \n\nIf $m_1$ and $m_2$ are chosen to be closer to each other, the convergence rate will increase slightly.\n\n### Run time analysis\n\n$$T(n) = T({2n}/{3}) + 1 = \\Theta(\\log n)$$\n\nIt can be visualized as follows: every time after evaluating the function at points $m_1$ and $m_2$, we are essentially ignoring about one third of the interval, either the left or right one. Thus the size of the search space is ${2n}/{3}$ of the original one. \n\nApplying [Master's Theorem](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)), we get the desired complexity estimate.\n\n### The case of the integer arguments\n\nIf $f(x)$ takes integer parameter, the interval $[l, r]$ becomes discrete. Since we did not impose any restrictions on the choice of points $m_1$ and $m_2$, the correctness of the algorithm is not affected. $m_1$ and $m_2$ can still be chosen to divide $[l, r]$ into 3 approximately equal parts.\n\nThe difference occurs in the stopping criterion of the algorithm. Ternary search will have to stop when $(r - l) < 3$, because in that case we can no longer select $m_1$ and $m_2$ to be different from each other as well as from $l$ and $r$, and this can cause an infinite loop. Once $(r - l) < 3$, the remaining pool of candidate points $(l, l + 1, \\ldots, r)$ needs to be checked to find the point which produces the maximum value $f(x)$.\n\n## Implementation\n\n```cpp\ndouble ternary_search(double l, double r) {\n\tdouble eps = 1e-9;\t\t\t\t//set the error limit here\n\twhile (r - l > eps) {\n\t\tdouble m1 = l + (r - l) / 3;\n\t\tdouble m2 = r - (r - l) / 3;\n\t\tdouble f1 = f(m1);\t\t//evaluates the function at m1\n\t\tdouble f2 = f(m2);\t\t//evaluates the function at m2\n\t\tif (f1 < f2)\n\t\t\tl = m1;\n\t\telse\n\t\t\tr = m2;\n\t}\n\treturn f(l);\t\t\t\t\t//return the maximum of f(x) in [l, r]\n}\n```\n\nHere `eps` is in fact the absolute error (not taking into account errors due to the inaccurate calculation of the function).\n\nInstead of the criterion `r - l > eps`, we can select a constant number of iterations as a stopping criterion. The number of iterations should be chosen to ensure the required accuracy. Typically, in most programming challenges the error limit is ${10}^{-6}$ and thus 200 - 300 iterations are sufficient. Also, the number of iterations doesn't depend on the values of $l$ and $r$, so the number of iterations corresponds to the required relative error.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: ternary_search\n---\t\n\n# Ternary Search\n\nWe are given a function $f(x)$ which is unimodal on an interval $[l, r]$. By unimodal function, we mean one of two behaviors of the function: \n\n1. The function strictly increases first, reaches a maximum (at a single point or over an interval), and then strictly decreases.\n\n2. The function strictly decreases first, reaches a minimum, and then strictly increases.\n\nIn this article, we will assume the first scenario.\nThe second scenario is completely symmetrical to the first.\n\nThe task is to find the maximum of function $f(x)$ on the interval $[l, r]$.\n\n## Algorithm\n\nConsider any 2 points $m_1$, and $m_2$ in this interval: $l < m_1 < m_2 < r$. We evaluate the function at $m_1$ and $m_2$, i.e. find the values of $f(m_1)$ and $f(m_2)$. Now, we get one of three options:\n\n-   $f(m_1) < f(m_2)$\n\n    The desired maximum can not be located on the left side of $m_1$, i.e. on the interval $[l, m_1]$, since either both points $m_1$ and $m_2$ or just $m_1$ belong to the area where the function increases. In either case, this means that we have to search for the maximum in the segment $[m_1, r]$.\n\n-   $f(m_1) > f(m_2)$\n\n    This situation is symmetrical to the previous one: the maximum can not be located on the right side of $m_2$, i.e. on the interval $[m_2, r]$, and the search space is reduced to the segment $[l, m_2]$.\n\n-   $f(m_1) = f(m_2)$\n\n    We can see that either both of these points belong to the area where the value of the function is maximized, or $m_1$ is in the area of increasing values and $m_2$ is in the area of descending values (here we used the strictness of function increasing/decreasing). Thus, the search space is reduced to $[m_1, m_2]$. To simplify the code, this case can be combined with any of the previous cases.\n\nThus, based on the comparison of the values in the two inner points, we can replace the current interval $[l, r]$ with a new, shorter interval $[l^\\prime, r^\\prime]$. Repeatedly applying the described procedure to the interval, we can get an arbitrarily short interval. Eventually, its length will be less than a certain pre-defined constant (accuracy), and the process can be stopped. This is a numerical method, so we can assume that after that the function reaches its maximum at all points of the last interval $[l, r]$. Without loss of generality, we can take $f(l)$ as the return value.\n\nWe didn't impose any restrictions on the choice of points $m_1$ and $m_2$. This choice will define the convergence rate and the accuracy of the implementation. The most common way is to choose the points so that they divide the interval $[l, r]$ into three equal parts. Thus, we have\n\n$$m_1 = l + \\frac{(r - l)}{3}$$\n\n$$m_2 = r - \\frac{(r - l)}{3}$$ \n\nIf $m_1$ and $m_2$ are chosen to be closer to each other, the convergence rate will increase slightly.\n\n### Run time analysis\n\n$$T(n) = T({2n}/{3}) + 1 = \\Theta(\\log n)$$\n\nIt can be visualized as follows: every time after evaluating the function at points $m_1$ and $m_2$, we are essentially ignoring about one third of the interval, either the left or right one. Thus the size of the search space is ${2n}/{3}$ of the original one. \n\nApplying [Master's Theorem](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)), we get the desired complexity estimate.\n\n### The case of the integer arguments\n\nIf $f(x)$ takes integer parameter, the interval $[l, r]$ becomes discrete. Since we did not impose any restrictions on the choice of points $m_1$ and $m_2$, the correctness of the algorithm is not affected. $m_1$ and $m_2$ can still be chosen to divide $[l, r]$ into 3 approximately equal parts.\n\nThe difference occurs in the stopping criterion of the algorithm. Ternary search will have to stop when $(r - l) < 3$, because in that case we can no longer select $m_1$ and $m_2$ to be different from each other as well as from $l$ and $r$, and this can cause an infinite loop. Once $(r - l) < 3$, the remaining pool of candidate points $(l, l + 1, \\ldots, r)$ needs to be checked to find the point which produces the maximum value $f(x)$.\n\n## Implementation\n\n```cpp\ndouble ternary_search(double l, double r) {\n\tdouble eps = 1e-9;\t\t\t\t//set the error limit here\n\twhile (r - l > eps) {\n\t\tdouble m1 = l + (r - l) / 3;\n\t\tdouble m2 = r - (r - l) / 3;\n\t\tdouble f1 = f(m1);\t\t//evaluates the function at m1\n\t\tdouble f2 = f(m2);\t\t//evaluates the function at m2\n\t\tif (f1 < f2)\n\t\t\tl = m1;\n\t\telse\n\t\t\tr = m2;\n\t}\n\treturn f(l);\t\t\t\t\t//return the maximum of f(x) in [l, r]\n}\n```\n\nHere `eps` is in fact the absolute error (not taking into account errors due to the inaccurate calculation of the function).\n\nInstead of the criterion `r - l > eps`, we can select a constant number of iterations as a stopping criterion. The number of iterations should be chosen to ensure the required accuracy. Typically, in most programming challenges the error limit is ${10}^{-6}$ and thus 200 - 300 iterations are sufficient. Also, the number of iterations doesn't depend on the values of $l$ and $r$, so the number of iterations corresponds to the required relative error.\n\n## Practice Problems\n- [Codechef - Race time](https://www.codechef.com/problems/AMCS03)\n- [Hackerearth - Rescuer](https://www.hackerearth.com/problem/algorithm/rescuer-2d2495cb/)\n- [Spoj - Building Construction](http://www.spoj.com/problems/KOPC12A/)\n- [Codeforces - Weakness and Poorness](http://codeforces.com/problemset/problem/578/C)\n* [LOJ - Closest Distance](http://lightoj.com/volume_showproblem.php?problem=1146)\n* [GYM - Dome of Circus (D)](http://codeforces.com/gym/101309)\n* [UVA - Galactic Taxes](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4898)\n* [GYM - Chasing the Cheetahs (A)](http://codeforces.com/gym/100829)\n* [UVA - 12197 - Trick or Treat](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3349)\n* [SPOJ - Building Construction](http://www.spoj.com/problems/KOPC12A/)\n* [Codeforces - Devu and his Brother](https://codeforces.com/problemset/problem/439/D)\n* [Codechef - Is This JEE ](https://www.codechef.com/problems/ICM2003)\n* [Codeforces - Restorer Distance](https://codeforces.com/contest/1355/problem/E)\n* [TIMUS 1719 Kill the Shaitan-Boss](https://acm.timus.ru/problem.aspx?space=1&num=1719)\n* [TIMUS 1913 Titan Ruins: Alignment of Forces](https://acm.timus.ru/problem.aspx?space=1&num=1913)\n", "problem_ids": ["578_C", "439_D", "1355_E"], "title": "Ternary Search"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: roots_newton\n---\n\n# Newton's method for finding roots \n\nThis is an iterative method invented by Isaac Newton around 1664. However, this method is also sometimes called the Raphson method, since Raphson invented the same algorithm a few years after Newton, but his article was published much earlier.\n\nThe task is as follows. Given the following equation:\n\n$$f(x) = 0$$\n\nWe want to solve the equation. More precisely, we want to find one of its roots (it is assumed that the root exists). It is assumed that $f(x)$ is continuous and differentiable on an interval $[a, b]$.\n\n## Algorithm\n\nThe input parameters of the algorithm consist of not only the function $f(x)$ but also the initial approximation - some $x_0$, with which the algorithm starts.\n\n<p align=\"center\">\n\t<img src=\"./roots_newton.png\" alt=\"plot_f(x)\">\n</p>\n\nSuppose we have already calculated $x_i$, calculate $x_{i+1}$ as follows. Draw the tangent to the graph of the function $f(x)$ at the point $x = x_i$, and find the point of intersection of this tangent with the $x$-axis. $x_{i+1}$ is set equal to the $x$-coordinate of the point found, and we repeat the whole process from the beginning.\n\nIt is not difficult to obtain the following formula,\n\n$$ x_{i+1} = x_i - \\frac{f(x_i)}{f^\\prime(x_i)} $$\n\nFirst, we calculate the slope $f'(x)$, derivative of $f(x)$, and then determine the equation of the tangent which is,\n\n$$ y - f(x_i) = f'(x_i)(x - x_i) $$ \n\nThe tangent intersects with the x-axis at cordinate, $y = 0$ and $x = x_{i+1}$,\n\n$$ - f(x_i) = f'(x_i)(x_{i+1} - x_i) $$ \n\nNow, solving the equation we get the value of $x_{i+1}$.\n\nIt is intuitively clear that if the function $f(x)$ is \"good\" (smooth), and $x_i$ is close enough to the root, then $x_{i+1}$ will be even closer to the desired root.\n\nThe rate of convergence is quadratic, which, conditionally speaking, means that the number of exact digits in the approximate value $x_i$ doubles with each iteration.\n\n## Application for calculating the square root\n\nLet's use the calculation of square root as an example of Newton's method.\n\nIf we substitute $f(x) = x^2 - n$, then after simplifying the expression, we get:\n\n$$ x_{i+1} = \\frac{x_i + \\frac{n}{x_i}}{2} $$\n\nThe first typical variant of the problem is when a rational number $n$ is given, and its root must be calculated with some accuracy `eps`:\n\n```cpp\ndouble sqrt_newton(double n) {\n\tconst double eps = 1E-15;\n\tdouble x = 1;\n\tfor (;;) {\n\t\tdouble nx = (x + n / x) / 2;\n\t\tif (abs(x - nx) < eps)\n\t\t\tbreak;\n\t\tx = nx;\n\t}\n\treturn x;\n}\n```\n\nAnother common variant of the problem is when we need to calculate the integer root (for the given $n$ find the largest $x$ such that $x^2 \\le n$). Here it is necessary to slightly change the termination condition of the algorithm, since it may happen that $x$ will start to \"jump\" near the answer. Therefore, we add a condition that if the value $x$ has decreased in the previous step, and it tries to increase at the current step, then the algorithm must be stopped.\n\n```cpp\nint isqrt_newton(int n) {\n\tint x = 1;\n\tbool decreased = false;\n\tfor (;;) {\n\t\tint nx = (x + n / x) >> 1;\n\t\tif (x == nx || nx > x && decreased)\n\t\t\tbreak;\n\t\tdecreased = nx < x;\n\t\tx = nx;\n\t}\n\treturn x;\n}\n```\n\nFinally, we are given the third variant - for the case of bignum arithmetic. Since the number $n$ can be large enough, it makes sense to pay attention to the initial approximation. Obviously, the closer it is to the root, the faster the result will be achieved. It is simple enough and effective to take the initial approximation as the number $2^{\\textrm{bits}/2}$, where $\\textrm{bits}$ is the number of bits in the number $n$. Here is the Java code that demonstrates this variant:\n\n```java\npublic static BigInteger isqrtNewton(BigInteger n) {\n\tBigInteger a = BigInteger.ONE.shiftLeft(n.bitLength() / 2);\n\tboolean p_dec = false;\n\tfor (;;) {\n\t\tBigInteger b = n.divide(a).add(a).shiftRight(1);\n\t\tif (a.compareTo(b) == 0 || a.compareTo(b) < 0 && p_dec)\n\t\t\tbreak;\n\t\tp_dec = a.compareTo(b) > 0;\n\t\ta = b;\n\t}\n\treturn a;\n}\n```\n\nFor example, this code is executed in $60$ milliseconds for $n = 10^{1000}$, and if we remove the improved selection of the initial approximation (just starting with $1$), then it will be executed in about $120$ milliseconds.\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: roots_newton\n---\n\n# Newton's method for finding roots \n\nThis is an iterative method invented by Isaac Newton around 1664. However, this method is also sometimes called the Raphson method, since Raphson invented the same algorithm a few years after Newton, but his article was published much earlier.\n\nThe task is as follows. Given the following equation:\n\n$$f(x) = 0$$\n\nWe want to solve the equation. More precisely, we want to find one of its roots (it is assumed that the root exists). It is assumed that $f(x)$ is continuous and differentiable on an interval $[a, b]$.\n\n## Algorithm\n\nThe input parameters of the algorithm consist of not only the function $f(x)$ but also the initial approximation - some $x_0$, with which the algorithm starts.\n\n<p align=\"center\">\n\t<img src=\"./roots_newton.png\" alt=\"plot_f(x)\">\n</p>\n\nSuppose we have already calculated $x_i$, calculate $x_{i+1}$ as follows. Draw the tangent to the graph of the function $f(x)$ at the point $x = x_i$, and find the point of intersection of this tangent with the $x$-axis. $x_{i+1}$ is set equal to the $x$-coordinate of the point found, and we repeat the whole process from the beginning.\n\nIt is not difficult to obtain the following formula,\n\n$$ x_{i+1} = x_i - \\frac{f(x_i)}{f^\\prime(x_i)} $$\n\nFirst, we calculate the slope $f'(x)$, derivative of $f(x)$, and then determine the equation of the tangent which is,\n\n$$ y - f(x_i) = f'(x_i)(x - x_i) $$ \n\nThe tangent intersects with the x-axis at cordinate, $y = 0$ and $x = x_{i+1}$,\n\n$$ - f(x_i) = f'(x_i)(x_{i+1} - x_i) $$ \n\nNow, solving the equation we get the value of $x_{i+1}$.\n\nIt is intuitively clear that if the function $f(x)$ is \"good\" (smooth), and $x_i$ is close enough to the root, then $x_{i+1}$ will be even closer to the desired root.\n\nThe rate of convergence is quadratic, which, conditionally speaking, means that the number of exact digits in the approximate value $x_i$ doubles with each iteration.\n\n## Application for calculating the square root\n\nLet's use the calculation of square root as an example of Newton's method.\n\nIf we substitute $f(x) = x^2 - n$, then after simplifying the expression, we get:\n\n$$ x_{i+1} = \\frac{x_i + \\frac{n}{x_i}}{2} $$\n\nThe first typical variant of the problem is when a rational number $n$ is given, and its root must be calculated with some accuracy `eps`:\n\n```cpp\ndouble sqrt_newton(double n) {\n\tconst double eps = 1E-15;\n\tdouble x = 1;\n\tfor (;;) {\n\t\tdouble nx = (x + n / x) / 2;\n\t\tif (abs(x - nx) < eps)\n\t\t\tbreak;\n\t\tx = nx;\n\t}\n\treturn x;\n}\n```\n\nAnother common variant of the problem is when we need to calculate the integer root (for the given $n$ find the largest $x$ such that $x^2 \\le n$). Here it is necessary to slightly change the termination condition of the algorithm, since it may happen that $x$ will start to \"jump\" near the answer. Therefore, we add a condition that if the value $x$ has decreased in the previous step, and it tries to increase at the current step, then the algorithm must be stopped.\n\n```cpp\nint isqrt_newton(int n) {\n\tint x = 1;\n\tbool decreased = false;\n\tfor (;;) {\n\t\tint nx = (x + n / x) >> 1;\n\t\tif (x == nx || nx > x && decreased)\n\t\t\tbreak;\n\t\tdecreased = nx < x;\n\t\tx = nx;\n\t}\n\treturn x;\n}\n```\n\nFinally, we are given the third variant - for the case of bignum arithmetic. Since the number $n$ can be large enough, it makes sense to pay attention to the initial approximation. Obviously, the closer it is to the root, the faster the result will be achieved. It is simple enough and effective to take the initial approximation as the number $2^{\\textrm{bits}/2}$, where $\\textrm{bits}$ is the number of bits in the number $n$. Here is the Java code that demonstrates this variant:\n\n```java\npublic static BigInteger isqrtNewton(BigInteger n) {\n\tBigInteger a = BigInteger.ONE.shiftLeft(n.bitLength() / 2);\n\tboolean p_dec = false;\n\tfor (;;) {\n\t\tBigInteger b = n.divide(a).add(a).shiftRight(1);\n\t\tif (a.compareTo(b) == 0 || a.compareTo(b) < 0 && p_dec)\n\t\t\tbreak;\n\t\tp_dec = a.compareTo(b) > 0;\n\t\ta = b;\n\t}\n\treturn a;\n}\n```\n\nFor example, this code is executed in $60$ milliseconds for $n = 10^{1000}$, and if we remove the improved selection of the initial approximation (just starting with $1$), then it will be executed in about $120$ milliseconds.\n\n## Practice Problems\n- [UVa 10428 - The Roots](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1369)\n", "problem_ids": [], "title": "Newton's method for finding roots"}, {"article": "---\ntags:\n  - Translated\ne_maxx_link: simpson_integrating\n---\n\n# Integration by Simpson's formula\n\nWe are going to calculate the value of a definite integral\n\n$$\\int_a ^ b f (x) dx$$\n\nThe solution described here was published in one of the dissertations of **Thomas Simpson** in 1743.\n\n## Simpson's formula\n\nLet $n$ be some natural number. We divide the integration segment $[a, b]$ into $2n$ equal parts:\n\n$$x_i = a + i h, ~~ i = 0 \\ldots 2n,$$\n\n$$h = \\frac {b-a} {2n}.$$\n\nNow we calculate the integral separately on each of the segments $[x_ {2i-2}, x_ {2i}]$, $i = 1 \\ldots n$, and then add all the values.\n\nSo, suppose we consider the next segment $[x_ {2i-2}, x_ {2i}],  i = 1 \\ldots n$. Replace the function $f(x)$ on it with a parabola $P(x)$ passing through 3 points $(x_ {2i-2}, x_ {2i-1}, x_ {2i})$. Such a parabola always exists and is unique; it can be found analytically.\nFor instance we could construct it using the Lagrange polynomial interpolation.\nThe only remaining thing left to do is to integrate this polynomial.\nIf you do this for a general function $f$, you receive a remarkably simple expression:\n\n$$\\int_{x_ {2i-2}} ^ {x_ {2i}} f (x) ~dx \\approx \\int_{x_ {2i-2}} ^ {x_ {2i}} P (x) ~dx = \\left(f(x_{2i-2}) + 4f(x_{2i-1})+(f(x_{2i})\\right)\\frac {h} {3} $$\n\nAdding these values over all segments, we obtain the final **Simpson's formula**:\n\n$$\\int_a ^ b f (x) dx \\approx \\left(f (x_0) + 4 f (x_1) + 2 f (x_2) + 4f(x_3) + 2 f(x_4) + \\ldots + 4 f(x_{2N-1}) + f(x_{2N}) \\right)\\frac {h} {3} $$\n\n## Error\n\nThe error in approximating an integral by Simpson's formula is\n\n$$ -\\tfrac{1}{90} \\left(\\tfrac{b-a}{2}\\right)^5 f^{(4)}(\\xi)$$\n\nwhere $\\xi$ is some number between $a$ and $b$.\n\nThe error is asymptotically proportional to $(b-a)^5$. However, the above derivations suggest an error proportional to $(b-a)^4$. Simpson's rule gains an extra order because the points at which the integrand is evaluated are distributed symmetrically in the interval $[a, b]$.\n\n## Implementation\n\nHere, $f(x)$ is some user-defined function.\n\n```cpp\nconst int N = 1000 * 1000; // number of steps (already multiplied by 2)\n\ndouble simpson_integration(double a, double b){\n    double h = (b - a) / N;\n    double s = f(a) + f(b); // a = x_0 and b = x_2n\n    for (int i = 1; i <= N - 1; ++i) { // Refer to final Simpson's formula\n        double x = a + h * i;\n        s += f(x) * ((i & 1) ? 4 : 2);\n    }\n    s *= h / 3;\n    return s;\n}\n```\n\n", "full_article": "---\ntags:\n  - Translated\ne_maxx_link: simpson_integrating\n---\n\n# Integration by Simpson's formula\n\nWe are going to calculate the value of a definite integral\n\n$$\\int_a ^ b f (x) dx$$\n\nThe solution described here was published in one of the dissertations of **Thomas Simpson** in 1743.\n\n## Simpson's formula\n\nLet $n$ be some natural number. We divide the integration segment $[a, b]$ into $2n$ equal parts:\n\n$$x_i = a + i h, ~~ i = 0 \\ldots 2n,$$\n\n$$h = \\frac {b-a} {2n}.$$\n\nNow we calculate the integral separately on each of the segments $[x_ {2i-2}, x_ {2i}]$, $i = 1 \\ldots n$, and then add all the values.\n\nSo, suppose we consider the next segment $[x_ {2i-2}, x_ {2i}],  i = 1 \\ldots n$. Replace the function $f(x)$ on it with a parabola $P(x)$ passing through 3 points $(x_ {2i-2}, x_ {2i-1}, x_ {2i})$. Such a parabola always exists and is unique; it can be found analytically.\nFor instance we could construct it using the Lagrange polynomial interpolation.\nThe only remaining thing left to do is to integrate this polynomial.\nIf you do this for a general function $f$, you receive a remarkably simple expression:\n\n$$\\int_{x_ {2i-2}} ^ {x_ {2i}} f (x) ~dx \\approx \\int_{x_ {2i-2}} ^ {x_ {2i}} P (x) ~dx = \\left(f(x_{2i-2}) + 4f(x_{2i-1})+(f(x_{2i})\\right)\\frac {h} {3} $$\n\nAdding these values over all segments, we obtain the final **Simpson's formula**:\n\n$$\\int_a ^ b f (x) dx \\approx \\left(f (x_0) + 4 f (x_1) + 2 f (x_2) + 4f(x_3) + 2 f(x_4) + \\ldots + 4 f(x_{2N-1}) + f(x_{2N}) \\right)\\frac {h} {3} $$\n\n## Error\n\nThe error in approximating an integral by Simpson's formula is\n\n$$ -\\tfrac{1}{90} \\left(\\tfrac{b-a}{2}\\right)^5 f^{(4)}(\\xi)$$\n\nwhere $\\xi$ is some number between $a$ and $b$.\n\nThe error is asymptotically proportional to $(b-a)^5$. However, the above derivations suggest an error proportional to $(b-a)^4$. Simpson's rule gains an extra order because the points at which the integrand is evaluated are distributed symmetrically in the interval $[a, b]$.\n\n## Implementation\n\nHere, $f(x)$ is some user-defined function.\n\n```cpp\nconst int N = 1000 * 1000; // number of steps (already multiplied by 2)\n\ndouble simpson_integration(double a, double b){\n    double h = (b - a) / N;\n    double s = f(a) + f(b); // a = x_0 and b = x_2n\n    for (int i = 1; i <= N - 1; ++i) { // Refer to final Simpson's formula\n        double x = a + h * i;\n        s += f(x) * ((i & 1) ? 4 : 2);\n    }\n    s *= h / 3;\n    return s;\n}\n```\n\n## Practice Problems\n\n* [URI - Environment Protection](https://www.urionlinejudge.com.br/judge/en/problems/view/1297)\n", "problem_ids": [], "title": "Integration by Simpson's formula"}]