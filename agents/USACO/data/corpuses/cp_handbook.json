[{"section_name": "Programming languages", "section_content": "\\chapter{Introduction}\n\nCompetitive programming combines two topics:\n(1) the design of algorithms and (2) the implementation of algorithms.\n\nThe \\key{design of algorithms} consists of problem solving\nand mathematical thinking.\nSkills for analyzing problems and solving them\ncreatively are needed.\nAn algorithm for solving a problem\nhas to be both correct and efficient,\nand the core of the problem is often\nabout inventing an efficient algorithm.\n\nTheoretical knowledge of algorithms\nis important to competitive programmers.\nTypically, a solution to a problem is\na combination of well-known techniques and\nnew insights.\nThe techniques that appear in competitive programming\nalso form the basis for the scientific research\nof algorithms.\n\nThe \\key{implementation of algorithms} requires good\nprogramming skills.\nIn competitive programming, the solutions\nare graded by testing an implemented algorithm\nusing a set of test cases.\nThus, it is not enough that the idea of the\nalgorithm is correct, but the implementation also\nhas to be correct.\n\nA good coding style in contests is\nstraightforward and concise.\nPrograms should be written quickly,\nbecause there is not much time available.\nUnlike in traditional software engineering,\nthe programs are short (usually at most a few\nhundred lines of code), and they do not need to \nbe maintained after the contest.\n\n\\section{Programming languages}\n\n\\index{programming language}\n\nAt the moment, the most popular programming\nlanguages used in contests are C++, Python and Java.\nFor example, in Google Code Jam 2017,\namong the best 3,000 participants,\n79 \\% used C++,\n16 \\% used Python and\n8 \\% used Java \\cite{goo17}.\nSome participants also used several languages.\n\nMany people think that C++ is the best choice\nfor a competitive programmer,\nand C++ is nearly always available in\ncontest systems.\nThe benefits of using C++ are that\nit is a very efficient language and\nits standard library contains a \nlarge collection\nof data structures and algorithms.\n\nOn the other hand, it is good to\nmaster several languages and understand\ntheir strengths.\nFor example, if large integers are needed\nin the problem,\nPython can be a good choice, because it\ncontains built-in operations for\ncalculating with large integers.\nStill, most problems in programming contests\nare set so that\nusing a specific programming language\nis not an unfair advantage.\n\nAll example programs in this book are written in C++,\nand the standard library's\ndata structures and algorithms are often used.\nThe programs follow the C++11 standard,\nwhich can be used in most contests nowadays.\nIf you cannot program in C++ yet,\nnow is a good time to start learning.\n\n\\subsubsection{C++ code template}\n\nA typical C++ code template for competitive programming\nlooks like this:\n\n\\begin{lstlisting}\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    // solution comes here\n}\n\\end{lstlisting}\n\nThe \\texttt{\\#include} line at the beginning\nof the code is a feature of the \\texttt{g++} compiler\nthat allows us to include the entire standard library.\nThus, it is not needed to separately include\nlibraries such as \\texttt{iostream},\n\\texttt{vector} and \\texttt{algorithm},\nbut rather they are available automatically.\n\nThe \\texttt{using} line declares\nthat the classes and functions\nof the standard library can be used directly\nin the code.\nWithout the \\texttt{using} line we would have\nto write, for example, \\texttt{std::cout},\nbut now it suffices to write \\texttt{cout}.\n\nThe code can be compiled using the following command:\n\n\\begin{lstlisting}\ng++ -std=c++11 -O2 -Wall test.cpp -o test\n\\end{lstlisting}\n\nThis command produces a binary file \\texttt{test}\nfrom the source code \\texttt{test.cpp}.\nThe compiler follows the C++11 standard\n(\\texttt{-std=c++11}),\noptimizes the code (\\texttt{-O2})\nand shows warnings about possible errors (\\texttt{-Wall}).\n\n", "chapter_name": "Introduction", "chapter_path": "cphb/chapter01.tex"}, {"section_name": "Input and output", "section_content": "\\section{Input and output}\n\n\\index{input and output}\n\nIn most contests, standard streams are used for\nreading input and writing output.\nIn C++, the standard streams are\n\\texttt{cin} for input and \\texttt{cout} for output.\nIn addition, the C functions\n\\texttt{scanf} and \\texttt{printf} can be used.\n\nThe input for the program usually consists of\nnumbers and strings that are separated with\nspaces and newlines.\nThey can be read from the \\texttt{cin} stream\nas follows:\n\n\\begin{lstlisting}\nint a, b;\nstring x;\ncin >> a >> b >> x;\n\\end{lstlisting}\n\nThis kind of code always works,\nassuming that there is at least one space\nor newline between each element in the input.\nFor example, the above code can read\nboth of the following inputs:\n\\begin{lstlisting}\n123 456 monkey\n\\end{lstlisting}\n\\begin{lstlisting}\n123    456\nmonkey\n\\end{lstlisting}\nThe \\texttt{cout} stream is used for output\nas follows:\n\\begin{lstlisting}\nint a = 123, b = 456;\nstring x = \"monkey\";\ncout << a << \" \" << b << \" \" << x << \"\\n\";\n\\end{lstlisting}\n\nInput and output is sometimes\na bottleneck in the program.\nThe following lines at the beginning of the code\nmake input and output more efficient:\n\n\\begin{lstlisting}\nios::sync_with_stdio(0);\ncin.tie(0);\n\\end{lstlisting}\n\nNote that the newline \\texttt{\"\\textbackslash n\"}\nworks faster than \\texttt{endl},\nbecause \\texttt{endl} always causes\na flush operation.\n\nThe C functions \\texttt{scanf}\nand \\texttt{printf} are an alternative\nto the C++ standard streams.\nThey are usually a bit faster,\nbut they are also more difficult to use.\nThe following code reads two integers from the input:\n\\begin{lstlisting}\nint a, b;\nscanf(\"%d %d\", &a, &b);\n\\end{lstlisting}\nThe following code prints two integers:\n\\begin{lstlisting}\nint a = 123, b = 456;\nprintf(\"%d %d\\n\", a, b);\n\\end{lstlisting}\n\nSometimes the program should read a whole line\nfrom the input, possibly containing spaces.\nThis can be accomplished by using the\n\\texttt{getline} function:\n\n\\begin{lstlisting}\nstring s;\ngetline(cin, s);\n\\end{lstlisting}\n\nIf the amount of data is unknown, the following\nloop is useful:\n\\begin{lstlisting}\nwhile (cin >> x) {\n    // code\n}\n\\end{lstlisting}\nThis loop reads elements from the input\none after another, until there is no\nmore data available in the input.\n\nIn some contest systems, files are used for\ninput and output.\nAn easy solution for this is to write\nthe code as usual using standard streams,\nbut add the following lines to the beginning of the code:\n\\begin{lstlisting}\nfreopen(\"input.txt\", \"r\", stdin);\nfreopen(\"output.txt\", \"w\", stdout);\n\\end{lstlisting}\nAfter this, the program reads the input from the file\n''input.txt'' and writes the output to the file\n''output.txt''.\n\n", "chapter_name": "Introduction", "chapter_path": "cphb/chapter01.tex"}, {"section_name": "Working with numbers", "section_content": "\\section{Working with numbers}\n\n\\index{integer}\n\n\\subsubsection{Integers}\n\nThe most used integer type in competitive programming\nis \\texttt{int}, which is a 32-bit type with\na value range of $-2^{31} \\ldots 2^{31}-1$\nor about $-2 \\cdot 10^9 \\ldots 2 \\cdot 10^9$.\nIf the type \\texttt{int} is not enough,\nthe 64-bit type \\texttt{long long} can be used.\nIt has a value range of $-2^{63} \\ldots 2^{63}-1$\nor about $-9 \\cdot 10^{18} \\ldots 9 \\cdot 10^{18}$.\n\nThe following code defines a\n\\texttt{long long} variable:\n\\begin{lstlisting}\nlong long x = 123456789123456789LL;\n\\end{lstlisting}\nThe suffix \\texttt{LL} means that the\ntype of the number is \\texttt{long long}.\n\nA common mistake when using the type \\texttt{long long}\nis that the type \\texttt{int} is still used somewhere\nin the code.\nFor example, the following code contains\na subtle error:\n\n\\begin{lstlisting}\nint a = 123456789;\nlong long b = a*a;\ncout << b << \"\\n\"; // -1757895751\n\\end{lstlisting}\n\nEven though the variable \\texttt{b} is of type \\texttt{long long},\nboth numbers in the expression \\texttt{a*a}\nare of type \\texttt{int} and the result is\nalso of type \\texttt{int}.\nBecause of this, the variable \\texttt{b} will\ncontain a wrong result.\nThe problem can be solved by changing the type\nof \\texttt{a} to \\texttt{long long} or\nby changing the expression to \\texttt{(long long)a*a}.\n\nUsually contest problems are set so that the\ntype \\texttt{long long} is enough.\nStill, it is good to know that\nthe \\texttt{g++} compiler also provides\na 128-bit type \\texttt{\\_\\_int128\\_t}\nwith a value range of\n$-2^{127} \\ldots 2^{127}-1$ or about $-10^{38} \\ldots 10^{38}$.\nHowever, this type is not available in all contest systems.\n\n\\subsubsection{Modular arithmetic}\n\n\\index{remainder}\n\\index{modular arithmetic}\n\nWe denote by $x \\bmod m$ the remainder\nwhen $x$ is divided by $m$.\nFor example, $17 \\bmod 5 = 2$,\nbecause $17 = 3 \\cdot 5 + 2$.\n\nSometimes, the answer to a problem is a\nvery large number but it is enough to\noutput it ''modulo $m$'', i.e.,\nthe remainder when the answer is divided by $m$\n(for example, ''modulo $10^9+7$'').\nThe idea is that even if the actual answer\nis very large,\nit suffices to use the types\n\\texttt{int} and \\texttt{long long}.\n\nAn important property of the remainder is that\nin addition, subtraction and multiplication,\nthe remainder can be taken before the operation:\n\n\\[\n\\begin{array}{rcr}\n(a+b) \\bmod m & = & (a \\bmod m + b \\bmod m) \\bmod m \\\\\n(a-b) \\bmod m & = & (a \\bmod m - b \\bmod m) \\bmod m \\\\\n(a \\cdot b) \\bmod m & = & (a \\bmod m \\cdot b \\bmod m) \\bmod m\n\\end{array}\n\\]\n\nThus, we can take the remainder after every operation\nand the numbers will never become too large.\n\nFor example, the following code calculates $n!$,\nthe factorial of $n$, modulo $m$:\n\\begin{lstlisting}\nlong long x = 1;\nfor (int i = 2; i <= n; i++) {\n    x = (x*i)%m;\n}\ncout << x%m << \"\\n\";\n\\end{lstlisting}\n\nUsually we want the remainder to always\nbe between $0\\ldots m-1$.\nHowever, in C++ and other languages,\nthe remainder of a negative number\nis either zero or negative.\nAn easy way to make sure there\nare no negative remainders is to first calculate\nthe remainder as usual and then add $m$\nif the result is negative:\n\\begin{lstlisting}\nx = x%m;\nif (x < 0) x += m;\n\\end{lstlisting}\nHowever, this is only needed when there\nare subtractions in the code and the\nremainder may become negative.\n\n\\subsubsection{Floating point numbers}\n\n\\index{floating point number}\n\nThe usual floating point types in\ncompetitive programming are\nthe 64-bit \\texttt{double}\nand, as an extension in the \\texttt{g++} compiler,\nthe 80-bit \\texttt{long double}.\nIn most cases, \\texttt{double} is enough,\nbut \\texttt{long double} is more accurate.\n\nThe required precision of the answer\nis usually given in the problem statement.\nAn easy way to output the answer is to use\nthe \\texttt{printf} function\nand give the number of decimal places\nin the formatting string.\nFor example, the following code prints\nthe value of $x$ with 9 decimal places:\n\n\\begin{lstlisting}\nprintf(\"%.9f\\n\", x);\n\\end{lstlisting}\n\nA difficulty when using floating point numbers\nis that some numbers cannot be represented\naccurately as floating point numbers,\nand there will be rounding errors.\nFor example, the result of the following code\nis surprising:\n\n\\begin{lstlisting}\ndouble x = 0.3*3+0.1;\nprintf(\"%.20f\\n\", x); // 0.99999999999999988898\n\\end{lstlisting}\n\nDue to a rounding error,\nthe value of \\texttt{x} is a bit smaller than 1,\nwhile the correct value would be 1.\n\nIt is risky to compare floating point numbers\nwith the \\texttt{==} operator,\nbecause it is possible that the values should be\nequal but they are not because of precision errors.\nA better way to compare floating point numbers\nis to assume that two numbers are equal\nif the difference between them is less than $\\varepsilon$,\nwhere $\\varepsilon$ is a small number.\n\nIn practice, the numbers can be compared\nas follows ($\\varepsilon=10^{-9}$):\n\n\\begin{lstlisting}\nif (abs(a-b) < 1e-9) {\n    // a and b are equal\n}\n\\end{lstlisting}\n\nNote that while floating point numbers are inaccurate,\nintegers up to a certain limit can still be\nrepresented accurately.\nFor example, using \\texttt{double},\nit is possible to accurately represent all\nintegers whose absolute value is at most $2^{53}$.\n\n", "chapter_name": "Introduction", "chapter_path": "cphb/chapter01.tex"}, {"section_name": "Shortening code", "section_content": "\\section{Shortening code}\n\nShort code is ideal in competitive programming,\nbecause programs should be written\nas fast as possible.\nBecause of this, competitive programmers often define\nshorter names for datatypes and other parts of code.\n\n\\subsubsection{Type names}\n\\index{tuppdef@\\texttt{typedef}}\nUsing the command \\texttt{typedef}\nit is possible to give a shorter name\nto a datatype.\nFor example, the name \\texttt{long long} is long,\nso we can define a shorter name \\texttt{ll}:\n\\begin{lstlisting}\ntypedef long long ll;\n\\end{lstlisting}\nAfter this, the code\n\\begin{lstlisting}\nlong long a = 123456789;\nlong long b = 987654321;\ncout << a*b << \"\\n\";\n\\end{lstlisting}\ncan be shortened as follows:\n\\begin{lstlisting}\nll a = 123456789;\nll b = 987654321;\ncout << a*b << \"\\n\";\n\\end{lstlisting}\n\nThe command \\texttt{typedef}\ncan also be used with more complex types.\nFor example, the following code gives\nthe name \\texttt{vi} for a vector of integers\nand the name \\texttt{pi} for a pair\nthat contains two integers.\n\\begin{lstlisting}\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\\end{lstlisting}\n\n\\subsubsection{Macros}\n\\index{macro}\nAnother way to shorten code is to define\n\\key{macros}.\nA macro means that certain strings in\nthe code will be changed before the compilation.\nIn C++, macros are defined using the\n\\texttt{\\#define} keyword.\n\nFor example, we can define the following macros:\n\\begin{lstlisting}\n#define F first\n#define S second\n#define PB push_back\n#define MP make_pair\n\\end{lstlisting}\nAfter this, the code\n\\begin{lstlisting}\nv.push_back(make_pair(y1,x1));\nv.push_back(make_pair(y2,x2));\nint d = v[i].first+v[i].second;\n\\end{lstlisting}\ncan be shortened as follows:\n\\begin{lstlisting}\nv.PB(MP(y1,x1));\nv.PB(MP(y2,x2));\nint d = v[i].F+v[i].S;\n\\end{lstlisting}\n\nA macro can also have parameters\nwhich makes it possible to shorten loops and other\nstructures.\nFor example, we can define the following macro:\n\\begin{lstlisting}\n#define REP(i,a,b) for (int i = a; i <= b; i++)\n\\end{lstlisting}\nAfter this, the code\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i++) {\n    search(i);\n}\n\\end{lstlisting}\ncan be shortened as follows:\n\\begin{lstlisting}\nREP(i,1,n) {\n    search(i);\n}\n\\end{lstlisting}\n\nSometimes macros cause bugs that may be difficult\nto detect. For example, consider the following macro\nthat calculates the square of a number:\n\\begin{lstlisting}\n#define SQ(a) a*a\n\\end{lstlisting}\nThis macro \\emph{does not} always work as expected.\nFor example, the code\n\\begin{lstlisting}\ncout << SQ(3+3) << \"\\n\";\n\\end{lstlisting}\ncorresponds to the code\n\\begin{lstlisting}\ncout << 3+3*3+3 << \"\\n\"; // 15\n\\end{lstlisting}\n\nA better version of the macro is as follows:\n\\begin{lstlisting}\n#define SQ(a) (a)*(a)\n\\end{lstlisting}\nNow the code\n\\begin{lstlisting}\ncout << SQ(3+3) << \"\\n\";\n\\end{lstlisting}\ncorresponds to the code\n\\begin{lstlisting}\ncout << (3+3)*(3+3) << \"\\n\"; // 36\n\\end{lstlisting}\n\n\n", "chapter_name": "Introduction", "chapter_path": "cphb/chapter01.tex"}, {"section_name": "Mathematics", "section_content": "\\section{Mathematics}\n\nMathematics plays an important role in competitive\nprogramming, and it is not possible to become\na successful competitive programmer without\nhaving good mathematical skills.\nThis section discusses some important\nmathematical concepts and formulas that\nare needed later in the book.\n\n\\subsubsection{Sum formulas}\n\nEach sum of the form\n\\[\\sum_{x=1}^n x^k = 1^k+2^k+3^k+\\ldots+n^k,\\]\nwhere $k$ is a positive integer,\nhas a closed-form formula that is a\npolynomial of degree $k+1$.\nFor example\\footnote{\\index{Faulhaber's formula}\nThere is even a general formula for such sums, called \\key{Faulhaber's formula},\nbut it is too complex to be presented here.},\n\\[\\sum_{x=1}^n x = 1+2+3+\\ldots+n = \\frac{n(n+1)}{2}\\]\nand\n\\[\\sum_{x=1}^n x^2 = 1^2+2^2+3^2+\\ldots+n^2 = \\frac{n(n+1)(2n+1)}{6}.\\]\n\nAn \\key{arithmetic progression} is a \\index{arithmetic progression}\nsequence of numbers\nwhere the difference between any two consecutive\nnumbers is constant.\nFor example,\n\\[3, 7, 11, 15\\]\nis an arithmetic progression with constant 4.\nThe sum of an arithmetic progression can be calculated\nusing the formula\n\\[\\underbrace{a + \\cdots + b}_{n \\,\\, \\textrm{numbers}} = \\frac{n(a+b)}{2}\\]\nwhere $a$ is the first number,\n$b$ is the last number and\n$n$ is the amount of numbers.\nFor example,\n\\[3+7+11+15=\\frac{4 \\cdot (3+15)}{2} = 36.\\]\nThe formula is based on the fact\nthat the sum consists of $n$ numbers and\nthe value of each number is $(a+b)/2$ on average.\n\n\\index{geometric progression}\nA \\key{geometric progression} is a sequence\nof numbers\nwhere the ratio between any two consecutive\nnumbers is constant.\nFor example,\n\\[3,6,12,24\\]\nis a geometric progression with constant 2.\nThe sum of a geometric progression can be calculated\nusing the formula\n\\[a + ak + ak^2 + \\cdots + b = \\frac{bk-a}{k-1}\\]\nwhere $a$ is the first number,\n$b$ is the last number and the\nratio between consecutive numbers is $k$.\nFor example,\n\\[3+6+12+24=\\frac{24 \\cdot 2 - 3}{2-1} = 45.\\]\n\nThis formula can be derived as follows. Let\n\\[ S = a + ak + ak^2 + \\cdots + b .\\]\nBy multiplying both sides by $k$, we get\n\\[ kS = ak + ak^2 + ak^3 + \\cdots + bk,\\]\nand solving the equation\n\\[ kS-S = bk-a\\]\nyields the formula.\n\nA special case of a sum of a geometric progression is the formula\n\\[1+2+4+8+\\ldots+2^{n-1}=2^n-1.\\]\n\n\\index{harmonic sum}\n\nA \\key{harmonic sum} is a sum of the form\n\\[ \\sum_{x=1}^n \\frac{1}{x} = 1+\\frac{1}{2}+\\frac{1}{3}+\\ldots+\\frac{1}{n}.\\]\n\nAn upper bound for a harmonic sum is $\\log_2(n)+1$.\nNamely, we can\nmodify each term $1/k$ so that $k$ becomes\nthe nearest power of two that does not exceed $k$.\nFor example, when $n=6$, we can estimate\nthe sum as follows:\n\\[ 1+\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}+\\frac{1}{6} \\le\n1+\\frac{1}{2}+\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{4}+\\frac{1}{4}.\\]\nThis upper bound consists of $\\log_2(n)+1$ parts\n($1$, $2 \\cdot 1/2$, $4 \\cdot 1/4$, etc.),\nand the value of each part is at most 1.\n\n\\subsubsection{Set theory}\n\n\\index{set theory}\n\\index{set}\n\\index{intersection}\n\\index{union}\n\\index{difference}\n\\index{subset}\n\\index{universal set}\n\\index{complement}\n\nA \\key{set} is a collection of elements.\nFor example, the set\n\\[X=\\{2,4,7\\}\\]\ncontains elements 2, 4 and 7.\nThe symbol $\\emptyset$ denotes an empty set,\nand $|S|$ denotes the size of a set $S$,\ni.e., the number of elements in the set.\nFor example, in the above set, $|X|=3$.\n\nIf a set $S$ contains an element $x$,\nwe write $x \\in S$,\nand otherwise we write $x \\notin S$.\nFor example, in the above set\n\\[4 \\in X \\hspace{10px}\\textrm{and}\\hspace{10px} 5 \\notin X.\\]\n\n\\begin{samepage}\nNew sets can be constructed using set operations:\n\\begin{itemize}\n\\item The \\key{intersection} $A \\cap B$ consists of elements\nthat are in both $A$ and $B$.\nFor example, if $A=\\{1,2,5\\}$ and $B=\\{2,4\\}$,\nthen $A \\cap B = \\{2\\}$.\n\\item The \\key{union} $A \\cup B$ consists of elements\nthat are in $A$ or $B$ or both.\nFor example, if $A=\\{3,7\\}$ and $B=\\{2,3,8\\}$,\nthen $A \\cup B = \\{2,3,7,8\\}$.\n\\item The \\key{complement} $\\bar A$ consists of elements\nthat are not in $A$.\nThe interpretation of a complement depends on\nthe \\key{universal set}, which contains all possible elements.\nFor example, if $A=\\{1,2,5,7\\}$ and the universal set is\n$\\{1,2,\\ldots,10\\}$, then $\\bar A = \\{3,4,6,8,9,10\\}$.\n\\item The \\key{difference} $A \\setminus B = A \\cap \\bar B$\nconsists of elements that are in $A$ but not in $B$.\nNote that $B$ can contain elements that are not in $A$.\nFor example, if $A=\\{2,3,7,8\\}$ and $B=\\{3,5,8\\}$,\nthen $A \\setminus B = \\{2,7\\}$.\n\\end{itemize}\n\\end{samepage}\n\nIf each element of $A$ also belongs to $S$,\nwe say that $A$ is a \\key{subset} of $S$,\ndenoted by $A \\subset S$.\nA set $S$ always has $2^{|S|}$ subsets,\nincluding the empty set.\nFor example, the subsets of the set $\\{2,4,7\\}$ are\n\\begin{center}\n$\\emptyset$,\n$\\{2\\}$, $\\{4\\}$, $\\{7\\}$, $\\{2,4\\}$, $\\{2,7\\}$, $\\{4,7\\}$ and $\\{2,4,7\\}$.\n\\end{center}\n\nSome often used sets are\n$\\mathbb{N}$ (natural numbers),\n$\\mathbb{Z}$ (integers),\n$\\mathbb{Q}$ (rational numbers) and\n$\\mathbb{R}$ (real numbers).\nThe set $\\mathbb{N}$\ncan be defined in two ways, depending\non the situation:\neither $\\mathbb{N}=\\{0,1,2,\\ldots\\}$\nor $\\mathbb{N}=\\{1,2,3,...\\}$.\n\nWe can also construct a set using a rule of the form\n\\[\\{f(n) : n \\in S\\},\\]\nwhere $f(n)$ is some function.\nThis set contains all elements of the form $f(n)$,\nwhere $n$ is an element in $S$.\nFor example, the set\n\\[X=\\{2n : n \\in \\mathbb{Z}\\}\\]\ncontains all even integers.\n\n\\subsubsection{Logic}\n\n\\index{logic}\n\\index{negation}\n\\index{conjuction}\n\\index{disjunction}\n\\index{implication}\n\\index{equivalence}\n\nThe value of a logical expression is either\n\\key{true} (1) or \\key{false} (0).\nThe most important logical operators are\n$\\lnot$ (\\key{negation}),\n$\\land$ (\\key{conjunction}),\n$\\lor$ (\\key{disjunction}),\n$\\Rightarrow$ (\\key{implication}) and\n$\\Leftrightarrow$ (\\key{equivalence}).\nThe following table shows the meanings of these operators:\n\n\\begin{center}\n\\begin{tabular}{rr|rrrrrrr}\n$A$ & $B$ & $\\lnot A$ & $\\lnot B$ & $A \\land B$ & $A \\lor B$ & $A \\Rightarrow B$ & $A \\Leftrightarrow B$ \\\\\n\\hline\n0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\\n0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 \\\\\n1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\\\\n\\end{tabular}\n\\end{center}\n\nThe expression $\\lnot A$ has the opposite value of $A$.\nThe expression $A \\land B$ is true if both $A$ and $B$\nare true,\nand the expression $A \\lor B$ is true if $A$ or $B$ or both\nare true.\nThe expression $A \\Rightarrow B$ is true\nif whenever $A$ is true, also $B$ is true.\nThe expression $A \\Leftrightarrow B$ is true\nif $A$ and $B$ are both true or both false.\n\n\\index{predicate}\n\nA \\key{predicate} is an expression that is true or false\ndepending on its parameters.\nPredicates are usually denoted by capital letters.\nFor example, we can define a predicate $P(x)$\nthat is true exactly when $x$ is a prime number.\nUsing this definition, $P(7)$ is true but $P(8)$ is false.\n\n\\index{quantifier}\n\nA \\key{quantifier} connects a logical expression\nto the elements of a set.\nThe most important quantifiers are\n$\\forall$ (\\key{for all}) and $\\exists$ (\\key{there is}).\nFor example,\n\\[\\forall x (\\exists y (y < x))\\]\nmeans that for each element $x$ in the set,\nthere is an element $y$ in the set\nsuch that $y$ is smaller than $x$.\nThis is true in the set of integers,\nbut false in the set of natural numbers.\n\nUsing the notation described above,\nwe can express many kinds of logical propositions.\nFor example,\n\\[\\forall x ((x>1 \\land \\lnot P(x)) \\Rightarrow (\\exists a (\\exists b (a > 1 \\land b > 1 \\land x = ab))))\\]\nmeans that if a number $x$ is larger than 1\nand not a prime number,\nthen there are numbers $a$ and $b$\nthat are larger than $1$ and whose product is $x$.\nThis proposition is true in the set of integers.\n\n\\subsubsection{Functions}\n\nThe function $\\lfloor x \\rfloor$ rounds the number $x$\ndown to an integer, and the function\n$\\lceil x \\rceil$ rounds the number $x$\nup to an integer. For example,\n\\[ \\lfloor 3/2 \\rfloor = 1 \\hspace{10px} \\textrm{and} \\hspace{10px} \\lceil 3/2 \\rceil = 2.\\]\n\nThe functions $\\min(x_1,x_2,\\ldots,x_n)$\nand $\\max(x_1,x_2,\\ldots,x_n)$\ngive the smallest and largest of values\n$x_1,x_2,\\ldots,x_n$.\nFor example,\n\\[ \\min(1,2,3)=1 \\hspace{10px} \\textrm{and} \\hspace{10px} \\max(1,2,3)=3.\\]\n\n\\index{factorial}\n\nThe \\key{factorial} $n!$ can be defined\n\\[\\prod_{x=1}^n x = 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot n\\]\nor recursively\n\\[\n\\begin{array}{lcl}\n0! & = & 1 \\\\\nn! & = & n \\cdot (n-1)! \\\\\n\\end{array}\n\\]\n\n\\index{Fibonacci number}\n\nThe \\key{Fibonacci numbers}\n%\\footnote{Fibonacci (c. 1175--1250) was an Italian mathematician.}\narise in many situations.\nThey can be defined recursively as follows:\n\\[\n\\begin{array}{lcl}\nf(0) & = & 0 \\\\\nf(1) & = & 1 \\\\\nf(n) & = & f(n-1)+f(n-2) \\\\\n\\end{array}\n\\]\nThe first Fibonacci numbers are\n\\[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \\ldots\\]\nThere is also a closed-form formula\nfor calculating Fibonacci numbers, which is sometimes called\n\\index{Binet's formula} \\key{Binet's formula}:\n\\[f(n)=\\frac{(1 + \\sqrt{5})^n - (1-\\sqrt{5})^n}{2^n \\sqrt{5}}.\\]\n\n\\subsubsection{Logarithms}\n\n\\index{logarithm}\n\nThe \\key{logarithm} of a number $x$\nis denoted $\\log_k(x)$, where $k$ is the base\nof the logarithm.\nAccording to the definition,\n$\\log_k(x)=a$ exactly when $k^a=x$.\n\nA useful property of logarithms is\nthat $\\log_k(x)$ equals the number of times\nwe have to divide $x$ by $k$ before we reach \nthe number 1.\nFor example, $\\log_2(32)=5$\nbecause 5 divisions by 2 are needed:\n\n\\[32 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1 \\]\n\nLogarithms are often used in the analysis of\nalgorithms, because many efficient algorithms\nhalve something at each step.\nHence, we can estimate the efficiency of such algorithms\nusing logarithms.\n\nThe logarithm of a product is\n\\[\\log_k(ab) = \\log_k(a)+\\log_k(b),\\]\nand consequently,\n\\[\\log_k(x^n) = n \\cdot \\log_k(x).\\]\nIn addition, the logarithm of a quotient is\n\\[\\log_k\\Big(\\frac{a}{b}\\Big) = \\log_k(a)-\\log_k(b).\\]\nAnother useful formula is\n\\[\\log_u(x) = \\frac{\\log_k(x)}{\\log_k(u)},\\]\nand using this, it is possible to calculate\nlogarithms to any base if there is a way to\ncalculate logarithms to some fixed base.\n\n\\index{natural logarithm}\n\nThe \\key{natural logarithm} $\\ln(x)$ of a number $x$\nis a logarithm whose base is $e \\approx 2.71828$.\nAnother property of logarithms is that\nthe number of digits of an integer $x$ in base $b$ is\n$\\lfloor \\log_b(x)+1 \\rfloor$.\nFor example, the representation of\n$123$ in base $2$ is 1111011 and\n$\\lfloor \\log_2(123)+1 \\rfloor = 7$.\n\n", "chapter_name": "Introduction", "chapter_path": "cphb/chapter01.tex"}, {"section_name": "Contests and resources", "section_content": "\\section{Contests and resources}\n\n\\subsubsection{IOI}\n\nThe International Olympiad in Informatics (IOI)\nis an annual programming contest for\nsecondary school students.\nEach country is allowed to send a team of\nfour students to the contest.\nThere are usually about 300 participants\nfrom 80 countries.\n\nThe IOI consists of two five-hour long contests.\nIn both contests, the participants are asked to\nsolve three algorithm tasks of various difficulty.\nThe tasks are divided into subtasks,\neach of which has an assigned score.\nEven if the contestants are divided into teams,\nthey compete as individuals.\n\nThe IOI syllabus \\cite{iois} regulates the topics\nthat may appear in IOI tasks.\nAlmost all the topics in the IOI syllabus\nare covered by this book.\n\nParticipants for the IOI are selected through\nnational contests.\nBefore the IOI, many regional contests are organized,\nsuch as the Baltic Olympiad in Informatics (BOI),\nthe Central European Olympiad in Informatics (CEOI)\nand the Asia-Pacific Informatics Olympiad (APIO).\n\nSome countries organize online practice contests\nfor future IOI participants,\nsuch as the Croatian Open Competition in Informatics \\cite{coci}\nand the USA Computing Olympiad \\cite{usaco}.\nIn addition, a large collection of problems from Polish contests\nis available online \\cite{main}.\n\n\\subsubsection{ICPC}\n\nThe International Collegiate Programming Contest (ICPC)\nis an annual programming contest for university students.\nEach team in the contest consists of three students,\nand unlike in the IOI, the students work together;\nthere is only one computer available for each team.\n\nThe ICPC consists of several stages, and finally the\nbest teams are invited to the World Finals.\nWhile there are tens of thousands of participants\nin the contest, there are only a small number\\footnote{The exact number of final\nslots varies from year to year; in 2017, there were 133 final slots.} of final slots available,\nso even advancing to the finals\nis a great achievement in some regions.\n\nIn each ICPC contest, the teams have five hours of time to\nsolve about ten algorithm problems.\nA solution to a problem is accepted only if it solves\nall test cases efficiently.\nDuring the contest, competitors may view the results of other teams,\nbut for the last hour the scoreboard is frozen and it\nis not possible to see the results of the last submissions.\n\nThe topics that may appear at the ICPC are not so well\nspecified as those at the IOI.\nIn any case, it is clear that more knowledge is needed\nat the ICPC, especially more mathematical skills.\n\n\\subsubsection{Online contests}\n\nThere are also many online contests that are open for everybody.\nAt the moment, the most active contest site is Codeforces,\nwhich organizes contests about weekly.\nIn Codeforces, participants are divided into two divisions:\nbeginners compete in Div2 and more experienced programmers in Div1.\nOther contest sites include AtCoder, CS Academy, HackerRank and Topcoder.\n\nSome companies organize online contests with onsite finals.\nExamples of such contests are Facebook Hacker Cup,\nGoogle Code Jam and Yandex.Algorithm.\nOf course, companies also use those contests for recruiting:\nperforming well in a contest is a good way to prove one's skills.\n\n\\subsubsection{Books}\n\nThere are already some books (besides this book) that\nfocus on competitive programming and algorithmic problem solving:\n\n\\begin{itemize}\n\\item S. S. Skiena and M. A. Revilla:\n\\emph{Programming Challenges: The Programming Contest Training Manual} \\cite{ski03}\n\\item S. Halim and F. Halim:\n\\emph{Competitive Programming 3: The New Lower Bound of Programming Contests} \\cite{hal13}\n\\item K. Diks et al.: \\emph{Looking for a Challenge? The Ultimate Problem Set from\nthe University of Warsaw Programming Competitions} \\cite{dik12}\n\\end{itemize}\n\nThe first two books are intended for beginners,\nwhereas the last book contains advanced material.\n\nOf course, general algorithm books are also suitable for\ncompetitive programmers.\nSome popular books are:\n\n\\begin{itemize}\n\\item T. H. Cormen, C. E. Leiserson, R. L. Rivest and C. Stein:\n\\emph{Introduction to Algorithms} \\cite{cor09}\n\\item J. Kleinberg and \u00c9. Tardos:\n\\emph{Algorithm Design} \\cite{kle05}\n\\item S. S. Skiena:\n\\emph{The Algorithm Design Manual} \\cite{ski08}\n\\end{itemize}\n", "chapter_name": "Introduction", "chapter_path": "cphb/chapter01.tex"}, {"section_name": "Calculation rules", "section_content": "\\chapter{Time complexity}\n\n\\index{time complexity}\n\nThe efficiency of algorithms is important in competitive programming.\nUsually, it is easy to design an algorithm\nthat solves the problem slowly,\nbut the real challenge is to invent a\nfast algorithm.\nIf the algorithm is too slow, it will get only\npartial points or no points at all.\n\nThe \\key{time complexity} of an algorithm\nestimates how much time the algorithm will use\nfor some input.\nThe idea is to represent the efficiency\nas a function whose parameter is the size of the input.\nBy calculating the time complexity,\nwe can find out whether the algorithm is fast enough\nwithout implementing it.\n\n\\section{Calculation rules}\n\nThe time complexity of an algorithm\nis denoted $O(\\cdots)$\nwhere the three dots represent some\nfunction.\nUsually, the variable $n$ denotes\nthe input size.\nFor example, if the input is an array of numbers,\n$n$ will be the size of the array,\nand if the input is a string,\n$n$ will be the length of the string.\n\n\\subsubsection*{Loops}\n\nA common reason why an algorithm is slow is\nthat it contains many loops that go through the input.\nThe more nested loops the algorithm contains,\nthe slower it is.\nIf there are $k$ nested loops,\nthe time complexity is $O(n^k)$.\n\nFor example, the time complexity of the following code is $O(n)$:\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i++) {\n    // code\n}\n\\end{lstlisting}\n\nAnd the time complexity of the following code is $O(n^2)$:\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n        // code\n    }\n}\n\\end{lstlisting}\n\n\\subsubsection*{Order of magnitude}\n\nA time complexity does not tell us the exact number\nof times the code inside a loop is executed,\nbut it only shows the order of magnitude.\nIn the following examples, the code inside the loop\nis executed $3n$, $n+5$ and $\\lceil n/2 \\rceil$ times,\nbut the time complexity of each code is $O(n)$.\n\n\\begin{lstlisting}\nfor (int i = 1; i <= 3*n; i++) {\n    // code\n}\n\\end{lstlisting}\n\n\\begin{lstlisting}\nfor (int i = 1; i <= n+5; i++) {\n    // code\n}\n\\end{lstlisting}\n\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i += 2) {\n    // code\n}\n\\end{lstlisting}\n\nAs another example,\nthe time complexity of the following code is $O(n^2)$:\n\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i++) {\n    for (int j = i+1; j <= n; j++) {\n        // code\n    }\n}\n\\end{lstlisting}\n\n\\subsubsection*{Phases}\n\nIf the algorithm consists of consecutive phases,\nthe total time complexity is the largest\ntime complexity of a single phase.\nThe reason for this is that the slowest\nphase is usually the bottleneck of the code.\n\nFor example, the following code consists\nof three phases with time complexities\n$O(n)$, $O(n^2)$ and $O(n)$.\nThus, the total time complexity is $O(n^2)$.\n\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i++) {\n    // code\n}\nfor (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n        // code\n    }\n}\nfor (int i = 1; i <= n; i++) {\n    // code\n}\n\\end{lstlisting}\n\n\\subsubsection*{Several variables}\n\nSometimes the time complexity depends on\nseveral factors.\nIn this case, the time complexity formula\ncontains several variables.\n\nFor example, the time complexity of the\nfollowing code is $O(nm)$:\n\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n        // code\n    }\n}\n\\end{lstlisting}\n\n\\subsubsection*{Recursion}\n\nThe time complexity of a recursive function\ndepends on the number of times the function is called\nand the time complexity of a single call.\nThe total time complexity is the product of\nthese values.\n\nFor example, consider the following function:\n\\begin{lstlisting}\nvoid f(int n) {\n    if (n == 1) return;\n    f(n-1);\n}\n\\end{lstlisting}\nThe call $\\texttt{f}(n)$ causes $n$ function calls,\nand the time complexity of each call is $O(1)$.\nThus, the total time complexity is $O(n)$.\n\nAs another example, consider the following function:\n\\begin{lstlisting}\nvoid g(int n) {\n    if (n == 1) return;\n    g(n-1);\n    g(n-1);\n}\n\\end{lstlisting}\nIn this case each function call generates two other\ncalls, except for $n=1$.\nLet us see what happens when $g$ is called\nwith parameter $n$.\nThe following table shows the function calls\nproduced by this single call:\n\\begin{center}\n\\begin{tabular}{rr}\nfunction call & number of calls \\\\\n\\hline\n$g(n)$ & 1 \\\\\n$g(n-1)$ & 2 \\\\\n$g(n-2)$ & 4 \\\\\n$\\cdots$ & $\\cdots$ \\\\\n$g(1)$ & $2^{n-1}$ \\\\\n\\end{tabular}\n\\end{center}\nBased on this, the time complexity is\n\\[1+2+4+\\cdots+2^{n-1} = 2^n-1 = O(2^n).\\]\n\n", "chapter_name": "Time complexity", "chapter_path": "cphb/chapter02.tex"}, {"section_name": "Complexity classes", "section_content": "\\section{Complexity classes}\n\n\\index{complexity classes}\n\nThe following list contains common time complexities\nof algorithms:\n\n\\begin{description}\n\\item[$O(1)$]\n\\index{constant-time algorithm}\nThe running time of a \\key{constant-time} algorithm\ndoes not depend on the input size.\nA typical constant-time algorithm is a direct\nformula that calculates the answer.\n\n\\item[$O(\\log n)$]\n\\index{logarithmic algorithm}\nA \\key{logarithmic} algorithm often halves\nthe input size at each step.\nThe running time of such an algorithm\nis logarithmic, because\n$\\log_2 n$ equals the number of times\n$n$ must be divided by 2 to get 1.\n\n\\item[$O(\\sqrt n)$]\nA \\key{square root algorithm} is slower than\n$O(\\log n)$ but faster than $O(n)$.\nA special property of square roots is that\n$\\sqrt n = n/\\sqrt n$, so the square root $\\sqrt n$ lies,\nin some sense, in the middle of the input.\n\n\\item[$O(n)$]\n\\index{linear algorithm}\nA \\key{linear} algorithm goes through the input\na constant number of times.\nThis is often the best possible time complexity,\nbecause it is usually necessary to access each\ninput element at least once before\nreporting the answer.\n\n\\item[$O(n \\log n)$]\nThis time complexity often indicates that the\nalgorithm sorts the input,\nbecause the time complexity of efficient\nsorting algorithms is $O(n \\log n)$.\nAnother possibility is that the algorithm\nuses a data structure where each operation\ntakes $O(\\log n)$ time.\n\n\\item[$O(n^2)$]\n\\index{quadratic algorithm}\nA \\key{quadratic} algorithm often contains\ntwo nested loops.\nIt is possible to go through all pairs of\nthe input elements in $O(n^2)$ time.\n\n\\item[$O(n^3)$]\n\\index{cubic algorithm}\nA \\key{cubic} algorithm often contains\nthree nested loops.\nIt is possible to go through all triplets of\nthe input elements in $O(n^3)$ time.\n\n\\item[$O(2^n)$]\nThis time complexity often indicates that\nthe algorithm iterates through all\nsubsets of the input elements.\nFor example, the subsets of $\\{1,2,3\\}$ are\n$\\emptyset$, $\\{1\\}$, $\\{2\\}$, $\\{3\\}$, $\\{1,2\\}$,\n$\\{1,3\\}$, $\\{2,3\\}$ and $\\{1,2,3\\}$.\n\n\\item[$O(n!)$]\nThis time complexity often indicates that\nthe algorithm iterates through all\npermutations of the input elements.\nFor example, the permutations of $\\{1,2,3\\}$ are\n$(1,2,3)$, $(1,3,2)$, $(2,1,3)$, $(2,3,1)$,\n$(3,1,2)$ and $(3,2,1)$.\n\n\\end{description}\n\n\\index{polynomial algorithm}\nAn algorithm is \\key{polynomial}\nif its time complexity is at most $O(n^k)$\nwhere $k$ is a constant.\nAll the above time complexities except\n$O(2^n)$ and $O(n!)$ are polynomial.\nIn practice, the constant $k$ is usually small,\nand therefore a polynomial time complexity\nroughly means that the algorithm is \\emph{efficient}.\n\n\\index{NP-hard problem}\n\nMost algorithms in this book are polynomial.\nStill, there are many important problems for which\nno polynomial algorithm is known, i.e.,\nnobody knows how to solve them efficiently.\n\\key{NP-hard} problems are an important set\nof problems, for which no polynomial algorithm\nis known\\footnote{A classic book on the topic is\nM. R. Garey's and D. S. Johnson's\n\\emph{Computers and Intractability: A Guide to the Theory\nof NP-Completeness} \\cite{gar79}.}.\n\n", "chapter_name": "Time complexity", "chapter_path": "cphb/chapter02.tex"}, {"section_name": "Estimating efficiency", "section_content": "\\section{Estimating efficiency}\n\nBy calculating the time complexity of an algorithm,\nit is possible to check, before\nimplementing the algorithm, that it is\nefficient enough for the problem.\nThe starting point for estimations is the fact that\na modern computer can perform some hundreds of\nmillions of operations in a second.\n\nFor example, assume that the time limit for\na problem is one second and the input size is $n=10^5$.\nIf the time complexity is $O(n^2)$,\nthe algorithm will perform about $(10^5)^2=10^{10}$ operations.\nThis should take at least some tens of seconds,\nso the algorithm seems to be too slow for solving the problem.\n\nOn the other hand, given the input size,\nwe can try to \\emph{guess}\nthe required time complexity of the algorithm\nthat solves the problem.\nThe following table contains some useful estimates\nassuming a time limit of one second.\n\n\\begin{center}\n\\begin{tabular}{ll}\ninput size & required time complexity \\\\\n\\hline\n$n \\le 10$ & $O(n!)$ \\\\\n$n \\le 20$ & $O(2^n)$ \\\\\n$n \\le 500$ & $O(n^3)$ \\\\\n$n \\le 5000$ & $O(n^2)$ \\\\\n$n \\le 10^6$ & $O(n \\log n)$ or $O(n)$ \\\\\n$n$ is large & $O(1)$ or $O(\\log n)$ \\\\\n\\end{tabular}\n\\end{center}\n\nFor example, if the input size is $n=10^5$,\nit is probably expected that the time\ncomplexity of the algorithm is $O(n)$ or $O(n \\log n)$.\nThis information makes it easier to design the algorithm,\nbecause it rules out approaches that would yield\nan algorithm with a worse time complexity.\n\n\\index{constant factor}\n\nStill, it is important to remember that a\ntime complexity is only an estimate of efficiency,\nbecause it hides the \\emph{constant factors}.\nFor example, an algorithm that runs in $O(n)$ time\nmay perform $n/2$ or $5n$ operations.\nThis has an important effect on the actual\nrunning time of the algorithm.\n\n", "chapter_name": "Time complexity", "chapter_path": "cphb/chapter02.tex"}, {"section_name": "Maximum subarray sum", "section_content": "\\section{Maximum subarray sum}\n\n\\index{maximum subarray sum}\n\nThere are often several possible algorithms\nfor solving a problem such that their\ntime complexities are different.\nThis section discusses a classic problem that\nhas a straightforward $O(n^3)$ solution.\nHowever, by designing a better algorithm, it\nis possible to solve the problem in $O(n^2)$\ntime and even in $O(n)$ time.\n\nGiven an array of $n$ numbers,\nour task is to calculate the\n\\key{maximum subarray sum}, i.e.,\nthe largest possible sum of \na sequence of consecutive values\nin the array\\footnote{J. Bentley's\nbook \\emph{Programming Pearls} \\cite{ben86} made the problem popular.}.\nThe problem is interesting when there may be\nnegative values in the array.\nFor example, in the array\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$-1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$-3$};\n\\node at (4.5,0.5) {$5$};\n\\node at (5.5,0.5) {$2$};\n\\node at (6.5,0.5) {$-5$};\n\\node at (7.5,0.5) {$2$};\n\\end{tikzpicture}\n\\end{center}\n\\begin{samepage}\nthe following subarray produces the maximum sum $10$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (1,0) rectangle (6,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$-1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$-3$};\n\\node at (4.5,0.5) {$5$};\n\\node at (5.5,0.5) {$2$};\n\\node at (6.5,0.5) {$-5$};\n\\node at (7.5,0.5) {$2$};\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\nWe assume that an empty subarray is allowed,\nso the maximum subarray sum is always at least $0$.\n\n\\subsubsection{Algorithm 1}\n\nA straightforward way to solve the problem\nis to go through all possible subarrays,\ncalculate the sum of values in each subarray and maintain\nthe maximum sum.\nThe following code implements this algorithm:\n\n\\begin{lstlisting}\nint best = 0;\nfor (int a = 0; a < n; a++) {\n    for (int b = a; b < n; b++) {\n        int sum = 0;\n        for (int k = a; k <= b; k++) {\n            sum += array[k];\n        }\n        best = max(best,sum);\n    }\n}\ncout << best << \"\\n\";\n\\end{lstlisting}\n\nThe variables \\texttt{a} and \\texttt{b} fix the first and\nlast index of the subarray,\nand the sum of values is calculated to the variable \\texttt{sum}.\nThe variable \\texttt{best} contains the maximum sum found during the search.\n\nThe time complexity of the algorithm is $O(n^3)$,\nbecause it consists of three nested loops \nthat go through the input.\n\n\\subsubsection{Algorithm 2}\n\nIt is easy to make Algorithm 1 more efficient\nby removing one loop from it.\nThis is possible by calculating the sum at the same\ntime when the right end of the subarray moves.\nThe result is the following code:\n\n\\begin{lstlisting}\nint best = 0;\nfor (int a = 0; a < n; a++) {\n    int sum = 0;\n    for (int b = a; b < n; b++) {\n        sum += array[b];\n        best = max(best,sum);\n    }\n}\ncout << best << \"\\n\";\n\\end{lstlisting}\nAfter this change, the time complexity is $O(n^2)$.\n\n\\subsubsection{Algorithm 3}\n\nSurprisingly, it is possible to solve the problem\nin $O(n)$ time\\footnote{In \\cite{ben86}, this linear-time algorithm\nis attributed to J. B. Kadane, and the algorithm is sometimes\ncalled \\index{Kadane's algorithm} \\key{Kadane's algorithm}.}, which means\nthat just one loop is enough.\nThe idea is to calculate, for each array position,\nthe maximum sum of a subarray that ends at that position.\nAfter this, the answer for the problem is the\nmaximum of those sums.\n\nConsider the subproblem of finding the maximum-sum subarray\nthat ends at position $k$.\nThere are two possibilities:\n\\begin{enumerate}\n\\item The subarray only contains the element at position $k$.\n\\item The subarray consists of a subarray that ends\nat position $k-1$, followed by the element at position $k$.\n\\end{enumerate}\n\nIn the latter case, since we want to\nfind a subarray with maximum sum,\nthe subarray that ends at position $k-1$\nshould also have the maximum sum.\nThus, we can solve the problem efficiently\nby calculating the maximum subarray sum\nfor each ending position from left to right.\n\nThe following code implements the algorithm:\n\\begin{lstlisting}\nint best = 0, sum = 0;\nfor (int k = 0; k < n; k++) {\n    sum = max(array[k],sum+array[k]);\n    best = max(best,sum);\n}\ncout << best << \"\\n\";\n\\end{lstlisting}\n\nThe algorithm only contains one loop\nthat goes through the input,\nso the time complexity is $O(n)$.\nThis is also the best possible time complexity,\nbecause any algorithm for the problem\nhas to examine all array elements at least once.\n\n\\subsubsection{Efficiency comparison}\n\nIt is interesting to study how efficient \nalgorithms are in practice.\nThe following table shows the running times\nof the above algorithms for different\nvalues of $n$ on a modern computer.\n\nIn each test, the input was generated randomly.\nThe time needed for reading the input was not\nmeasured.\n\n\\begin{center}\n\\begin{tabular}{rrrr}\narray size $n$ & Algorithm 1 & Algorithm 2 & Algorithm 3 \\\\\n\\hline\n$10^2$ & $0.0$ s & $0.0$ s & $0.0$ s \\\\\n$10^3$ & $0.1$ s & $0.0$ s & $0.0$ s \\\\\n$10^4$ & > $10.0$ s & $0.1$ s & $0.0$ s \\\\\n$10^5$ & > $10.0$ s & $5.3$ s & $0.0$ s \\\\\n$10^6$ & > $10.0$ s & > $10.0$ s & $0.0$ s \\\\\n$10^7$ & > $10.0$ s & > $10.0$ s & $0.0$ s \\\\\n\\end{tabular}\n\\end{center}\n\nThe comparison shows that all algorithms\nare efficient when the input size is small,\nbut larger inputs bring out remarkable\ndifferences in the running times of the algorithms.\nAlgorithm 1 becomes slow\nwhen $n=10^4$, and Algorithm 2\nbecomes slow when $n=10^5$.\nOnly Algorithm 3 is able to process\neven the largest inputs instantly.\n", "chapter_name": "Time complexity", "chapter_path": "cphb/chapter02.tex"}, {"section_name": "Sorting theory", "section_content": "\\chapter{Sorting}\n\n\\index{sorting}\n\n\\key{Sorting}\nis a fundamental algorithm design problem.\nMany efficient algorithms\nuse sorting as a subroutine,\nbecause it is often easier to process\ndata if the elements are in a sorted order.\n\nFor example, the problem ''does an array contain\ntwo equal elements?'' is easy to solve using sorting.\nIf the array contains two equal elements,\nthey will be next to each other after sorting,\nso it is easy to find them.\nAlso, the problem ''what is the most frequent element\nin an array?'' can be solved similarly.\n\nThere are many algorithms for sorting, and they are\nalso good examples of how to apply\ndifferent algorithm design techniques.\nThe efficient general sorting algorithms\nwork in $O(n \\log n)$ time,\nand many algorithms that use sorting\nas a subroutine also\nhave this time complexity.\n\n\\section{Sorting theory}\n\nThe basic problem in sorting is as follows:\n\\begin{framed}\n\\noindent\nGiven an array that contains $n$ elements,\nyour task is to sort the elements\nin increasing order.\n\\end{framed}\n\\noindent\nFor example, the array\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$8$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$9$};\n\\node at (5.5,0.5) {$2$};\n\\node at (6.5,0.5) {$5$};\n\\node at (7.5,0.5) {$6$};\n\\end{tikzpicture}\n\\end{center}\nwill be as follows after sorting:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$3$};\n\\node at (4.5,0.5) {$5$};\n\\node at (5.5,0.5) {$6$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$9$};\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{$O(n^2)$ algorithms}\n\n\\index{bubble sort}\n\nSimple algorithms for sorting an array\nwork in $O(n^2)$ time.\nSuch algorithms are short and usually\nconsist of two nested loops.\nA famous $O(n^2)$ time sorting algorithm\nis \\key{bubble sort} where the elements\n''bubble'' in the array according to their values.\n\nBubble sort consists of $n$ rounds.\nOn each round, the algorithm iterates through\nthe elements of the array.\nWhenever two consecutive elements are found\nthat are not in correct order,\nthe algorithm swaps them.\nThe algorithm can be implemented as follows:\n\\begin{lstlisting}\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < n-1; j++) {\n        if (array[j] > array[j+1]) {\n            swap(array[j],array[j+1]);\n        }\n    }\n}\n\\end{lstlisting}\n\nAfter the first round of the algorithm,\nthe largest element will be in the correct position,\nand in general, after $k$ rounds, the $k$ largest\nelements will be in the correct positions.\nThus, after $n$ rounds, the whole array\nwill be sorted.\n\nFor example, in the array\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$8$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$9$};\n\\node at (5.5,0.5) {$2$};\n\\node at (6.5,0.5) {$5$};\n\\node at (7.5,0.5) {$6$};\n\\end{tikzpicture}\n\\end{center}\n\n\\noindent\nthe first round of bubble sort swaps elements\nas follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$9$};\n\\node at (5.5,0.5) {$2$};\n\\node at (6.5,0.5) {$5$};\n\\node at (7.5,0.5) {$6$};\n\n\\draw[thick,<->] (3.5,-0.25) .. controls (3.25,-1.00) and (2.75,-1.00) .. (2.5,-0.25);\n\\end{tikzpicture}\n\\end{center}\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$2$};\n\\node at (5.5,0.5) {$9$};\n\\node at (6.5,0.5) {$5$};\n\\node at (7.5,0.5) {$6$};\n\n\\draw[thick,<->] (5.5,-0.25) .. controls (5.25,-1.00) and (4.75,-1.00) .. (4.5,-0.25);\n\\end{tikzpicture}\n\\end{center}\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$2$};\n\\node at (5.5,0.5) {$5$};\n\\node at (6.5,0.5) {$9$};\n\\node at (7.5,0.5) {$6$};\n\n\\draw[thick,<->] (6.5,-0.25) .. controls (6.25,-1.00) and (5.75,-1.00) .. (5.5,-0.25);\n\\end{tikzpicture}\n\\end{center}\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$2$};\n\\node at (5.5,0.5) {$5$};\n\\node at (6.5,0.5) {$6$};\n\\node at (7.5,0.5) {$9$};\n\n\\draw[thick,<->] (7.5,-0.25) .. controls (7.25,-1.00) and (6.75,-1.00) .. (6.5,-0.25);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Inversions}\n\n\\index{inversion}\n\nBubble sort is an example of a sorting\nalgorithm that always swaps \\emph{consecutive}\nelements in the array.\nIt turns out that the time complexity\nof such an algorithm is \\emph{always}\nat least $O(n^2)$, because in the worst case,\n$O(n^2)$ swaps are required for sorting the array.\n\nA useful concept when analyzing sorting\nalgorithms is an \\key{inversion}:\na pair of array elements\n$(\\texttt{array}[a],\\texttt{array}[b])$ such that\n$a<b$ and $\\texttt{array}[a]>\\texttt{array}[b]$,\ni.e., the elements are in the wrong order.\nFor example, the array\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$6$};\n\\node at (4.5,0.5) {$3$};\n\\node at (5.5,0.5) {$5$};\n\\node at (6.5,0.5) {$9$};\n\\node at (7.5,0.5) {$8$};\n\\end{tikzpicture}\n\\end{center}\nhas three inversions: $(6,3)$, $(6,5)$ and $(9,8)$.\nThe number of inversions indicates\nhow much work is needed to sort the array.\nAn array is completely sorted when\nthere are no inversions.\nOn the other hand, if the array elements\nare in the reverse order,\nthe number of inversions is the largest possible:\n\\[1+2+\\cdots+(n-1)=\\frac{n(n-1)}{2} = O(n^2)\\]\n\nSwapping a pair of consecutive elements that are\nin the wrong order removes exactly one inversion\nfrom the array.\nHence, if a sorting algorithm can only\nswap consecutive elements, each swap removes\nat most one inversion, and the time complexity\nof the algorithm is at least $O(n^2)$.\n\n\\subsubsection{$O(n \\log n)$ algorithms}\n\n\\index{merge sort}\n\nIt is possible to sort an array efficiently\nin $O(n \\log n)$ time using algorithms\nthat are not limited to swapping consecutive elements.\nOne such algorithm is \\key{merge sort}\\footnote{According to \\cite{knu983},\nmerge sort was invented by J. von Neumann in 1945.},\nwhich is based on recursion.\n\nMerge sort sorts a subarray \\texttt{array}$[a \\ldots b]$ as follows:\n\n\\begin{enumerate}\n\\item If $a=b$, do not do anything, because the subarray is already sorted.\n\\item Calculate the position of the middle element: $k=\\lfloor (a+b)/2 \\rfloor$.\n\\item Recursively sort the subarray \\texttt{array}$[a \\ldots k]$.\n\\item Recursively sort the subarray \\texttt{array}$[k+1 \\ldots b]$.\n\\item \\emph{Merge} the sorted subarrays \\texttt{array}$[a \\ldots k]$ and\n\\texttt{array}$[k+1 \\ldots b]$\ninto a sorted subarray \\texttt{array}$[a \\ldots b]$.\n\\end{enumerate}\n\nMerge sort is an efficient algorithm, because it\nhalves the size of the subarray at each step.\nThe recursion consists of $O(\\log n)$ levels,\nand processing each level takes $O(n)$ time.\nMerging the subarrays \\texttt{array}$[a \\ldots k]$ and \\texttt{array}$[k+1 \\ldots b]$\nis possible in linear time, because they are already sorted.\n\nFor example, consider sorting the following array:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$6$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$8$};\n\\node at (5.5,0.5) {$2$};\n\\node at (6.5,0.5) {$5$};\n\\node at (7.5,0.5) {$9$};\n\\end{tikzpicture}\n\\end{center}\n\nThe array will be divided into two subarrays\nas follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (4,1);\n\\draw (5,0) grid (9,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$6$};\n\\node at (3.5,0.5) {$2$};\n\n\\node at (5.5,0.5) {$8$};\n\\node at (6.5,0.5) {$2$};\n\\node at (7.5,0.5) {$5$};\n\\node at (8.5,0.5) {$9$};\n\\end{tikzpicture}\n\\end{center}\n\nThen, the subarrays will be sorted recursively\nas follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (4,1);\n\\draw (5,0) grid (9,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$3$};\n\\node at (3.5,0.5) {$6$};\n\n\\node at (5.5,0.5) {$2$};\n\\node at (6.5,0.5) {$5$};\n\\node at (7.5,0.5) {$8$};\n\\node at (8.5,0.5) {$9$};\n\\end{tikzpicture}\n\\end{center}\n\nFinally, the algorithm merges the sorted\nsubarrays and creates the final sorted array:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$3$};\n\\node at (4.5,0.5) {$5$};\n\\node at (5.5,0.5) {$6$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$9$};\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Sorting lower bound}\n\nIs it possible to sort an array faster\nthan in $O(n \\log n)$ time?\nIt turns out that this is \\emph{not} possible\nwhen we restrict ourselves to sorting algorithms\nthat are based on comparing array elements.\n\nThe lower bound for the time complexity\ncan be proved by considering sorting\nas a process where each comparison of two elements\ngives more information about the contents of the array.\nThe process creates the following tree:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) rectangle (3,1);\n\\node at (1.5,0.5) {$x < y?$};\n\n\\draw[thick,->] (1.5,0) -- (-2.5,-1.5);\n\\draw[thick,->] (1.5,0) -- (5.5,-1.5);\n\n\\draw (-4,-2.5) rectangle (-1,-1.5);\n\\draw (4,-2.5) rectangle (7,-1.5);\n\\node at (-2.5,-2) {$x < y?$};\n\\node at (5.5,-2) {$x < y?$};\n\n\\draw[thick,->] (-2.5,-2.5) -- (-4.5,-4);\n\\draw[thick,->] (-2.5,-2.5) -- (-0.5,-4);\n\\draw[thick,->] (5.5,-2.5) -- (3.5,-4);\n\\draw[thick,->] (5.5,-2.5) -- (7.5,-4);\n\n\\draw (-6,-5) rectangle (-3,-4);\n\\draw (-2,-5) rectangle (1,-4);\n\\draw (2,-5) rectangle (5,-4);\n\\draw (6,-5) rectangle (9,-4);\n\\node at (-4.5,-4.5) {$x < y?$};\n\\node at (-0.5,-4.5) {$x < y?$};\n\\node at (3.5,-4.5) {$x < y?$};\n\\node at (7.5,-4.5) {$x < y?$};\n\n\\draw[thick,->] (-4.5,-5) -- (-5.5,-6);\n\\draw[thick,->] (-4.5,-5) -- (-3.5,-6);\n\\draw[thick,->] (-0.5,-5) -- (0.5,-6);\n\\draw[thick,->] (-0.5,-5) -- (-1.5,-6);\n\\draw[thick,->] (3.5,-5) -- (2.5,-6);\n\\draw[thick,->] (3.5,-5) -- (4.5,-6);\n\\draw[thick,->] (7.5,-5) -- (6.5,-6);\n\\draw[thick,->] (7.5,-5) -- (8.5,-6);\n\\end{tikzpicture}\n\\end{center}\n\nHere ''$x<y?$'' means that some elements\n$x$ and $y$ are compared.\nIf $x<y$, the process continues to the left,\nand otherwise to the right.\nThe results of the process are the possible\nways to sort the array, a total of $n!$ ways.\nFor this reason, the height of the tree\nmust be at least\n\\[ \\log_2(n!) = \\log_2(1)+\\log_2(2)+\\cdots+\\log_2(n).\\]\nWe get a lower bound for this sum\nby choosing the last $n/2$ elements and\nchanging the value of each element to $\\log_2(n/2)$.\nThis yields an estimate\n\\[ \\log_2(n!) \\ge (n/2) \\cdot \\log_2(n/2),\\]\nso the height of the tree and the minimum\npossible number of steps in a sorting\nalgorithm in the worst case\nis at least $n \\log n$.\n\n\\subsubsection{Counting sort}\n\n\\index{counting sort}\n\nThe lower bound $n \\log n$ does not apply to\nalgorithms that do not compare array elements\nbut use some other information.\nAn example of such an algorithm is\n\\key{counting sort} that sorts an array in\n$O(n)$ time assuming that every element in the array\nis an integer between $0 \\ldots c$ and $c=O(n)$.\n\nThe algorithm creates a \\emph{bookkeeping} array,\nwhose indices are elements of the original array.\nThe algorithm iterates through the original array\nand calculates how many times each element\nappears in the array.\n\\newpage\n\nFor example, the array\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$6$};\n\\node at (3.5,0.5) {$9$};\n\\node at (4.5,0.5) {$9$};\n\\node at (5.5,0.5) {$3$};\n\\node at (6.5,0.5) {$5$};\n\\node at (7.5,0.5) {$9$};\n\\end{tikzpicture}\n\\end{center}\ncorresponds to the following bookkeeping array:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (9,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$0$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$0$};\n\\node at (4.5,0.5) {$1$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$0$};\n\\node at (7.5,0.5) {$0$};\n\\node at (8.5,0.5) {$3$};\n\n\\footnotesize\n\n\\node at (0.5,1.5) {$1$};\n\\node at (1.5,1.5) {$2$};\n\\node at (2.5,1.5) {$3$};\n\\node at (3.5,1.5) {$4$};\n\\node at (4.5,1.5) {$5$};\n\\node at (5.5,1.5) {$6$};\n\\node at (6.5,1.5) {$7$};\n\\node at (7.5,1.5) {$8$};\n\\node at (8.5,1.5) {$9$};\n\\end{tikzpicture}\n\\end{center}\n\nFor example, the value at position 3\nin the bookkeeping array is 2,\nbecause the element 3 appears 2 times\nin the original array.\n\nConstruction of the bookkeeping array\ntakes $O(n)$ time. After this, the sorted array\ncan be created in $O(n)$ time because\nthe number of occurrences of each element can be retrieved\nfrom the bookkeeping array.\nThus, the total time complexity of counting\nsort is $O(n)$.\n\nCounting sort is a very efficient algorithm\nbut it can only be used when the constant $c$\nis small enough, so that the array elements can\nbe used as indices in the bookkeeping array.\n\n", "chapter_name": "Sorting", "chapter_path": "cphb/chapter03.tex"}, {"section_name": "Sorting in C++", "section_content": "\\section{Sorting in C++}\n\n\\index{sort@\\texttt{sort}}\n\nIt is almost never a good idea to use\na home-made sorting algorithm\nin a contest, because there are good\nimplementations available in programming languages.\nFor example, the C++ standard library contains\nthe function \\texttt{sort} that can be easily used for\nsorting arrays and other data structures.\n\nThere are many benefits in using a library function.\nFirst, it saves time because there is no need to\nimplement the function.\nSecond, the library implementation is\ncertainly correct and efficient: it is not probable\nthat a home-made sorting function would be better.\n\nIn this section we will see how to use the\nC++ \\texttt{sort} function.\nThe following code sorts\na vector in increasing order:\n\\begin{lstlisting}\nvector<int> v = {4,2,5,3,5,8,3};\nsort(v.begin(),v.end());\n\\end{lstlisting}\nAfter the sorting, the contents of the\nvector will be\n$[2,3,3,4,5,5,8]$.\nThe default sorting order is increasing,\nbut a reverse order is possible as follows:\n\\begin{lstlisting}\nsort(v.rbegin(),v.rend());\n\\end{lstlisting}\nAn ordinary array can be sorted as follows:\n\\begin{lstlisting}\nint n = 7; // array size\nint a[] = {4,2,5,3,5,8,3};\nsort(a,a+n);\n\\end{lstlisting}\n\\newpage\nThe following code sorts the string \\texttt{s}:\n\\begin{lstlisting}\nstring s = \"monkey\";\nsort(s.begin(), s.end());\n\\end{lstlisting}\nSorting a string means that the characters\nof the string are sorted.\nFor example, the string ''monkey'' becomes ''ekmnoy''.\n\n\\subsubsection{Comparison operators}\n\n\\index{comparison operator}\n\nThe function \\texttt{sort} requires that\na \\key{comparison operator} is defined for the data type\nof the elements to be sorted.\nWhen sorting, this operator will be used\nwhenever it is necessary to find out the order of two elements.\n\nMost C++ data types have a built-in comparison operator,\nand elements of those types can be sorted automatically.\nFor example, numbers are sorted according to their values\nand strings are sorted in alphabetical order.\n\n\\index{pair@\\texttt{pair}}\n\nPairs (\\texttt{pair}) are sorted primarily according to their\nfirst elements (\\texttt{first}).\nHowever, if the first elements of two pairs are equal,\nthey are sorted according to their second elements (\\texttt{second}):\n\\begin{lstlisting}\nvector<pair<int,int>> v;\nv.push_back({1,5});\nv.push_back({2,3});\nv.push_back({1,2});\nsort(v.begin(), v.end());\n\\end{lstlisting}\nAfter this, the order of the pairs is\n$(1,2)$, $(1,5)$ and $(2,3)$.\n\n\\index{tuple@\\texttt{tuple}}\n\nIn a similar way, tuples (\\texttt{tuple})\nare sorted primarily by the first element,\nsecondarily by the second element, etc.\\footnote{Note that in some older compilers,\nthe function \\texttt{make\\_tuple} has to be used to create a tuple instead of\nbraces (for example, \\texttt{make\\_tuple(2,1,4)} instead of \\texttt{\\{2,1,4\\}}).}:\n\\begin{lstlisting}\nvector<tuple<int,int,int>> v;\nv.push_back({2,1,4});\nv.push_back({1,5,3});\nv.push_back({2,1,3});\nsort(v.begin(), v.end());\n\\end{lstlisting}\nAfter this, the order of the tuples is\n$(1,5,3)$, $(2,1,3)$ and $(2,1,4)$.\n\n\\subsubsection{User-defined structs}\n\nUser-defined structs do not have a comparison\noperator automatically.\nThe operator should be defined inside\nthe struct as a function\n\\texttt{operator<},\nwhose parameter is another element of the same type.\nThe operator should return \\texttt{true}\nif the element is smaller than the parameter,\nand \\texttt{false} otherwise.\n\nFor example, the following struct \\texttt{P}\ncontains the x and y coordinates of a point.\nThe comparison operator is defined so that\nthe points are sorted primarily by the x coordinate\nand secondarily by the y coordinate.\n\n\\begin{lstlisting}\nstruct P {\n    int x, y;\n    bool operator<(const P &p) {\n        if (x != p.x) return x < p.x;\n        else return y < p.y;\n    }\n};\n\\end{lstlisting}\n\n\\subsubsection{Comparison functions}\n\n\\index{comparison function}\n\nIt is also possible to give an external\n\\key{comparison function} to the \\texttt{sort} function\nas a callback function.\nFor example, the following comparison function \\texttt{comp}\nsorts strings primarily by length and secondarily\nby alphabetical order:\n\n\\begin{lstlisting}\nbool comp(string a, string b) {\n    if (a.size() != b.size()) return a.size() < b.size();\n    return a < b;\n}\n\\end{lstlisting}\nNow a vector of strings can be sorted as follows:\n\\begin{lstlisting}\nsort(v.begin(), v.end(), comp);\n\\end{lstlisting}\n\n", "chapter_name": "Sorting", "chapter_path": "cphb/chapter03.tex"}, {"section_name": "Binary search", "section_content": "\\section{Binary search}\n\n\\index{binary search}\n\nA general method for searching for an element\nin an array is to use a \\texttt{for} loop\nthat iterates through the elements of the array.\nFor example, the following code searches for\nan element $x$ in an array:\n\n\\begin{lstlisting}\nfor (int i = 0; i < n; i++) {\n    if (array[i] == x) {\n        // x found at index i\n    }\n}\n\\end{lstlisting}\n\nThe time complexity of this approach is $O(n)$,\nbecause in the worst case, it is necessary to check\nall elements of the array.\nIf the order of the elements is arbitrary,\nthis is also the best possible approach, because\nthere is no additional information available where\nin the array we should search for the element $x$.\n\nHowever, if the array is \\emph{sorted},\nthe situation is different.\nIn this case it is possible to perform the\nsearch much faster, because the order of the\nelements in the array guides the search.\nThe following \\key{binary search} algorithm\nefficiently searches for an element in a sorted array\nin $O(\\log n)$ time.\n\n\\subsubsection{Method 1}\n\nThe usual way to implement binary search\nresembles looking for a word in a dictionary.\nThe search maintains an active region in the array,\nwhich initially contains all array elements.\nThen, a number of steps is performed,\neach of which halves the size of the region.\n\nAt each step, the search checks the middle element\nof the active region.\nIf the middle element is the target element,\nthe search terminates.\nOtherwise, the search recursively continues\nto the left or right half of the region,\ndepending on the value of the middle element.\n\nThe above idea can be implemented as follows:\n\\begin{lstlisting}\nint a = 0, b = n-1;\nwhile (a <= b) {\n    int k = (a+b)/2;\n    if (array[k] == x) {\n        // x found at index k\n    }\n    if (array[k] > x) b = k-1;\n    else a = k+1;\n}\n\\end{lstlisting}\n\nIn this implementation, the active region is $a \\ldots b$,\nand initially the region is $0 \\ldots n-1$.\nThe algorithm halves the size of the region at each step,\nso the time complexity is $O(\\log n)$.\n\n\\subsubsection{Method 2}\n\nAn alternative method to implement binary search\nis based on an efficient way to iterate through\nthe elements of the array.\nThe idea is to make jumps and slow the speed\nwhen we get closer to the target element.\n\nThe search goes through the array from left to\nright, and the initial jump length is $n/2$.\nAt each step, the jump length will be halved:\nfirst $n/4$, then $n/8$, $n/16$, etc., until\nfinally the length is 1.\nAfter the jumps, either the target element has\nbeen found or we know that it does not appear in the array.\n\nThe following code implements the above idea:\n\\begin{lstlisting}\nint k = 0;\nfor (int b = n/2; b >= 1; b /= 2) {\n    while (k+b < n && array[k+b] <= x) k += b;\n}\nif (array[k] == x) {\n    // x found at index k\n}\n\\end{lstlisting}\n\nDuring the search, the variable $b$\ncontains the current jump length.\nThe time complexity of the algorithm is $O(\\log n)$,\nbecause the code in the \\texttt{while} loop\nis performed at most twice for each jump length.\n\n\\subsubsection{C++ functions}\n\nThe C++ standard library contains the following functions\nthat are based on binary search and work in logarithmic time:\n\n\\begin{itemize}\n\\item \\texttt{lower\\_bound} returns a pointer to the\nfirst array element whose value is at least $x$.\n\\item \\texttt{upper\\_bound} returns a pointer to the\nfirst array element whose value is larger than $x$.\n\\item \\texttt{equal\\_range} returns both above pointers.\n\\end{itemize}\n\nThe functions assume that the array is sorted.\nIf there is no such element, the pointer points to\nthe element after the last array element.\nFor example, the following code finds out whether\nan array contains an element with value $x$:\n\n\\begin{lstlisting}\nauto k = lower_bound(array,array+n,x)-array;\nif (k < n && array[k] == x) {\n    // x found at index k\n}\n\\end{lstlisting}\n\nThen, the following code counts the number of elements\nwhose value is $x$:\n\n\\begin{lstlisting}\nauto a = lower_bound(array, array+n, x);\nauto b = upper_bound(array, array+n, x);\ncout << b-a << \"\\n\";\n\\end{lstlisting}\n\nUsing \\texttt{equal\\_range}, the code becomes shorter:\n\n\\begin{lstlisting}\nauto r = equal_range(array, array+n, x);\ncout << r.second-r.first << \"\\n\";\n\\end{lstlisting}\n\n\\subsubsection{Finding the smallest solution}\n\nAn important use for binary search is\nto find the position where the value of a \\emph{function} changes.\nSuppose that we wish to find the smallest value $k$\nthat is a valid solution for a problem.\nWe are given a function $\\texttt{ok}(x)$\nthat returns \\texttt{true} if $x$ is a valid solution\nand \\texttt{false} otherwise.\nIn addition, we know that $\\texttt{ok}(x)$ is \\texttt{false}\nwhen $x<k$ and \\texttt{true} when $x \\ge k$.\nThe situation looks as follows:\n\n\\begin{center}\n\\begin{tabular}{r|rrrrrrrr}\n$x$ & 0 & 1 & $\\cdots$ & $k-1$ & $k$ & $k+1$ & $\\cdots$ \\\\\n\\hline\n$\\texttt{ok}(x)$ & \\texttt{false} & \\texttt{false}\n& $\\cdots$ & \\texttt{false} & \\texttt{true} & \\texttt{true} & $\\cdots$ \\\\\n\\end{tabular}\n\\end{center}\n\n\\noindent\nNow, the value of $k$ can be found using binary search:\n\n\\begin{lstlisting}\nint x = -1;\nfor (int b = z; b >= 1; b /= 2) {\n    while (!ok(x+b)) x += b;\n}\nint k = x+1;\n\\end{lstlisting}\n\nThe search finds the largest value of $x$ for which\n$\\texttt{ok}(x)$ is \\texttt{false}.\nThus, the next value $k=x+1$\nis the smallest possible value for which\n$\\texttt{ok}(k)$ is \\texttt{true}.\nThe initial jump length $z$ has to be\nlarge enough, for example some value\nfor which we know beforehand that $\\texttt{ok}(z)$ is \\texttt{true}.\n\nThe algorithm calls the function \\texttt{ok}\n$O(\\log z)$ times, so the total time complexity\ndepends on the function \\texttt{ok}.\nFor example, if the function works in $O(n)$ time,\nthe total time complexity is $O(n \\log z)$.\n\n\\subsubsection{Finding the maximum value}\n\nBinary search can also be used to find\nthe maximum value for a function that is\nfirst increasing and then decreasing.\nOur task is to find a position $k$ such that\n\n\\begin{itemize}\n\\item\n$f(x)<f(x+1)$ when $x<k$, and\n\\item\n$f(x)>f(x+1)$ when $x \\ge k$.\n\\end{itemize}\n\nThe idea is to use binary search\nfor finding the largest value of $x$\nfor which $f(x)<f(x+1)$.\nThis implies that $k=x+1$\nbecause $f(x+1)>f(x+2)$.\nThe following code implements the search: \n\n\\begin{lstlisting}\nint x = -1;\nfor (int b = z; b >= 1; b /= 2) {\n    while (f(x+b) < f(x+b+1)) x += b;\n}\nint k = x+1;\n\\end{lstlisting}\n\nNote that unlike in the ordinary binary search,\nhere it is not allowed that consecutive values\nof the function are equal.\nIn this case it would not be possible to know\nhow to continue the search.\n", "chapter_name": "Sorting", "chapter_path": "cphb/chapter03.tex"}, {"section_name": "Dynamic arrays", "section_content": "\\chapter{Data structures}\n\n\\index{data structure}\n\nA \\key{data structure} is a way to store\ndata in the memory of a computer.\nIt is important to choose an appropriate\ndata structure for a problem,\nbecause each data structure has its own\nadvantages and disadvantages.\nThe crucial question is: which operations\nare efficient in the chosen data structure?\n\nThis chapter introduces the most important\ndata structures in the C++ standard library.\nIt is a good idea to use the standard library\nwhenever possible,\nbecause it will save a lot of time.\nLater in the book we will learn about more sophisticated\ndata structures that are not available\nin the standard library.\n\n\\section{Dynamic arrays}\n\n\\index{dynamic array}\n\\index{vector}\n\nA \\key{dynamic array} is an array whose\nsize can be changed during the execution\nof the program.\nThe most popular dynamic array in C++ is\nthe \\texttt{vector} structure,\nwhich can be used almost like an ordinary array.\n\nThe following code creates an empty vector and\nadds three elements to it:\n\n\\begin{lstlisting}\nvector<int> v;\nv.push_back(3); // [3]\nv.push_back(2); // [3,2]\nv.push_back(5); // [3,2,5]\n\\end{lstlisting}\n\nAfter this, the elements can be accessed like in an ordinary array:\n\n\\begin{lstlisting}\ncout << v[0] << \"\\n\"; // 3\ncout << v[1] << \"\\n\"; // 2\ncout << v[2] << \"\\n\"; // 5\n\\end{lstlisting}\n\nThe function \\texttt{size} returns the number of elements in the vector.\nThe following code iterates through\nthe vector and prints all elements in it:\n\n\\begin{lstlisting}\nfor (int i = 0; i < v.size(); i++) {\n    cout << v[i] << \"\\n\";\n}\n\\end{lstlisting}\n\n\\begin{samepage}\nA shorter way to iterate through a vector is as follows:\n\n\\begin{lstlisting}\nfor (auto x : v) {\n    cout << x << \"\\n\";\n}\n\\end{lstlisting}\n\\end{samepage}\n\nThe function \\texttt{back} returns the last element\nin the vector, and\nthe function \\texttt{pop\\_back} removes the last element:\n\n\\begin{lstlisting}\nvector<int> v;\nv.push_back(5);\nv.push_back(2);\ncout << v.back() << \"\\n\"; // 2\nv.pop_back();\ncout << v.back() << \"\\n\"; // 5\n\\end{lstlisting}\n\nThe following code creates a vector with five elements:\n\n\\begin{lstlisting}\nvector<int> v = {2,4,2,5,1};\n\\end{lstlisting}\n\nAnother way to create a vector is to give the number\nof elements and the initial value for each element:\n\n\\begin{lstlisting}\n// size 10, initial value 0\nvector<int> v(10);\n\\end{lstlisting}\n\\begin{lstlisting}\n// size 10, initial value 5\nvector<int> v(10, 5);\n\\end{lstlisting}\n\nThe internal implementation of a vector\nuses an ordinary array.\nIf the size of the vector increases and\nthe array becomes too small,\na new array is allocated and all the\nelements are moved to the new array.\nHowever, this does not happen often and the\naverage time complexity of\n\\texttt{push\\_back} is $O(1)$.\n\n\\index{string}\n\nThe \\texttt{string} structure\nis also a dynamic array that can be used almost like a vector.\nIn addition, there is special syntax for strings\nthat is not available in other data structures.\nStrings can be combined using the \\texttt{+} symbol.\nThe function $\\texttt{substr}(k,x)$ returns the substring\nthat begins at position $k$ and has length $x$,\nand the function $\\texttt{find}(\\texttt{t})$ finds the position\nof the first occurrence of a substring \\texttt{t}.\n\nThe following code presents some string operations:\n\n\\begin{lstlisting}\nstring a = \"hatti\";\nstring b = a+a;\ncout << b << \"\\n\"; // hattihatti\nb[5] = 'v';\ncout << b << \"\\n\"; // hattivatti\nstring c = b.substr(3,4);\ncout << c << \"\\n\"; // tiva\n\\end{lstlisting}\n\n", "chapter_name": "Data structures", "chapter_path": "cphb/chapter04.tex"}, {"section_name": "Set structures", "section_content": "\\section{Set structures}\n\n\\index{set}\n\nA \\key{set} is a data structure that\nmaintains a collection of elements.\nThe basic operations of sets are element\ninsertion, search and removal.\n\nThe C++ standard library contains two set\nimplementations:\nThe structure \\texttt{set} is based on a balanced\nbinary tree and its operations work in $O(\\log n)$ time.\nThe structure \\texttt{unordered\\_set} uses hashing,\nand its operations work in $O(1)$ time on average.\n\nThe choice of which set implementation to use\nis often a matter of taste.\nThe benefit of the \\texttt{set} structure\nis that it maintains the order of the elements\nand provides functions that are not available\nin \\texttt{unordered\\_set}.\nOn the other hand, \\texttt{unordered\\_set}\ncan be more efficient.\n\nThe following code creates a set\nthat contains integers,\nand shows some of the operations.\nThe function \\texttt{insert} adds an element to the set,\nthe function \\texttt{count} returns the number of occurrences\nof an element in the set,\nand the function \\texttt{erase} removes an element from the set.\n\n\\begin{lstlisting}\nset<int> s;\ns.insert(3);\ns.insert(2);\ns.insert(5);\ncout << s.count(3) << \"\\n\"; // 1\ncout << s.count(4) << \"\\n\"; // 0\ns.erase(3);\ns.insert(4);\ncout << s.count(3) << \"\\n\"; // 0\ncout << s.count(4) << \"\\n\"; // 1\n\\end{lstlisting}\n\nA set can be used mostly like a vector,\nbut it is not possible to access\nthe elements using the \\texttt{[]} notation.\nThe following code creates a set,\nprints the number of elements in it, and then\niterates through all the elements:\n\\begin{lstlisting}\nset<int> s = {2,5,6,8};\ncout << s.size() << \"\\n\"; // 4\nfor (auto x : s) {\n    cout << x << \"\\n\";\n}\n\\end{lstlisting}\n\nAn important property of sets is\nthat all their elements are \\emph{distinct}.\nThus, the function \\texttt{count} always returns\neither 0 (the element is not in the set)\nor 1 (the element is in the set),\nand the function \\texttt{insert} never adds\nan element to the set if it is\nalready there.\nThe following code illustrates this:\n\n\\begin{lstlisting}\nset<int> s;\ns.insert(5);\ns.insert(5);\ns.insert(5);\ncout << s.count(5) << \"\\n\"; // 1\n\\end{lstlisting}\n\nC++ also contains the structures\n\\texttt{multiset} and \\texttt{unordered\\_multiset}\nthat otherwise work like \\texttt{set}\nand \\texttt{unordered\\_set}\nbut they can contain multiple instances of an element.\nFor example, in the following code all three instances\nof the number 5 are added to a multiset:\n\n\\begin{lstlisting}\nmultiset<int> s;\ns.insert(5);\ns.insert(5);\ns.insert(5);\ncout << s.count(5) << \"\\n\"; // 3\n\\end{lstlisting}\nThe function \\texttt{erase} removes\nall instances of an element\nfrom a multiset:\n\\begin{lstlisting}\ns.erase(5);\ncout << s.count(5) << \"\\n\"; // 0\n\\end{lstlisting}\nOften, only one instance should be removed,\nwhich can be done as follows:\n\\begin{lstlisting}\ns.erase(s.find(5));\ncout << s.count(5) << \"\\n\"; // 2\n\\end{lstlisting}\n\n", "chapter_name": "Data structures", "chapter_path": "cphb/chapter04.tex"}, {"section_name": "Map structures", "section_content": "\\section{Map structures}\n\n\\index{map}\n\nA \\key{map} is a generalized array\nthat consists of key-value-pairs.\nWhile the keys in an ordinary array are always\nthe consecutive integers $0,1,\\ldots,n-1$,\nwhere $n$ is the size of the array,\nthe keys in a map can be of any data type and\nthey do not have to be consecutive values.\n\nThe C++ standard library contains two map\nimplementations that correspond to the set\nimplementations: the structure\n\\texttt{map} is based on a balanced\nbinary tree and accessing elements\ntakes $O(\\log n)$ time,\nwhile the structure\n\\texttt{unordered\\_map} uses hashing\nand accessing elements takes $O(1)$ time on average.\n\nThe following code creates a map\nwhere the keys are strings and the values are integers:\n\n\\begin{lstlisting}\nmap<string,int> m;\nm[\"monkey\"] = 4;\nm[\"banana\"] = 3;\nm[\"harpsichord\"] = 9;\ncout << m[\"banana\"] << \"\\n\"; // 3\n\\end{lstlisting}\n\nIf the value of a key is requested\nbut the map does not contain it,\nthe key is automatically added to the map with\na default value.\nFor example, in the following code,\nthe key ''aybabtu'' with value 0\nis added to the map.\n\n\\begin{lstlisting}\nmap<string,int> m;\ncout << m[\"aybabtu\"] << \"\\n\"; // 0\n\\end{lstlisting}\nThe function \\texttt{count} checks\nif a key exists in a map:\n\\begin{lstlisting}\nif (m.count(\"aybabtu\")) {\n    // key exists\n}\n\\end{lstlisting}\nThe following code prints all the keys and values\nin a map:\n\\begin{lstlisting}\nfor (auto x : m) {\n    cout << x.first << \" \" << x.second << \"\\n\";\n}\n\\end{lstlisting}\n\n", "chapter_name": "Data structures", "chapter_path": "cphb/chapter04.tex"}, {"section_name": "Iterators and ranges", "section_content": "\\section{Iterators and ranges}\n\n\\index{iterator}\n\nMany functions in the C++ standard library\noperate with iterators.\nAn \\key{iterator} is a variable that points\nto an element in a data structure.\n\nThe often used iterators \\texttt{begin}\nand \\texttt{end} define a range that contains\nall elements in a data structure.\nThe iterator \\texttt{begin} points to\nthe first element in the data structure,\nand the iterator \\texttt{end} points to\nthe position \\emph{after} the last element.\nThe situation looks as follows:\n\n\\begin{center}\n\\begin{tabular}{llllllllll}\n\\{ & 3, & 4, & 6, & 8, & 12, & 13, & 14, & 17 & \\} \\\\\n& $\\uparrow$ & & & & & & & & $\\uparrow$ \\\\\n& \\multicolumn{3}{l}{\\texttt{s.begin()}} & & & & & & \\texttt{s.end()} \\\\\n\\end{tabular}\n\\end{center}\n\nNote the asymmetry in the iterators:\n\\texttt{s.begin()} points to an element in the data structure,\nwhile \\texttt{s.end()} points outside the data structure.\nThus, the range defined by the iterators is \\emph{half-open}.\n\n\\subsubsection{Working with ranges}\n\nIterators are used in C++ standard library functions\nthat are given a range of elements in a data structure.\nUsually, we want to process all elements in a\ndata structure, so the iterators\n\\texttt{begin} and \\texttt{end} are given for the function.\n\nFor example, the following code sorts a vector\nusing the function \\texttt{sort},\nthen reverses the order of the elements using the function\n\\texttt{reverse}, and finally shuffles the order of\nthe elements using the function \\texttt{random\\_shuffle}.\n\n\\index{sort@\\texttt{sort}}\n\\index{reverse@\\texttt{reverse}}\n\\index{random\\_shuffle@\\texttt{random\\_shuffle}}\n\n\\begin{lstlisting}\nsort(v.begin(), v.end());\nreverse(v.begin(), v.end());\nrandom_shuffle(v.begin(), v.end());\n\\end{lstlisting}\n\nThese functions can also be used with an ordinary array.\nIn this case, the functions are given pointers to the array\ninstead of iterators:\n\n\\newpage\n\\begin{lstlisting}\nsort(a, a+n);\nreverse(a, a+n);\nrandom_shuffle(a, a+n);\n\\end{lstlisting}\n\n\\subsubsection{Set iterators}\n\nIterators are often used to access\nelements of a set.\nThe following code creates an iterator\n\\texttt{it} that points to the smallest element in a set:\n\\begin{lstlisting}\nset<int>::iterator it = s.begin();\n\\end{lstlisting}\nA shorter way to write the code is as follows:\n\\begin{lstlisting}\nauto it = s.begin();\n\\end{lstlisting}\nThe element to which an iterator points\ncan be accessed using the \\texttt{*} symbol.\nFor example, the following code prints\nthe first element in the set:\n\n\\begin{lstlisting}\nauto it = s.begin();\ncout << *it << \"\\n\";\n\\end{lstlisting}\n\nIterators can be moved using the operators\n\\texttt{++} (forward) and \\texttt{--} (backward),\nmeaning that the iterator moves to the next\nor previous element in the set.\n\nThe following code prints all the elements\nin increasing order:\n\\begin{lstlisting}\nfor (auto it = s.begin(); it != s.end(); it++) {\n    cout << *it << \"\\n\";\n}\n\\end{lstlisting}\nThe following code prints the largest element in the set:\n\\begin{lstlisting}\nauto it = s.end(); it--;\ncout << *it << \"\\n\";\n\\end{lstlisting}\n\nThe function $\\texttt{find}(x)$ returns an iterator\nthat points to an element whose value is $x$.\nHowever, if the set does not contain $x$,\nthe iterator will be \\texttt{end}.\n\n\\begin{lstlisting}\nauto it = s.find(x);\nif (it == s.end()) {\n    // x is not found\n}\n\\end{lstlisting}\n\nThe function $\\texttt{lower\\_bound}(x)$ returns\nan iterator to the smallest element in the set\nwhose value is \\emph{at least} $x$, and\nthe function $\\texttt{upper\\_bound}(x)$\nreturns an iterator to the smallest element in the set\nwhose value is \\emph{larger than} $x$.\nIn both functions, if such an element does not exist,\nthe return value is \\texttt{end}.\nThese functions are not supported by the\n\\texttt{unordered\\_set} structure which\ndoes not maintain the order of the elements.\n\n\\begin{samepage}\nFor example, the following code finds the element\nnearest to $x$:\n\n\\begin{lstlisting}\nauto it = s.lower_bound(x);\nif (it == s.begin()) {\n    cout << *it << \"\\n\";\n} else if (it == s.end()) {\n    it--;\n    cout << *it << \"\\n\";\n} else {\n    int a = *it; it--;\n    int b = *it;\n    if (x-b < a-x) cout << b << \"\\n\";\n    else cout << a << \"\\n\";\n}\n\\end{lstlisting}\n\nThe code assumes that the set is not empty,\nand goes through all possible cases\nusing an iterator \\texttt{it}.\nFirst, the iterator points to the smallest\nelement whose value is at least $x$.\nIf \\texttt{it} equals \\texttt{begin},\nthe corresponding element is nearest to $x$.\nIf \\texttt{it} equals \\texttt{end},\nthe largest element in the set is nearest to $x$.\nIf none of the previous cases hold,\nthe element nearest to $x$ is either the\nelement that corresponds to \\texttt{it} or the previous element.\n\\end{samepage}\n\n", "chapter_name": "Data structures", "chapter_path": "cphb/chapter04.tex"}, {"section_name": "Other structures", "section_content": "\\section{Other structures}\n\n\\subsubsection{Bitset}\n\n\\index{bitset}\n\nA \\key{bitset} is an array\nwhose each value is either 0 or 1.\nFor example, the following code creates\na bitset that contains 10 elements:\n\\begin{lstlisting}\nbitset<10> s;\ns[1] = 1;\ns[3] = 1;\ns[4] = 1;\ns[7] = 1;\ncout << s[4] << \"\\n\"; // 1\ncout << s[5] << \"\\n\"; // 0\n\\end{lstlisting}\n\nThe benefit of using bitsets is that\nthey require less memory than ordinary arrays,\nbecause each element in a bitset only\nuses one bit of memory.\nFor example, \nif $n$ bits are stored in an \\texttt{int} array,\n$32n$ bits of memory will be used,\nbut a corresponding bitset only requires $n$ bits of memory.\nIn addition, the values of a bitset\ncan be efficiently manipulated using\nbit operators, which makes it possible to\noptimize algorithms using bit sets.\n\nThe following code shows another way to create the above bitset:\n\\begin{lstlisting}\nbitset<10> s(string(\"0010011010\")); // from right to left\ncout << s[4] << \"\\n\"; // 1\ncout << s[5] << \"\\n\"; // 0\n\\end{lstlisting}\n\nThe function \\texttt{count} returns the number\nof ones in the bitset:\n\n\\begin{lstlisting}\nbitset<10> s(string(\"0010011010\"));\ncout << s.count() << \"\\n\"; // 4\n\\end{lstlisting}\n\nThe following code shows examples of using bit operations:\n\\begin{lstlisting}\nbitset<10> a(string(\"0010110110\"));\nbitset<10> b(string(\"1011011000\"));\ncout << (a&b) << \"\\n\"; // 0010010000\ncout << (a|b) << \"\\n\"; // 1011111110\ncout << (a^b) << \"\\n\"; // 1001101110\n\\end{lstlisting}\n\n\\subsubsection{Deque}\n\n\\index{deque}\n\nA \\key{deque} is a dynamic array\nwhose size can be efficiently\nchanged at both ends of the array.\nLike a vector, a deque provides the functions\n\\texttt{push\\_back} and \\texttt{pop\\_back}, but\nit also includes the functions\n\\texttt{push\\_front} and \\texttt{pop\\_front}\nwhich are not available in a vector.\n\nA deque can be used as follows:\n\\begin{lstlisting}\ndeque<int> d;\nd.push_back(5); // [5]\nd.push_back(2); // [5,2]\nd.push_front(3); // [3,5,2]\nd.pop_back(); // [3,5]\nd.pop_front(); // [5]\n\\end{lstlisting}\n\nThe internal implementation of a deque\nis more complex than that of a vector,\nand for this reason, a deque is slower than a vector.\nStill, both adding and removing\nelements take $O(1)$ time on average at both ends.\n\n\\subsubsection{Stack}\n\n\\index{stack}\n\nA \\key{stack}\nis a data structure that provides two\n$O(1)$ time operations:\nadding an element to the top,\nand removing an element from the top.\nIt is only possible to access the top\nelement of a stack.\n\nThe following code shows how a stack can be used:\n\\begin{lstlisting}\nstack<int> s;\ns.push(3);\ns.push(2);\ns.push(5);\ncout << s.top(); // 5\ns.pop();\ncout << s.top(); // 2\n\\end{lstlisting}\n\\subsubsection{Queue}\n\n\\index{queue}\n\nA \\key{queue} also\nprovides two $O(1)$ time operations:\nadding an element to the end of the queue,\nand removing the first element in the queue.\nIt is only possible to access the first\nand last element of a queue.\n\nThe following code shows how a queue can be used:\n\\begin{lstlisting}\nqueue<int> q;\nq.push(3);\nq.push(2);\nq.push(5);\ncout << q.front(); // 3\nq.pop();\ncout << q.front(); // 2\n\\end{lstlisting}\n\n\\subsubsection{Priority queue}\n\n\\index{priority queue}\n\\index{heap}\n\nA \\key{priority queue}\nmaintains a set of elements.\nThe supported operations are insertion and,\ndepending on the type of the queue,\nretrieval and removal of\neither the minimum or maximum element.\nInsertion and removal take $O(\\log n)$ time,\nand retrieval takes $O(1)$ time.\n\nWhile an ordered set efficiently supports\nall the operations of a priority queue,\nthe benefit of using a priority queue is\nthat it has smaller constant factors.\nA priority queue is usually implemented using\na heap structure that is much simpler than a\nbalanced binary tree used in an ordered set.\n\n\\begin{samepage}\nBy default, the elements in a C++\npriority queue are sorted in decreasing order,\nand it is possible to find and remove the\nlargest element in the queue.\nThe following code illustrates this:\n\n\\begin{lstlisting}\npriority_queue<int> q;\nq.push(3);\nq.push(5);\nq.push(7);\nq.push(2);\ncout << q.top() << \"\\n\"; // 7\nq.pop();\ncout << q.top() << \"\\n\"; // 5\nq.pop();\nq.push(6);\ncout << q.top() << \"\\n\"; // 6\nq.pop();\n\\end{lstlisting}\n\\end{samepage}\n\nIf we want to create a priority queue\nthat supports finding and removing\nthe smallest element,\nwe can do it as follows:\n\n\\begin{lstlisting}\npriority_queue<int,vector<int>,greater<int>> q;\n\\end{lstlisting}\n\n\\subsubsection{Policy-based data structures}\n\nThe \\texttt{g++} compiler also supports\nsome data structures that are not part\nof the C++ standard library.\nSuch structures are called \\emph{policy-based}\ndata structures.\nTo use these structures, the following lines\nmust be added to the code:\n\\begin{lstlisting}\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds; \n\\end{lstlisting}\nAfter this, we can define a data structure \\texttt{indexed\\_set} that\nis like \\texttt{set} but can be indexed like an array.\nThe definition for \\texttt{int} values is as follows:\n\\begin{lstlisting}\ntypedef tree<int,null_type,less<int>,rb_tree_tag,\n             tree_order_statistics_node_update> indexed_set; \n\\end{lstlisting}\nNow we can create a set as follows:\n\\begin{lstlisting}\nindexed_set s;\ns.insert(2);\ns.insert(3);\ns.insert(7);\ns.insert(9);\n\\end{lstlisting}\nThe speciality of this set is that we have access to\nthe indices that the elements would have in a sorted array.\nThe function $\\texttt{find\\_by\\_order}$ returns\nan iterator to the element at a given position:\n\\begin{lstlisting}\nauto x = s.find_by_order(2);\ncout << *x << \"\\n\"; // 7\n\\end{lstlisting}\nAnd the function $\\texttt{order\\_of\\_key}$\nreturns the position of a given element:\n\\begin{lstlisting}\ncout << s.order_of_key(7) << \"\\n\"; // 2\n\\end{lstlisting}\nIf the element does not appear in the set,\nwe get the position that the element would have\nin the set:\n\\begin{lstlisting}\ncout << s.order_of_key(6) << \"\\n\"; // 2\ncout << s.order_of_key(8) << \"\\n\"; // 3\n\\end{lstlisting}\nBoth the functions work in logarithmic time.\n\n", "chapter_name": "Data structures", "chapter_path": "cphb/chapter04.tex"}, {"section_name": "Comparison to sorting", "section_content": "\\section{Comparison to sorting}\n\nIt is often possible to solve a problem\nusing either data structures or sorting.\nSometimes there are remarkable differences\nin the actual efficiency of these approaches,\nwhich may be hidden in their time complexities.\n\nLet us consider a problem where\nwe are given two lists $A$ and $B$\nthat both contain $n$ elements.\nOur task is to calculate the number of elements\nthat belong to both of the lists.\nFor example, for the lists\n\\[A = [5,2,8,9] \\hspace{10px} \\textrm{and} \\hspace{10px} B = [3,2,9,5],\\]\nthe answer is 3 because the numbers 2, 5\nand 9 belong to both of the lists.\n\nA straightforward solution to the problem is\nto go through all pairs of elements in $O(n^2)$ time,\nbut next we will focus on\nmore efficient algorithms.\n\n\\subsubsection{Algorithm 1}\n\nWe construct a set of the elements that appear in $A$,\nand after this, we iterate through the elements\nof $B$ and check for each elements if it\nalso belongs to $A$.\nThis is efficient because the elements of $A$\nare in a set.\nUsing the \\texttt{set} structure,\nthe time complexity of the algorithm is $O(n \\log n)$.\n\n\\subsubsection{Algorithm 2}\n\nIt is not necessary to maintain an ordered set,\nso instead of the \\texttt{set} structure\nwe can also use the \\texttt{unordered\\_set} structure.\nThis is an easy way to make the algorithm\nmore efficient, because we only have to change\nthe underlying data structure.\nThe time complexity of the new algorithm is $O(n)$.\n\n\\subsubsection{Algorithm 3}\n\nInstead of data structures, we can use sorting.\nFirst, we sort both lists $A$ and $B$.\nAfter this, we iterate through both the lists\nat the same time and find the common elements.\nThe time complexity of sorting is $O(n \\log n)$,\nand the rest of the algorithm works in $O(n)$ time,\nso the total time complexity is $O(n \\log n)$.\n\n\\subsubsection{Efficiency comparison}\n\nThe following table shows how efficient\nthe above algorithms are when $n$ varies and\nthe elements of the lists are random\nintegers between $1 \\ldots 10^9$:\n\n\\begin{center}\n\\begin{tabular}{rrrr}\n$n$ & Algorithm 1 & Algorithm 2 & Algorithm 3 \\\\\n\\hline\n$10^6$ & $1.5$ s & $0.3$ s & $0.2$ s \\\\\n$2 \\cdot 10^6$ & $3.7$ s & $0.8$ s & $0.3$ s \\\\\n$3 \\cdot 10^6$ & $5.7$ s & $1.3$ s & $0.5$ s \\\\\n$4 \\cdot 10^6$ & $7.7$ s & $1.7$ s & $0.7$ s \\\\\n$5 \\cdot 10^6$ & $10.0$ s & $2.3$ s & $0.9$ s \\\\\n\\end{tabular}\n\\end{center}\n\nAlgorithms 1 and 2 are equal except that\nthey use different set structures.\nIn this problem, this choice has an important effect on\nthe running time, because Algorithm 2\nis 4\u20135 times faster than Algorithm 1.\n\nHowever, the most efficient algorithm is Algorithm 3\nwhich uses sorting.\nIt only uses half the time compared to Algorithm 2.\nInterestingly, the time complexity of both\nAlgorithm 1 and Algorithm 3 is $O(n \\log n)$,\nbut despite this, Algorithm 3 is ten times faster.\nThis can be explained by the fact that\nsorting is a simple procedure and it is done\nonly once at the beginning of Algorithm 3,\nand the rest of the algorithm works in linear time.\nOn the other hand,\nAlgorithm 1 maintains a complex balanced binary tree\nduring the whole algorithm.\n", "chapter_name": "Data structures", "chapter_path": "cphb/chapter04.tex"}, {"section_name": "Generating subsets", "section_content": "\\chapter{Complete search}\n\n\\key{Complete search}\nis a general method that can be used\nto solve almost any algorithm problem.\nThe idea is to generate all possible\nsolutions to the problem using brute force,\nand then select the best solution or count the\nnumber of solutions, depending on the problem.\n\nComplete search is a good technique\nif there is enough time to go through all the solutions,\nbecause the search is usually easy to implement\nand it always gives the correct answer.\nIf complete search is too slow,\nother techniques, such as greedy algorithms or\ndynamic programming, may be needed.\n\n\\section{Generating subsets}\n\n\\index{subset}\n\nWe first consider the problem of generating\nall subsets of a set of $n$ elements.\nFor example, the subsets of $\\{0,1,2\\}$ are\n$\\emptyset$, $\\{0\\}$, $\\{1\\}$, $\\{2\\}$, $\\{0,1\\}$,\n$\\{0,2\\}$, $\\{1,2\\}$ and $\\{0,1,2\\}$.\nThere are two common methods to generate subsets:\nwe can either perform a recursive search\nor exploit the bit representation of integers.\n\n\\subsubsection{Method 1}\n\nAn elegant way to go through all subsets\nof a set is to use recursion.\nThe following function \\texttt{search}\ngenerates the subsets of the set\n$\\{0,1,\\ldots,n-1\\}$.\nThe function maintains a vector \\texttt{subset}\nthat will contain the elements of each subset.\nThe search begins when the function is called\nwith parameter 0.\n\n\\begin{lstlisting}\nvoid search(int k) {\n    if (k == n) {\n        // process subset\n    } else {\n        search(k+1);\n        subset.push_back(k);\n        search(k+1);\n        subset.pop_back();\n    }\n}\n\\end{lstlisting}\n\nWhen the function \\texttt{search}\nis called with parameter $k$,\nit decides whether to include the\nelement $k$ in the subset or not,\nand in both cases,\nthen calls itself with parameter $k+1$\nHowever, if $k=n$, the function notices that\nall elements have been processed\nand a subset has been generated.\n\nThe following tree illustrates the function calls when $n=3$.\nWe can always choose either the left branch\n($k$ is not included in the subset) or the right branch\n($k$ is included in the subset).\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.45]\n  \\begin{scope}\n    \\small\n    \\node at (0,0) {$\\texttt{search}(0)$};\n\n    \\node at (-8,-4) {$\\texttt{search}(1)$};\n    \\node at (8,-4) {$\\texttt{search}(1)$};\n\n    \\path[draw,thick,->] (0,0-0.5) -- (-8,-4+0.5);\n    \\path[draw,thick,->] (0,0-0.5) -- (8,-4+0.5);\n\n    \\node at (-12,-8) {$\\texttt{search}(2)$};\n    \\node at (-4,-8) {$\\texttt{search}(2)$};\n    \\node at (4,-8) {$\\texttt{search}(2)$};\n    \\node at (12,-8) {$\\texttt{search}(2)$};\n\n    \\path[draw,thick,->] (-8,-4-0.5) -- (-12,-8+0.5);\n    \\path[draw,thick,->] (-8,-4-0.5) -- (-4,-8+0.5);\n    \\path[draw,thick,->] (8,-4-0.5) -- (4,-8+0.5);\n    \\path[draw,thick,->] (8,-4-0.5) -- (12,-8+0.5);\n\n    \\node at (-14,-12) {$\\texttt{search}(3)$};\n    \\node at (-10,-12) {$\\texttt{search}(3)$};\n    \\node at (-6,-12) {$\\texttt{search}(3)$};\n    \\node at (-2,-12) {$\\texttt{search}(3)$};\n    \\node at (2,-12) {$\\texttt{search}(3)$};\n    \\node at (6,-12) {$\\texttt{search}(3)$};\n    \\node at (10,-12) {$\\texttt{search}(3)$};\n    \\node at (14,-12) {$\\texttt{search}(3)$};\n\n    \\node at (-14,-13.5) {$\\emptyset$};\n    \\node at (-10,-13.5) {$\\{2\\}$};\n    \\node at (-6,-13.5) {$\\{1\\}$};\n    \\node at (-2,-13.5) {$\\{1,2\\}$};\n    \\node at (2,-13.5) {$\\{0\\}$};\n    \\node at (6,-13.5) {$\\{0,2\\}$};\n    \\node at (10,-13.5) {$\\{0,1\\}$};\n    \\node at (14,-13.5) {$\\{0,1,2\\}$};\n\n\n    \\path[draw,thick,->] (-12,-8-0.5) -- (-14,-12+0.5);\n    \\path[draw,thick,->] (-12,-8-0.5) -- (-10,-12+0.5);\n    \\path[draw,thick,->] (-4,-8-0.5) -- (-6,-12+0.5);\n    \\path[draw,thick,->] (-4,-8-0.5) -- (-2,-12+0.5);\n    \\path[draw,thick,->] (4,-8-0.5) -- (2,-12+0.5);\n    \\path[draw,thick,->] (4,-8-0.5) -- (6,-12+0.5);\n    \\path[draw,thick,->] (12,-8-0.5) -- (10,-12+0.5);\n    \\path[draw,thick,->] (12,-8-0.5) -- (14,-12+0.5);\n\\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Method 2}\n\nAnother way to generate subsets is based on\nthe bit representation of integers.\nEach subset of a set of $n$ elements\ncan be represented as a sequence of $n$ bits,\nwhich corresponds to an integer between $0 \\ldots 2^n-1$.\nThe ones in the bit sequence indicate\nwhich elements are included in the subset.\n\nThe usual convention is that\nthe last bit corresponds to element 0,\nthe second last bit corresponds to element 1,\nand so on.\nFor example, the bit representation of 25\nis 11001, which corresponds to the subset $\\{0,3,4\\}$.\n\nThe following code goes through the subsets\nof a set of $n$ elements\n\n\\begin{lstlisting}\nfor (int b = 0; b < (1<<n); b++) {\n    // process subset\n}\n\\end{lstlisting}\n\nThe following code shows how we can find\nthe elements of a subset that corresponds to a bit sequence.\nWhen processing each subset,\nthe code builds a vector that contains the\nelements in the subset.\n\n\\begin{lstlisting}\nfor (int b = 0; b < (1<<n); b++) {\n    vector<int> subset;\n    for (int i = 0; i < n; i++) {\n        if (b&(1<<i)) subset.push_back(i);\n    }\n}\n\\end{lstlisting}\n\n", "chapter_name": "Complete search", "chapter_path": "cphb/chapter05.tex"}, {"section_name": "Generating permutations", "section_content": "\\section{Generating permutations}\n\n\\index{permutation}\n\nNext we consider the problem of generating\nall permutations of a set of $n$ elements.\nFor example, the permutations of $\\{0,1,2\\}$ are\n$(0,1,2)$, $(0,2,1)$, $(1,0,2)$, $(1,2,0)$,\n$(2,0,1)$ and $(2,1,0)$.\nAgain, there are two approaches:\nwe can either use recursion or go through the\npermutations iteratively.\n\n\\subsubsection{Method 1}\n\nLike subsets, permutations can be generated\nusing recursion.\nThe following function \\texttt{search} goes\nthrough the permutations of the set $\\{0,1,\\ldots,n-1\\}$.\nThe function builds a vector \\texttt{permutation}\nthat contains the permutation,\nand the search begins when the function is\ncalled without parameters.\n\n\\begin{lstlisting}\nvoid search() {\n    if (permutation.size() == n) {\n        // process permutation\n    } else {\n        for (int i = 0; i < n; i++) {\n            if (chosen[i]) continue;\n            chosen[i] = true;\n            permutation.push_back(i);\n            search();\n            chosen[i] = false;\n            permutation.pop_back();\n        }\n    }\n}\n\\end{lstlisting}\n\nEach function call adds a new element to\n\\texttt{permutation}.\nThe array \\texttt{chosen} indicates which\nelements are already included in the permutation.\nIf the size of \\texttt{permutation} equals the size of the set,\na permutation has been generated.\n\n\\subsubsection{Method 2}\n\n\\index{next\\_permutation@\\texttt{next\\_permutation}}\n\nAnother method for generating permutations\nis to begin with the permutation\n$\\{0,1,\\ldots,n-1\\}$ and repeatedly\nuse a function that constructs the next permutation\nin increasing order.\nThe C++ standard library contains the function\n\\texttt{next\\_permutation} that can be used for this:\n\n\\begin{lstlisting}\nvector<int> permutation;\nfor (int i = 0; i < n; i++) {\n    permutation.push_back(i);\n}\ndo {\n    // process permutation\n} while (next_permutation(permutation.begin(),permutation.end()));\n\\end{lstlisting}\n\n", "chapter_name": "Complete search", "chapter_path": "cphb/chapter05.tex"}, {"section_name": "Backtracking", "section_content": "\\section{Backtracking}\n\n\\index{backtracking}\n\nA \\key{backtracking} algorithm\nbegins with an empty solution\nand extends the solution step by step.\nThe search recursively\ngoes through all different ways how\na solution can be constructed.\n\n\\index{queen problem}\n\nAs an example, consider the problem of\ncalculating the number\nof ways $n$ queens can be placed on\nan $n \\times n$ chessboard so that\nno two queens attack each other.\nFor example, when $n=4$,\nthere are two possible solutions:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n  \\begin{scope}\n    \\draw (0, 0) grid (4, 4);\n    \\node at (1.5,3.5) {\\symqueen};\n    \\node at (3.5,2.5) {\\symqueen};\n    \\node at (0.5,1.5) {\\symqueen};\n    \\node at (2.5,0.5) {\\symqueen};\n\n    \\draw (6, 0) grid (10, 4);\n    \\node at (6+2.5,3.5) {\\symqueen};\n    \\node at (6+0.5,2.5) {\\symqueen};\n    \\node at (6+3.5,1.5) {\\symqueen};\n    \\node at (6+1.5,0.5) {\\symqueen};\n\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nThe problem can be solved using backtracking\nby placing queens to the board row by row.\nMore precisely, exactly one queen will\nbe placed on each row so that no queen attacks\nany of the queens placed before.\nA solution has been found when all\n$n$ queens have been placed on the board.\n\nFor example, when $n=4$,\nsome partial solutions generated by\nthe backtracking algorithm are as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\draw (0, 0) grid (4, 4);\n\n    \\draw (-9, -6) grid (-5, -2);\n    \\draw (-3, -6) grid (1, -2);\n    \\draw (3, -6) grid (7, -2);\n    \\draw (9, -6) grid (13, -2);\n\n    \\node at (-9+0.5,-3+0.5) {\\symqueen};\n    \\node at (-3+1+0.5,-3+0.5) {\\symqueen};\n    \\node at (3+2+0.5,-3+0.5) {\\symqueen};\n    \\node at (9+3+0.5,-3+0.5) {\\symqueen};\n\n    \\draw (2,0) -- (-7,-2);\n    \\draw (2,0) -- (-1,-2);\n    \\draw (2,0) -- (5,-2);\n    \\draw (2,0) -- (11,-2);\n\n    \\draw (-11, -12) grid (-7, -8);\n    \\draw (-6, -12) grid (-2, -8);\n    \\draw (-1, -12) grid (3, -8);\n    \\draw (4, -12) grid (8, -8);\n    \\draw[white] (11, -12) grid (15, -8);\n    \\node at (-11+1+0.5,-9+0.5) {\\symqueen};\n    \\node at (-6+1+0.5,-9+0.5) {\\symqueen};\n    \\node at (-1+1+0.5,-9+0.5) {\\symqueen};\n    \\node at (4+1+0.5,-9+0.5) {\\symqueen};\n    \\node at (-11+0+0.5,-10+0.5) {\\symqueen};\n    \\node at (-6+1+0.5,-10+0.5) {\\symqueen};\n    \\node at (-1+2+0.5,-10+0.5) {\\symqueen};\n    \\node at (4+3+0.5,-10+0.5) {\\symqueen};\n\n    \\draw (-1,-6) -- (-9,-8);\n    \\draw (-1,-6) -- (-4,-8);\n    \\draw (-1,-6) -- (1,-8);\n    \\draw (-1,-6) -- (6,-8);\n\n    \\node at (-9,-13) {illegal};\n    \\node at (-4,-13) {illegal};\n    \\node at (1,-13) {illegal};\n    \\node at (6,-13) {valid};\n\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nAt the bottom level, the three first configurations\nare illegal, because the queens attack each other.\nHowever, the fourth configuration is valid\nand it can be extended to a complete solution by\nplacing two more queens to the board.\nThere is only one way to place the two remaining queens.\n\n\\begin{samepage}\nThe algorithm can be implemented as follows:\n\\begin{lstlisting}\nvoid search(int y) {\n    if (y == n) {\n        count++;\n        return;\n    }\n    for (int x = 0; x < n; x++) {\n        if (column[x] || diag1[x+y] || diag2[x-y+n-1]) continue;\n        column[x] = diag1[x+y] = diag2[x-y+n-1] = 1;\n        search(y+1);\n        column[x] = diag1[x+y] = diag2[x-y+n-1] = 0;\n    }\n}\n\\end{lstlisting}\n\\end{samepage}\nThe search begins by calling \\texttt{search(0)}.\nThe size of the board is $n \\times n$,\nand the code calculates the number of solutions\nto \\texttt{count}.\n\nThe code assumes that the rows and columns\nof the board are numbered from 0 to $n-1$.\nWhen the function \\texttt{search} is\ncalled with parameter $y$,\nit places a queen on row $y$\nand then calls itself with parameter $y+1$.\nThen, if $y=n$, a solution has been found\nand the variable \\texttt{count} is increased by one.\n\nThe array \\texttt{column} keeps track of columns\nthat contain a queen,\nand the arrays \\texttt{diag1} and \\texttt{diag2}\nkeep track of diagonals.\nIt is not allowed to add another queen to a\ncolumn or diagonal that already contains a queen. \nFor example, the columns and diagonals of\nthe $4 \\times 4$ board are numbered as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n  \\begin{scope}\n    \\draw (0-6, 0) grid (4-6, 4);\n    \\node at (-6+0.5,3.5) {$0$};\n    \\node at (-6+1.5,3.5) {$1$};\n    \\node at (-6+2.5,3.5) {$2$};\n    \\node at (-6+3.5,3.5) {$3$};\n    \\node at (-6+0.5,2.5) {$0$};\n    \\node at (-6+1.5,2.5) {$1$};\n    \\node at (-6+2.5,2.5) {$2$};\n    \\node at (-6+3.5,2.5) {$3$};\n    \\node at (-6+0.5,1.5) {$0$};\n    \\node at (-6+1.5,1.5) {$1$};\n    \\node at (-6+2.5,1.5) {$2$};\n    \\node at (-6+3.5,1.5) {$3$};\n    \\node at (-6+0.5,0.5) {$0$};\n    \\node at (-6+1.5,0.5) {$1$};\n    \\node at (-6+2.5,0.5) {$2$};\n    \\node at (-6+3.5,0.5) {$3$};\n\n    \\draw (0, 0) grid (4, 4);\n    \\node at (0.5,3.5) {$0$};\n    \\node at (1.5,3.5) {$1$};\n    \\node at (2.5,3.5) {$2$};\n    \\node at (3.5,3.5) {$3$};\n    \\node at (0.5,2.5) {$1$};\n    \\node at (1.5,2.5) {$2$};\n    \\node at (2.5,2.5) {$3$};\n    \\node at (3.5,2.5) {$4$};\n    \\node at (0.5,1.5) {$2$};\n    \\node at (1.5,1.5) {$3$};\n    \\node at (2.5,1.5) {$4$};\n    \\node at (3.5,1.5) {$5$};\n    \\node at (0.5,0.5) {$3$};\n    \\node at (1.5,0.5) {$4$};\n    \\node at (2.5,0.5) {$5$};\n    \\node at (3.5,0.5) {$6$};\n\n    \\draw (6, 0) grid (10, 4);\n    \\node at (6.5,3.5) {$3$};\n    \\node at (7.5,3.5) {$4$};\n    \\node at (8.5,3.5) {$5$};\n    \\node at (9.5,3.5) {$6$};\n    \\node at (6.5,2.5) {$2$};\n    \\node at (7.5,2.5) {$3$};\n    \\node at (8.5,2.5) {$4$};\n    \\node at (9.5,2.5) {$5$};\n    \\node at (6.5,1.5) {$1$};\n    \\node at (7.5,1.5) {$2$};\n    \\node at (8.5,1.5) {$3$};\n    \\node at (9.5,1.5) {$4$};\n    \\node at (6.5,0.5) {$0$};\n    \\node at (7.5,0.5) {$1$};\n    \\node at (8.5,0.5) {$2$};\n    \\node at (9.5,0.5) {$3$};\n\n    \\node at (-4,-1) {\\texttt{column}};\n    \\node at (2,-1) {\\texttt{diag1}};\n    \\node at (8,-1) {\\texttt{diag2}};\n\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nLet $q(n)$ denote the number of ways\nto place $n$ queens on an $n \\times n$ chessboard.\nThe above backtracking\nalgorithm tells us that, for example, $q(8)=92$.\nWhen $n$ increases, the search quickly becomes slow,\nbecause the number of solutions increases\nexponentially.\nFor example, calculating $q(16)=14772512$\nusing the above algorithm already takes about a minute\non a modern computer\\footnote{There is no known way to efficiently\ncalculate larger values of $q(n)$. The current record is\n$q(27)=234907967154122528$, calculated in 2016 \\cite{q27}.}.\n\n", "chapter_name": "Complete search", "chapter_path": "cphb/chapter05.tex"}, {"section_name": "Pruning the search", "section_content": "\\section{Pruning the search}\n\nWe can often optimize backtracking\nby pruning the search tree.\nThe idea is to add ''intelligence'' to the algorithm\nso that it will notice as soon as possible\nif a partial solution cannot be extended\nto a complete solution.\nSuch optimizations can have a tremendous\neffect on the efficiency of the search.\n\nLet us consider the problem\nof calculating the number of paths\nin an $n \\times n$ grid from the upper-left corner\nto the lower-right corner such that the\npath visits each square exactly once.\nFor example, in a $7 \\times 7$ grid,\nthere are 111712 such paths.\nOne of the paths is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\draw (0, 0) grid (7, 7);\n    \\draw[thick,->] (0.5,6.5) -- (0.5,4.5) -- (2.5,4.5) --\n          (2.5,3.5) -- (0.5,3.5) -- (0.5,0.5) --\n          (3.5,0.5) -- (3.5,1.5) -- (1.5,1.5) --\n          (1.5,2.5) -- (4.5,2.5) -- (4.5,0.5) --\n          (5.5,0.5) -- (5.5,3.5) -- (3.5,3.5) --\n          (3.5,5.5) -- (1.5,5.5) -- (1.5,6.5) --\n          (4.5,6.5) -- (4.5,4.5) -- (5.5,4.5) --\n          (5.5,6.5) -- (6.5,6.5) -- (6.5,0.5);\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nWe focus on the $7 \\times 7$ case,\nbecause its level of difficulty is appropriate to our needs.\nWe begin with a straightforward backtracking algorithm,\nand then optimize it step by step using observations\nof how the search can be pruned.\nAfter each optimization, we measure the running time\nof the algorithm and the number of recursive calls,\nso that we clearly see the effect of each\noptimization on the efficiency of the search.\n\n\\subsubsection{Basic algorithm}\n\nThe first version of the algorithm does not contain\nany optimizations. We simply use backtracking to generate\nall possible paths from the upper-left corner to\nthe lower-right corner and count the number of such paths.\n\n\\begin{itemize}\n\\item\nrunning time: 483 seconds\n\\item\nnumber of recursive calls: 76 billion\n\\end{itemize}\n\n\\subsubsection{Optimization 1}\n\nIn any solution, we first move one step\ndown or right.\nThere are always two paths that \nare symmetric\nabout the diagonal of the grid\nafter the first step.\nFor example, the following paths are symmetric:\n\n\\begin{center}\n\\begin{tabular}{ccc}\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\draw (0, 0) grid (7, 7);\n    \\draw[thick,->] (0.5,6.5) -- (0.5,4.5) -- (2.5,4.5) --\n          (2.5,3.5) -- (0.5,3.5) -- (0.5,0.5) --\n          (3.5,0.5) -- (3.5,1.5) -- (1.5,1.5) --\n          (1.5,2.5) -- (4.5,2.5) -- (4.5,0.5) --\n          (5.5,0.5) -- (5.5,3.5) -- (3.5,3.5) --\n          (3.5,5.5) -- (1.5,5.5) -- (1.5,6.5) --\n          (4.5,6.5) -- (4.5,4.5) -- (5.5,4.5) --\n          (5.5,6.5) -- (6.5,6.5) -- (6.5,0.5);\n  \\end{scope}\n\\end{tikzpicture}\n& \\hspace{20px}\n& \n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}[yscale=1,xscale=-1,rotate=-90]\n    \\draw (0, 0) grid (7, 7);\n    \\draw[thick,->] (0.5,6.5) -- (0.5,4.5) -- (2.5,4.5) --\n          (2.5,3.5) -- (0.5,3.5) -- (0.5,0.5) --\n          (3.5,0.5) -- (3.5,1.5) -- (1.5,1.5) --\n          (1.5,2.5) -- (4.5,2.5) -- (4.5,0.5) --\n          (5.5,0.5) -- (5.5,3.5) -- (3.5,3.5) --\n          (3.5,5.5) -- (1.5,5.5) -- (1.5,6.5) --\n          (4.5,6.5) -- (4.5,4.5) -- (5.5,4.5) --\n          (5.5,6.5) -- (6.5,6.5) -- (6.5,0.5);\n  \\end{scope}\n\\end{tikzpicture}\n\\end{tabular}\n\\end{center}\n\nHence, we can decide that we always first\nmove one step down (or right),\nand finally multiply the number of solutions by two.\n\n\\begin{itemize}\n\\item\nrunning time: 244 seconds\n\\item\nnumber of recursive calls: 38 billion\n\\end{itemize}\n\n\\subsubsection{Optimization 2}\n\nIf the path reaches the lower-right square\nbefore it has visited all other squares of the grid,\nit is clear that\nit will not be possible to complete the solution.\nAn example of this is the following path:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\draw (0, 0) grid (7, 7);\n    \\draw[thick,->] (0.5,6.5) -- (0.5,4.5) -- (2.5,4.5) --\n          (2.5,3.5) -- (0.5,3.5) -- (0.5,0.5) --\n          (3.5,0.5) -- (3.5,1.5) -- (1.5,1.5) --\n          (1.5,2.5) -- (4.5,2.5) -- (4.5,0.5) --\n          (6.5,0.5);\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\nUsing this observation, we can terminate the search\nimmediately if we reach the lower-right square too early.\n\\begin{itemize}\n\\item\nrunning time: 119 seconds\n\\item\nnumber of recursive calls: 20 billion\n\\end{itemize}\n\n\\subsubsection{Optimization 3}\n\nIf the path touches a wall\nand can turn either left or right,\nthe grid splits into two parts\nthat contain unvisited squares.\nFor example, in the following situation,\nthe path can turn either left or right:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\draw (0, 0) grid (7, 7);\n    \\draw[thick,->] (0.5,6.5) -- (0.5,4.5) -- (2.5,4.5) --\n          (2.5,3.5) -- (0.5,3.5) -- (0.5,0.5) --\n          (3.5,0.5) -- (3.5,1.5) -- (1.5,1.5) --\n          (1.5,2.5) -- (4.5,2.5) -- (4.5,0.5) --\n          (5.5,0.5) -- (5.5,6.5);\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\nIn this case, we cannot visit all squares anymore,\nso we can terminate the search.\nThis optimization is very useful:\n\n\\begin{itemize}\n\\item\nrunning time: 1.8 seconds\n\\item\nnumber of recursive calls: 221 million\n\\end{itemize}\n\n\\subsubsection{Optimization 4}\n\nThe idea of Optimization 3\ncan be generalized:\nif the path cannot continue forward\nbut can turn either left or right,\nthe grid splits into two parts\nthat both contain unvisited squares.\nFor example, consider the following path:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\draw (0, 0) grid (7, 7);\n    \\draw[thick,->] (0.5,6.5) -- (0.5,4.5) -- (2.5,4.5) --\n          (2.5,3.5) -- (0.5,3.5) -- (0.5,0.5) --\n          (3.5,0.5) -- (3.5,1.5) -- (1.5,1.5) --\n          (1.5,2.5) -- (4.5,2.5) -- (4.5,0.5) --\n          (5.5,0.5) -- (5.5,4.5) -- (3.5,4.5);\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\nIt is clear that we cannot visit all squares anymore,\nso we can terminate the search.\nAfter this optimization, the search is\nvery efficient:\n\n\\begin{itemize}\n\\item\nrunning time: 0.6 seconds\n\\item\nnumber of recursive calls: 69 million\n\\end{itemize}\n\n~\\\\\nNow is a good moment to stop optimizing\nthe algorithm and see what we have achieved.\nThe running time of the original algorithm\nwas 483 seconds,\nand now after the optimizations,\nthe running time is only 0.6 seconds.\nThus, the algorithm became nearly 1000 times\nfaster after the optimizations.\n\nThis is a usual phenomenon in backtracking,\nbecause the search tree is usually large\nand even simple observations can effectively\nprune the search.\nEspecially useful are optimizations that\noccur during the first steps of the algorithm,\ni.e., at the top of the search tree.\n\n", "chapter_name": "Complete search", "chapter_path": "cphb/chapter05.tex"}, {"section_name": "Meet in the middle", "section_content": "\\section{Meet in the middle}\n\n\\index{meet in the middle}\n\n\\key{Meet in the middle} is a technique\nwhere the search space is divided into\ntwo parts of about equal size.\nA separate search is performed\nfor both of the parts,\nand finally the results of the searches are combined.\n\nThe technique can be used\nif there is an efficient way to combine the\nresults of the searches.\nIn such a situation, the two searches may require less\ntime than one large search.\nTypically, we can turn a factor of $2^n$\ninto a factor of $2^{n/2}$ using the meet in the\nmiddle technique.\n\nAs an example, consider a problem where\nwe are given a list of $n$ numbers and\na number $x$,\nand we want to find out if it is possible\nto choose some numbers from the list so that\ntheir sum is $x$.\nFor example, given the list $[2,4,5,9]$ and $x=15$,\nwe can choose the numbers $[2,4,9]$ to get $2+4+9=15$.\nHowever, if $x=10$ for the same list,\nit is not possible to form the sum.\n\nA simple algorithm to the problem is to\ngo through all subsets of the elements and\ncheck if the sum of any of the subsets is $x$.\nThe running time of such an algorithm is $O(2^n)$,\nbecause there are $2^n$ subsets.\nHowever, using the meet in the middle technique,\nwe can achieve a more efficient $O(2^{n/2})$ time algorithm\\footnote{This\nidea was introduced in 1974 by E. Horowitz and S. Sahni \\cite{hor74}.}.\nNote that $O(2^n)$ and $O(2^{n/2})$ are different\ncomplexities because $2^{n/2}$ equals $\\sqrt{2^n}$.\n\nThe idea is to divide the list into\ntwo lists $A$ and $B$ such that both\nlists contain about half of the numbers.\nThe first search generates all subsets\nof $A$ and stores their sums to a list $S_A$.\nCorrespondingly, the second search creates\na list $S_B$ from $B$.\nAfter this, it suffices to check if it is possible\nto choose one element from $S_A$ and another\nelement from $S_B$ such that their sum is $x$.\nThis is possible exactly when there is a way to\nform the sum $x$ using the numbers of the original list.\n\nFor example, suppose that the list is $[2,4,5,9]$ and $x=15$.\nFirst, we divide the list into $A=[2,4]$ and $B=[5,9]$.\nAfter this, we create lists\n$S_A=[0,2,4,6]$ and $S_B=[0,5,9,14]$.\nIn this case, the sum $x=15$ is possible to form,\nbecause $S_A$ contains the sum $6$,\n$S_B$ contains the sum $9$, and $6+9=15$.\nThis corresponds to the solution $[2,4,9]$.\n\nWe can implement the algorithm so that\nits time complexity is $O(2^{n/2})$.\nFirst, we generate \\emph{sorted} lists $S_A$ and $S_B$,\nwhich can be done in $O(2^{n/2})$ time using a merge-like technique.\nAfter this, since the lists are sorted,\nwe can check in $O(2^{n/2})$ time if\nthe sum $x$ can be created from $S_A$ and $S_B$.", "chapter_name": "Complete search", "chapter_path": "cphb/chapter05.tex"}, {"section_name": "Coin problem", "section_content": "\\chapter{Greedy algorithms}\n\n\\index{greedy algorithm}\n\nA \\key{greedy algorithm}\nconstructs a solution to the problem\nby always making a choice that looks\nthe best at the moment.\nA greedy algorithm never takes back\nits choices, but directly constructs\nthe final solution.\nFor this reason, greedy algorithms\nare usually very efficient.\n\nThe difficulty in designing greedy algorithms\nis to find a greedy strategy\nthat always produces an optimal solution\nto the problem.\nThe locally optimal choices in a greedy\nalgorithm should also be globally optimal.\nIt is often difficult to argue that\na greedy algorithm works.\n\n\\section{Coin problem}\n\nAs a first example, we consider a problem\nwhere we are given a set of coins\nand our task is to form a sum of money $n$\nusing the coins.\nThe values of the coins are\n$\\texttt{coins}=\\{c_1,c_2,\\ldots,c_k\\}$,\nand each coin can be used as many times we want.\nWhat is the minimum number of coins needed?\n\nFor example, if the coins are the euro coins (in cents)\n\\[\\{1,2,5,10,20,50,100,200\\}\\]\nand $n=520$,\nwe need at least four coins.\nThe optimal solution is to select coins\n$200+200+100+20$ whose sum is 520.\n\n\\subsubsection{Greedy algorithm}\n\nA simple greedy algorithm to the problem\nalways selects the largest possible coin,\nuntil the required sum of money has been constructed.\nThis algorithm works in the example case,\nbecause we first select two 200 cent coins,\nthen one 100 cent coin and finally one 20 cent coin.\nBut does this algorithm always work?\n\nIt turns out that if the coins are the euro coins,\nthe greedy algorithm \\emph{always} works, i.e.,\nit always produces a solution with the fewest\npossible number of coins.\nThe correctness of the algorithm can be\nshown as follows:\n\nFirst, each coin 1, 5, 10, 50 and 100 appears\nat most once in an optimal solution,\nbecause if the\nsolution would contain two such coins,\nwe could replace them by one coin and\nobtain a better solution.\nFor example, if the solution would contain\ncoins $5+5$, we could replace them by coin $10$.\n\nIn the same way, coins 2 and 20 appear\nat most twice in an optimal solution,\nbecause we could replace\ncoins $2+2+2$ by coins $5+1$ and\ncoins $20+20+20$ by coins $50+10$.\nMoreover, an optimal solution cannot contain\ncoins $2+2+1$ or $20+20+10$,\nbecause we could replace them by coins $5$ and $50$.\n\nUsing these observations,\nwe can show for each coin $x$ that\nit is not possible to optimally construct\na sum $x$ or any larger sum by only using coins\nthat are smaller than $x$.\nFor example, if $x=100$, the largest optimal\nsum using the smaller coins is  $50+20+20+5+2+2=99$.\nThus, the greedy algorithm that always selects\nthe largest coin produces the optimal solution.\n\nThis example shows that it can be difficult\nto argue that a greedy algorithm works,\neven if the algorithm itself is simple.\n\n\\subsubsection{General case}\n\nIn the general case, the coin set can contain any coins\nand the greedy algorithm \\emph{does not} necessarily produce\nan optimal solution.\n\nWe can prove that a greedy algorithm does not work\nby showing a counterexample\nwhere the algorithm gives a wrong answer.\nIn this problem we can easily find a counterexample:\nif the coins are $\\{1,3,4\\}$ and the target sum\nis 6, the greedy algorithm produces the solution\n$4+1+1$ while the optimal solution is $3+3$.\n\nIt is not known if the general coin problem\ncan be solved using any greedy algorithm\\footnote{However, it is possible\nto \\emph{check} in polynomial time\nif the greedy algorithm presented in this chapter works for\na given set of coins \\cite{pea05}.}.\nHowever, as we will see in Chapter 7,\nin some cases,\nthe general problem can be efficiently\nsolved using a dynamic\nprogramming algorithm that always gives the\ncorrect answer.\n\n", "chapter_name": "Greedy algorithms", "chapter_path": "cphb/chapter06.tex"}, {"section_name": "Scheduling", "section_content": "\\section{Scheduling}\n\nMany scheduling problems can be solved\nusing greedy algorithms.\nA classic problem is as follows:\nGiven $n$ events with their starting and ending\ntimes, find a schedule\nthat includes as many events as possible.\nIt is not possible to select an event partially.\nFor example, consider the following events:\n\\begin{center}\n\\begin{tabular}{lll}\nevent & starting time & ending time \\\\\n\\hline\n$A$ & 1 & 3 \\\\\n$B$ & 2 & 5 \\\\\n$C$ & 3 & 9 \\\\\n$D$ & 6 & 8 \\\\\n\\end{tabular}\n\\end{center}\nIn this case the maximum number of events is two.\nFor example, we can select events $B$ and $D$\nas follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=.4]\n  \\begin{scope}\n    \\draw (2, 0) rectangle (6, -1);\n    \\draw[fill=lightgray] (4, -1.5) rectangle (10, -2.5);\n    \\draw (6, -3) rectangle (18, -4);\n    \\draw[fill=lightgray] (12, -4.5) rectangle (16, -5.5);\n    \\node at (2.5,-0.5) {$A$};\n    \\node at (4.5,-2) {$B$};\n    \\node at (6.5,-3.5) {$C$};\n    \\node at (12.5,-5) {$D$};\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nIt is possible to invent several greedy algorithms\nfor the problem, but which of them works in every case?\n\n\\subsubsection*{Algorithm 1}\n\nThe first idea is to select as \\emph{short}\nevents as possible.\nIn the example case this algorithm\nselects the following events:\n\\begin{center}\n\\begin{tikzpicture}[scale=.4]\n  \\begin{scope}\n    \\draw[fill=lightgray] (2, 0) rectangle (6, -1);\n    \\draw (4, -1.5) rectangle (10, -2.5);\n    \\draw (6, -3) rectangle (18, -4);\n    \\draw[fill=lightgray] (12, -4.5) rectangle (16, -5.5);\n    \\node at (2.5,-0.5) {$A$};\n    \\node at (4.5,-2) {$B$};\n    \\node at (6.5,-3.5) {$C$};\n    \\node at (12.5,-5) {$D$};\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nHowever, selecting short events is not always\na correct strategy. For example, the algorithm fails\nin the following case:\n\\begin{center}\n\\begin{tikzpicture}[scale=.4]\n  \\begin{scope}\n    \\draw (1, 0) rectangle (7, -1);\n    \\draw[fill=lightgray] (6, -1.5) rectangle (9, -2.5);\n    \\draw (8, -3) rectangle (14, -4);\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\nIf we select the short event, we can only select one event.\nHowever, it would be possible to select both long events.\n\n\\subsubsection*{Algorithm 2}\n\nAnother idea is to always select the next possible\nevent that \\emph{begins} as \\emph{early} as possible.\nThis algorithm selects the following events:\n\\begin{center}\n\\begin{tikzpicture}[scale=.4]\n  \\begin{scope}\n    \\draw[fill=lightgray] (2, 0) rectangle (6, -1);\n    \\draw (4, -1.5) rectangle (10, -2.5);\n    \\draw[fill=lightgray] (6, -3) rectangle (18, -4);\n    \\draw (12, -4.5) rectangle (16, -5.5);\n    \\node at (2.5,-0.5) {$A$};\n    \\node at (4.5,-2) {$B$};\n    \\node at (6.5,-3.5) {$C$};\n    \\node at (12.5,-5) {$D$};\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nHowever, we can find a counterexample\nalso for this algorithm.\nFor example, in the following case,\nthe algorithm only selects one event:\n\\begin{center}\n\\begin{tikzpicture}[scale=.4]\n  \\begin{scope}\n    \\draw[fill=lightgray] (1, 0) rectangle (14, -1);\n    \\draw (3, -1.5) rectangle (7, -2.5);\n    \\draw (8, -3) rectangle (12, -4);\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\nIf we select the first event, it is not possible\nto select any other events.\nHowever, it would be possible to select the\nother two events.\n\n\\subsubsection*{Algorithm 3}\n\nThe third idea is to always select the next\npossible event that \\emph{ends} as \\emph{early} as possible.\nThis algorithm selects the following events: \n\\begin{center}\n\\begin{tikzpicture}[scale=.4]\n  \\begin{scope}\n    \\draw[fill=lightgray] (2, 0) rectangle (6, -1);\n    \\draw (4, -1.5) rectangle (10, -2.5);\n    \\draw (6, -3) rectangle (18, -4);\n    \\draw[fill=lightgray] (12, -4.5) rectangle (16, -5.5);\n    \\node at (2.5,-0.5) {$A$};\n    \\node at (4.5,-2) {$B$};\n    \\node at (6.5,-3.5) {$C$};\n    \\node at (12.5,-5) {$D$};\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nIt turns out that this algorithm\n\\emph{always} produces an optimal solution.\nThe reason for this is that it is always an optimal choice\nto first select an event that ends\nas early as possible.\nAfter this, it is an optimal choice\nto select the next event\nusing the same strategy, etc.,\nuntil we cannot select any more events.\n\nOne way to argue that the algorithm works\nis to consider\nwhat happens if we first select an event\nthat ends later than the event that ends\nas early as possible.\nNow, we will have at most an equal number of\nchoices how we can select the next event.\nHence, selecting an event that ends later\ncan never yield a better solution,\nand the greedy algorithm is correct.\n\n", "chapter_name": "Greedy algorithms", "chapter_path": "cphb/chapter06.tex"}, {"section_name": "Tasks and deadlines", "section_content": "\\section{Tasks and deadlines}\n\nLet us now consider a problem where\nwe are given $n$ tasks with durations and deadlines\nand our task is to choose an order to perform the tasks.\nFor each task, we earn $d-x$ points\nwhere $d$ is the task's deadline\nand $x$ is the moment when we finish the task.\nWhat is the largest possible total score\nwe can obtain?\n\nFor example, suppose that the tasks are as follows:\n\\begin{center}\n\\begin{tabular}{lll}\ntask & duration & deadline \\\\\n\\hline\n$A$ & 4 & 2 \\\\\n$B$ & 3 & 5 \\\\\n$C$ & 2 & 7 \\\\\n$D$ & 4 & 5 \\\\\n\\end{tabular}\n\\end{center}\nIn this case, an optimal schedule for the tasks\nis as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=.4]\n  \\begin{scope}\n    \\draw (0, 0) rectangle (4, -1);\n    \\draw (4, 0) rectangle (10, -1);\n    \\draw (10, 0) rectangle (18, -1);\n    \\draw (18, 0) rectangle (26, -1);\n    \\node at (0.5,-0.5) {$C$};\n    \\node at (4.5,-0.5) {$B$};\n    \\node at (10.5,-0.5) {$A$};\n    \\node at (18.5,-0.5) {$D$};\n\n    \\draw (0,1.5) -- (26,1.5);\n    \\foreach \\i in {0,2,...,26}\n    {\n        \\draw (\\i,1.25) -- (\\i,1.75);\n    }\n    \\footnotesize\n    \\node at (0,2.5) {0};\n    \\node at (10,2.5) {5};\n    \\node at (20,2.5) {10};\n\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\nIn this solution, $C$ yields 5 points,\n$B$ yields 0 points, $A$ yields $-7$ points\nand $D$ yields $-8$ points,\nso the total score is $-10$.\n\nSurprisingly, the optimal solution to the problem\ndoes not depend on the deadlines at all,\nbut a correct greedy strategy is to simply\nperform the tasks \\emph{sorted by their durations}\nin increasing order.\nThe reason for this is that if we ever perform\ntwo tasks one after another such that the first task\ntakes longer than the second task,\nwe can obtain a better solution if we swap the tasks.\nFor example, consider the following schedule:\n\\begin{center}\n\\begin{tikzpicture}[scale=.4]\n  \\begin{scope}\n    \\draw (0, 0) rectangle (8, -1);\n    \\draw (8, 0) rectangle (12, -1);\n    \\node at (0.5,-0.5) {$X$};\n    \\node at (8.5,-0.5) {$Y$};\n\n\\draw [decoration={brace}, decorate, line width=0.3mm] (7.75,-1.5) -- (0.25,-1.5);\n\\draw [decoration={brace}, decorate, line width=0.3mm] (11.75,-1.5) -- (8.25,-1.5);\n\n\\footnotesize\n\\node at (4,-2.5) {$a$};\n\\node at (10,-2.5) {$b$};\n\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\nHere $a>b$, so we should swap the tasks:\n\\begin{center}\n\\begin{tikzpicture}[scale=.4]\n  \\begin{scope}\n    \\draw (0, 0) rectangle (4, -1);\n    \\draw (4, 0) rectangle (12, -1);\n    \\node at (0.5,-0.5) {$Y$};\n    \\node at (4.5,-0.5) {$X$};\n\n\\draw [decoration={brace}, decorate, line width=0.3mm] (3.75,-1.5) -- (0.25,-1.5);\n\\draw [decoration={brace}, decorate, line width=0.3mm] (11.75,-1.5) -- (4.25,-1.5);\n\n\\footnotesize\n\\node at (2,-2.5) {$b$};\n\\node at (8,-2.5) {$a$};\n\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\nNow $X$ gives $b$ points less and $Y$ gives $a$ points more,\nso the total score increases by $a-b > 0$.\nIn an optimal solution,\nfor any two consecutive tasks,\nit must hold that the shorter task comes\nbefore the longer task.\nThus, the tasks must be performed\nsorted by their durations.\n\n", "chapter_name": "Greedy algorithms", "chapter_path": "cphb/chapter06.tex"}, {"section_name": "Minimizing sums", "section_content": "\\section{Minimizing sums}\n\nWe next consider a problem where\nwe are given $n$ numbers $a_1,a_2,\\ldots,a_n$\nand our task is to find a value $x$\nthat minimizes the sum\n\\[|a_1-x|^c+|a_2-x|^c+\\cdots+|a_n-x|^c.\\]\nWe focus on the cases $c=1$ and $c=2$.\n\n\\subsubsection{Case $c=1$}\n\nIn this case, we should minimize the sum\n\\[|a_1-x|+|a_2-x|+\\cdots+|a_n-x|.\\]\nFor example, if the numbers are $[1,2,9,2,6]$,\nthe best solution is to select $x=2$\nwhich produces the sum\n\\[\n|1-2|+|2-2|+|9-2|+|2-2|+|6-2|=12.\n\\]\nIn the general case, the best choice for $x$\nis the \\textit{median} of the numbers,\ni.e., the middle number after sorting.\nFor example, the list $[1,2,9,2,6]$\nbecomes $[1,2,2,6,9]$ after sorting,\nso the median is 2.\n\nThe median is an optimal choice,\nbecause if $x$ is smaller than the median,\nthe sum becomes smaller by increasing $x$,\nand if $x$ is larger then the median,\nthe sum becomes smaller by decreasing $x$.\nHence, the optimal solution is that $x$\nis the median.\nIf $n$ is even and there are two medians,\nboth medians and all values between them\nare optimal choices.\n\n\\subsubsection{Case $c=2$}\n\nIn this case, we should minimize the sum\n\\[(a_1-x)^2+(a_2-x)^2+\\cdots+(a_n-x)^2.\\]\nFor example, if the numbers are $[1,2,9,2,6]$,\nthe best solution is to select $x=4$\nwhich produces the sum\n\\[\n(1-4)^2+(2-4)^2+(9-4)^2+(2-4)^2+(6-4)^2=46.\n\\]\nIn the general case, the best choice for $x$\nis the \\emph{average} of the numbers.\nIn the example the average is $(1+2+9+2+6)/5=4$.\nThis result can be derived by presenting\nthe sum as follows:\n\\[\nnx^2 - 2x(a_1+a_2+\\cdots+a_n) + (a_1^2+a_2^2+\\cdots+a_n^2)\n\\]\nThe last part does not depend on $x$,\nso we can ignore it.\nThe remaining parts form a function\n$nx^2-2xs$ where $s=a_1+a_2+\\cdots+a_n$.\nThis is a parabola opening upwards\nwith roots $x=0$ and $x=2s/n$,\nand the minimum value is the average\nof the roots $x=s/n$, i.e.,\nthe average of the numbers $a_1,a_2,\\ldots,a_n$.\n\n", "chapter_name": "Greedy algorithms", "chapter_path": "cphb/chapter06.tex"}, {"section_name": "Data compression", "section_content": "\\section{Data compression}\n\n\\index{data compression}\n\\index{binary code}\n\\index{codeword}\n\nA \\key{binary code} assigns for each character\nof a string a \\key{codeword} that consists of bits.\nWe can \\emph{compress} the string using the binary code\nby replacing each character by the\ncorresponding codeword.\nFor example, the following binary code\nassigns codewords for characters\n\\texttt{A}\u2013\\texttt{D}:\n\\begin{center}\n\\begin{tabular}{rr}\ncharacter & codeword \\\\\n\\hline\n\\texttt{A} & 00 \\\\\n\\texttt{B} & 01 \\\\\n\\texttt{C} & 10 \\\\\n\\texttt{D} & 11 \\\\\n\\end{tabular}\n\\end{center}\nThis is a \\key{constant-length} code\nwhich means that the length of each\ncodeword is the same.\nFor example, we can compress the string\n\\texttt{AABACDACA} as follows:\n\\[00\\,00\\,01\\,00\\,10\\,11\\,00\\,10\\,00\\]\nUsing this code, the length of the compressed\nstring is 18 bits.\nHowever, we can compress the string better\nif we use a \\key{variable-length} code\nwhere codewords may have different lengths.\nThen we can give short codewords for\ncharacters that appear often\nand long codewords for characters\nthat appear rarely.\nIt turns out that an \\key{optimal} code\nfor the above string is as follows:\n\\begin{center}\n\\begin{tabular}{rr}\ncharacter & codeword \\\\\n\\hline\n\\texttt{A} & 0 \\\\\n\\texttt{B} & 110 \\\\\n\\texttt{C} & 10 \\\\\n\\texttt{D} & 111 \\\\\n\\end{tabular}\n\\end{center}\nAn optimal code produces a compressed string\nthat is as short as possible.\nIn this case, the compressed string using\nthe optimal code is\n\\[0\\,0\\,110\\,0\\,10\\,111\\,0\\,10\\,0,\\]\nso only 15 bits are needed instead of 18 bits.\nThus, thanks to a better code it was possible to\nsave 3 bits in the compressed string.\n\nWe require that no codeword\nis a prefix of another codeword.\nFor example, it is not allowed that a code\nwould contain both codewords 10\nand 1011.\nThe reason for this is that we want\nto be able to generate the original string\nfrom the compressed string.\nIf a codeword could be a prefix of another codeword,\nthis would not always be possible.\nFor example, the following code is \\emph{not} valid:\n\\begin{center}\n\\begin{tabular}{rr}\ncharacter & codeword \\\\\n\\hline\n\\texttt{A} & 10 \\\\\n\\texttt{B} & 11 \\\\\n\\texttt{C} & 1011 \\\\\n\\texttt{D} & 111 \\\\\n\\end{tabular}\n\\end{center}\nUsing this code, it would not be possible to know\nif the compressed string 1011 corresponds to\nthe string \\texttt{AB} or the string \\texttt{C}.\n\n\\index{Huffman coding}\n\n\\subsubsection{Huffman coding}\n\n\\key{Huffman coding}\\footnote{D. A. Huffman discovered this method\nwhen solving a university course assignment\nand published the algorithm in 1952 \\cite{huf52}.} is a greedy algorithm\nthat constructs an optimal code for\ncompressing a given string.\nThe algorithm builds a binary tree\nbased on the frequencies of the characters\nin the string,\nand each character's codeword can be read\nby following a path from the root to\nthe corresponding node.\nA move to the left corresponds to bit 0,\nand a move to the right corresponds to bit 1.\n\nInitially, each character of the string is\nrepresented by a node whose weight is the\nnumber of times the character occurs in the string.\nThen at each step two nodes with minimum weights\nare combined by creating\na new node whose weight is the sum of the weights\nof the original nodes.\nThe process continues until all nodes have been combined.\n\nNext we will see how Huffman coding creates\nthe optimal code for the string\n\\texttt{AABACDACA}.\nInitially, there are four nodes that correspond\nto the characters of the string:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$5$};\n\\node[draw, circle] (2) at (2,0) {$1$};\n\\node[draw, circle] (3) at (4,0) {$2$};\n\\node[draw, circle] (4) at (6,0) {$1$};\n\n\\node[color=blue] at (0,-0.75) {\\texttt{A}};\n\\node[color=blue] at (2,-0.75) {\\texttt{B}};\n\\node[color=blue] at (4,-0.75) {\\texttt{C}};\n\\node[color=blue] at (6,-0.75) {\\texttt{D}};\n\n%\\path[draw,thick,-] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\nThe node that represents character \\texttt{A}\nhas weight 5 because character \\texttt{A}\nappears 5 times in the string.\nThe other weights have been calculated\nin the same way.\n\nThe first step is to combine the nodes that\ncorrespond to characters \\texttt{B} and \\texttt{D},\nboth with weight 1.\nThe result is:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$5$};\n\\node[draw, circle] (3) at (2,0) {$2$};\n\\node[draw, circle] (2) at (4,0) {$1$};\n\\node[draw, circle] (4) at (6,0) {$1$};\n\\node[draw, circle] (5) at (5,1) {$2$};\n\n\\node[color=blue] at (0,-0.75) {\\texttt{A}};\n\\node[color=blue] at (2,-0.75) {\\texttt{C}};\n\\node[color=blue] at (4,-0.75) {\\texttt{B}};\n\\node[color=blue] at (6,-0.75) {\\texttt{D}};\n\n\\node at (4.3,0.7) {0};\n\\node at (5.7,0.7) {1};\n\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\nAfter this, the nodes with weight 2 are combined:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,0) {$5$};\n\\node[draw, circle] (3) at (3,1) {$2$};\n\\node[draw, circle] (2) at (4,0) {$1$};\n\\node[draw, circle] (4) at (6,0) {$1$};\n\\node[draw, circle] (5) at (5,1) {$2$};\n\\node[draw, circle] (6) at (4,2) {$4$};\n\n\\node[color=blue] at (1,-0.75) {\\texttt{A}};\n\\node[color=blue] at (3,1-0.75) {\\texttt{C}};\n\\node[color=blue] at (4,-0.75) {\\texttt{B}};\n\\node[color=blue] at (6,-0.75) {\\texttt{D}};\n\n\\node at (4.3,0.7) {0};\n\\node at (5.7,0.7) {1};\n\\node at (3.3,1.7) {0};\n\\node at (4.7,1.7) {1};\n\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (5) -- (6);\n\\end{tikzpicture}\n\\end{center}\nFinally, the two remaining nodes are combined:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (2,2) {$5$};\n\\node[draw, circle] (3) at (3,1) {$2$};\n\\node[draw, circle] (2) at (4,0) {$1$};\n\\node[draw, circle] (4) at (6,0) {$1$};\n\\node[draw, circle] (5) at (5,1) {$2$};\n\\node[draw, circle] (6) at (4,2) {$4$};\n\\node[draw, circle] (7) at (3,3) {$9$};\n\n\\node[color=blue] at (2,2-0.75) {\\texttt{A}};\n\\node[color=blue] at (3,1-0.75) {\\texttt{C}};\n\\node[color=blue] at (4,-0.75) {\\texttt{B}};\n\\node[color=blue] at (6,-0.75) {\\texttt{D}};\n\n\\node at (4.3,0.7) {0};\n\\node at (5.7,0.7) {1};\n\\node at (3.3,1.7) {0};\n\\node at (4.7,1.7) {1};\n\\node at (2.3,2.7) {0};\n\\node at (3.7,2.7) {1};\n\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (5) -- (6);\n\\path[draw,thick,-] (1) -- (7);\n\\path[draw,thick,-] (6) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nNow all nodes are in the tree, so the code is ready.\nThe following codewords can be read from the tree:\n\\begin{center}\n\\begin{tabular}{rr}\ncharacter & codeword \\\\\n\\hline\n\\texttt{A} & 0 \\\\\n\\texttt{B} & 110 \\\\\n\\texttt{C} & 10 \\\\\n\\texttt{D} & 111 \\\\\n\\end{tabular}\n\\end{center}\n", "chapter_name": "Greedy algorithms", "chapter_path": "cphb/chapter06.tex"}, {"section_name": "Coin problem", "section_content": "\\chapter{Dynamic programming}\n\n\\index{dynamic programming}\n\n\\key{Dynamic programming}\nis a technique that combines the correctness\nof complete search and the efficiency\nof greedy algorithms.\nDynamic programming can be applied if the\nproblem can be divided into overlapping subproblems\nthat can be solved independently.\n\nThere are two uses for dynamic programming:\n\n\\begin{itemize}\n\\item\n\\key{Finding an optimal solution}:\nWe want to find a solution that is\nas large as possible or as small as possible.\n\\item\n\\key{Counting the number of solutions}:\nWe want to calculate the total number of\npossible solutions.\n\\end{itemize}\n\nWe will first see how dynamic programming can\nbe used to find an optimal solution,\nand then we will use the same idea for\ncounting the solutions.\n\nUnderstanding dynamic programming is a milestone\nin every competitive programmer's career.\nWhile the basic idea is simple,\nthe challenge is how to apply\ndynamic programming to different problems.\nThis chapter introduces a set of classic problems\nthat are a good starting point.\n\n\\section{Coin problem}\n\nWe first focus on a problem that we\nhave already seen in Chapter 6:\nGiven a set of coin values $\\texttt{coins} = \\{c_1,c_2,\\ldots,c_k\\}$\nand a target sum of money $n$, our task is to\nform the sum $n$ using as few coins as possible.\n\nIn Chapter 6, we solved the problem using a\ngreedy algorithm that always chooses the largest\npossible coin.\nThe greedy algorithm works, for example,\nwhen the coins are the euro coins,\nbut in the general case the greedy algorithm\ndoes not necessarily produce an optimal solution.\n\nNow is time to solve the problem efficiently\nusing dynamic programming, so that the algorithm\nworks for any coin set.\nThe dynamic programming\nalgorithm is based on a recursive function\nthat goes through all possibilities how to\nform the sum, like a brute force algorithm.\nHowever, the dynamic programming\nalgorithm is efficient because\nit uses \\emph{memoization} and\ncalculates the answer to each subproblem only once.\n\n\\subsubsection{Recursive formulation}\n\nThe idea in dynamic programming is to\nformulate the problem recursively so\nthat the solution to the problem can be\ncalculated from solutions to smaller\nsubproblems.\nIn the coin problem, a natural recursive\nproblem is as follows:\nwhat is the smallest number of coins\nrequired to form a sum $x$?\n\nLet $\\texttt{solve}(x)$\ndenote the minimum\nnumber of coins required for a sum $x$.\nThe values of the function depend on the\nvalues of the coins.\nFor example, if $\\texttt{coins} = \\{1,3,4\\}$,\nthe first values of the function are as follows:\n\n\\[\n\\begin{array}{lcl}\n\\texttt{solve}(0) & = & 0 \\\\\n\\texttt{solve}(1) & = & 1 \\\\\n\\texttt{solve}(2) & = & 2 \\\\\n\\texttt{solve}(3) & = & 1 \\\\\n\\texttt{solve}(4) & = & 1 \\\\\n\\texttt{solve}(5) & = & 2 \\\\\n\\texttt{solve}(6) & = & 2 \\\\\n\\texttt{solve}(7) & = & 2 \\\\\n\\texttt{solve}(8) & = & 2 \\\\\n\\texttt{solve}(9) & = & 3 \\\\\n\\texttt{solve}(10) & = & 3 \\\\\n\\end{array}\n\\]\n\nFor example, $\\texttt{solve}(10)=3$,\nbecause at least 3 coins are needed\nto form the sum 10.\nThe optimal solution is $3+3+4=10$.\n\nThe essential property of $\\texttt{solve}$ is\nthat its values can be\nrecursively calculated from its smaller values.\nThe idea is to focus on the \\emph{first}\ncoin that we choose for the sum.\nFor example, in the above scenario,\nthe first coin can be either 1, 3 or 4.\nIf we first choose coin 1,\nthe remaining task is to form the sum 9\nusing the minimum number of coins,\nwhich is a subproblem of the original problem.\nOf course, the same applies to coins 3 and 4.\nThus, we can use the following recursive formula\nto calculate the minimum number of coins:\n\\begin{equation*}\n\\begin{split}\n\\texttt{solve}(x) = \\min( & \\texttt{solve}(x-1)+1, \\\\\n                           & \\texttt{solve}(x-3)+1, \\\\\n                           & \\texttt{solve}(x-4)+1).\n\\end{split}\n\\end{equation*}\nThe base case of the recursion is $\\texttt{solve}(0)=0$,\nbecause no coins are needed to form an empty sum.\nFor example,\n\\[ \\texttt{solve}(10) = \\texttt{solve}(7)+1 = \\texttt{solve}(4)+2 = \\texttt{solve}(0)+3 = 3.\\]\n\nNow we are ready to give a general recursive function\nthat calculates the minimum number of\ncoins needed to form a sum $x$:\n\\begin{equation*}\n    \\texttt{solve}(x) = \\begin{cases}\n               \\infty               & x < 0\\\\\n               0               & x = 0\\\\\n               \\min_{c \\in \\texttt{coins}} \\texttt{solve}(x-c)+1 & x > 0 \\\\\n           \\end{cases}\n\\end{equation*}\n\nFirst, if $x<0$, the value is $\\infty$,\nbecause it is impossible to form a negative\nsum of money.\nThen, if $x=0$, the value is $0$,\nbecause no coins are needed to form an empty sum.\nFinally, if $x>0$, the variable $c$ goes through\nall possibilities how to choose the first coin\nof the sum.\n\nOnce a recursive function that solves the problem\nhas been found,\nwe can directly implement a solution in C++\n(the constant \\texttt{INF} denotes infinity):\n\n\\begin{lstlisting}\nint solve(int x) {\n    if (x < 0) return INF;\n    if (x == 0) return 0;\n    int best = INF;\n    for (auto c : coins) {\n        best = min(best, solve(x-c)+1);\n    }\n    return best;\n}\n\\end{lstlisting}\n\nStill, this function is not efficient,\nbecause there may be an exponential number of ways\nto construct the sum.\nHowever, next we will see how to make the\nfunction efficient using a technique called memoization.\n\n\\subsubsection{Using memoization}\n\n\\index{memoization}\n\nThe idea of dynamic programming is to use\n\\key{memoization} to efficiently calculate\nvalues of a recursive function.\nThis means that the values of the function\nare stored in an array after calculating them.\nFor each parameter, the value of the function\nis calculated recursively only once, and after this,\nthe value can be directly retrieved from the array.\n\nIn this problem, we use arrays\n\\begin{lstlisting}\nbool ready[N];\nint value[N];\n\\end{lstlisting}\n\nwhere $\\texttt{ready}[x]$ indicates\nwhether the value of $\\texttt{solve}(x)$ has been calculated,\nand if it is, $\\texttt{value}[x]$\ncontains this value.\nThe constant $N$ has been chosen so\nthat all required values fit in the arrays.\n\nNow the function can be efficiently\nimplemented as follows:\n\n\\begin{lstlisting}\nint solve(int x) {\n    if (x < 0) return INF;\n    if (x == 0) return 0;\n    if (ready[x]) return value[x];\n    int best = INF;\n    for (auto c : coins) {\n        best = min(best, solve(x-c)+1);\n    }\n    value[x] = best;\n    ready[x] = true;\n    return best;\n}\n\\end{lstlisting}\n\nThe function handles the base cases\n$x<0$ and $x=0$ as previously.\nThen the function checks from\n$\\texttt{ready}[x]$ if\n$\\texttt{solve}(x)$ has already been stored\nin $\\texttt{value}[x]$,\nand if it is, the function directly returns it.\nOtherwise the function calculates the value\nof $\\texttt{solve}(x)$\nrecursively and stores it in $\\texttt{value}[x]$.\n\nThis function works efficiently,\nbecause the answer for each parameter $x$\nis calculated recursively only once.\nAfter a value of $\\texttt{solve}(x)$ has been stored in $\\texttt{value}[x]$,\nit can be efficiently retrieved whenever the\nfunction will be called again with the parameter $x$.\nThe time complexity of the algorithm is $O(nk)$,\nwhere $n$ is the target sum and $k$ is the number of coins.\n\nNote that we can also \\emph{iteratively}\nconstruct the array \\texttt{value} using\na loop that simply calculates all the values\nof $\\texttt{solve}$ for parameters $0 \\ldots n$:\n\\begin{lstlisting}\nvalue[0] = 0;\nfor (int x = 1; x <= n; x++) {\n    value[x] = INF;\n    for (auto c : coins) {\n        if (x-c >= 0) {\n            value[x] = min(value[x], value[x-c]+1);\n        }\n    }\n}\n\\end{lstlisting}\n\nIn fact, most competitive programmers prefer this\nimplementation, because it is shorter and has\nlower constant factors.\nFrom now on, we also use iterative implementations\nin our examples.\nStill, it is often easier to think about\ndynamic programming solutions\nin terms of recursive functions.\n\n\n\\subsubsection{Constructing a solution}\n\nSometimes we are asked both to find the value\nof an optimal solution and to give\nan example how such a solution can be constructed.\nIn the coin problem, for example,\nwe can declare another array\nthat indicates for\neach sum of money the first coin \nin an optimal solution:\n\\begin{lstlisting}\nint first[N];\n\\end{lstlisting}\nThen, we can modify the algorithm as follows:\n\\begin{lstlisting}\nvalue[0] = 0;\nfor (int x = 1; x <= n; x++) {\n    value[x] = INF;\n    for (auto c : coins) {\n        if (x-c >= 0 && value[x-c]+1 < value[x]) {\n            value[x] = value[x-c]+1;\n            first[x] = c;\n        }\n    }\n}\n\\end{lstlisting}\nAfter this, the following code can be used to\nprint the coins that appear in an optimal solution for\nthe sum $n$:\n\\begin{lstlisting}\nwhile (n > 0) {\n    cout << first[n] << \"\\n\";\n    n -= first[n];\n}\n\\end{lstlisting}\n\n\\subsubsection{Counting the number of solutions}\n\nLet us now consider another version\nof the coin problem where our task is to\ncalculate the total number of ways\nto produce a sum $x$ using the coins.\nFor example, if $\\texttt{coins}=\\{1,3,4\\}$ and\n$x=5$, there are a total of 6 ways:\n\n\\begin{multicols}{2}\n\\begin{itemize}\n\\item $1+1+1+1+1$\n\\item $1+1+3$\n\\item $1+3+1$\n\\item $3+1+1$\n\\item $1+4$\n\\item $4+1$\n\\end{itemize}\n\\end{multicols}\n\nAgain, we can solve the problem recursively.\nLet $\\texttt{solve}(x)$ denote the number of ways\nwe can form the sum $x$.\nFor example, if $\\texttt{coins}=\\{1,3,4\\}$,\nthen $\\texttt{solve}(5)=6$ and the recursive formula is\n\\begin{equation*}\n\\begin{split}\n\\texttt{solve}(x) = & \\texttt{solve}(x-1) + \\\\\n                    & \\texttt{solve}(x-3) + \\\\\n                    & \\texttt{solve}(x-4)  .\n\\end{split}\n\\end{equation*}\n\nThen, the general recursive function is as follows:\n\\begin{equation*}\n    \\texttt{solve}(x) = \\begin{cases}\n               0               & x < 0\\\\\n               1               & x = 0\\\\\n               \\sum_{c \\in \\texttt{coins}} \\texttt{solve}(x-c) & x > 0 \\\\\n           \\end{cases}\n\\end{equation*}\n\nIf $x<0$, the value is 0, because there are no solutions.\nIf $x=0$, the value is 1, because there is only one way\nto form an empty sum.\nOtherwise we calculate the sum of all values\nof the form $\\texttt{solve}(x-c)$ where $c$ is in \\texttt{coins}.\n\nThe following code constructs an array\n$\\texttt{count}$ such that\n$\\texttt{count}[x]$ equals\nthe value of $\\texttt{solve}(x)$\nfor $0 \\le x \\le n$:\n\n\\begin{lstlisting}\ncount[0] = 1;\nfor (int x = 1; x <= n; x++) {\n    for (auto c : coins) {\n        if (x-c >= 0) {\n            count[x] += count[x-c];\n        }\n    }\n}\n\\end{lstlisting}\n\nOften the number of solutions is so large\nthat it is not required to calculate the exact number\nbut it is enough to give the answer modulo $m$\nwhere, for example, $m=10^9+7$.\nThis can be done by changing the code so that\nall calculations are done modulo $m$.\nIn the above code, it suffices to add the line\n\\begin{lstlisting}\n        count[x] %= m;\n\\end{lstlisting}\nafter the line\n\\begin{lstlisting}\n        count[x] += count[x-c];\n\\end{lstlisting}\n\nNow we have discussed all basic\nideas of dynamic programming.\nSince dynamic programming can be used\nin many different situations,\nwe will now go through a set of problems\nthat show further examples about the\npossibilities of dynamic programming.\n\n", "chapter_name": "Dynamic programming", "chapter_path": "cphb/chapter07.tex"}, {"section_name": "Longest increasing subsequence", "section_content": "\\section{Longest increasing subsequence}\n\n\\index{longest increasing subsequence}\n\nOur first problem is to find the\n\\key{longest increasing subsequence}\nin an array of $n$ elements.\nThis is a maximum-length\nsequence of array elements\nthat goes from left to right,\nand each element in the sequence is larger\nthan the previous element.\nFor example, in the array\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$6$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$5$};\n\\node at (3.5,0.5) {$1$};\n\\node at (4.5,0.5) {$7$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$3$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nthe longest increasing subsequence\ncontains 4 elements:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (1,0) rectangle (2,1);\n\\fill[color=lightgray] (2,0) rectangle (3,1);\n\\fill[color=lightgray] (4,0) rectangle (5,1);\n\\fill[color=lightgray] (6,0) rectangle (7,1);\n\\draw (0,0) grid (8,1);\n\\node at (0.5,0.5) {$6$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$5$};\n\\node at (3.5,0.5) {$1$};\n\\node at (4.5,0.5) {$7$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$3$};\n\n\\draw[thick,->] (1.5,-0.25) .. controls (1.75,-1.00) and (2.25,-1.00) .. (2.4,-0.25);\n\\draw[thick,->] (2.6,-0.25) .. controls (3.0,-1.00) and (4.0,-1.00) .. (4.4,-0.25);\n\\draw[thick,->] (4.6,-0.25) .. controls (5.0,-1.00) and (6.0,-1.00) .. (6.5,-0.25);\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\n\nLet $\\texttt{length}(k)$ denote\nthe length of the\nlongest increasing subsequence\nthat ends at position $k$.\nThus, if we calculate all values of\n$\\texttt{length}(k)$ where $0 \\le k \\le n-1$,\nwe will find out the length of the\nlongest increasing subsequence.\nFor example, the values of the function\nfor the above array are as follows:\n\\[\n\\begin{array}{lcl}\n\\texttt{length}(0) & = & 1 \\\\\n\\texttt{length}(1) & = & 1 \\\\\n\\texttt{length}(2) & = & 2 \\\\\n\\texttt{length}(3) & = & 1 \\\\\n\\texttt{length}(4) & = & 3 \\\\\n\\texttt{length}(5) & = & 2 \\\\\n\\texttt{length}(6) & = & 4 \\\\\n\\texttt{length}(7) & = & 2 \\\\\n\\end{array}\n\\]\n\nFor example, $\\texttt{length}(6)=4$,\nbecause the longest increasing subsequence\nthat ends at position 6 consists of 4 elements.\n\nTo calculate a value of $\\texttt{length}(k)$,\nwe should find a position $i<k$\nfor which $\\texttt{array}[i]<\\texttt{array}[k]$\nand $\\texttt{length}(i)$ is as large as possible.\nThen we know that\n$\\texttt{length}(k)=\\texttt{length}(i)+1$,\nbecause this is an optimal way to add\n$\\texttt{array}[k]$ to a subsequence.\nHowever, if there is no such position $i$,\nthen $\\texttt{length}(k)=1$,\nwhich means that the subsequence only contains\n$\\texttt{array}[k]$.\n\nSince all values of the function can be calculated\nfrom its smaller values,\nwe can use dynamic programming.\nIn the following code, the values\nof the function will be stored in an array\n$\\texttt{length}$.\n\n\\begin{lstlisting}\nfor (int k = 0; k < n; k++) {\n    length[k] = 1;\n    for (int i = 0; i < k; i++) {\n        if (array[i] < array[k]) {\n            length[k] = max(length[k],length[i]+1);\n        }\n    }\n}\n\\end{lstlisting}\n\nThis code works in $O(n^2)$ time,\nbecause it consists of two nested loops.\nHowever, it is also possible to implement\nthe dynamic programming calculation\nmore efficiently in $O(n \\log n)$ time.\nCan you find a way to do this?\n\n", "chapter_name": "Dynamic programming", "chapter_path": "cphb/chapter07.tex"}, {"section_name": "Paths in a grid", "section_content": "\\section{Paths in a grid}\n\nOur next problem is to find a path\nfrom the upper-left corner to\nthe lower-right corner\nof an $n \\times n$ grid, such that\nwe only move down and right.\nEach square contains a positive integer,\nand the path should be constructed so\nthat the sum of the values along\nthe path is as large as possible.\n\nThe following picture shows an optimal\npath in a grid:\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n  \\begin{scope}\n    \\fill [color=lightgray] (0, 9) rectangle (1, 8);\n    \\fill [color=lightgray] (0, 8) rectangle (1, 7);\n    \\fill [color=lightgray] (1, 8) rectangle (2, 7);\n    \\fill [color=lightgray] (1, 7) rectangle (2, 6);\n    \\fill [color=lightgray] (2, 7) rectangle (3, 6);\n    \\fill [color=lightgray] (3, 7) rectangle (4, 6);\n    \\fill [color=lightgray] (4, 7) rectangle (5, 6);\n    \\fill [color=lightgray] (4, 6) rectangle (5, 5);\n    \\fill [color=lightgray] (4, 5) rectangle (5, 4);\n    \\draw (0, 4) grid (5, 9);\n    \\node at (0.5,8.5) {3};\n    \\node at (1.5,8.5) {7};\n    \\node at (2.5,8.5) {9};\n    \\node at (3.5,8.5) {2};\n    \\node at (4.5,8.5) {7};\n    \\node at (0.5,7.5) {9};\n    \\node at (1.5,7.5) {8};\n    \\node at (2.5,7.5) {3};\n    \\node at (3.5,7.5) {5};\n    \\node at (4.5,7.5) {5};\n    \\node at (0.5,6.5) {1};\n    \\node at (1.5,6.5) {7};\n    \\node at (2.5,6.5) {9};\n    \\node at (3.5,6.5) {8};\n    \\node at (4.5,6.5) {5};\n    \\node at (0.5,5.5) {3};\n    \\node at (1.5,5.5) {8};\n    \\node at (2.5,5.5) {6};\n    \\node at (3.5,5.5) {4};\n    \\node at (4.5,5.5) {10};\n    \\node at (0.5,4.5) {6};\n    \\node at (1.5,4.5) {3};\n    \\node at (2.5,4.5) {9};\n    \\node at (3.5,4.5) {7};\n    \\node at (4.5,4.5) {8};\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\nThe sum of the values on the path is 67,\nand this is the largest possible sum on a path\nfrom the\nupper-left corner to the lower-right corner.\n\nAssume that the rows and columns of the\ngrid are numbered from 1 to $n$,\nand $\\texttt{value}[y][x]$ equals the value\nof square $(y,x)$.\nLet $\\texttt{sum}(y,x)$ denote the maximum\nsum on a path from the upper-left corner\nto square $(y,x)$.\nNow $\\texttt{sum}(n,n)$ tells us\nthe maximum sum\nfrom the upper-left corner to\nthe lower-right corner.\nFor example, in the above grid,\n$\\texttt{sum}(5,5)=67$.\n\nWe can recursively calculate the sums\nas follows:\n\\[ \\texttt{sum}(y,x) = \\max(\\texttt{sum}(y,x-1),\\texttt{sum}(y-1,x))+\\texttt{value}[y][x]\\]\n\n\nThe recursive formula is based on the observation\nthat a path that ends at square $(y,x)$\ncan come either from square $(y,x-1)$\nor square $(y-1,x)$:\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n  \\begin{scope}\n    \\fill [color=lightgray] (3, 7) rectangle (4, 6);\n    \\draw (0, 4) grid (5, 9);\n    \n    \\node at (2.5,6.5) {$\\rightarrow$};\n    \\node at (3.5,7.5) {$\\downarrow$};\n    \n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nThus, we select the direction that maximizes\nthe sum.\nWe assume that $\\texttt{sum}(y,x)=0$\nif $y=0$ or $x=0$ (because no such paths exist),\nso the recursive formula also works when $y=1$ or $x=1$.\n\nSince the function \\texttt{sum} has two parameters,\nthe dynamic programming array also has two dimensions.\nFor example, we can use an array\n\\begin{lstlisting}\nint sum[N][N];\n\\end{lstlisting}\nand calculate the sums as follows:\n\\begin{lstlisting}\nfor (int y = 1; y <= n; y++) {\n    for (int x = 1; x <= n; x++) {\n        sum[y][x] = max(sum[y][x-1],sum[y-1][x])+value[y][x];\n    }\n}\n\\end{lstlisting}\nThe time complexity of the algorithm is $O(n^2)$.\n\n", "chapter_name": "Dynamic programming", "chapter_path": "cphb/chapter07.tex"}, {"section_name": "Knapsack problems", "section_content": "\\section{Knapsack problems}\n\n\\index{knapsack}\n\nThe term \\key{knapsack} refers to problems where\na set of objects is given, and \nsubsets with some properties\nhave to be found.\nKnapsack problems can often be solved\nusing dynamic programming.\n\nIn this section, we focus on the following\nproblem: Given a list of weights\n$[w_1,w_2,\\ldots,w_n]$,\ndetermine all\nsums that can be constructed using the weights.\nFor example, if the weights are\n$[1,3,3,5]$, the following sums are possible:\n\n\\begin{center}\n\\begin{tabular}{rrrrrrrrrrrrr}\n 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\\\\n\\hline\n X & X & & X & X & X & X & X & X & X & & X & X \\\\\n\\end{tabular}\n\\end{center}\n\nIn this case, all sums between $0 \\ldots 12$\nare possible, except 2 and 10.\nFor example, the sum 7 is possible because we\ncan select the weights $[1,3,3]$.\n\nTo solve the problem, we focus on subproblems\nwhere we only use the first $k$ weights\nto construct sums.\nLet $\\texttt{possible}(x,k)=\\textrm{true}$ if\nwe can construct a sum $x$\nusing the first $k$ weights,\nand otherwise $\\texttt{possible}(x,k)=\\textrm{false}$.\nThe values of the function can be recursively\ncalculated as follows:\n\\[ \\texttt{possible}(x,k) = \\texttt{possible}(x-w_k,k-1) \\lor \\texttt{possible}(x,k-1) \\]\nThe formula is based on the fact that we can\neither use or not use the weight $w_k$ in the sum.\nIf we use $w_k$, the remaining task is to\nform the sum $x-w_k$ using the first $k-1$ weights,\nand if we do not use $w_k$,\nthe remaining task is to form the sum $x$\nusing the first $k-1$ weights.\nAs the base cases,\n\\begin{equation*}\n    \\texttt{possible}(x,0) = \\begin{cases}\n               \\textrm{true}    & x = 0\\\\\n               \\textrm{false}   & x \\neq 0 \\\\\n           \\end{cases}\n\\end{equation*}\nbecause if no weights are used,\nwe can only form the sum 0.\n\nThe following table shows all values of the function\nfor the weights $[1,3,3,5]$ (the symbol ''X''\nindicates the true values):\n\n\\begin{center}\n\\begin{tabular}{r|rrrrrrrrrrrrr}\n$k \\backslash x$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\\\\n\\hline\n 0 & X & \\\\\n 1 & X & X \\\\\n 2 & X & X & & X & X \\\\\n 3 & X & X & & X & X & & X & X \\\\\n 4 & X & X & & X & X & X & X & X & X & X & & X & X \\\\\n\\end{tabular}\n\\end{center}\n\nAfter calculating those values, $\\texttt{possible}(x,n)$\ntells us whether we can construct a\nsum $x$ using \\emph{all} weights.\n\nLet $W$ denote the total sum of the weights.\nThe following $O(nW)$ time\ndynamic programming solution\ncorresponds to the recursive function:\n\\begin{lstlisting}\npossible[0][0] = true;\nfor (int k = 1; k <= n; k++) {\n    for (int x = 0; x <= W; x++) {\n        if (x-w[k] >= 0) possible[x][k] |= possible[x-w[k]][k-1];\n        possible[x][k] |= possible[x][k-1];\n    }\n}\n\\end{lstlisting}\n\nHowever, here is a better implementation that only uses\na one-dimensional array $\\texttt{possible}[x]$\nthat indicates whether we can construct a subset with sum $x$.\nThe trick is to update the array from right to left for\neach new weight:\n\\begin{lstlisting}\npossible[0] = true;\nfor (int k = 1; k <= n; k++) {\n    for (int x = W; x >= 0; x--) {\n        if (possible[x]) possible[x+w[k]] = true;\n    }\n}\n\\end{lstlisting}\n\nNote that the general idea presented here can be used\nin many knapsack problems.\nFor example, if we are given objects with weights and values,\nwe can determine for each weight sum the maximum value\nsum of a subset.\n\n", "chapter_name": "Dynamic programming", "chapter_path": "cphb/chapter07.tex"}, {"section_name": "Edit distance", "section_content": "\\section{Edit distance}\n\n\\index{edit distance}\n\\index{Levenshtein distance}\n\nThe \\key{edit distance} or \\key{Levenshtein distance}\\footnote{The distance\nis named after V. I. Levenshtein who studied it in connection with binary codes \\cite{lev66}.}\nis the minimum number of editing operations\nneeded to transform a string\ninto another string.\nThe allowed editing operations are as follows:\n\\begin{itemize}\n\\item insert a character (e.g. \\texttt{ABC} $\\rightarrow$ \\texttt{ABCA})\n\\item remove a character (e.g. \\texttt{ABC} $\\rightarrow$ \\texttt{AC})\n\\item modify a character (e.g. \\texttt{ABC} $\\rightarrow$ \\texttt{ADC})\n\\end{itemize}\n\nFor example, the edit distance between\n\\texttt{LOVE} and \\texttt{MOVIE} is 2,\nbecause we can first perform the operation\n \\texttt{LOVE} $\\rightarrow$ \\texttt{MOVE}\n(modify) and then the operation\n\\texttt{MOVE} $\\rightarrow$ \\texttt{MOVIE}\n(insert).\nThis is the smallest possible number of operations,\nbecause it is clear that only one operation is not enough.\n\nSuppose that we are given a string \\texttt{x}\nof length $n$ and a string \\texttt{y} of length $m$,\nand we want to calculate the edit distance between\n\\texttt{x} and \\texttt{y}.\nTo solve the problem, we define a function\n$\\texttt{distance}(a,b)$ that gives the\nedit distance between prefixes\n$\\texttt{x}[0 \\ldots a]$ and $\\texttt{y}[0 \\ldots b]$.\nThus, using this function, the edit distance\nbetween \\texttt{x} and \\texttt{y} equals $\\texttt{distance}(n-1,m-1)$.\n\nWe can calculate values of \\texttt{distance}\nas follows:\n\\begin{equation*}\n\\begin{split}\n\\texttt{distance}(a,b) = \\min(& \\texttt{distance}(a,b-1)+1, \\\\\n                           & \\texttt{distance}(a-1,b)+1, \\\\\n                           & \\texttt{distance}(a-1,b-1)+\\texttt{cost}(a,b)).\n\\end{split}\n\\end{equation*}\nHere $\\texttt{cost}(a,b)=0$ if $\\texttt{x}[a]=\\texttt{y}[b]$,\nand otherwise $\\texttt{cost}(a,b)=1$.\nThe formula considers the following ways to\nedit the string \\texttt{x}:\n\\begin{itemize}\n\\item $\\texttt{distance}(a,b-1)$: insert a character at the end of \\texttt{x}\n\\item $\\texttt{distance}(a-1,b)$: remove the last character from \\texttt{x}\n\\item $\\texttt{distance}(a-1,b-1)$: match or modify the last character of \\texttt{x}\n\\end{itemize}\nIn the two first cases, one editing operation is needed\n(insert or remove).\nIn the last case, if $\\texttt{x}[a]=\\texttt{y}[b]$,\nwe can match the last characters without editing,\nand otherwise one editing operation is needed (modify).\n\nThe following table shows the values of \\texttt{distance}\nin the example case:\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n  \\begin{scope}\n    %\\fill [color=lightgray] (5, -3) rectangle (6, -4);\n    \\draw (1, -1) grid (7, -6);\n    \n    \\node at (0.5,-2.5) {\\texttt{L}};\n    \\node at (0.5,-3.5) {\\texttt{O}};\n    \\node at (0.5,-4.5) {\\texttt{V}};\n    \\node at (0.5,-5.5) {\\texttt{E}};\n\n    \\node at (2.5,-0.5) {\\texttt{M}};\n    \\node at (3.5,-0.5) {\\texttt{O}};\n    \\node at (4.5,-0.5) {\\texttt{V}};\n    \\node at (5.5,-0.5) {\\texttt{I}};\n    \\node at (6.5,-0.5) {\\texttt{E}};\n\n    \\node at (1.5,-1.5) {$0$};\n    \\node at (1.5,-2.5) {$1$};\n    \\node at (1.5,-3.5) {$2$};\n    \\node at (1.5,-4.5) {$3$};\n    \\node at (1.5,-5.5) {$4$};\n    \\node at (2.5,-1.5) {$1$};\n    \\node at (2.5,-2.5) {$1$};\n    \\node at (2.5,-3.5) {$2$};\n    \\node at (2.5,-4.5) {$3$};\n    \\node at (2.5,-5.5) {$4$};\n    \\node at (3.5,-1.5) {$2$};\n    \\node at (3.5,-2.5) {$2$};\n    \\node at (3.5,-3.5) {$1$};\n    \\node at (3.5,-4.5) {$2$};\n    \\node at (3.5,-5.5) {$3$};\n    \\node at (4.5,-1.5) {$3$};\n    \\node at (4.5,-2.5) {$3$};\n    \\node at (4.5,-3.5) {$2$};\n    \\node at (4.5,-4.5) {$1$};\n    \\node at (4.5,-5.5) {$2$};\n    \\node at (5.5,-1.5) {$4$};\n    \\node at (5.5,-2.5) {$4$};\n    \\node at (5.5,-3.5) {$3$};\n    \\node at (5.5,-4.5) {$2$};\n    \\node at (5.5,-5.5) {$2$};\n    \\node at (6.5,-1.5) {$5$};\n    \\node at (6.5,-2.5) {$5$};\n    \\node at (6.5,-3.5) {$4$};\n    \\node at (6.5,-4.5) {$3$};\n    \\node at (6.5,-5.5) {$2$};\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nThe lower-right corner of the table\ntells us that the edit distance between\n\\texttt{LOVE} and \\texttt{MOVIE} is 2.\nThe table also shows how to construct\nthe shortest sequence of editing operations.\nIn this case the path is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n  \\begin{scope}\n    \\draw (1, -1) grid (7, -6);\n    \n    \\node at (0.5,-2.5) {\\texttt{L}};\n    \\node at (0.5,-3.5) {\\texttt{O}};\n    \\node at (0.5,-4.5) {\\texttt{V}};\n    \\node at (0.5,-5.5) {\\texttt{E}};\n\n    \\node at (2.5,-0.5) {\\texttt{M}};\n    \\node at (3.5,-0.5) {\\texttt{O}};\n    \\node at (4.5,-0.5) {\\texttt{V}};\n    \\node at (5.5,-0.5) {\\texttt{I}};\n    \\node at (6.5,-0.5) {\\texttt{E}};\n\n    \\node at (1.5,-1.5) {$0$};\n    \\node at (1.5,-2.5) {$1$};\n    \\node at (1.5,-3.5) {$2$};\n    \\node at (1.5,-4.5) {$3$};\n    \\node at (1.5,-5.5) {$4$};\n    \\node at (2.5,-1.5) {$1$};\n    \\node at (2.5,-2.5) {$1$};\n    \\node at (2.5,-3.5) {$2$};\n    \\node at (2.5,-4.5) {$3$};\n    \\node at (2.5,-5.5) {$4$};\n    \\node at (3.5,-1.5) {$2$};\n    \\node at (3.5,-2.5) {$2$};\n    \\node at (3.5,-3.5) {$1$};\n    \\node at (3.5,-4.5) {$2$};\n    \\node at (3.5,-5.5) {$3$};\n    \\node at (4.5,-1.5) {$3$};\n    \\node at (4.5,-2.5) {$3$};\n    \\node at (4.5,-3.5) {$2$};\n    \\node at (4.5,-4.5) {$1$};\n    \\node at (4.5,-5.5) {$2$};\n    \\node at (5.5,-1.5) {$4$};\n    \\node at (5.5,-2.5) {$4$};\n    \\node at (5.5,-3.5) {$3$};\n    \\node at (5.5,-4.5) {$2$};\n    \\node at (5.5,-5.5) {$2$};\n    \\node at (6.5,-1.5) {$5$};\n    \\node at (6.5,-2.5) {$5$};\n    \\node at (6.5,-3.5) {$4$};\n    \\node at (6.5,-4.5) {$3$};\n    \\node at (6.5,-5.5) {$2$};\n\n    \\path[draw=red,thick,-,line width=2pt] (6.5,-5.5) -- (5.5,-4.5);\n    \\path[draw=red,thick,-,line width=2pt] (5.5,-4.5) -- (4.5,-4.5);\n    \\path[draw=red,thick,->,line width=2pt] (4.5,-4.5) -- (1.5,-1.5);\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nThe last characters of \\texttt{LOVE} and \\texttt{MOVIE}\nare equal, so the edit distance between them\nequals the edit distance between \\texttt{LOV} and \\texttt{MOVI}.\nWe can use one editing operation to remove the\ncharacter \\texttt{I} from \\texttt{MOVI}.\nThus, the edit distance is one larger than\nthe edit distance between \\texttt{LOV} and \\texttt{MOV}, etc.\n\n", "chapter_name": "Dynamic programming", "chapter_path": "cphb/chapter07.tex"}, {"section_name": "Counting tilings", "section_content": "\\section{Counting tilings}\n\nSometimes the states of a dynamic programming solution\nare more complex than fixed combinations of numbers.\nAs an example,\nconsider the problem of calculating\nthe number of distinct ways to\nfill an $n \\times m$ grid using\n$1 \\times 2$ and $2 \\times 1$ size tiles.\nFor example, one valid solution\nfor the $4 \\times 7$ grid is\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n    \\draw (0,0) grid (7,4);\n    \\draw[fill=gray] (0+0.2,0+0.2) rectangle (2-0.2,1-0.2);\n    \\draw[fill=gray] (2+0.2,0+0.2) rectangle (4-0.2,1-0.2);\n    \\draw[fill=gray] (4+0.2,0+0.2) rectangle (6-0.2,1-0.2);\n    \\draw[fill=gray] (0+0.2,1+0.2) rectangle (2-0.2,2-0.2);\n    \\draw[fill=gray] (2+0.2,1+0.2) rectangle (4-0.2,2-0.2);\n    \\draw[fill=gray] (1+0.2,2+0.2) rectangle (3-0.2,3-0.2);\n    \\draw[fill=gray] (1+0.2,3+0.2) rectangle (3-0.2,4-0.2);\n    \\draw[fill=gray] (4+0.2,3+0.2) rectangle (6-0.2,4-0.2);\n\n    \\draw[fill=gray] (0+0.2,2+0.2) rectangle (1-0.2,4-0.2);\n    \\draw[fill=gray] (3+0.2,2+0.2) rectangle (4-0.2,4-0.2);\n    \\draw[fill=gray] (6+0.2,2+0.2) rectangle (7-0.2,4-0.2);\n    \\draw[fill=gray] (4+0.2,1+0.2) rectangle (5-0.2,3-0.2);\n    \\draw[fill=gray] (5+0.2,1+0.2) rectangle (6-0.2,3-0.2);\n    \\draw[fill=gray] (6+0.2,0+0.2) rectangle (7-0.2,2-0.2);\n\n\\end{tikzpicture}\n\\end{center}\nand the total number of solutions is 781.\n\nThe problem can be solved using dynamic programming\nby going through the grid row by row.\nEach row in a solution can be represented as a\nstring that contains $m$ characters from the set\n$\\{\\sqcap, \\sqcup, \\sqsubset, \\sqsupset \\}$.\nFor example, the above solution consists of four rows\nthat correspond to the following strings:\n\\begin{itemize}\n\\item\n$\\sqcap \\sqsubset \\sqsupset \\sqcap \\sqsubset \\sqsupset \\sqcap$\n\\item\n$\\sqcup \\sqsubset \\sqsupset \\sqcup \\sqcap \\sqcap \\sqcup$\n\\item\n$\\sqsubset \\sqsupset \\sqsubset \\sqsupset \\sqcup \\sqcup \\sqcap$ \n\\item\n$\\sqsubset \\sqsupset \\sqsubset \\sqsupset \\sqsubset \\sqsupset \\sqcup$\n\\end{itemize}\n\nLet $\\texttt{count}(k,x)$ denote the number of ways to\nconstruct a solution for rows $1 \\ldots k$\nof the grid such that string $x$ corresponds to row $k$.\nIt is possible to use dynamic programming here,\nbecause the state of a row is constrained\nonly by the state of the previous row.\n\nA solution is valid if row $1$ does not contain\nthe character $\\sqcup$,\nrow $n$ does not contain the character $\\sqcap$,\nand all consecutive rows are \\emph{compatible}.\nFor example, the rows\n$\\sqcup \\sqsubset \\sqsupset \\sqcup \\sqcap \\sqcap \\sqcup$ and\n$\\sqsubset \\sqsupset \\sqsubset \\sqsupset \\sqcup \\sqcup \\sqcap$ \nare compatible, while the rows\n$\\sqcap \\sqsubset \\sqsupset \\sqcap \\sqsubset \\sqsupset \\sqcap$ and\n$\\sqsubset \\sqsupset \\sqsubset \\sqsupset \\sqsubset \\sqsupset \\sqcup$\nare not compatible.\n\nSince a row consists of $m$ characters and there are\nfour choices for each character, the number of distinct\nrows is at most $4^m$.\nThus, the time complexity of the solution is\n$O(n 4^{2m})$ because we can go through the\n$O(4^m)$ possible states for each row,\nand for each state, there are $O(4^m)$\npossible states for the previous row.\nIn practice, it is a good idea to rotate the grid\nso that the shorter side has length $m$,\nbecause the factor $4^{2m}$ dominates the time complexity.\n\nIt is possible to make the solution more efficient\nby using a more compact representation for the rows.\nIt turns out that it is sufficient to know which\ncolumns of the previous row contain the upper square\nof a vertical tile.\nThus, we can represent a row using only characters\n$\\sqcap$ and $\\Box$, where $\\Box$ is a combination\nof characters\n$\\sqcup$, $\\sqsubset$ and $\\sqsupset$.\nUsing this representation, there are only\n$2^m$ distinct rows and the time complexity is\n$O(n 2^{2m})$.\n\nAs a final note, there is also a surprising direct formula\nfor calculating the number of tilings\\footnote{Surprisingly,\nthis formula was discovered in 1961 by two research teams \\cite{kas61,tem61}\nthat worked independently.}:\n\\[ \\prod_{a=1}^{\\lceil n/2 \\rceil} \\prod_{b=1}^{\\lceil m/2 \\rceil} 4 \\cdot (\\cos^2 \\frac{\\pi a}{n + 1} + \\cos^2 \\frac{\\pi b}{m+1})\\]\nThis formula is very efficient, because it calculates\nthe number of tilings in $O(nm)$ time,\nbut since the answer is a product of real numbers,\na problem when using the formula is\nhow to store the intermediate results accurately.\n\n\n", "chapter_name": "Dynamic programming", "chapter_path": "cphb/chapter07.tex"}, {"section_name": "Two pointers method", "section_content": "\\chapter{Amortized analysis}\n\n\\index{amortized analysis}\n\nThe time complexity of an algorithm\nis often easy to analyze\njust by examining the structure\nof the algorithm:\nwhat loops does the algorithm contain\nand how many times the loops are performed.\nHowever, sometimes a straightforward analysis\ndoes not give a true picture of the efficiency of the algorithm.\n\n\\key{Amortized analysis} can be used to analyze\nalgorithms that contain operations whose\ntime complexity varies.\nThe idea is to estimate the total time used to\nall such operations during the\nexecution of the algorithm, instead of focusing\non individual operations.\n\n\\section{Two pointers method}\n\n\\index{two pointers method}\n\nIn the \\key{two pointers method},\ntwo pointers are used to\niterate through the array values.\nBoth pointers can move to one direction only,\nwhich ensures that the algorithm works efficiently.\nNext we discuss two problems that can be solved\nusing the two pointers method.\n\n\\subsubsection{Subarray sum}\n\nAs the first example,\nconsider a problem where we are\ngiven an array of $n$ positive integers\nand a target sum $x$,\nand we want to find a subarray whose sum is $x$\nor report that there is no such subarray.\n\nFor example, the array\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$1$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$2$};\n\\node at (7.5,0.5) {$3$};\n\\end{tikzpicture}\n\\end{center}\ncontains a subarray whose sum is 8:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (2,0) rectangle (5,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$1$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$2$};\n\\node at (7.5,0.5) {$3$};\n\\end{tikzpicture}\n\\end{center}\n\nThis problem can be solved in\n$O(n)$ time by using the two pointers method.\nThe idea is to maintain pointers that point to the\nfirst and last value of a subarray.\nOn each turn, the left pointer moves one step\nto the right, and the right pointer moves to the right\nas long as the resulting subarray sum is at most $x$.\nIf the sum becomes exactly $x$,\na solution has been found.\n\nAs an example, consider the following array\nand a target sum $x=8$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$1$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$2$};\n\\node at (7.5,0.5) {$3$};\n\\end{tikzpicture}\n\\end{center}\n\nThe initial subarray contains the values\n1, 3 and 2 whose sum is 6:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (0,0) rectangle (3,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$1$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$2$};\n\\node at (7.5,0.5) {$3$};\n\n\\draw[thick,->] (0.5,-0.7) -- (0.5,-0.1);\n\\draw[thick,->] (2.5,-0.7) -- (2.5,-0.1);\n\\end{tikzpicture}\n\\end{center}\n\nThen, the left pointer moves one step to the right.\nThe right pointer does not move, because otherwise\nthe subarray sum would exceed $x$.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (1,0) rectangle (3,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$1$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$2$};\n\\node at (7.5,0.5) {$3$};\n\n\\draw[thick,->] (1.5,-0.7) -- (1.5,-0.1);\n\\draw[thick,->] (2.5,-0.7) -- (2.5,-0.1);\n\\end{tikzpicture}\n\\end{center}\n\nAgain, the left pointer moves one step to the right,\nand this time the right pointer moves three\nsteps to the right.\nThe subarray sum is $2+5+1=8$, so a subarray\nwhose sum is $x$ has been found.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (2,0) rectangle (5,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$1$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$2$};\n\\node at (7.5,0.5) {$3$};\n\n\\draw[thick,->] (2.5,-0.7) -- (2.5,-0.1);\n\\draw[thick,->] (4.5,-0.7) -- (4.5,-0.1);\n\\end{tikzpicture}\n\\end{center}\n\nThe running time of the algorithm depends on\nthe number of steps the right pointer moves.\nWhile there is no useful upper bound on how many steps the\npointer can move on a \\emph{single} turn.\nwe know that the pointer moves \\emph{a total of}\n$O(n)$ steps during the algorithm,\nbecause it only moves to the right.\n\nSince both the left and right pointer\nmove $O(n)$ steps during the algorithm,\nthe algorithm works in $O(n)$ time.\n\n\\subsubsection{2SUM problem}\n\n\\index{2SUM problem}\n\nAnother problem that can be solved using\nthe two pointers method is the following problem,\nalso known as the \\key{2SUM problem}:\ngiven an array of $n$ numbers and\na target sum $x$, find\ntwo array values such that their sum is $x$,\nor report that no such values exist.\n\nTo solve the problem, we first\nsort the array values in increasing order.\nAfter that, we iterate through the array using\ntwo pointers.\nThe left pointer starts at the first value\nand moves one step to the right on each turn.\nThe right pointer begins at the last value\nand always moves to the left until the sum of the\nleft and right value is at most $x$.\nIf the sum is exactly $x$,\na solution has been found.\n\nFor example, consider the following array\nand a target sum $x=12$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$4$};\n\\node at (2.5,0.5) {$5$};\n\\node at (3.5,0.5) {$6$};\n\\node at (4.5,0.5) {$7$};\n\\node at (5.5,0.5) {$9$};\n\\node at (6.5,0.5) {$9$};\n\\node at (7.5,0.5) {$10$};\n\\end{tikzpicture}\n\\end{center}\n\nThe initial positions of the pointers\nare as follows.\nThe sum of the values is $1+10=11$\nthat is smaller than $x$.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (0,0) rectangle (1,1);\n\\fill[color=lightgray] (7,0) rectangle (8,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$4$};\n\\node at (2.5,0.5) {$5$};\n\\node at (3.5,0.5) {$6$};\n\\node at (4.5,0.5) {$7$};\n\\node at (5.5,0.5) {$9$};\n\\node at (6.5,0.5) {$9$};\n\\node at (7.5,0.5) {$10$};\n\n\\draw[thick,->] (0.5,-0.7) -- (0.5,-0.1);\n\\draw[thick,->] (7.5,-0.7) -- (7.5,-0.1);\n\\end{tikzpicture}\n\\end{center}\n\nThen the left pointer moves one step to the right.\nThe right pointer moves three steps to the left,\nand the sum becomes $4+7=11$.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (1,0) rectangle (2,1);\n\\fill[color=lightgray] (4,0) rectangle (5,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$4$};\n\\node at (2.5,0.5) {$5$};\n\\node at (3.5,0.5) {$6$};\n\\node at (4.5,0.5) {$7$};\n\\node at (5.5,0.5) {$9$};\n\\node at (6.5,0.5) {$9$};\n\\node at (7.5,0.5) {$10$};\n\n\\draw[thick,->] (1.5,-0.7) -- (1.5,-0.1);\n\\draw[thick,->] (4.5,-0.7) -- (4.5,-0.1);\n\\end{tikzpicture}\n\\end{center}\n\nAfter this, the left pointer moves one step to the right again.\nThe right pointer does not move, and a solution\n$5+7=12$ has been found.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (2,0) rectangle (3,1);\n\\fill[color=lightgray] (4,0) rectangle (5,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$4$};\n\\node at (2.5,0.5) {$5$};\n\\node at (3.5,0.5) {$6$};\n\\node at (4.5,0.5) {$7$};\n\\node at (5.5,0.5) {$9$};\n\\node at (6.5,0.5) {$9$};\n\\node at (7.5,0.5) {$10$};\n\n\\draw[thick,->] (2.5,-0.7) -- (2.5,-0.1);\n\\draw[thick,->] (4.5,-0.7) -- (4.5,-0.1);\n\\end{tikzpicture}\n\\end{center}\n\nThe running time of the algorithm is\n$O(n \\log n)$, because it first sorts\nthe array in $O(n \\log n)$ time,\nand then both pointers move $O(n)$ steps.\n\nNote that it is possible to solve the problem\nin another way in $O(n \\log n)$ time using binary search.\nIn such a solution, we iterate through the array\nand for each array value, we try to find another\nvalue that yields the sum $x$.\nThis can be done by performing $n$ binary searches,\neach of which takes $O(\\log n)$ time.\n\n\\index{3SUM problem}\nA more difficult problem is \nthe \\key{3SUM problem} that asks to\nfind \\emph{three} array values\nwhose sum is $x$.\nUsing the idea of the above algorithm,\nthis problem can be solved in $O(n^2)$ time\\footnote{For a long time,\nit was thought that solving\nthe 3SUM problem more efficiently than in $O(n^2)$ time\nwould not be possible.\nHowever, in 2014, it turned out \\cite{gro14}\nthat this is not the case.}.\nCan you see how?\n\n", "chapter_name": "Amortized analysis", "chapter_path": "cphb/chapter08.tex"}, {"section_name": "Nearest smaller elements", "section_content": "\\section{Nearest smaller elements}\n\n\\index{nearest smaller elements}\n\nAmortized analysis is often used to\nestimate the number of operations\nperformed on a data structure.\nThe operations may be distributed unevenly so\nthat most operations occur during a\ncertain phase of the algorithm, but the total\nnumber of the operations is limited.\n\nAs an example, consider the problem\nof finding for each array element\nthe \\key{nearest smaller element}, i.e.,\nthe first smaller element that precedes the element\nin the array.\nIt is possible that no such element exists,\nin which case the algorithm should report this.\nNext we will see how the problem can be\nefficiently solved using a stack structure.\n\nWe go through the array from left to right\nand maintain a stack of array elements.\nAt each array position, we remove elements from the stack\nuntil the top element is smaller than the\ncurrent element, or the stack is empty.\nThen, we report that the top element is\nthe nearest smaller element of the current element,\nor if the stack is empty, there is no such element.\nFinally, we add the current element to the stack.\n\nAs an example, consider the following array:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$5$};\n\\node at (5.5,0.5) {$3$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\\end{tikzpicture}\n\\end{center}\n\nFirst, the elements 1, 3 and 4 are added to the stack,\nbecause each element is larger than the previous element.\nThus, the nearest smaller element of 4 is 3,\nand the nearest smaller element of 3 is 1.\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (2,0) rectangle (3,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$5$};\n\\node at (5.5,0.5) {$3$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\draw (0.2,0.2-1.2) rectangle (0.8,0.8-1.2);\n\\draw (1.2,0.2-1.2) rectangle (1.8,0.8-1.2);\n\\draw (2.2,0.2-1.2) rectangle (2.8,0.8-1.2);\n\n\\node at (0.5,0.5-1.2) {$1$};\n\\node at (1.5,0.5-1.2) {$3$};\n\\node at (2.5,0.5-1.2) {$4$};\n\n\\draw[->,thick] (0.8,0.5-1.2) -- (1.2,0.5-1.2);\n\\draw[->,thick] (1.8,0.5-1.2) -- (2.2,0.5-1.2);\n\\end{tikzpicture}\n\\end{center}\n\nThe next element 2 is smaller than the two top\nelements in the stack.\nThus, the elements 3 and 4 are removed from the stack,\nand then the element 2 is added to the stack.\nIts nearest smaller element is 1:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (3,0) rectangle (4,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$5$};\n\\node at (5.5,0.5) {$3$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\draw (0.2,0.2-1.2) rectangle (0.8,0.8-1.2);\n\\draw (3.2,0.2-1.2) rectangle (3.8,0.8-1.2);\n\n\\node at (0.5,0.5-1.2) {$1$};\n\\node at (3.5,0.5-1.2) {$2$};\n\n\\draw[->,thick] (0.8,0.5-1.2) -- (3.2,0.5-1.2);\n\\end{tikzpicture}\n\\end{center}\n\nThen, the element 5 is larger than the element 2,\nso it will be added to the stack, and\nits nearest smaller element is 2:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (4,0) rectangle (5,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$5$};\n\\node at (5.5,0.5) {$3$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\draw (0.2,0.2-1.2) rectangle (0.8,0.8-1.2);\n\\draw (3.2,0.2-1.2) rectangle (3.8,0.8-1.2);\n\\draw (4.2,0.2-1.2) rectangle (4.8,0.8-1.2);\n\n\\node at (0.5,0.5-1.2) {$1$};\n\\node at (3.5,0.5-1.2) {$2$};\n\\node at (4.5,0.5-1.2) {$5$};\n\n\\draw[->,thick] (0.8,0.5-1.2) -- (3.2,0.5-1.2);\n\\draw[->,thick] (3.8,0.5-1.2) -- (4.2,0.5-1.2);\n\\end{tikzpicture}\n\\end{center}\n\nAfter this, the element 5 is removed from the stack\nand the elements 3 and 4 are added to the stack:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (6,0) rectangle (7,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$5$};\n\\node at (5.5,0.5) {$3$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\draw (0.2,0.2-1.2) rectangle (0.8,0.8-1.2);\n\\draw (3.2,0.2-1.2) rectangle (3.8,0.8-1.2);\n\\draw (5.2,0.2-1.2) rectangle (5.8,0.8-1.2);\n\\draw (6.2,0.2-1.2) rectangle (6.8,0.8-1.2);\n\n\\node at (0.5,0.5-1.2) {$1$};\n\\node at (3.5,0.5-1.2) {$2$};\n\\node at (5.5,0.5-1.2) {$3$};\n\\node at (6.5,0.5-1.2) {$4$};\n\n\\draw[->,thick] (0.8,0.5-1.2) -- (3.2,0.5-1.2);\n\\draw[->,thick] (3.8,0.5-1.2) -- (5.2,0.5-1.2);\n\\draw[->,thick] (5.8,0.5-1.2) -- (6.2,0.5-1.2);\n\\end{tikzpicture}\n\\end{center}\n\nFinally, all elements except 1 are removed\nfrom the stack and the last element 2\nis added to the stack:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (7,0) rectangle (8,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$5$};\n\\node at (5.5,0.5) {$3$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\draw (0.2,0.2-1.2) rectangle (0.8,0.8-1.2);\n\\draw (7.2,0.2-1.2) rectangle (7.8,0.8-1.2);\n\n\\node at (0.5,0.5-1.2) {$1$};\n\\node at (7.5,0.5-1.2) {$2$};\n\n\\draw[->,thick] (0.8,0.5-1.2) -- (7.2,0.5-1.2);\n\\end{tikzpicture}\n\\end{center}\n\nThe efficiency of the algorithm depends on\nthe total number of stack operations.\nIf the current element is larger than\nthe top element in the stack, it is directly\nadded to the stack, which is efficient.\nHowever, sometimes the stack can contain several\nlarger elements and it takes time to remove them.\nStill, each element is added \\emph{exactly once} to the stack\nand removed \\emph{at most once} from the stack.\nThus, each element causes $O(1)$ stack operations,\nand the algorithm works in $O(n)$ time.\n\n", "chapter_name": "Amortized analysis", "chapter_path": "cphb/chapter08.tex"}, {"section_name": "Sliding window minimum", "section_content": "\\section{Sliding window minimum}\n\n\\index{sliding window}\n\\index{sliding window minimum}\n\nA \\key{sliding window} is a constant-size subarray\nthat moves from left to right through the array.\nAt each window position,\nwe want to calculate some information\nabout the elements inside the window.\nIn this section, we focus on the problem\nof maintaining the \\key{sliding window minimum},\nwhich means that\nwe should report the smallest value inside each window.\n\nThe sliding window minimum can be calculated\nusing a similar idea that we used to calculate\nthe nearest smaller elements.\nWe maintain a queue\nwhere each element is larger than\nthe previous element,\nand the first element\nalways corresponds to the minimum element inside the window.\nAfter each window move,\nwe remove elements from the end of the queue\nuntil the last queue element\nis smaller than the new window element,\nor the queue becomes empty.\nWe also remove the first queue element\nif it is not inside the window anymore.\nFinally, we add the new window element\nto the end of the queue.\n\nAs an example, consider the following array:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$2$};\n\\node at (1.5,0.5) {$1$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$3$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$1$};\n\\node at (7.5,0.5) {$2$};\n\\end{tikzpicture}\n\\end{center}\n\nSuppose that the size of the sliding window is 4.\nAt the first window position, the smallest value is 1:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (0,0) rectangle (4,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$2$};\n\\node at (1.5,0.5) {$1$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$3$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$1$};\n\\node at (7.5,0.5) {$2$};\n\n\\draw (1.2,0.2-1.2) rectangle (1.8,0.8-1.2);\n\\draw (2.2,0.2-1.2) rectangle (2.8,0.8-1.2);\n\\draw (3.2,0.2-1.2) rectangle (3.8,0.8-1.2);\n\n\\node at (1.5,0.5-1.2) {$1$};\n\\node at (2.5,0.5-1.2) {$4$};\n\\node at (3.5,0.5-1.2) {$5$};\n\n\\draw[->,thick] (1.8,0.5-1.2) -- (2.2,0.5-1.2);\n\\draw[->,thick] (2.8,0.5-1.2) -- (3.2,0.5-1.2);\n\\end{tikzpicture}\n\\end{center}\n\nThen the window moves one step right.\nThe new element 3 is smaller than the elements\n4 and 5 in the queue, so the elements 4 and 5\nare removed from the queue\nand the element 3 is added to the queue.\nThe smallest value is still 1.\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (1,0) rectangle (5,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$2$};\n\\node at (1.5,0.5) {$1$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$3$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$1$};\n\\node at (7.5,0.5) {$2$};\n\n\\draw (1.2,0.2-1.2) rectangle (1.8,0.8-1.2);\n\\draw (4.2,0.2-1.2) rectangle (4.8,0.8-1.2);\n\n\\node at (1.5,0.5-1.2) {$1$};\n\\node at (4.5,0.5-1.2) {$3$};\n\n\\draw[->,thick] (1.8,0.5-1.2) -- (4.2,0.5-1.2);\n\\end{tikzpicture}\n\\end{center}\n\nAfter this, the window moves again,\nand the smallest element 1\ndoes not belong to the window anymore.\nThus, it is removed from the queue and the smallest\nvalue is now 3. Also the new element 4\nis added to the queue.\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (2,0) rectangle (6,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$2$};\n\\node at (1.5,0.5) {$1$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$3$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$1$};\n\\node at (7.5,0.5) {$2$};\n\n\\draw (4.2,0.2-1.2) rectangle (4.8,0.8-1.2);\n\\draw (5.2,0.2-1.2) rectangle (5.8,0.8-1.2);\n\n\\node at (4.5,0.5-1.2) {$3$};\n\\node at (5.5,0.5-1.2) {$4$};\n\n\\draw[->,thick] (4.8,0.5-1.2) -- (5.2,0.5-1.2);\n\\end{tikzpicture}\n\\end{center}\n\nThe next new element 1 is smaller than all elements\nin the queue.\nThus, all elements are removed from the queue\nand it will only contain the element 1:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (3,0) rectangle (7,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$2$};\n\\node at (1.5,0.5) {$1$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$3$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$1$};\n\\node at (7.5,0.5) {$2$};\n\n\\draw (6.2,0.2-1.2) rectangle (6.8,0.8-1.2);\n\n\\node at (6.5,0.5-1.2) {$1$};\n\\end{tikzpicture}\n\\end{center}\n\nFinally the window reaches its last position.\nThe element 2 is added to the queue,\nbut the smallest value inside the window\nis still 1.\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (4,0) rectangle (8,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$2$};\n\\node at (1.5,0.5) {$1$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$5$};\n\\node at (4.5,0.5) {$3$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$1$};\n\\node at (7.5,0.5) {$2$};\n\n\\draw (6.2,0.2-1.2) rectangle (6.8,0.8-1.2);\n\\draw (7.2,0.2-1.2) rectangle (7.8,0.8-1.2);\n\n\\node at (6.5,0.5-1.2) {$1$};\n\\node at (7.5,0.5-1.2) {$2$};\n\n\\draw[->,thick] (6.8,0.5-1.2) -- (7.2,0.5-1.2);\n\\end{tikzpicture}\n\\end{center}\n\nSince each array element\nis added to the queue exactly once and\nremoved from the queue at most once,\nthe algorithm works in $O(n)$ time.\n\n\n\n", "chapter_name": "Amortized analysis", "chapter_path": "cphb/chapter08.tex"}, {"section_name": "Static array queries", "section_content": "\\chapter{Range queries}\n\n\\index{range query}\n\\index{sum query}\n\\index{minimum query}\n\\index{maximum query}\n\nIn this chapter, we discuss data structures\nthat allow us to efficiently process range queries.\nIn a \\key{range query},\nour task is to calculate a value\nbased on a subarray of an array.\nTypical range queries are:\n\\begin{itemize}\n\\item $\\texttt{sum}_q(a,b)$: calculate the sum of values in range $[a,b]$\n\\item $\\texttt{min}_q(a,b)$: find the minimum value in range $[a,b]$\n\\item $\\texttt{max}_q(a,b)$: find the maximum value in range $[a,b]$\n\\end{itemize}\n\nFor example, consider the range $[3,6]$ in the following array:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (3,0) rectangle (7,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$8$};\n\\node at (3.5,0.5) {$4$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$3$};\n\\node at (7.5,0.5) {$4$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nIn this case, $\\texttt{sum}_q(3,6)=14$,\n$\\texttt{min}_q(3,6)=1$ and $\\texttt{max}_q(3,6)=6$.\n\nA simple way to process range queries is to use\na loop that goes through all array values in the range.\nFor example, the following function can be\nused to process sum queries on an array:\n\n\\begin{lstlisting}\nint sum(int a, int b) {\n    int s = 0;\n    for (int i = a; i <= b; i++) {\n        s += array[i];\n    }\n    return s;\n}\n\\end{lstlisting}\n\nThis function works in $O(n)$ time,\nwhere $n$ is the size of the array.\nThus, we can process $q$ queries in $O(nq)$\ntime using the function.\nHowever, if both $n$ and $q$ are large, this approach\nis slow. Fortunately, it turns out that there are\nways to process range queries much more efficiently.\n\n\\section{Static array queries}\n\nWe first focus on a situation where\nthe array is \\emph{static}, i.e.,\nthe array values are never updated between the queries.\nIn this case, it suffices to construct\na static data structure that tells us\nthe answer for any possible query.\n\n\\subsubsection{Sum queries}\n\n\\index{prefix sum array}\n\nWe can easily process\nsum queries on a static array\nby constructing a \\key{prefix sum array}.\nEach value in the prefix sum array equals\nthe sum of values in the original array up to that position,\ni.e., the value at position $k$ is $\\texttt{sum}_q(0,k)$.\nThe prefix sum array can be constructed in $O(n)$ time.\n\nFor example, consider the following array:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n%\\fill[color=lightgray] (3,0) rectangle (7,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nThe corresponding prefix sum array is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n%\\fill[color=lightgray] (3,0) rectangle (7,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$4$};\n\\node at (2.5,0.5) {$8$};\n\\node at (3.5,0.5) {$16$};\n\\node at (4.5,0.5) {$22$};\n\\node at (5.5,0.5) {$23$};\n\\node at (6.5,0.5) {$27$};\n\\node at (7.5,0.5) {$29$};\n\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nSince the prefix sum array contains all values\nof $\\texttt{sum}_q(0,k)$,\nwe can calculate any value of\n$\\texttt{sum}_q(a,b)$ in $O(1)$ time as follows:\n\\[ \\texttt{sum}_q(a,b) = \\texttt{sum}_q(0,b) - \\texttt{sum}_q(0,a-1)\\]\nBy defining $\\texttt{sum}_q(0,-1)=0$,\nthe above formula also holds when $a=0$.\n\nFor example, consider the range $[3,6]$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (3,0) rectangle (7,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nIn this case $\\texttt{sum}_q(3,6)=8+6+1+4=19$.\nThis sum can be calculated from\ntwo values of the prefix sum array:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (2,0) rectangle (3,1);\n\\fill[color=lightgray] (6,0) rectangle (7,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$4$};\n\\node at (2.5,0.5) {$8$};\n\\node at (3.5,0.5) {$16$};\n\\node at (4.5,0.5) {$22$};\n\\node at (5.5,0.5) {$23$};\n\\node at (6.5,0.5) {$27$};\n\\node at (7.5,0.5) {$29$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nThus, $\\texttt{sum}_q(3,6)=\\texttt{sum}_q(0,6)-\\texttt{sum}_q(0,2)=27-8=19$.\n\nIt is also possible to generalize this idea\nto higher dimensions.\nFor example, we can construct a two-dimensional\nprefix sum array that can be used to calculate\nthe sum of any rectangular subarray in $O(1)$ time.\nEach sum in such an array corresponds to\na subarray\nthat begins at the upper-left corner of the array.\n\n\\begin{samepage}\nThe following picture illustrates the idea:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.54]\n\\draw[fill=lightgray] (3,2) rectangle (7,5);\n\\draw (0,0) grid (10,7);\n\\node[anchor=center] at (6.5, 2.5) {$A$};\n\\node[anchor=center] at (2.5, 2.5) {$B$};\n\\node[anchor=center] at (6.5, 5.5) {$C$};\n\\node[anchor=center] at (2.5, 5.5) {$D$};\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\nThe sum of the gray subarray can be calculated\nusing the formula\n\\[S(A) - S(B) - S(C) + S(D),\\]\nwhere $S(X)$ denotes the sum of values\nin a rectangular\nsubarray from the upper-left corner\nto the position of $X$.\n\n\\subsubsection{Minimum queries}\n\n\\index{sparse table}\n\nMinimum queries are more difficult to process\nthan sum queries.\nStill, there is a quite simple \n$O(n \\log n)$ time preprocessing\nmethod after which we can answer any minimum\nquery in $O(1)$ time\\footnote{This technique\nwas introduced in \\cite{ben00} and sometimes\ncalled the \\key{sparse table} method.\nThere are also more sophisticated techniques \\cite{fis06} where\nthe preprocessing time is only $O(n)$, but such algorithms\nare not needed in competitive programming.}.\nNote that since minimum and maximum queries can\nbe processed similarly,\nwe can focus on minimum queries.\n\nThe idea is to precalculate all values of\n$\\textrm{min}_q(a,b)$ where\n$b-a+1$ (the length of the range) is a power of two.\nFor example, for the array\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nthe following values are calculated:\n\n\\begin{center}\n\\begin{tabular}{ccc}\n\n\\begin{tabular}{lll}\n$a$ & $b$ & $\\texttt{min}_q(a,b)$ \\\\\n\\hline\n0 & 0 & 1 \\\\\n1 & 1 & 3 \\\\\n2 & 2 & 4 \\\\\n3 & 3 & 8 \\\\\n4 & 4 & 6 \\\\\n5 & 5 & 1 \\\\\n6 & 6 & 4 \\\\\n7 & 7 & 2 \\\\\n\\end{tabular}\n\n&\n\n\\begin{tabular}{lll}\n$a$ & $b$ & $\\texttt{min}_q(a,b)$ \\\\\n\\hline\n0 & 1 & 1 \\\\\n1 & 2 & 3 \\\\\n2 & 3 & 4 \\\\\n3 & 4 & 6 \\\\\n4 & 5 & 1 \\\\\n5 & 6 & 1 \\\\\n6 & 7 & 2 \\\\\n\\\\\n\\end{tabular}\n\n&\n\n\\begin{tabular}{lll}\n$a$ & $b$ & $\\texttt{min}_q(a,b)$ \\\\\n\\hline\n0 & 3 & 1 \\\\\n1 & 4 & 3 \\\\\n2 & 5 & 1 \\\\\n3 & 6 & 1 \\\\\n4 & 7 & 1 \\\\\n0 & 7 & 1 \\\\\n\\\\\n\\\\\n\\end{tabular}\n\n\\end{tabular}\n\\end{center}\n\nThe number of precalculated values is $O(n \\log n)$,\nbecause there are $O(\\log n)$ range lengths\nthat are powers of two.\nThe values can be calculated efficiently\nusing the recursive formula\n\\[\\texttt{min}_q(a,b) = \\min(\\texttt{min}_q(a,a+w-1),\\texttt{min}_q(a+w,b)),\\]\nwhere $b-a+1$ is a power of two and $w=(b-a+1)/2$.\nCalculating all those values takes $O(n \\log n)$ time.\n\nAfter this, any value of $\\texttt{min}_q(a,b)$ can be calculated\nin $O(1)$ time as a minimum of two precalculated values.\nLet $k$ be the largest power of two that does not exceed $b-a+1$.\nWe can calculate the value of $\\texttt{min}_q(a,b)$ using the formula\n\\[\\texttt{min}_q(a,b) = \\min(\\texttt{min}_q(a,a+k-1),\\texttt{min}_q(b-k+1,b)).\\]\nIn the above formula, the range $[a,b]$ is represented\nas the union of the ranges $[a,a+k-1]$ and $[b-k+1,b]$, both of length $k$.\n\nAs an example, consider the range $[1,6]$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (1,0) rectangle (7,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nThe length of the range is 6,\nand the largest power of two that does\nnot exceed 6 is 4.\nThus the range $[1,6]$ is\nthe union of the ranges $[1,4]$ and $[3,6]$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (1,0) rectangle (5,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (3,0) rectangle (7,1);\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nSince $\\texttt{min}_q(1,4)=3$ and $\\texttt{min}_q(3,6)=1$,\nwe conclude that $\\texttt{min}_q(1,6)=1$.\n\n", "chapter_name": "Range queries", "chapter_path": "cphb/chapter09.tex"}, {"section_name": "Binary indexed tree", "section_content": "\\section{Binary indexed tree}\n\n\\index{binary indexed tree}\n\\index{Fenwick tree}\n\nA \\key{binary indexed tree} or a \\key{Fenwick tree}\\footnote{The\nbinary indexed tree structure was presented by P. M. Fenwick in 1994 \\cite{fen94}.}\ncan be seen as a dynamic variant of a prefix sum array.\nIt supports two $O(\\log n)$ time operations on an array:\nprocessing a range sum query and updating a value.\n\nThe advantage of a binary indexed tree is\nthat it allows us to efficiently update\narray values between sum queries.\nThis would not be possible using a prefix sum array,\nbecause after each update, it would be necessary to build the\nwhole prefix sum array again in $O(n)$ time.\n\n\\subsubsection{Structure}\n\nEven if the name of the structure is a binary indexed \\emph{tree},\nit is usually represented as an array.\nIn this section we assume that all arrays are one-indexed,\nbecause it makes the implementation easier.\n\nLet $p(k)$ denote the largest power of two that\ndivides $k$.\nWe store a binary indexed tree as an array \\texttt{tree}\nsuch that\n\\[ \\texttt{tree}[k] = \\texttt{sum}_q(k-p(k)+1,k),\\]\ni.e., each position $k$ contains the sum of values\nin a range of the original array whose length is $p(k)$\nand that ends at position $k$.\nFor example, since $p(6)=2$, $\\texttt{tree}[6]$\ncontains the value of $\\texttt{sum}_q(5,6)$.\n\nFor example, consider the following array:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$8$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$1$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$2$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$1$};\n\\node at (1.5,1.4) {$2$};\n\\node at (2.5,1.4) {$3$};\n\\node at (3.5,1.4) {$4$};\n\\node at (4.5,1.4) {$5$};\n\\node at (5.5,1.4) {$6$};\n\\node at (6.5,1.4) {$7$};\n\\node at (7.5,1.4) {$8$};\n\\end{tikzpicture}\n\\end{center}\n\nThe corresponding binary indexed tree is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$4$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$16$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$29$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$1$};\n\\node at (1.5,1.4) {$2$};\n\\node at (2.5,1.4) {$3$};\n\\node at (3.5,1.4) {$4$};\n\\node at (4.5,1.4) {$5$};\n\\node at (5.5,1.4) {$6$};\n\\node at (6.5,1.4) {$7$};\n\\node at (7.5,1.4) {$8$};\n\\end{tikzpicture}\n\\end{center}\n\nThe following picture shows more clearly\nhow each value in the binary indexed tree\ncorresponds to a range in the original array:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$4$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$16$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$29$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$1$};\n\\node at (1.5,1.4) {$2$};\n\\node at (2.5,1.4) {$3$};\n\\node at (3.5,1.4) {$4$};\n\\node at (4.5,1.4) {$5$};\n\\node at (5.5,1.4) {$6$};\n\\node at (6.5,1.4) {$7$};\n\\node at (7.5,1.4) {$8$};\n\n\\draw[->,thick] (0.5,-0.9) -- (0.5,-0.1);\n\\draw[->,thick] (2.5,-0.9) -- (2.5,-0.1);\n\\draw[->,thick] (4.5,-0.9) -- (4.5,-0.1);\n\\draw[->,thick] (6.5,-0.9) -- (6.5,-0.1);\n\\draw[->,thick] (1.5,-1.9) -- (1.5,-0.1);\n\\draw[->,thick] (5.5,-1.9) -- (5.5,-0.1);\n\\draw[->,thick] (3.5,-2.9) -- (3.5,-0.1);\n\\draw[->,thick] (7.5,-3.9) -- (7.5,-0.1);\n\n\\draw (0,-1) -- (1,-1) -- (1,-1.5) -- (0,-1.5) -- (0,-1);\n\\draw (2,-1) -- (3,-1) -- (3,-1.5) -- (2,-1.5) -- (2,-1);\n\\draw (4,-1) -- (5,-1) -- (5,-1.5) -- (4,-1.5) -- (4,-1);\n\\draw (6,-1) -- (7,-1) -- (7,-1.5) -- (6,-1.5) -- (6,-1);\n\\draw (0,-2) -- (2,-2) -- (2,-2.5) -- (0,-2.5) -- (0,-2);\n\\draw (4,-2) -- (6,-2) -- (6,-2.5) -- (4,-2.5) -- (4,-2);\n\\draw (0,-3) -- (4,-3) -- (4,-3.5) -- (0,-3.5) -- (0,-3);\n\\draw (0,-4) -- (8,-4) -- (8,-4.5) -- (0,-4.5) -- (0,-4);\n\\end{tikzpicture}\n\\end{center}\n\nUsing a binary indexed tree,\nany value of $\\texttt{sum}_q(1,k)$\ncan be calculated in $O(\\log n)$ time,\nbecause a range $[1,k]$ can always be divided into\n$O(\\log n)$ ranges whose sums are stored in the tree.\n\nFor example, the range $[1,7]$ consists of\nthe following ranges:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$4$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$16$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$29$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$1$};\n\\node at (1.5,1.4) {$2$};\n\\node at (2.5,1.4) {$3$};\n\\node at (3.5,1.4) {$4$};\n\\node at (4.5,1.4) {$5$};\n\\node at (5.5,1.4) {$6$};\n\\node at (6.5,1.4) {$7$};\n\\node at (7.5,1.4) {$8$};\n\n\\draw[->,thick] (0.5,-0.9) -- (0.5,-0.1);\n\\draw[->,thick] (2.5,-0.9) -- (2.5,-0.1);\n\\draw[->,thick] (4.5,-0.9) -- (4.5,-0.1);\n\\draw[->,thick] (6.5,-0.9) -- (6.5,-0.1);\n\\draw[->,thick] (1.5,-1.9) -- (1.5,-0.1);\n\\draw[->,thick] (5.5,-1.9) -- (5.5,-0.1);\n\\draw[->,thick] (3.5,-2.9) -- (3.5,-0.1);\n\\draw[->,thick] (7.5,-3.9) -- (7.5,-0.1);\n\n\\draw (0,-1) -- (1,-1) -- (1,-1.5) -- (0,-1.5) -- (0,-1);\n\\draw (2,-1) -- (3,-1) -- (3,-1.5) -- (2,-1.5) -- (2,-1);\n\\draw (4,-1) -- (5,-1) -- (5,-1.5) -- (4,-1.5) -- (4,-1);\n\\draw[fill=lightgray] (6,-1) -- (7,-1) -- (7,-1.5) -- (6,-1.5) -- (6,-1);\n\\draw (0,-2) -- (2,-2) -- (2,-2.5) -- (0,-2.5) -- (0,-2);\n\\draw[fill=lightgray] (4,-2) -- (6,-2) -- (6,-2.5) -- (4,-2.5) -- (4,-2);\n\\draw[fill=lightgray] (0,-3) -- (4,-3) -- (4,-3.5) -- (0,-3.5) -- (0,-3);\n\\draw (0,-4) -- (8,-4) -- (8,-4.5) -- (0,-4.5) -- (0,-4);\n\\end{tikzpicture}\n\\end{center}\nThus, we can calculate the corresponding sum as follows:\n\\[\\texttt{sum}_q(1,7)=\\texttt{sum}_q(1,4)+\\texttt{sum}_q(5,6)+\\texttt{sum}_q(7,7)=16+7+4=27\\]\n\nTo calculate the value of $\\texttt{sum}_q(a,b)$ where $a>1$,\nwe can use the same trick that we used with prefix sum arrays:\n\\[ \\texttt{sum}_q(a,b) = \\texttt{sum}_q(1,b) - \\texttt{sum}_q(1,a-1).\\]\nSince we can calculate both $\\texttt{sum}_q(1,b)$\nand $\\texttt{sum}_q(1,a-1)$ in $O(\\log n)$ time,\nthe total time complexity is $O(\\log n)$.\n\nThen, after updating a value in the original array,\nseveral values in the binary indexed tree\nshould be updated.\nFor example, if the value at position 3 changes,\nthe sums of the following ranges change:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$4$};\n\\node at (2.5,0.5) {$4$};\n\\node at (3.5,0.5) {$16$};\n\\node at (4.5,0.5) {$6$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$4$};\n\\node at (7.5,0.5) {$29$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$1$};\n\\node at (1.5,1.4) {$2$};\n\\node at (2.5,1.4) {$3$};\n\\node at (3.5,1.4) {$4$};\n\\node at (4.5,1.4) {$5$};\n\\node at (5.5,1.4) {$6$};\n\\node at (6.5,1.4) {$7$};\n\\node at (7.5,1.4) {$8$};\n\n\\draw[->,thick] (0.5,-0.9) -- (0.5,-0.1);\n\\draw[->,thick] (2.5,-0.9) -- (2.5,-0.1);\n\\draw[->,thick] (4.5,-0.9) -- (4.5,-0.1);\n\\draw[->,thick] (6.5,-0.9) -- (6.5,-0.1);\n\\draw[->,thick] (1.5,-1.9) -- (1.5,-0.1);\n\\draw[->,thick] (5.5,-1.9) -- (5.5,-0.1);\n\\draw[->,thick] (3.5,-2.9) -- (3.5,-0.1);\n\\draw[->,thick] (7.5,-3.9) -- (7.5,-0.1);\n\n\\draw (0,-1) -- (1,-1) -- (1,-1.5) -- (0,-1.5) -- (0,-1);\n\\draw[fill=lightgray] (2,-1) -- (3,-1) -- (3,-1.5) -- (2,-1.5) -- (2,-1);\n\\draw (4,-1) -- (5,-1) -- (5,-1.5) -- (4,-1.5) -- (4,-1);\n\\draw (6,-1) -- (7,-1) -- (7,-1.5) -- (6,-1.5) -- (6,-1);\n\\draw (0,-2) -- (2,-2) -- (2,-2.5) -- (0,-2.5) -- (0,-2);\n\\draw (4,-2) -- (6,-2) -- (6,-2.5) -- (4,-2.5) -- (4,-2);\n\\draw[fill=lightgray] (0,-3) -- (4,-3) -- (4,-3.5) -- (0,-3.5) -- (0,-3);\n\\draw[fill=lightgray] (0,-4) -- (8,-4) -- (8,-4.5) -- (0,-4.5) -- (0,-4);\n\\end{tikzpicture}\n\\end{center}\n\nSince each array element belongs to $O(\\log n)$\nranges in the binary indexed tree,\nit suffices to update $O(\\log n)$ values in the tree.\n\n\\subsubsection{Implementation}\n\nThe operations of a binary indexed tree can be\nefficiently implemented using bit operations.\nThe key fact needed is that we can\ncalculate any value of $p(k)$ using the formula\n\\[p(k) = k \\& -k.\\]\n\nThe following function calculates the value of $\\texttt{sum}_q(1,k)$:\n\\begin{lstlisting}\nint sum(int k) {\n    int s = 0;\n    while (k >= 1) {\n        s += tree[k];\n        k -= k&-k;\n    }\n    return s;\n}\n\\end{lstlisting}\n\nThe following function increases the\narray value at position $k$ by $x$\n($x$ can be positive or negative):\n\\begin{lstlisting}\nvoid add(int k, int x) {\n    while (k <= n) {\n        tree[k] += x;\n        k += k&-k;\n    }\n}\n\\end{lstlisting}\n\nThe time complexity of both the functions is\n$O(\\log n)$, because the functions access $O(\\log n)$\nvalues in the binary indexed tree, and each move\nto the next position takes $O(1)$ time.\n\n", "chapter_name": "Range queries", "chapter_path": "cphb/chapter09.tex"}, {"section_name": "Segment tree", "section_content": "\\section{Segment tree}\n\n\\index{segment tree}\n\nA \\key{segment tree}\\footnote{The bottom-up-implementation in this chapter corresponds to\nthat in \\cite{sta06}. Similar structures were used\nin late 1970's to solve geometric problems \\cite{ben80}.} is a data structure\nthat supports two operations:\nprocessing a range query and\nupdating an array value.\nSegment trees can support\nsum queries, minimum and maximum queries and many other\nqueries so that both operations work in $O(\\log n)$ time.\n\nCompared to a binary indexed tree,\nthe advantage of a segment tree is that it is\na more general data structure.\nWhile binary indexed trees only support\nsum queries\\footnote{In fact, using \\emph{two} binary\nindexed trees it is possible to support minimum queries \\cite{dim15},\nbut this is more complicated than to use a segment tree.},\nsegment trees also support other queries.\nOn the other hand, a segment tree requires more\nmemory and is a bit more difficult to implement.\n\n\\subsubsection{Structure}\n\nA segment tree is a binary tree\nsuch that the nodes on the bottom level of the tree\ncorrespond to the array elements,\nand the other nodes\ncontain information needed for processing range queries.\n\nIn this section, we assume that the size\nof the array is a power of two and zero-based\nindexing is used, because it is convenient to build\na segment tree for such an array.\nIf the size of the array is not a power of two,\nwe can always append extra elements to it.\n\nWe will first discuss segment trees that support sum queries.\nAs an example, consider the following array:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$5$};\n\\node at (1.5,0.5) {$8$};\n\\node at (2.5,0.5) {$6$};\n\\node at (3.5,0.5) {$3$};\n\\node at (4.5,0.5) {$2$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$2$};\n\\node at (7.5,0.5) {$6$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nThe corresponding segment tree is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {2};\n\\node[anchor=center] at (5.5, 0.5) {7};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\n\\node[draw, circle] (a) at (1,2.5) {13};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,minimum size=22pt] (b) at (3,2.5) {9};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\\node[draw, circle,minimum size=22pt] (c) at (5,2.5) {9};\n\\path[draw,thick,-] (c) -- (4.5,1);\n\\path[draw,thick,-] (c) -- (5.5,1);\n\\node[draw, circle,minimum size=22pt] (d) at (7,2.5) {8};\n\\path[draw,thick,-] (d) -- (6.5,1);\n\\path[draw,thick,-] (d) -- (7.5,1);\n\n\\node[draw, circle] (i) at (2,4.5) {22};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, circle] (j) at (6,4.5) {17};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\n\\node[draw, circle] (m) at (4,6.5) {39};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\\end{tikzpicture}\n\\end{center}\n\nEach internal tree node\ncorresponds to an array range\nwhose size is a power of two.\nIn the above tree, the value of each internal\nnode is the sum of the corresponding array values,\nand it can be calculated as the sum of\nthe values of its left and right child node.\n\nIt turns out that any range $[a,b]$\ncan be divided into $O(\\log n)$ ranges\nwhose values are stored in tree nodes.\nFor example, consider the range [2,7]:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=gray!50] (2,0) rectangle (8,1);\n\\draw (0,0) grid (8,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {2};\n\\node[anchor=center] at (5.5, 0.5) {7};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\nHere $\\texttt{sum}_q(2,7)=6+3+2+7+2+6=26$.\nIn this case, the following two tree nodes\ncorrespond to the range:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {2};\n\\node[anchor=center] at (5.5, 0.5) {7};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\n\\node[draw, circle] (a) at (1,2.5) {13};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,fill=gray!50,minimum size=22pt] (b) at (3,2.5) {9};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\\node[draw, circle,minimum size=22pt] (c) at (5,2.5) {9};\n\\path[draw,thick,-] (c) -- (4.5,1);\n\\path[draw,thick,-] (c) -- (5.5,1);\n\\node[draw, circle,minimum size=22pt] (d) at (7,2.5) {8};\n\\path[draw,thick,-] (d) -- (6.5,1);\n\\path[draw,thick,-] (d) -- (7.5,1);\n\n\\node[draw, circle] (i) at (2,4.5) {22};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, circle,fill=gray!50] (j) at (6,4.5) {17};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\n\\node[draw, circle] (m) at (4,6.5) {39};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\\end{tikzpicture}\n\\end{center}\nThus, another way to calculate the sum is $9+17=26$.\n\nWhen the sum is calculated using nodes\nlocated as high as possible in the tree,\nat most two nodes on each level\nof the tree are needed.\nHence, the total number of nodes\nis $O(\\log n)$.\n\nAfter an array update,\nwe should update all nodes\nwhose value depends on the updated value.\nThis can be done by traversing the path\nfrom the updated array element to the top node\nand updating the nodes along the path.\n\nThe following picture shows which tree nodes\nchange if the array value 7 changes:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=gray!50] (5,0) rectangle (6,1);\n\\draw (0,0) grid (8,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {2};\n\\node[anchor=center] at (5.5, 0.5) {7};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\n\\node[draw, circle] (a) at (1,2.5) {13};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,minimum size=22pt] (b) at (3,2.5) {9};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\\node[draw, circle,minimum size=22pt,fill=gray!50] (c) at (5,2.5) {9};\n\\path[draw,thick,-] (c) -- (4.5,1);\n\\path[draw,thick,-] (c) -- (5.5,1);\n\\node[draw, circle,minimum size=22pt] (d) at (7,2.5) {8};\n\\path[draw,thick,-] (d) -- (6.5,1);\n\\path[draw,thick,-] (d) -- (7.5,1);\n\n\\node[draw, circle] (i) at (2,4.5) {22};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, circle,fill=gray!50] (j) at (6,4.5) {17};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\n\\node[draw, circle,fill=gray!50] (m) at (4,6.5) {39};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\\end{tikzpicture}\n\\end{center}\n\nThe path from bottom to top\nalways consists of $O(\\log n)$ nodes,\nso each update changes $O(\\log n)$ nodes in the tree.\n\n\\subsubsection{Implementation}\n\nWe store a segment tree as an array\nof $2n$ elements where $n$ is the size of\nthe original array and a power of two.\nThe tree nodes are stored from top to bottom:\n$\\texttt{tree}[1]$ is the top node,\n$\\texttt{tree}[2]$ and $\\texttt{tree}[3]$\nare its children, and so on.\nFinally, the values from $\\texttt{tree}[n]$\nto $\\texttt{tree}[2n-1]$ correspond to\nthe values of the original array\non the bottom level of the tree.\n\nFor example, the segment tree\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {2};\n\\node[anchor=center] at (5.5, 0.5) {7};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\n\\node[draw, circle] (a) at (1,2.5) {13};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,minimum size=22pt] (b) at (3,2.5) {9};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\\node[draw, circle,minimum size=22pt] (c) at (5,2.5) {9};\n\\path[draw,thick,-] (c) -- (4.5,1);\n\\path[draw,thick,-] (c) -- (5.5,1);\n\\node[draw, circle,minimum size=22pt] (d) at (7,2.5) {8};\n\\path[draw,thick,-] (d) -- (6.5,1);\n\\path[draw,thick,-] (d) -- (7.5,1);\n\n\\node[draw, circle] (i) at (2,4.5) {22};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, circle] (j) at (6,4.5) {17};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\n\\node[draw, circle] (m) at (4,6.5) {39};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\\end{tikzpicture}\n\\end{center}\nis stored as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (15,1);\n\n\\node at (0.5,0.5) {$39$};\n\\node at (1.5,0.5) {$22$};\n\\node at (2.5,0.5) {$17$};\n\\node at (3.5,0.5) {$13$};\n\\node at (4.5,0.5) {$9$};\n\\node at (5.5,0.5) {$9$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$5$};\n\\node at (8.5,0.5) {$8$};\n\\node at (9.5,0.5) {$6$};\n\\node at (10.5,0.5) {$3$};\n\\node at (11.5,0.5) {$2$};\n\\node at (12.5,0.5) {$7$};\n\\node at (13.5,0.5) {$2$};\n\\node at (14.5,0.5) {$6$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$1$};\n\\node at (1.5,1.4) {$2$};\n\\node at (2.5,1.4) {$3$};\n\\node at (3.5,1.4) {$4$};\n\\node at (4.5,1.4) {$5$};\n\\node at (5.5,1.4) {$6$};\n\\node at (6.5,1.4) {$7$};\n\\node at (7.5,1.4) {$8$};\n\\node at (8.5,1.4) {$9$};\n\\node at (9.5,1.4) {$10$};\n\\node at (10.5,1.4) {$11$};\n\\node at (11.5,1.4) {$12$};\n\\node at (12.5,1.4) {$13$};\n\\node at (13.5,1.4) {$14$};\n\\node at (14.5,1.4) {$15$};\n\\end{tikzpicture}\n\\end{center}\nUsing this representation,\nthe parent of $\\texttt{tree}[k]$\nis $\\texttt{tree}[\\lfloor k/2 \\rfloor]$,\nand its children are $\\texttt{tree}[2k]$\nand $\\texttt{tree}[2k+1]$.\nNote that this implies that the position of a node\nis even if it is a left child and odd if it is a right child.\n\nThe following function\ncalculates the value of $\\texttt{sum}_q(a,b)$:\n\\begin{lstlisting}\nint sum(int a, int b) {\n    a += n; b += n;\n    int s = 0;\n    while (a <= b) {\n        if (a%2 == 1) s += tree[a++];\n        if (b%2 == 0) s += tree[b--];\n        a /= 2; b /= 2;\n    }\n    return s;\n}\n\\end{lstlisting}\nThe function maintains a range\nthat is initially $[a+n,b+n]$.\nThen, at each step, the range is moved\none level higher in the tree,\nand before that, the values of the nodes that do not\nbelong to the higher range are added to the sum.\n\nThe following function increases the array value\nat position $k$ by $x$:\n\\begin{lstlisting}\nvoid add(int k, int x) {\n    k += n;\n    tree[k] += x;\n    for (k /= 2; k >= 1; k /= 2) {\n        tree[k] = tree[2*k]+tree[2*k+1];\n    }\n}\n\\end{lstlisting}\nFirst the function updates the value\nat the bottom level of the tree.\nAfter this, the function updates the values of all\ninternal tree nodes, until it reaches\nthe top node of the tree.\n\nBoth the above functions work\nin $O(\\log n)$ time, because a segment tree\nof $n$ elements consists of $O(\\log n)$ levels,\nand the functions move one level higher\nin the tree at each step.\n\n\\subsubsection{Other queries}\n\nSegment trees can support all range queries\nwhere it is possible to divide a range into two parts,\ncalculate the answer separately for both parts\nand then efficiently combine the answers.\nExamples of such queries are\nminimum and maximum, greatest common divisor,\nand bit operations and, or and xor.\n\nFor example, the following segment tree\nsupports minimum queries:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {1};\n\\node[anchor=center] at (5.5, 0.5) {7};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\n\\node[draw, circle,minimum size=22pt] (a) at (1,2.5) {5};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,minimum size=22pt] (b) at (3,2.5) {3};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\\node[draw, circle,minimum size=22pt] (c) at (5,2.5) {1};\n\\path[draw,thick,-] (c) -- (4.5,1);\n\\path[draw,thick,-] (c) -- (5.5,1);\n\\node[draw, circle,minimum size=22pt] (d) at (7,2.5) {2};\n\\path[draw,thick,-] (d) -- (6.5,1);\n\\path[draw,thick,-] (d) -- (7.5,1);\n\n\\node[draw, circle,minimum size=22pt] (i) at (2,4.5) {3};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, circle,minimum size=22pt] (j) at (6,4.5) {1};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\n\\node[draw, circle,minimum size=22pt] (m) at (4,6.5) {1};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\\end{tikzpicture}\n\\end{center}\n\nIn this case, every tree node contains\nthe smallest value in the corresponding\narray range.\nThe top node of the tree contains the smallest\nvalue in the whole array.\nThe operations can be implemented like previously,\nbut instead of sums, minima are calculated.\n\nThe structure of a segment tree also allows us\nto use binary search for locating array elements.\nFor example, if the tree supports minimum queries,\nwe can find the position of an element\nwith the smallest value in $O(\\log n)$ time.\n\nFor example, in the above tree, an\nelement with the smallest value 1 can be found\nby traversing a path downwards from the top node:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {1};\n\\node[anchor=center] at (5.5, 0.5) {7};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\n\\node[draw, circle,minimum size=22pt] (a) at (1,2.5) {5};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,minimum size=22pt] (b) at (3,2.5) {3};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\\node[draw, circle,minimum size=22pt] (c) at (5,2.5) {1};\n\\path[draw,thick,-] (c) -- (4.5,1);\n\\path[draw,thick,-] (c) -- (5.5,1);\n\\node[draw, circle,minimum size=22pt] (d) at (7,2.5) {2};\n\\path[draw,thick,-] (d) -- (6.5,1);\n\\path[draw,thick,-] (d) -- (7.5,1);\n\n\\node[draw, circle,minimum size=22pt] (i) at (2,4.5) {3};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, circle,minimum size=22pt] (j) at (6,4.5) {1};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\n\\node[draw, circle,minimum size=22pt] (m) at (4,6.5) {1};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\n\\path[draw=red,thick,->,line width=2pt] (m) -- (j);\n\\path[draw=red,thick,->,line width=2pt] (j) -- (c);\n\\path[draw=red,thick,->,line width=2pt] (c) -- (4.5,1);\n\\end{tikzpicture}\n\\end{center}\n\n", "chapter_name": "Range queries", "chapter_path": "cphb/chapter09.tex"}, {"section_name": "Additional techniques", "section_content": "\\section{Additional techniques}\n\n\\subsubsection{Index compression}\n\nA limitation in data structures that\nare built upon an array is that\nthe elements are indexed using\nconsecutive integers.\nDifficulties arise when large indices\nare needed.\nFor example, if we wish to use the index $10^9$,\nthe array should contain $10^9$\nelements which would require too much memory.\n\n\\index{index compression}\n\nHowever, we can often bypass this limitation\nby using \\key{index compression},\nwhere the original indices are replaced\nwith indices $1,2,3,$ etc.\nThis can be done if we know all the indices\nneeded during the algorithm beforehand.\n\nThe idea is to replace each original index $x$\nwith $c(x)$ where $c$ is a function that\ncompresses the indices.\nWe require that the order of the indices\ndoes not change, so if $a<b$, then $c(a)<c(b)$.\nThis allows us to conveniently perform queries\neven if the indices are compressed.\n\nFor example, if the original indices are\n$555$, $10^9$ and $8$, the new indices are:\n\n\\[\n\\begin{array}{lcl}\nc(8) & = & 1 \\\\\nc(555) & = & 2 \\\\\nc(10^9) & = & 3 \\\\\n\\end{array}\n\\]\n\n\\subsubsection{Range updates}\n\nSo far, we have implemented data structures\nthat support range queries and updates\nof single values.\nLet us now consider an opposite situation,\nwhere we should update ranges and\nretrieve single values.\nWe focus on an operation that increases all\nelements in a range $[a,b]$ by $x$.\n\n\\index{difference array}\n\nSurprisingly, we can use the data structures\npresented in this chapter also in this situation.\nTo do this, we build a \\key{difference array}\nwhose values indicate\nthe differences between consecutive values\nin the original array.\nThus, the original array is the\nprefix sum array of the\ndifference array.\nFor example, consider the following array:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$3$};\n\\node at (1.5,0.5) {$3$};\n\\node at (2.5,0.5) {$1$};\n\\node at (3.5,0.5) {$1$};\n\\node at (4.5,0.5) {$1$};\n\\node at (5.5,0.5) {$5$};\n\\node at (6.5,0.5) {$2$};\n\\node at (7.5,0.5) {$2$};\n\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\n\nThe difference array for the above array is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$3$};\n\\node at (1.5,0.5) {$0$};\n\\node at (2.5,0.5) {$-2$};\n\\node at (3.5,0.5) {$0$};\n\\node at (4.5,0.5) {$0$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$-3$};\n\\node at (7.5,0.5) {$0$};\n\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\n\nFor example, the value 2 at position 6 in the original array\ncorresponds to the sum $3-2+4-3=2$ in the difference array.\n\nThe advantage of the difference array is\nthat we can update a range\nin the original array by changing just\ntwo elements in the difference array.\nFor example, if we want to \nincrease the original array \nvalues between positions 1 and 4 by 5,\nit suffices to increase the\ndifference array value at position 1 by 5\nand decrease the value at position 5 by 5.\nThe result is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (8,1);\n\n\\node at (0.5,0.5) {$3$};\n\\node at (1.5,0.5) {$5$};\n\\node at (2.5,0.5) {$-2$};\n\\node at (3.5,0.5) {$0$};\n\\node at (4.5,0.5) {$0$};\n\\node at (5.5,0.5) {$-1$};\n\\node at (6.5,0.5) {$-3$};\n\\node at (7.5,0.5) {$0$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\end{tikzpicture}\n\\end{center}\n\nMore generally, to increase the values\nin range $[a,b]$ by $x$,\nwe increase the value at position $a$ by $x$\nand decrease the value at position $b+1$ by $x$.\nThus, it is only needed to update single values\nand process sum queries,\nso we can use a binary indexed tree or a segment tree.\n\nA more difficult problem is to support both\nrange queries and range updates.\nIn Chapter 28 we will see that even this is possible.\n\n\n\n", "chapter_name": "Range queries", "chapter_path": "cphb/chapter09.tex"}, {"section_name": "Bit representation", "section_content": "\\chapter{Bit manipulation}\n\nAll data in computer programs is internally stored as bits,\ni.e., as numbers 0 and 1.\nThis chapter discusses the bit representation\nof integers, and shows examples\nof how to use bit operations.\nIt turns out that there are many uses for\nbit manipulation in algorithm programming.\n\n\\section{Bit representation}\n\n\\index{bit representation}\n\nIn programming, an $n$ bit integer is internally\nstored as a binary number that consists of $n$ bits.\nFor example, the C++ type \\texttt{int} is\na 32-bit type, which means that every \\texttt{int}\nnumber consists of 32 bits.\n\nHere is the bit representation of\nthe \\texttt{int} number 43: \n\\[00000000000000000000000000101011\\]\nThe bits in the representation are indexed from right to left.\nTo convert a bit representation $b_k \\cdots b_2 b_1 b_0$ into a number,\nwe can use the formula\n\\[b_k 2^k + \\ldots + b_2 2^2 + b_1 2^1 + b_0 2^0.\\]\nFor example,\n\\[1 \\cdot 2^5 + 1 \\cdot 2^3 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 43.\\]\n\nThe bit representation of a number is either\n\\key{signed} or \\key{unsigned}.\nUsually a signed representation is used,\nwhich means that both negative and positive\nnumbers can be represented.\nA signed variable of $n$ bits can contain any\ninteger between $-2^{n-1}$ and $2^{n-1}-1$.\nFor example, the \\texttt{int} type in C++ is\na signed type, so an \\texttt{int} variable can contain any\ninteger between $-2^{31}$ and $2^{31}-1$.\n\nThe first bit in a signed representation\nis the sign of the number (0 for nonnegative numbers\nand 1 for negative numbers), and\nthe remaining $n-1$ bits contain the magnitude of the number.\n\\key{Two's complement} is used, which means that the\nopposite number of a number is calculated by first\ninverting all the bits in the number,\nand then increasing the number by one.\n\nFor example, the bit representation of\nthe \\texttt{int} number $-43$ is\n\\[11111111111111111111111111010101.\\]\n\nIn an unsigned representation, only nonnegative\nnumbers can be used, but the upper bound for the values is larger.\nAn unsigned variable of $n$ bits can contain any\ninteger between $0$ and $2^n-1$.\nFor example, in C++, an \\texttt{unsigned int} variable\ncan contain any integer between $0$ and $2^{32}-1$.\n\nThere is a connection between the\nrepresentations:\na signed number $-x$ equals an unsigned number $2^n-x$.\nFor example, the following code shows that\nthe signed number $x=-43$ equals the unsigned\nnumber $y=2^{32}-43$:\n\\begin{lstlisting}\nint x = -43;\nunsigned int y = x;\ncout << x << \"\\n\"; // -43\ncout << y << \"\\n\"; // 4294967253\n\\end{lstlisting}\n\nIf a number is larger than the upper bound\nof the bit representation, the number will overflow.\nIn a signed representation,\nthe next number after $2^{n-1}-1$ is $-2^{n-1}$,\nand in an unsigned representation,\nthe next number after $2^n-1$ is $0$.\nFor example, consider the following code:\n\\begin{lstlisting}\nint x = 2147483647\ncout << x << \"\\n\"; // 2147483647\nx++;\ncout << x << \"\\n\"; // -2147483648\n\\end{lstlisting}\n\nInitially, the value of $x$ is $2^{31}-1$.\nThis is the largest value that can be stored\nin an \\texttt{int} variable,\nso the next number after $2^{31}-1$ is $-2^{31}$.\n\n\n", "chapter_name": "Bit manipulation", "chapter_path": "cphb/chapter10.tex"}, {"section_name": "Bit operations", "section_content": "\\section{Bit operations}\n\n\\newcommand\\XOR{\\mathbin{\\char`\\^}}\n\n\\subsubsection{And operation}\n\n\\index{and operation}\n\nThe \\key{and} operation $x$ \\& $y$ produces a number\nthat has one bits in positions where both\n$x$ and $y$ have one bits.\nFor example, $22$ \\& $26$ = 18, because\n\n\\begin{center}\n\\begin{tabular}{rrr}\n& 10110 & (22)\\\\\n\\& & 11010 & (26) \\\\\n\\hline\n = & 10010 & (18) \\\\\n\\end{tabular}\n\\end{center}\n\nUsing the and operation, we can check if a number\n$x$ is even because\n$x$ \\& $1$ = 0 if $x$ is even, and\n$x$ \\& $1$ = 1 if $x$ is odd.\nMore generally, $x$ is divisible by $2^k$\nexactly when $x$ \\& $(2^k-1)$ = 0.\n\n\\subsubsection{Or operation}\n\n\\index{or operation}\n\nThe \\key{or} operation $x$ | $y$ produces a number\nthat has one bits in positions where at least one\nof $x$ and $y$ have one bits.\nFor example, $22$ | $26$ = 30, because\n\n\\begin{center}\n\\begin{tabular}{rrr}\n& 10110 & (22)\\\\\n| & 11010 & (26) \\\\\n\\hline\n = & 11110 & (30) \\\\\n\\end{tabular}\n\\end{center}\n\n\\subsubsection{Xor operation}\n\n\\index{xor operation}\n\nThe \\key{xor} operation $x$ $\\XOR$ $y$ produces a number\nthat has one bits in positions where exactly one\nof $x$ and $y$ have one bits.\nFor example, $22$ $\\XOR$ $26$ = 12, because\n\n\\begin{center}\n\\begin{tabular}{rrr}\n& 10110 & (22)\\\\\n$\\XOR$ & 11010 & (26) \\\\\n\\hline\n = & 01100 & (12) \\\\\n\\end{tabular}\n\\end{center}\n\n\\subsubsection{Not operation}\n\n\\index{not operation}\n\nThe \\key{not} operation \\textasciitilde$x$\nproduces a number where all the bits of $x$\nhave been inverted.\nThe formula \\textasciitilde$x = -x-1$ holds,\nfor example, \\textasciitilde$29 = -30$.\n\nThe result of the not operation at the bit level\ndepends on the length of the bit representation,\nbecause the operation inverts all bits.\nFor example, if the numbers are 32-bit\n\\texttt{int} numbers, the result is as follows:\n\n\\begin{center}\n\\begin{tabular}{rrrr}\n$x$ & = & 29 &   00000000000000000000000000011101 \\\\\n\\textasciitilde$x$ & = & $-30$ & 11111111111111111111111111100010 \\\\\n\\end{tabular}\n\\end{center}\n\n\\subsubsection{Bit shifts}\n\n\\index{bit shift}\n\nThe left bit shift $x < < k$ appends $k$\nzero bits to the number,\nand the right bit shift $x > > k$\nremoves the $k$ last bits from the number.\nFor example, $14 < < 2 = 56$,\nbecause $14$ and $56$ correspond to 1110 and 111000.\nSimilarly, $49 > > 3 = 6$,\nbecause $49$ and $6$ correspond to 110001 and 110.\n\nNote that $x < < k$\ncorresponds to multiplying $x$ by $2^k$,\nand $x > > k$\ncorresponds to dividing $x$ by $2^k$\nrounded down to an integer.\n\n\\subsubsection{Applications}\n\nA number of the form $1 < < k$ has a one bit\nin position $k$ and all other bits are zero,\nso we can use such numbers to access single bits of numbers.\nIn particular, the $k$th bit of a number is one\nexactly when $x$ \\& $(1 < < k)$ is not zero.\nThe following code prints the bit representation\nof an \\texttt{int} number $x$:\n\n\\begin{lstlisting}\nfor (int i = 31; i >= 0; i--) {\n    if (x&(1<<i)) cout << \"1\";\n    else cout << \"0\";\n}\n\\end{lstlisting}\n\nIt is also possible to modify single bits\nof numbers using similar ideas.\nFor example, the formula $x$ | $(1 < < k)$\nsets the $k$th bit of $x$ to one,\nthe formula\n$x$ \\& \\textasciitilde $(1 < < k)$\nsets the $k$th bit of $x$ to zero,\nand the formula\n$x$ $\\XOR$ $(1 < < k)$\ninverts the $k$th bit of $x$.\n\nThe formula $x$ \\& $(x-1)$ sets the last\none bit of $x$ to zero,\nand the formula $x$ \\& $-x$ sets all the\none bits to zero, except for the last one bit.\nThe formula $x$ | $(x-1)$\ninverts all the bits after the last one bit.\nAlso note that a positive number $x$ is\na power of two exactly when $x$ \\& $(x-1) = 0$.\n\n\\subsubsection*{Additional functions}\n\nThe g++ compiler provides the following\nfunctions for counting bits:\n\n\\begin{itemize}\n\\item\n$\\texttt{\\_\\_builtin\\_clz}(x)$:\nthe number of zeros at the beginning of the number\n\\item\n$\\texttt{\\_\\_builtin\\_ctz}(x)$:\nthe number of zeros at the end of the number\n\\item\n$\\texttt{\\_\\_builtin\\_popcount}(x)$:\nthe number of ones in the number\n\\item\n$\\texttt{\\_\\_builtin\\_parity}(x)$:\nthe parity (even or odd) of the number of ones\n\\end{itemize}\n\\begin{samepage}\n\nThe functions can be used as follows:\n\\begin{lstlisting}\nint x = 5328; // 00000000000000000001010011010000\ncout << __builtin_clz(x) << \"\\n\"; // 19\ncout << __builtin_ctz(x) << \"\\n\"; // 4\ncout << __builtin_popcount(x) << \"\\n\"; // 5\ncout << __builtin_parity(x) << \"\\n\"; // 1\n\\end{lstlisting}\n\\end{samepage}\n\nWhile the above functions only support \\texttt{int} numbers,\nthere are also \\texttt{long long} versions of\nthe functions available with the suffix \\texttt{ll}.\n\n", "chapter_name": "Bit manipulation", "chapter_path": "cphb/chapter10.tex"}, {"section_name": "Representing sets", "section_content": "\\section{Representing sets}\n\nEvery subset of a set\n$\\{0,1,2,\\ldots,n-1\\}$\ncan be represented as an $n$ bit integer\nwhose one bits indicate which\nelements belong to the subset.\nThis is an efficient way to represent sets,\nbecause every element requires only one bit of memory,\nand set operations can be implemented as bit operations.\n\nFor example, since \\texttt{int} is a 32-bit type,\nan \\texttt{int} number can represent any subset\nof the set $\\{0,1,2,\\ldots,31\\}$.\nThe bit representation of the set $\\{1,3,4,8\\}$ is\n\\[00000000000000000000000100011010,\\]\nwhich corresponds to the number $2^8+2^4+2^3+2^1=282$.\n\n\\subsubsection{Set implementation}\n\nThe following code declares an \\texttt{int}\nvariable $x$ that can contain\na subset of $\\{0,1,2,\\ldots,31\\}$.\nAfter this, the code adds the elements 1, 3, 4 and 8\nto the set and prints the size of the set.\n\\begin{lstlisting}\nint x = 0;\nx |= (1<<1);\nx |= (1<<3);\nx |= (1<<4);\nx |= (1<<8);\ncout << __builtin_popcount(x) << \"\\n\"; // 4\n\\end{lstlisting}\nThen, the following code prints all\nelements that belong to the set:\n\\begin{lstlisting}\nfor (int i = 0; i < 32; i++) {\n    if (x&(1<<i)) cout << i << \" \";\n}\n// output: 1 3 4 8\n\\end{lstlisting}\n\n\\subsubsection{Set operations}\n\nSet operations can be implemented as follows as bit operations:\n\n\\begin{center}\n\\begin{tabular}{lll}\n& set syntax & bit syntax \\\\\n\\hline\nintersection & $a \\cap b$ & $a$ \\& $b$ \\\\\nunion & $a \\cup b$ & $a$ | $b$ \\\\\ncomplement & $\\bar a$ & \\textasciitilde$a$ \\\\\ndifference & $a \\setminus b$ & $a$ \\& (\\textasciitilde$b$) \\\\\n\\end{tabular}\n\\end{center}\n\nFor example, the following code first constructs\nthe sets $x=\\{1,3,4,8\\}$ and $y=\\{3,6,8,9\\}$,\nand then constructs the set $z = x \\cup y = \\{1,3,4,6,8,9\\}$:\n\n\\begin{lstlisting}\nint x = (1<<1)|(1<<3)|(1<<4)|(1<<8);\nint y = (1<<3)|(1<<6)|(1<<8)|(1<<9);\nint z = x|y;\ncout << __builtin_popcount(z) << \"\\n\"; // 6\n\\end{lstlisting}\n\n\\subsubsection{Iterating through subsets}\n\nThe following code goes through\nthe subsets of $\\{0,1,\\ldots,n-1\\}$:\n\n\\begin{lstlisting}\nfor (int b = 0; b < (1<<n); b++) {\n    // process subset b\n}\n\\end{lstlisting}\nThe following code goes through\nthe subsets with exactly $k$ elements:\n\\begin{lstlisting}\nfor (int b = 0; b < (1<<n); b++) {\n    if (__builtin_popcount(b) == k) {\n        // process subset b\n    }\n}\n\\end{lstlisting}\nThe following code goes through the subsets\nof a set $x$:\n\\begin{lstlisting}\nint b = 0;\ndo {\n    // process subset b\n} while (b=(b-x)&x);\n\\end{lstlisting}\n\n", "chapter_name": "Bit manipulation", "chapter_path": "cphb/chapter10.tex"}, {"section_name": "Bit optimizations", "section_content": "\\section{Bit optimizations}\n\nMany algorithms can be optimized using\nbit operations.\nSuch optimizations do not change the\ntime complexity of the algorithm,\nbut they may have a large impact\non the actual running time of the code.\nIn this section we discuss examples\nof such situations.\n\n\\subsubsection{Hamming distances}\n\n\\index{Hamming distance}\nThe \\key{Hamming distance}\n$\\texttt{hamming}(a,b)$ between two\nstrings $a$ and $b$ of equal length is\nthe number of positions where the strings differ.\nFor example,\n\\[\\texttt{hamming}(01101,11001)=2.\\]\n\nConsider the following problem: Given\na list of $n$ bit strings, each of length $k$,\ncalculate the minimum Hamming distance\nbetween two strings in the list.\nFor example, the answer for $[00111,01101,11110]$\nis 2, because\n\\begin{itemize}[noitemsep]\n\\item $\\texttt{hamming}(00111,01101)=2$,\n\\item $\\texttt{hamming}(00111,11110)=3$, and\n\\item $\\texttt{hamming}(01101,11110)=3$.\n\\end{itemize}\n\nA straightforward way to solve the problem is\nto go through all pairs of strings and calculate\ntheir Hamming distances,\nwhich yields an $O(n^2 k)$ time algorithm.\nThe following function can be used to\ncalculate distances:\n\\begin{lstlisting}\nint hamming(string a, string b) {\n    int d = 0;\n    for (int i = 0; i < k; i++) {\n        if (a[i] != b[i]) d++;\n    }\n    return d;\n}\n\\end{lstlisting}\n\nHowever, if $k$ is small, we can optimize the code\nby storing the bit strings as integers and\ncalculating the Hamming distances using bit operations.\nIn particular, if $k \\le 32$, we can just store\nthe strings as \\texttt{int} values and use the\nfollowing function to calculate distances:\n\\begin{lstlisting}\nint hamming(int a, int b) {\n    return __builtin_popcount(a^b);\n}\n\\end{lstlisting}\nIn the above function, the xor operation constructs\na bit string that has one bits in positions\nwhere $a$ and $b$ differ.\nThen, the number of bits is calculated using\nthe \\texttt{\\_\\_builtin\\_popcount} function.\n\nTo compare the implementations, we generated\na list of 10000 random bit strings of length 30.\nUsing the first approach, the search took\n13.5 seconds, and after the bit optimization,\nit only took 0.5 seconds.\nThus, the bit optimized code was almost\n30 times faster than the original code.\n\n\\subsubsection{Counting subgrids}\n\nAs another example, consider the\nfollowing problem:\nGiven an $n \\times n$ grid whose\neach square is either black (1) or white (0),\ncalculate the number of subgrids\nwhose all corners are black.\nFor example, the grid\n\\begin{center}\n\\begin{tikzpicture}[scale=0.5]\n\\fill[black] (1,1) rectangle (2,2);\n\\fill[black] (1,4) rectangle (2,5);\n\\fill[black] (4,1) rectangle (5,2);\n\\fill[black] (4,4) rectangle (5,5);\n\\fill[black] (1,3) rectangle (2,4);\n\\fill[black] (2,3) rectangle (3,4);\n\\fill[black] (2,1) rectangle (3,2);\n\\fill[black] (0,2) rectangle (1,3);\n\\draw (0,0) grid (5,5);\n\\end{tikzpicture}\n\\end{center}\ncontains two such subgrids:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.5]\n\\fill[black] (1,1) rectangle (2,2);\n\\fill[black] (1,4) rectangle (2,5);\n\\fill[black] (4,1) rectangle (5,2);\n\\fill[black] (4,4) rectangle (5,5);\n\\fill[black] (1,3) rectangle (2,4);\n\\fill[black] (2,3) rectangle (3,4);\n\\fill[black] (2,1) rectangle (3,2);\n\\fill[black] (0,2) rectangle (1,3);\n\\draw (0,0) grid (5,5);\n\n\\fill[black] (7+1,1) rectangle (7+2,2);\n\\fill[black] (7+1,4) rectangle (7+2,5);\n\\fill[black] (7+4,1) rectangle (7+5,2);\n\\fill[black] (7+4,4) rectangle (7+5,5);\n\\fill[black] (7+1,3) rectangle (7+2,4);\n\\fill[black] (7+2,3) rectangle (7+3,4);\n\\fill[black] (7+2,1) rectangle (7+3,2);\n\\fill[black] (7+0,2) rectangle (7+1,3);\n\\draw (7+0,0) grid (7+5,5);\n\n\\draw[color=red,line width=1mm] (1,1) rectangle (3,4);\n\\draw[color=red,line width=1mm] (7+1,1) rectangle (7+5,5);\n\\end{tikzpicture}\n\\end{center}\n\nThere is an $O(n^3)$ time algorithm for solving the problem:\ngo through all $O(n^2)$ pairs of rows and for each pair\n$(a,b)$ calculate the number of columns that contain a black\nsquare in both rows in $O(n)$ time.\nThe following code assumes that $\\texttt{color}[y][x]$\ndenotes the color in row $y$ and column $x$:\n\\begin{lstlisting}\nint count = 0;\nfor (int i = 0; i < n; i++) {\n    if (color[a][i] == 1 && color[b][i] == 1) count++;\n}\n\\end{lstlisting}\nThen, those columns\naccount for $\\texttt{count}(\\texttt{count}-1)/2$ subgrids with black corners,\nbecause we can choose any two of them to form a subgrid.\n\nTo optimize this algorithm, we divide the grid into blocks\nof columns such that each block consists of $N$\nconsecutive columns. Then, each row is stored as\na list of $N$-bit numbers that describe the colors\nof the squares. Now we can process $N$ columns at the same time\nusing bit operations. In the following code,\n$\\texttt{color}[y][k]$ represents\na block of $N$ colors as bits.\n\\begin{lstlisting}\nint count = 0;\nfor (int i = 0; i <= n/N; i++) {\n    count += __builtin_popcount(color[a][i]&color[b][i]);\n}\n\\end{lstlisting}\nThe resulting algorithm works in $O(n^3/N)$ time.\n\nWe generated a random grid of size $2500 \\times 2500$\nand compared the original and bit optimized implementation.\nWhile the original code took $29.6$ seconds,\nthe bit optimized version only took $3.1$ seconds\nwith $N=32$ (\\texttt{int} numbers) and $1.7$ seconds\nwith $N=64$ (\\texttt{long long} numbers).\n\n", "chapter_name": "Bit manipulation", "chapter_path": "cphb/chapter10.tex"}, {"section_name": "Dynamic programming", "section_content": "\\section{Dynamic programming}\n\nBit operations provide an efficient and convenient\nway to implement dynamic programming algorithms\nwhose states contain subsets of elements,\nbecause such states can be stored as integers.\nNext we discuss examples of combining\nbit operations and dynamic programming.\n\n\\subsubsection{Optimal selection}\n\nAs a first example, consider the following problem:\nWe are given the prices of $k$ products\nover $n$ days, and we want to buy each product\nexactly once.\nHowever, we are allowed to buy at most one product\nin a day.\nWhat is the minimum total price?\nFor example, consider the following scenario ($k=3$ and $n=8$):\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n    \\draw (0, 0) grid (8,3);\n    \\node at (-2.5,2.5) {product 0};\n    \\node at (-2.5,1.5) {product 1};\n    \\node at (-2.5,0.5) {product 2};\n\n    \\foreach \\x in {0,...,7}\n        {\\node at (\\x+0.5,3.5) {\\x};}\n    \\foreach \\x/\\v in {0/6,1/9,2/5,3/2,4/8,5/9,6/1,7/6}\n        {\\node at (\\x+0.5,2.5) {\\v};}\n    \\foreach \\x/\\v in {0/8,1/2,2/6,3/2,4/7,5/5,6/7,7/2}\n        {\\node at (\\x+0.5,1.5) {\\v};}\n    \\foreach \\x/\\v in {0/5,1/3,2/9,3/7,4/3,5/5,6/1,7/4}\n        {\\node at (\\x+0.5,0.5) {\\v};}\n\\end{tikzpicture}\n\\end{center}\nIn this scenario, the minimum total price is $5$:\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n    \\fill [color=lightgray] (1, 1) rectangle (2, 2);\n    \\fill [color=lightgray] (3, 2) rectangle (4, 3);\n    \\fill [color=lightgray] (6, 0) rectangle (7, 1);\n    \\draw (0, 0) grid (8,3);\n    \\node at (-2.5,2.5) {product 0};\n    \\node at (-2.5,1.5) {product 1};\n    \\node at (-2.5,0.5) {product 2};\n\n    \\foreach \\x in {0,...,7}\n        {\\node at (\\x+0.5,3.5) {\\x};}\n    \\foreach \\x/\\v in {0/6,1/9,2/5,3/2,4/8,5/9,6/1,7/6}\n        {\\node at (\\x+0.5,2.5) {\\v};}\n    \\foreach \\x/\\v in {0/8,1/2,2/6,3/2,4/7,5/5,6/7,7/2}\n        {\\node at (\\x+0.5,1.5) {\\v};}\n    \\foreach \\x/\\v in {0/5,1/3,2/9,3/7,4/3,5/5,6/1,7/4}\n        {\\node at (\\x+0.5,0.5) {\\v};}\n\\end{tikzpicture}\n\\end{center}\n\nLet $\\texttt{price}[x][d]$ denote the price of product $x$\non day $d$.\nFor example, in the above scenario $\\texttt{price}[2][3] = 7$.\nThen, let $\\texttt{total}(S,d)$ denote the minimum total\nprice for buying a subset $S$ of products by day $d$.\nUsing this function, the solution to the problem is\n$\\texttt{total}(\\{0 \\ldots k-1\\},n-1)$.\n\nFirst, $\\texttt{total}(\\emptyset,d) = 0$,\nbecause it does not cost anything to buy an empty set,\nand $\\texttt{total}(\\{x\\},0) = \\texttt{price}[x][0]$,\nbecause there is one way to buy one product on the first day.\nThen, the following recurrence can be used:\n\\begin{equation*}\n\\begin{split}\n\\texttt{total}(S,d) = \\min( & \\texttt{total}(S,d-1), \\\\\n& \\min_{x \\in S} (\\texttt{total}(S \\setminus x,d-1)+\\texttt{price}[x][d]))\n\\end{split}\n\\end{equation*}\nThis means that we either do not buy any product on day $d$\nor buy a product $x$ that belongs to $S$.\nIn the latter case, we remove $x$ from $S$ and add the\nprice of $x$ to the total price.\n\nThe next step is to calculate the values of the function\nusing dynamic programming.\nTo store the function values, we declare an array\n\\begin{lstlisting}\nint total[1<<K][N];\n\\end{lstlisting}\nwhere $K$ and $N$ are suitably large constants.\nThe first dimension of the array corresponds to a bit\nrepresentation of a subset.\n\nFirst, the cases where $d=0$ can be processed as follows:\n\\begin{lstlisting}\nfor (int x = 0; x < k; x++) {\n    total[1<<x][0] = price[x][0];\n}\n\\end{lstlisting}\nThen, the recurrence translates into the following code:\n\\begin{lstlisting}\nfor (int d = 1; d < n; d++) {\n    for (int s = 0; s < (1<<k); s++) {\n        total[s][d] = total[s][d-1];\n        for (int x = 0; x < k; x++) {\n            if (s&(1<<x)) {\n                total[s][d] = min(total[s][d],\n                                    total[s^(1<<x)][d-1]+price[x][d]);\n            }\n        }\n    }\n}\n\\end{lstlisting}\nThe time complexity of the algorithm is $O(n 2^k k)$.\n\n\\subsubsection{From permutations to subsets}\n\nUsing dynamic programming, it is often possible\nto change an iteration over permutations into\nan iteration over subsets\\footnote{This technique was introduced in 1962\nby M. Held and R. M. Karp \\cite{hel62}.}.\nThe benefit of this is that\n$n!$, the number of permutations,\nis much larger than $2^n$, the number of subsets.\nFor example, if $n=20$, then\n$n! \\approx 2.4 \\cdot 10^{18}$ and $2^n \\approx 10^6$.\nThus, for certain values of $n$,\nwe can efficiently go through the subsets but not through the permutations.\n\nAs an example, consider the following problem:\nThere is an elevator with maximum weight $x$,\nand $n$ people with known weights\nwho want to get from the ground floor\nto the top floor.\nWhat is the minimum number of rides needed\nif the people enter the elevator in an optimal order?\n\nFor example, suppose that $x=10$, $n=5$\nand the weights are as follows:\n\\begin{center}\n\\begin{tabular}{ll}\nperson & weight \\\\\n\\hline\n0 & 2 \\\\\n1 & 3 \\\\\n2 & 3 \\\\\n3 & 5 \\\\\n4 & 6 \\\\\n\\end{tabular}\n\\end{center}\nIn this case, the minimum number of rides is 2.\nOne optimal order is $\\{0,2,3,1,4\\}$,\nwhich partitions the people into two rides:\nfirst $\\{0,2,3\\}$ (total weight 10),\nand then $\\{1,4\\}$ (total weight 9).\n\nThe problem can be easily solved in $O(n! n)$ time\nby testing all possible permutations of $n$ people.\nHowever, we can use dynamic programming to get\na more efficient $O(2^n n)$ time algorithm.\nThe idea is to calculate for each subset of people\ntwo values: the minimum number of rides needed and\nthe minimum weight of people who ride in the last group.\n\nLet $\\texttt{weight}[p]$ denote the weight of\nperson $p$.\nWe define two functions:\n$\\texttt{rides}(S)$ is the minimum number of\nrides for a subset $S$,\nand $\\texttt{last}(S)$ is the minimum weight\nof the last ride.\nFor example, in the above scenario\n\\[ \\texttt{rides}(\\{1,3,4\\})=2 \\hspace{10px} \\textrm{and}\n\\hspace{10px} \\texttt{last}(\\{1,3,4\\})=5,\\]\nbecause the optimal rides are $\\{1,4\\}$ and $\\{3\\}$,\nand the second ride has weight 5.\nOf course, our final goal is to calculate the value\nof $\\texttt{rides}(\\{0 \\ldots n-1\\})$.\n\nWe can calculate the values\nof the functions recursively and then apply\ndynamic programming.\nThe idea is to go through all people\nwho belong to $S$ and optimally\nchoose the last person $p$ who enters the elevator.\nEach such choice yields a subproblem\nfor a smaller subset of people.\nIf $\\texttt{last}(S \\setminus p)+\\texttt{weight}[p] \\le x$,\nwe can add $p$ to the last ride.\nOtherwise, we have to reserve a new ride\nthat initially only contains $p$.\n\nTo implement dynamic programming,\nwe declare an array\n\\begin{lstlisting}\npair<int,int> best[1<<N];\n\\end{lstlisting}\nthat contains for each subset $S$\na pair $(\\texttt{rides}(S),\\texttt{last}(S))$.\nWe set the value for an empty group as follows:\n\\begin{lstlisting}\nbest[0] = {1,0};\n\\end{lstlisting}\nThen, we can fill the array as follows:\n\n\\begin{lstlisting}\nfor (int s = 1; s < (1<<n); s++) {\n    // initial value: n+1 rides are needed\n    best[s] = {n+1,0};\n    for (int p = 0; p < n; p++) {\n        if (s&(1<<p)) {\n            auto option = best[s^(1<<p)];\n            if (option.second+weight[p] <= x) {\n                // add p to an existing ride\n                option.second += weight[p];\n            } else {\n                // reserve a new ride for p\n                option.first++;\n                option.second = weight[p];\n            }\n            best[s] = min(best[s], option);\n        }\n    }\n}\n\\end{lstlisting}\nNote that the above loop guarantees that\nfor any two subsets $S_1$ and $S_2$\nsuch that $S_1 \\subset S_2$, we process $S_1$ before $S_2$.\nThus, the dynamic programming values are calculated in the\ncorrect order.\n\n\\subsubsection{Counting subsets}\n\nOur last problem in this chapter is as follows:\nLet $X=\\{0 \\ldots n-1\\}$, and each subset $S \\subset X$\nis assigned an integer $\\texttt{value}[S]$.\nOur task is to calculate for each $S$\n\\[\\texttt{sum}(S) = \\sum_{A \\subset S} \\texttt{value}[A],\\]\ni.e., the sum of values of subsets of $S$.\n\nFor example, suppose that $n=3$ and the values are as follows:\n\\begin{multicols}{2}\n\\begin{itemize}\n\\item $\\texttt{value}[\\emptyset] = 3$\n\\item $\\texttt{value}[\\{0\\}] = 1$\n\\item $\\texttt{value}[\\{1\\}] = 4$\n\\item $\\texttt{value}[\\{0,1\\}] = 5$\n\\item $\\texttt{value}[\\{2\\}] = 5$\n\\item $\\texttt{value}[\\{0,2\\}] = 1$\n\\item $\\texttt{value}[\\{1,2\\}] = 3$\n\\item $\\texttt{value}[\\{0,1,2\\}] = 3$\n\\end{itemize}\n\\end{multicols}\nIn this case, for example,\n\\begin{equation*}\n\\begin{split}\n\\texttt{sum}(\\{0,2\\}) &= \\texttt{value}[\\emptyset]+\\texttt{value}[\\{0\\}]+\\texttt{value}[\\{2\\}]+\\texttt{value}[\\{0,2\\}] \\\\ \n                      &= 3 + 1 + 5 + 1 = 10.\n\\end{split}\n\\end{equation*}\n\nBecause there are a total of $2^n$ subsets,\none possible solution is to go through all\npairs of subsets in $O(2^{2n})$ time.\nHowever, using dynamic programming, we\ncan solve the problem in $O(2^n n)$ time.\nThe idea is to focus on sums where the\nelements that may be removed from $S$ are restricted.\n\nLet $\\texttt{partial}(S,k)$ denote the sum of\nvalues of subsets of $S$ with the restriction\nthat only elements $0 \\ldots k$\nmay be removed from $S$.\nFor example,\n\\[\\texttt{partial}(\\{0,2\\},1)=\\texttt{value}[\\{2\\}]+\\texttt{value}[\\{0,2\\}],\\]\nbecause we may only remove elements $0 \\ldots 1$.\nWe can calculate values of \\texttt{sum} using\nvalues of \\texttt{partial}, because\n\\[\\texttt{sum}(S) = \\texttt{partial}(S,n-1).\\]\nThe base cases for the function are\n\\[\\texttt{partial}(S,-1)=\\texttt{value}[S],\\]\nbecause in this case no elements can be removed from $S$.\nThen, in the general case we can use the following recurrence:\n\\begin{equation*}\n    \\texttt{partial}(S,k) = \\begin{cases}\n               \\texttt{partial}(S,k-1) & k \\notin S \\\\\n               \\texttt{partial}(S,k-1) + \\texttt{partial}(S \\setminus \\{k\\},k-1) & k \\in S\n           \\end{cases}\n\\end{equation*}\nHere we focus on the element $k$.\nIf $k \\in S$, we have two options: we may either keep $k$ in $S$\nor remove it from $S$.\n\nThere is a particularly clever way to implement the\ncalculation of sums. We can declare an array\n\\begin{lstlisting}\nint sum[1<<N];\n\\end{lstlisting}\nthat will contain the sum of each subset.\nThe array is initialized as follows:\n\\begin{lstlisting}\nfor (int s = 0; s < (1<<n); s++) {\n    sum[s] = value[s];\n}\n\\end{lstlisting}\nThen, we can fill the array as follows:\n\\begin{lstlisting}\nfor (int k = 0; k < n; k++) {\n    for (int s = 0; s < (1<<n); s++) {\n        if (s&(1<<k)) sum[s] += sum[s^(1<<k)];\n    }\n}\n\\end{lstlisting}\nThis code calculates the values of $\\texttt{partial}(S,k)$\nfor $k=0 \\ldots n-1$ to the array \\texttt{sum}.\nSince $\\texttt{partial}(S,k)$ is always based on\n$\\texttt{partial}(S,k-1)$, we can reuse the array\n\\texttt{sum}, which yields a very efficient implementation.", "chapter_name": "Bit manipulation", "chapter_path": "cphb/chapter10.tex"}, {"section_name": "Graph terminology", "section_content": "\\chapter{Basics of graphs}\n\nMany programming problems can be solved by\nmodeling the problem as a graph problem\nand using an appropriate graph algorithm.\nA typical example of a graph is a network\nof roads and cities in a country.\nSometimes, though, the graph is hidden\nin the problem and it may be difficult to detect it.\n\nThis part of the book discusses graph algorithms,\nespecially focusing on topics that\nare important in competitive programming.\nIn this chapter, we go through concepts\nrelated to graphs,\nand study different ways to represent graphs in algorithms.\n\n\\section{Graph terminology}\n\n\\index{graph}\n\\index{node}\n\\index{edge}\n\nA \\key{graph} consists of \\key{nodes}\nand \\key{edges}. In this book,\nthe variable $n$ denotes the number of nodes\nin a graph, and the variable $m$ denotes\nthe number of edges.\nThe nodes are numbered\nusing integers $1,2,\\ldots,n$.\n\nFor example, the following graph consists of 5 nodes and 7 edges:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (6,2) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\n\\index{path}\n\nA \\key{path} leads from node $a$ to node $b$\nthrough edges of the graph.\nThe \\key{length} of a path is the number of\nedges in it.\nFor example, the above graph contains\na path $1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5$\nof length 3\nfrom node 1 to node 5:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (6,2) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (4);\n\\path[draw=red,thick,->,line width=2pt] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\n\\index{cycle}\n\nA path is a \\key{cycle} if the first and last\nnode is the same.\nFor example, the above graph contains\na cycle $1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1$.\nA path is \\key{simple} if each node appears\nat most once in the path.\n\n\n% \n% \\begin{itemize}\n% \\item $1 \\rightarrow 2 \\rightarrow 5$ (length 2)\n% \\item $1 \\rightarrow 4 \\rightarrow 5$ (length 2)\n% \\item $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5$ (length 3)\n% \\item $1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5$ (length 3)\n% \\item $1 \\rightarrow 4 \\rightarrow 2 \\rightarrow 5$ (length 3)\n% \\item $1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 2 \\rightarrow 5$ (length 4)\n% \\end{itemize}\n\n\\subsubsection{Connectivity}\n\n\\index{connected graph}\n\nA graph is \\key{connected} if there is a path\nbetween any two nodes.\nFor example, the following graph is connected:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\end{tikzpicture}\n\\end{center}\n\nThe following graph is not connected,\nbecause it is not possible to get\nfrom node 4 to any other node:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (2) -- (3);\n\\end{tikzpicture}\n\\end{center}\n\n\\index{component}\n\nThe connected parts of a graph are\ncalled its \\key{components}.\nFor example, the following graph\ncontains three components:\n$\\{1,\\,2,\\,3\\}$,\n$\\{4,\\,5,\\,6,\\,7\\}$ and\n$\\{8\\}$.\n\\begin{center}\n\\begin{tikzpicture}[scale=0.8]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\n\\node[draw, circle] (6) at (6,1) {$6$};\n\\node[draw, circle] (7) at (9,1) {$7$};\n\\node[draw, circle] (4) at (6,3) {$4$};\n\\node[draw, circle] (5) at (9,3) {$5$};\n\n\\node[draw, circle] (8) at (11,2) {$8$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (4) -- (5);\n\\path[draw,thick,-] (5) -- (7);\n\\path[draw,thick,-] (6) -- (7);\n\\path[draw,thick,-] (6) -- (4);\n\\end{tikzpicture}\n\\end{center}\n\n\\index{tree}\n\nA \\key{tree} is a connected graph\nthat consists of $n$ nodes and $n-1$ edges.\nThere is a unique path\nbetween any two nodes of a tree.\nFor example, the following graph is a tree:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (6,2) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n%\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (4);\n%\\path[draw,thick,-] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Edge directions}\n\n\\index{directed graph}\n\nA graph is \\key{directed}\nif the edges can be traversed\nin one direction only.\nFor example, the following graph is directed:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (6,2) {$5$};\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (4);\n\\path[draw,thick,->,>=latex] (2) -- (5);\n\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\path[draw,thick,->,>=latex] (3) -- (1);\n\\end{tikzpicture}\n\\end{center}\n\nThe above graph contains\na path $3 \\rightarrow 1 \\rightarrow 2 \\rightarrow 5$\nfrom node $3$ to node $5$,\nbut there is no path from node $5$ to node $3$.\n\n\\subsubsection{Edge weights}\n\n\\index{weighted graph}\n\nIn a \\key{weighted} graph, each edge is assigned\na \\key{weight}.\nThe weights are often interpreted as edge lengths.\nFor example, the following graph is weighted:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (6,2) {$5$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:5] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:1] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:7] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:7] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:3] {} (5);\n\\end{tikzpicture}\n\\end{center}\n\nThe length of a path in a weighted graph\nis the sum of the edge weights on the path.\nFor example, in the above graph,\nthe length of the path\n$1 \\rightarrow 2 \\rightarrow 5$ is $12$,\nand the length of the path\n$1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5$ is $11$.\nThe latter path is the \\key{shortest} path from node $1$ to node $5$.\n\n\\subsubsection{Neighbors and degrees}\n\n\\index{neighbor}\n\\index{degree}\n\nTwo nodes are \\key{neighbors} or \\key{adjacent}\nif there is an edge between them.\nThe \\key{degree} of a node\nis the number of its neighbors.\nFor example, in the following graph,\nthe neighbors of node 2 are 1, 4 and 5,\nso its degree is 3.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (6,2) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n%\\path[draw,thick,-] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\nThe sum of degrees in a graph is always $2m$,\nwhere $m$ is the number of edges,\nbecause each edge\nincreases the degree of exactly two nodes by one.\nFor this reason, the sum of degrees is always even.\n\n\\index{regular graph}\n\\index{complete graph}\n\nA graph is \\key{regular} if the\ndegree of every node is a constant $d$.\nA graph is \\key{complete} if the\ndegree of every node is $n-1$, i.e.,\nthe graph contains all possible edges\nbetween the nodes.\n\n\\index{indegree}\n\\index{outdegree}\n\nIn a directed graph, the \\key{indegree}\nof a node is the number of edges\nthat end at the node,\nand the \\key{outdegree} of a node\nis the number of edges that start at the node.\nFor example, in the following graph,\nthe indegree of node 2 is 2,\nand the outdegree of node 2 is 1.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (6,2) {$5$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (1) -- (3);\n\\path[draw,thick,->,>=latex] (1) -- (4);\n\\path[draw,thick,->,>=latex] (3) -- (4);\n\\path[draw,thick,->,>=latex] (2) -- (4);\n\\path[draw,thick,<-,>=latex] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Colorings}\n\n\\index{coloring}\n\\index{bipartite graph}\n\nIn a \\key{coloring} of a graph,\neach node is assigned a color so that\nno adjacent nodes have the same color.\n\nA graph is \\key{bipartite} if\nit is possible to color it using two colors.\nIt turns out that a graph is bipartite\nexactly when it does not contain a cycle\nwith an odd number of edges.\nFor example, the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$2$};\n\\node[draw, circle] (2) at (4,3) {$3$};\n\\node[draw, circle] (3) at (1,1) {$5$};\n\\node[draw, circle] (4) at (4,1) {$6$};\n\\node[draw, circle] (5) at (-2,1) {$4$};\n\\node[draw, circle] (6) at (-2,3) {$1$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (5) -- (6);\n\\end{tikzpicture}\n\\end{center}\nis bipartite, because it can be colored as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle, fill=blue!40] (1) at (1,3) {$2$};\n\\node[draw, circle, fill=red!40] (2) at (4,3) {$3$};\n\\node[draw, circle, fill=red!40] (3) at (1,1) {$5$};\n\\node[draw, circle, fill=blue!40] (4) at (4,1) {$6$};\n\\node[draw, circle, fill=red!40] (5) at (-2,1) {$4$};\n\\node[draw, circle, fill=blue!40] (6) at (-2,3) {$1$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (5) -- (6);\n\\end{tikzpicture}\n\\end{center}\nHowever, the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$2$};\n\\node[draw, circle] (2) at (4,3) {$3$};\n\\node[draw, circle] (3) at (1,1) {$5$};\n\\node[draw, circle] (4) at (4,1) {$6$};\n\\node[draw, circle] (5) at (-2,1) {$4$};\n\\node[draw, circle] (6) at (-2,3) {$1$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (5) -- (6);\n\\path[draw,thick,-] (1) -- (6);\n\\end{tikzpicture}\n\\end{center}\nis not bipartite, because it is not possible to color\nthe following cycle of three nodes using two colors:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$2$};\n\\node[draw, circle] (2) at (4,3) {$3$};\n\\node[draw, circle] (3) at (1,1) {$5$};\n\\node[draw, circle] (4) at (4,1) {$6$};\n\\node[draw, circle] (5) at (-2,1) {$4$};\n\\node[draw, circle] (6) at (-2,3) {$1$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (5) -- (6);\n\\path[draw,thick,-] (1) -- (6);\n\n\\path[draw=red,thick,-,line width=2pt] (1) -- (3);\n\\path[draw=red,thick,-,line width=2pt] (3) -- (6);\n\\path[draw=red,thick,-,line width=2pt] (6) -- (1);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Simplicity}\n\n\\index{simple graph}\n\nA graph is \\key{simple}\nif no edge starts and ends at the same node,\nand there are no multiple\nedges between two nodes.\nOften we assume that graphs are simple.\nFor example, the following graph is \\emph{not} simple:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$2$};\n\\node[draw, circle] (2) at (4,3) {$3$};\n\\node[draw, circle] (3) at (1,1) {$5$};\n\\node[draw, circle] (4) at (4,1) {$6$};\n\\node[draw, circle] (5) at (-2,1) {$4$};\n\\node[draw, circle] (6) at (-2,3) {$1$};\n\n\\path[draw,thick,-] (1) edge [bend right=20] (2);\n\\path[draw,thick,-] (2) edge [bend right=20] (1);\n%\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (5) -- (6);\n\n\\tikzset{every loop/.style={in=135,out=190}}\n\\path[draw,thick,-] (5) edge [loop left] (5);\n\\end{tikzpicture}\n\\end{center}\n\n", "chapter_name": "Basics of graphs", "chapter_path": "cphb/chapter11.tex"}, {"section_name": "Graph representation", "section_content": "\\section{Graph representation}\n\nThere are several ways to represent graphs\nin algorithms.\nThe choice of a data structure\ndepends on the size of the graph and\nthe way the algorithm processes it.\nNext we will go through three common representations.\n\n\\subsubsection{Adjacency list representation}\n\n\\index{adjacency list}\n\nIn the adjacency list representation,\neach node $x$ in the graph is assigned an \\key{adjacency list}\nthat consists of nodes\nto which there is an edge from $x$.\nAdjacency lists are the most popular\nway to represent graphs, and most algorithms can be\nefficiently implemented using them.\n\nA convenient way to store the adjacency lists is to declare\nan array of vectors as follows:\n\\begin{lstlisting}\nvector<int> adj[N];\n\\end{lstlisting}\n\nThe constant $N$ is chosen so that all\nadjacency lists can be stored.\nFor example, the graph\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (3,1) {$4$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (2) -- (4);\n\\path[draw,thick,->,>=latex] (3) -- (4);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\end{tikzpicture}\n\\end{center}\ncan be stored as follows:\n\\begin{lstlisting}\nadj[1].push_back(2);\nadj[2].push_back(3);\nadj[2].push_back(4);\nadj[3].push_back(4);\nadj[4].push_back(1);\n\\end{lstlisting}\n\nIf the graph is undirected, it can be stored in a similar way,\nbut each edge is added in both directions.\n\nFor a weighted graph, the structure can be extended\nas follows:\n\n\\begin{lstlisting}\nvector<pair<int,int>> adj[N];\n\\end{lstlisting}\n\nIn this case, the adjacency list of node $a$\ncontains the pair $(b,w)$\nalways when there is an edge from node $a$ to node $b$\nwith weight $w$. For example, the graph\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (3,1) {$4$};\n\n\\path[draw,thick,->,>=latex] (1) -- node[font=\\small,label=above:5] {} (2);\n\\path[draw,thick,->,>=latex] (2) -- node[font=\\small,label=above:7] {} (3);\n\\path[draw,thick,->,>=latex] (2) -- node[font=\\small,label=left:6] {} (4);\n\\path[draw,thick,->,>=latex] (3) -- node[font=\\small,label=right:5] {} (4);\n\\path[draw,thick,->,>=latex] (4) -- node[font=\\small,label=left:2] {} (1);\n\\end{tikzpicture}\n\\end{center}\ncan be stored as follows:\n\\begin{lstlisting}\nadj[1].push_back({2,5});\nadj[2].push_back({3,7});\nadj[2].push_back({4,6});\nadj[3].push_back({4,5});\nadj[4].push_back({1,2});\n\\end{lstlisting}\n\nThe benefit of using adjacency lists is that\nwe can efficiently find the nodes to which\nwe can move from a given node through an edge.\nFor example, the following loop goes through all nodes\nto which we can move from node $s$:\n\n\\begin{lstlisting}\nfor (auto u : adj[s]) {\n    // process node u\n}\n\\end{lstlisting}\n\n\\subsubsection{Adjacency matrix representation}\n\n\\index{adjacency matrix}\n\nAn \\key{adjacency matrix} is a two-dimensional array\nthat indicates which edges the graph contains.\nWe can efficiently check from an adjacency matrix\nif there is an edge between two nodes.\nThe matrix can be stored as an array\n\\begin{lstlisting}\nint adj[N][N];\n\\end{lstlisting}\nwhere each value $\\texttt{adj}[a][b]$ indicates\nwhether the graph contains an edge from\nnode $a$ to node $b$.\nIf the edge is included in the graph,\nthen $\\texttt{adj}[a][b]=1$,\nand otherwise $\\texttt{adj}[a][b]=0$.\nFor example, the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (3,1) {$4$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (2) -- (4);\n\\path[draw,thick,->,>=latex] (3) -- (4);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\end{tikzpicture}\n\\end{center}\ncan be represented as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (4,4);\n\\node at (0.5,0.5) {1};\n\\node at (1.5,0.5) {0};\n\\node at (2.5,0.5) {0};\n\\node at (3.5,0.5) {0};\n\\node at (0.5,1.5) {0};\n\\node at (1.5,1.5) {0};\n\\node at (2.5,1.5) {0};\n\\node at (3.5,1.5) {1};\n\\node at (0.5,2.5) {0};\n\\node at (1.5,2.5) {0};\n\\node at (2.5,2.5) {1};\n\\node at (3.5,2.5) {1};\n\\node at (0.5,3.5) {0};\n\\node at (1.5,3.5) {1};\n\\node at (2.5,3.5) {0};\n\\node at (3.5,3.5) {0};\n\\node at (-0.5,0.5) {4};\n\\node at (-0.5,1.5) {3};\n\\node at (-0.5,2.5) {2};\n\\node at (-0.5,3.5) {1};\n\\node at (0.5,4.5) {1};\n\\node at (1.5,4.5) {2};\n\\node at (2.5,4.5) {3};\n\\node at (3.5,4.5) {4};\n\\end{tikzpicture}\n\\end{center}\n\nIf the graph is weighted, the adjacency matrix\nrepresentation can be extended so that\nthe matrix contains the weight of the edge\nif the edge exists.\nUsing this representation, the graph\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (3,1) {$4$};\n\n\\path[draw,thick,->,>=latex] (1) -- node[font=\\small,label=above:5] {} (2);\n\\path[draw,thick,->,>=latex] (2) -- node[font=\\small,label=above:7] {} (3);\n\\path[draw,thick,->,>=latex] (2) -- node[font=\\small,label=left:6] {} (4);\n\\path[draw,thick,->,>=latex] (3) -- node[font=\\small,label=right:5] {} (4);\n\\path[draw,thick,->,>=latex] (4) -- node[font=\\small,label=left:2] {} (1);\n\\end{tikzpicture}\n\\end{center}\n\\begin{samepage}\ncorresponds to the following matrix:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (4,4);\n\\node at (0.5,0.5) {2};\n\\node at (1.5,0.5) {0};\n\\node at (2.5,0.5) {0};\n\\node at (3.5,0.5) {0};\n\\node at (0.5,1.5) {0};\n\\node at (1.5,1.5) {0};\n\\node at (2.5,1.5) {0};\n\\node at (3.5,1.5) {5};\n\\node at (0.5,2.5) {0};\n\\node at (1.5,2.5) {0};\n\\node at (2.5,2.5) {7};\n\\node at (3.5,2.5) {6};\n\\node at (0.5,3.5) {0};\n\\node at (1.5,3.5) {5};\n\\node at (2.5,3.5) {0};\n\\node at (3.5,3.5) {0};\n\\node at (-0.5,0.5) {4};\n\\node at (-0.5,1.5) {3};\n\\node at (-0.5,2.5) {2};\n\\node at (-0.5,3.5) {1};\n\\node at (0.5,4.5) {1};\n\\node at (1.5,4.5) {2};\n\\node at (2.5,4.5) {3};\n\\node at (3.5,4.5) {4};\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\nThe drawback of the adjacency matrix representation\nis that the matrix contains $n^2$ elements,\nand usually most of them are zero.\nFor this reason, the representation cannot be used\nif the graph is large.\n\n\\subsubsection{Edge list representation}\n\n\\index{edge list}\n\nAn \\key{edge list} contains all edges of a graph\nin some order.\nThis is a convenient way to represent a graph\nif the algorithm processes all edges of the graph\nand it is not needed to find edges that start\nat a given node.\n\nThe edge list can be stored in a vector\n\\begin{lstlisting}\nvector<pair<int,int>> edges;\n\\end{lstlisting}\nwhere each pair $(a,b)$ denotes that\nthere is an edge from node $a$ to node $b$.\nThus, the graph\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (3,1) {$4$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (2) -- (4);\n\\path[draw,thick,->,>=latex] (3) -- (4);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\end{tikzpicture}\n\\end{center}\ncan be represented as follows:\n\\begin{lstlisting}\nedges.push_back({1,2});\nedges.push_back({2,3});\nedges.push_back({2,4});\nedges.push_back({3,4});\nedges.push_back({4,1});\n\\end{lstlisting}\n\n\\noindent\nIf the graph is weighted, the structure can\nbe extended as follows:\n\\begin{lstlisting}\nvector<tuple<int,int,int>> edges;\n\\end{lstlisting}\nEach element in this list is of the\nform $(a,b,w)$, which means that there\nis an edge from node $a$ to node $b$ with weight $w$.\nFor example, the graph\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (3,1) {$4$};\n\n\\path[draw,thick,->,>=latex] (1) -- node[font=\\small,label=above:5] {} (2);\n\\path[draw,thick,->,>=latex] (2) -- node[font=\\small,label=above:7] {} (3);\n\\path[draw,thick,->,>=latex] (2) -- node[font=\\small,label=left:6] {} (4);\n\\path[draw,thick,->,>=latex] (3) -- node[font=\\small,label=right:5] {} (4);\n\\path[draw,thick,->,>=latex] (4) -- node[font=\\small,label=left:2] {} (1);\n\\end{tikzpicture}\n\\end{center}\n\\begin{samepage}\ncan be represented as follows\\footnote{In some older compilers, the function\n\\texttt{make\\_tuple} must be used instead of the braces (for example,\n\\texttt{make\\_tuple(1,2,5)} instead of \\texttt{\\{1,2,5\\}}).}:\n\\begin{lstlisting}\nedges.push_back({1,2,5});\nedges.push_back({2,3,7});\nedges.push_back({2,4,6});\nedges.push_back({3,4,5});\nedges.push_back({4,1,2});\n\\end{lstlisting}\n\\end{samepage}\n", "chapter_name": "Basics of graphs", "chapter_path": "cphb/chapter11.tex"}, {"section_name": "Depth-first search", "section_content": "\\chapter{Graph traversal}\n\nThis chapter discusses two fundamental\ngraph algorithms:\ndepth-first search and breadth-first search.\nBoth algorithms are given a starting\nnode in the graph,\nand they visit all nodes that can be reached\nfrom the starting node.\nThe difference in the algorithms is the order\nin which they visit the nodes.\n\n\\section{Depth-first search}\n\n\\index{depth-first search}\n\n\\key{Depth-first search} (DFS)\nis a straightforward graph traversal technique.\nThe algorithm begins at a starting node,\nand proceeds to all other nodes that are\nreachable from the starting node using\nthe edges of the graph.\n\nDepth-first search always follows a single\npath in the graph as long as it finds\nnew nodes.\nAfter this, it returns to previous\nnodes and begins to explore other parts of the graph.\nThe algorithm keeps track of visited nodes,\nso that it processes each node only once.\n\n\\subsubsection*{Example}\n\nLet us consider how depth-first search processes\nthe following graph:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\nWe may begin the search at any node of the graph;\nnow we will begin the search at node 1.\n\nThe search first proceeds to node 2:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle,fill=lightgray] (1) at (1,5) {$1$};\n\\node[draw, circle,fill=lightgray] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (2);\n\\end{tikzpicture}\n\\end{center}\nAfter this, nodes 3 and 5 will be visited:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle,fill=lightgray] (1) at (1,5) {$1$};\n\\node[draw, circle,fill=lightgray] (2) at (3,5) {$2$};\n\\node[draw, circle,fill=lightgray] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle,fill=lightgray] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (5);\n\\end{tikzpicture}\n\\end{center}\nThe neighbors of node 5 are 2 and 3,\nbut the search has already visited both of them,\nso it is time to return to the previous nodes.\nAlso the neighbors of nodes 3 and 2\nhave been visited, so we next move\nfrom node 1 to node 4:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle,fill=lightgray] (1) at (1,5) {$1$};\n\\node[draw, circle,fill=lightgray] (2) at (3,5) {$2$};\n\\node[draw, circle,fill=lightgray] (3) at (5,4) {$3$};\n\\node[draw, circle,fill=lightgray] (4) at (1,3) {$4$};\n\\node[draw, circle,fill=lightgray] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (4);\n\\end{tikzpicture}\n\\end{center}\nAfter this, the search terminates because it has visited\nall nodes.\n\nThe time complexity of depth-first search is $O(n+m)$\nwhere $n$ is the number of nodes and $m$ is the\nnumber of edges,\nbecause the algorithm processes each node and edge once.\n\n\\subsubsection*{Implementation}\n\nDepth-first search can be conveniently\nimplemented using recursion.\nThe following function \\texttt{dfs} begins\na depth-first search at a given node.\nThe function assumes that the graph is\nstored as adjacency lists in an array\n\\begin{lstlisting}\nvector<int> adj[N];\n\\end{lstlisting}\nand also maintains an array\n\\begin{lstlisting}\nbool visited[N];\n\\end{lstlisting}\nthat keeps track of the visited nodes.\nInitially, each array value is \\texttt{false},\nand when the search arrives at node $s$,\nthe value of \\texttt{visited}[$s$] becomes \\texttt{true}.\nThe function can be implemented as follows:\n\\begin{lstlisting}\nvoid dfs(int s) {\n    if (visited[s]) return;\n    visited[s] = true;\n    // process node s\n    for (auto u: adj[s]) {\n        dfs(u);\n    }\n}\n\\end{lstlisting}\n\n", "chapter_name": "Graph traversal", "chapter_path": "cphb/chapter12.tex"}, {"section_name": "Breadth-first search", "section_content": "\\section{Breadth-first search}\n\n\\index{breadth-first search}\n\n\\key{Breadth-first search} (BFS) visits the nodes\nin increasing order of their distance\nfrom the starting node.\nThus, we can calculate the distance\nfrom the starting node to all other\nnodes using breadth-first search.\nHowever, breadth-first search is more difficult\nto implement than depth-first search.\n\nBreadth-first search goes through the nodes\none level after another.\nFirst the search explores the nodes whose\ndistance from the starting node is 1,\nthen the nodes whose distance is 2, and so on.\nThis process continues until all nodes\nhave been visited.\n\n\\subsubsection*{Example}\n\nLet us consider how breadth-first search processes\nthe following graph:\n\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,5) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\\node[draw, circle] (6) at (5,3) {$6$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (5) -- (6);\n\\end{tikzpicture}\n\\end{center}\nSuppose that the search begins at node 1.\nFirst, we process all nodes that can be reached\nfrom node 1 using a single edge:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle,fill=lightgray] (1) at (1,5) {$1$};\n\\node[draw, circle,fill=lightgray] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,5) {$3$};\n\\node[draw, circle,fill=lightgray] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\\node[draw, circle] (6) at (5,3) {$6$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (5) -- (6);\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (2);\n\\path[draw=red,thick,->,line width=2pt] (1) -- (4);\n\\end{tikzpicture}\n\\end{center}\nAfter this, we proceed to nodes 3 and 5:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle,fill=lightgray] (1) at (1,5) {$1$};\n\\node[draw, circle,fill=lightgray] (2) at (3,5) {$2$};\n\\node[draw, circle,fill=lightgray] (3) at (5,5) {$3$};\n\\node[draw, circle,fill=lightgray] (4) at (1,3) {$4$};\n\\node[draw, circle,fill=lightgray] (5) at (3,3) {$5$};\n\\node[draw, circle] (6) at (5,3) {$6$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (5) -- (6);\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (2) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\nFinally, we visit node 6:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle,fill=lightgray] (1) at (1,5) {$1$};\n\\node[draw, circle,fill=lightgray] (2) at (3,5) {$2$};\n\\node[draw, circle,fill=lightgray] (3) at (5,5) {$3$};\n\\node[draw, circle,fill=lightgray] (4) at (1,3) {$4$};\n\\node[draw, circle,fill=lightgray] (5) at (3,3) {$5$};\n\\node[draw, circle,fill=lightgray] (6) at (5,3) {$6$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (5) -- (6);\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (3) -- (6);\n\\path[draw=red,thick,->,line width=2pt] (5) -- (6);\n\\end{tikzpicture}\n\\end{center}\nNow we have calculated the distances\nfrom the starting node to all nodes of the graph.\nThe distances are as follows:\n\n\\begin{tabular}{ll}\n\\\\\nnode & distance \\\\\n\\hline\n1 & 0 \\\\\n2 & 1 \\\\\n3 & 2 \\\\\n4 & 1 \\\\\n5 & 2 \\\\\n6 & 3 \\\\\n\\\\\n\\end{tabular}\n\nLike in depth-first search,\nthe time complexity of breadth-first search\nis $O(n+m)$, where $n$ is the number of nodes\nand $m$ is the number of edges.\n\n\\subsubsection*{Implementation}\n\nBreadth-first search is more difficult\nto implement than depth-first search,\nbecause the algorithm visits nodes\nin different parts of the graph.\nA typical implementation is based on\na queue that contains nodes.\nAt each step, the next node in the queue\nwill be processed.\n\nThe following code assumes that the graph is stored\nas adjacency lists and maintains the following\ndata structures:\n\\begin{lstlisting}\nqueue<int> q;\nbool visited[N];\nint distance[N];\n\\end{lstlisting}\n\nThe queue \\texttt{q}\ncontains nodes to be processed\nin increasing order of their distance.\nNew nodes are always added to the end\nof the queue, and the node at the beginning\nof the queue is the next node to be processed.\nThe array \\texttt{visited} indicates\nwhich nodes the search has already visited,\nand the array \\texttt{distance} will contain the\ndistances from the starting node to all nodes of the graph.\n\nThe search can be implemented as follows,\nstarting at node $x$:\n\\begin{lstlisting}\nvisited[x] = true;\ndistance[x] = 0;\nq.push(x);\nwhile (!q.empty()) {\n    int s = q.front(); q.pop();\n    // process node s\n    for (auto u : adj[s]) {\n        if (visited[u]) continue;\n        visited[u] = true;\n        distance[u] = distance[s]+1;\n        q.push(u);\n    }\n}\n\\end{lstlisting}\n\n", "chapter_name": "Graph traversal", "chapter_path": "cphb/chapter12.tex"}, {"section_name": "Applications", "section_content": "\\section{Applications}\n\nUsing the graph traversal algorithms,\nwe can check many properties of graphs.\nUsually, both depth-first search and\nbreadth-first search may be used,\nbut in practice, depth-first search\nis a better choice, because it is\neasier to implement.\nIn the following applications we will\nassume that the graph is undirected.\n\n\\subsubsection{Connectivity check}\n\n\\index{connected graph}\n\nA graph is connected if there is a path\nbetween any two nodes of the graph.\nThus, we can check if a graph is connected\nby starting at an arbitrary node and\nfinding out if we can reach all other nodes.\n\nFor example, in the graph\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (2) at (7,5) {$2$};\n\\node[draw, circle] (1) at (3,5) {$1$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (5) at (7,3) {$5$};\n\\node[draw, circle] (4) at (3,3) {$4$};\n\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\na depth-first search from node $1$ visits\nthe following nodes:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (2) at (7,5) {$2$};\n\\node[draw, circle,fill=lightgray] (1) at (3,5) {$1$};\n\\node[draw, circle,fill=lightgray] (3) at (5,4) {$3$};\n\\node[draw, circle] (5) at (7,3) {$5$};\n\\node[draw, circle,fill=lightgray] (4) at (3,3) {$4$};\n\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (4);\n\n\\end{tikzpicture}\n\\end{center}\n\nSince the search did not visit all the nodes,\nwe can conclude that the graph is not connected.\nIn a similar way, we can also find all connected components\nof a graph by iterating through the nodes and always\nstarting a new depth-first search if the current node\ndoes not belong to any component yet.\n\n\\subsubsection{Finding cycles}\n\n\\index{cycle}\n\nA graph contains a cycle if during a graph traversal,\nwe find a node whose neighbor (other than the\nprevious node in the current path) has already been\nvisited.\nFor example, the graph\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (2) at (7,5) {$2$};\n\\node[draw, circle] (1) at (3,5) {$1$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (5) at (7,3) {$5$};\n\\node[draw, circle] (4) at (3,3) {$4$};\n\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (3) -- (5);\n\\end{tikzpicture}\n\\end{center}\ncontains two cycles and we can find one\nof them as follows:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle,fill=lightgray] (2) at (7,5) {$2$};\n\\node[draw, circle,fill=lightgray] (1) at (3,5) {$1$};\n\\node[draw, circle,fill=lightgray] (3) at (5,4) {$3$};\n\\node[draw, circle,fill=lightgray] (5) at (7,3) {$5$};\n\\node[draw, circle] (4) at (3,3) {$4$};\n\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (3) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- (5);\n\n\\end{tikzpicture}\n\\end{center}\nAfter moving from node 2 to node 5 we notice that\nthe neighbor 3 of node 5 has already been visited.\nThus, the graph contains a cycle that goes through node 3,\nfor example, $3 \\rightarrow 2 \\rightarrow 5 \\rightarrow 3$.\n\nAnother way to find out whether a graph contains a cycle\nis to simply calculate the number of nodes and edges\nin every component.\nIf a component contains $c$ nodes and no cycle,\nit must contain exactly $c-1$ edges\n(so it has to be a tree).\nIf there are $c$ or more edges, the component\nsurely contains a cycle.\n\n\\subsubsection{Bipartiteness check}\n\n\\index{bipartite graph}\n\nA graph is bipartite if its nodes can be colored\nusing two colors so that there are no adjacent\nnodes with the same color.\nIt is surprisingly easy to check if a graph\nis bipartite using graph traversal algorithms.\n\nThe idea is to color the starting node blue,\nall its neighbors red, all their neighbors blue, and so on.\nIf at some point of the search we notice that\ntwo adjacent nodes have the same color,\nthis means that the graph is not bipartite.\nOtherwise the graph is bipartite and one coloring\nhas been found.\n\nFor example, the graph\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (2) at (5,5) {$2$};\n\\node[draw, circle] (1) at (3,5) {$1$};\n\\node[draw, circle] (3) at (7,4) {$3$};\n\\node[draw, circle] (5) at (5,3) {$5$};\n\\node[draw, circle] (4) at (3,3) {$4$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (5) -- (4);\n\\path[draw,thick,-] (4) -- (1);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (5) -- (3);\n\\end{tikzpicture}\n\\end{center}\nis not bipartite, because a search from node 1\nproceeds as follows:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle,fill=red!40] (2) at (5,5) {$2$};\n\\node[draw, circle,fill=blue!40] (1) at (3,5) {$1$};\n\\node[draw, circle,fill=blue!40] (3) at (7,4) {$3$};\n\\node[draw, circle,fill=red!40] (5) at (5,3) {$5$};\n\\node[draw, circle] (4) at (3,3) {$4$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (5) -- (4);\n\\path[draw,thick,-] (4) -- (1);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (5) -- (3);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- (2);\n\\end{tikzpicture}\n\\end{center}\nWe notice that the color of both nodes 2 and 5\nis red, while they are adjacent nodes in the graph.\nThus, the graph is not bipartite.\n\nThis algorithm always works, because when there\nare only two colors available,\nthe color of the starting node in a component\ndetermines the colors of all other nodes in the component.\nIt does not make any difference whether the\nstarting node is red or blue.\n\nNote that in the general case,\nit is difficult to find out if the nodes\nin a graph can be colored using $k$ colors\nso that no adjacent nodes have the same color.\nEven when $k=3$, no efficient algorithm is known\nbut the problem is NP-hard.\n", "chapter_name": "Graph traversal", "chapter_path": "cphb/chapter12.tex"}, {"section_name": "Bellman\u2013Ford algorithm", "section_content": "\\chapter{Shortest paths}\n\n\\index{shortest path}\n\nFinding a shortest path between two nodes\nof a graph\nis an important problem that has many\npractical applications.\nFor example, a natural problem related to a road network\nis to calculate the shortest possible length of a route\nbetween two cities, given the lengths of the roads.\n\nIn an unweighted graph, the length of a path equals\nthe number of its edges, and we can\nsimply use breadth-first search to find\na shortest path.\nHowever, in this chapter we focus on\nweighted graphs\nwhere more sophisticated algorithms\nare needed\nfor finding shortest paths.\n\n\\section{Bellman\u2013Ford algorithm}\n\n\\index{Bellman\u2013Ford algorithm}\n\nThe \\key{Bellman\u2013Ford algorithm}\\footnote{The algorithm is named after\nR. E. Bellman and L. R. Ford who published it independently\nin 1958 and 1956, respectively \\cite{bel58,for56a}.} finds\nshortest paths from a starting node to all\nnodes of the graph.\nThe algorithm can process all kinds of graphs,\nprovided that the graph does not contain a\ncycle with negative length.\nIf the graph contains a negative cycle,\nthe algorithm can detect this.\n\nThe algorithm keeps track of distances\nfrom the starting node to all nodes of the graph.\nInitially, the distance to the starting node is 0\nand the distance to all other nodes in infinite.\nThe algorithm reduces the distances by finding\nedges that shorten the paths until it is not\npossible to reduce any distance.\n\n\\subsubsection{Example}\n\nLet us consider how the Bellman\u2013Ford algorithm\nworks in the following graph:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,3) {1};\n\\node[draw, circle] (2) at (4,3) {2};\n\\node[draw, circle] (3) at (1,1) {3};\n\\node[draw, circle] (4) at (4,1) {4};\n\\node[draw, circle] (5) at (6,2) {6};\n\\node[color=red] at (1,3+0.55) {$0$};\n\\node[color=red] at (4,3+0.55) {$\\infty$};\n\\node[color=red] at (1,1-0.55) {$\\infty$};\n\\node[color=red] at (4,1-0.55) {$\\infty$};\n\\node[color=red] at (6,2-0.55) {$\\infty$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:5] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:3] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:1] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:3] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:2] {} (5);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:7] {} (4);\n\\end{tikzpicture}\n\\end{center}\nEach node of the graph is assigned a distance.\nInitially, the distance to the starting node is 0,\nand the distance to all other nodes is infinite.\n\nThe algorithm searches for edges that reduce distances.\nFirst, all edges from node 1 reduce distances:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,3) {1};\n\\node[draw, circle] (2) at (4,3) {2};\n\\node[draw, circle] (3) at (1,1) {3};\n\\node[draw, circle] (4) at (4,1) {4};\n\\node[draw, circle] (5) at (6,2) {5};\n\\node[color=red] at (1,3+0.55) {$0$};\n\\node[color=red] at (4,3+0.55) {$5$};\n\\node[color=red] at (1,1-0.55) {$3$};\n\\node[color=red] at (4,1-0.55) {$7$};\n\\node[color=red] at (6,2-0.55) {$\\infty$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:5] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:3] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:1] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:3] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:2] {} (5);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:7] {} (4);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (2);\n\\path[draw=red,thick,->,line width=2pt] (1) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (1) -- (4);\n\\end{tikzpicture}\n\\end{center}\nAfter this, edges\n$2 \\rightarrow 5$ and $3 \\rightarrow 4$\nreduce distances:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,3) {1};\n\\node[draw, circle] (2) at (4,3) {2};\n\\node[draw, circle] (3) at (1,1) {3};\n\\node[draw, circle] (4) at (4,1) {4};\n\\node[draw, circle] (5) at (6,2) {5};\n\\node[color=red] at (1,3+0.55) {$0$};\n\\node[color=red] at (4,3+0.55) {$5$};\n\\node[color=red] at (1,1-0.55) {$3$};\n\\node[color=red] at (4,1-0.55) {$4$};\n\\node[color=red] at (6,2-0.55) {$7$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:5] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:3] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:1] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:3] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:2] {} (5);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:7] {} (4);\n\n\\path[draw=red,thick,->,line width=2pt] (2) -- (5);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (4);\n\\end{tikzpicture}\n\\end{center}\nFinally, there is one more change:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,3) {1};\n\\node[draw, circle] (2) at (4,3) {2};\n\\node[draw, circle] (3) at (1,1) {3};\n\\node[draw, circle] (4) at (4,1) {4};\n\\node[draw, circle] (5) at (6,2) {5};\n\\node[color=red] at (1,3+0.55) {$0$};\n\\node[color=red] at (4,3+0.55) {$5$};\n\\node[color=red] at (1,1-0.55) {$3$};\n\\node[color=red] at (4,1-0.55) {$4$};\n\\node[color=red] at (6,2-0.55) {$6$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:5] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:3] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:1] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:3] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:2] {} (5);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:7] {} (4);\n\n\\path[draw=red,thick,->,line width=2pt] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\nAfter this, no edge can reduce any distance.\nThis means that the distances are final,\nand we have successfully\ncalculated the shortest distances\nfrom the starting node to all nodes of the graph.\n\nFor example, the shortest distance 3\nfrom node 1 to node 5 corresponds to\nthe following path:\n\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,3) {1};\n\\node[draw, circle] (2) at (4,3) {2};\n\\node[draw, circle] (3) at (1,1) {3};\n\\node[draw, circle] (4) at (4,1) {4};\n\\node[draw, circle] (5) at (6,2) {5};\n\\node[color=red] at (1,3+0.55) {$0$};\n\\node[color=red] at (4,3+0.55) {$5$};\n\\node[color=red] at (1,1-0.55) {$3$};\n\\node[color=red] at (4,1-0.55) {$4$};\n\\node[color=red] at (6,2-0.55) {$6$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:5] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:3] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:1] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:3] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:2] {} (5);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:7] {} (4);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (4);\n\\path[draw=red,thick,->,line width=2pt] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Implementation}\n\nThe following implementation of the\nBellman\u2013Ford algorithm determines the shortest distances\nfrom a node $x$ to all nodes of the graph.\nThe code assumes that the graph is stored\nas an edge list \\texttt{edges}\nthat consists of tuples of the form $(a,b,w)$,\nmeaning that there is an edge from node $a$ to node $b$\nwith weight $w$.\n\nThe algorithm consists of $n-1$ rounds,\nand on each round the algorithm goes through\nall edges of the graph and tries to\nreduce the distances.\nThe algorithm constructs an array \\texttt{distance}\nthat will contain the distances from $x$\nto all nodes of the graph.\nThe constant \\texttt{INF} denotes an infinite distance.\n\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i++) distance[i] = INF;\ndistance[x] = 0;\nfor (int i = 1; i <= n-1; i++) {\n    for (auto e : edges) {\n        int a, b, w;\n        tie(a, b, w) = e;\n        distance[b] = min(distance[b], distance[a]+w);\n    }\n}\n\\end{lstlisting}\n\nThe time complexity of the algorithm is $O(nm)$,\nbecause the algorithm consists of $n-1$ rounds and\niterates through all $m$ edges during a round.\nIf there are no negative cycles in the graph,\nall distances are final after $n-1$ rounds,\nbecause each shortest path can contain at most $n-1$ edges.\n\nIn practice, the final distances can usually\nbe found faster than in $n-1$ rounds.\nThus, a possible way to make the algorithm more efficient\nis to stop the algorithm if no distance\ncan be reduced during a round.\n\n\\subsubsection{Negative cycles}\n\n\\index{negative cycle}\n\nThe Bellman\u2013Ford algorithm can also be used to\ncheck if the graph contains a cycle with negative length.\nFor example, the graph\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (2,1) {$2$};\n\\node[draw, circle] (3) at (2,-1) {$3$};\n\\node[draw, circle] (4) at (4,0) {$4$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:$3$] {} (2);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:$1$] {} (4);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=below:$5$] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:$-7$] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=right:$2$] {} (3);\n\\end{tikzpicture}\n\\end{center}\n\\noindent\ncontains a negative cycle\n$2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 2$\nwith length $-4$.\n\nIf the graph contains a negative cycle,\nwe can shorten infinitely many times\nany path that contains the cycle by repeating the cycle\nagain and again.\nThus, the concept of a shortest path\nis not meaningful in this situation.\n\nA negative cycle can be detected\nusing the Bellman\u2013Ford algorithm by\nrunning the algorithm for $n$ rounds.\nIf the last round reduces any distance,\nthe graph contains a negative cycle.\nNote that this algorithm can be used to\nsearch for\na negative cycle in the whole graph\nregardless of the starting node.\n\n\\subsubsection{SPFA algorithm}\n\n\\index{SPFA algorithm}\n\nThe \\key{SPFA algorithm} (''Shortest Path Faster Algorithm'') \\cite{fan94}\nis a variant of the Bellman\u2013Ford algorithm,\nthat is often more efficient than the original algorithm.\nThe SPFA algorithm does not go through all the edges on each round,\nbut instead, it chooses the edges to be examined\nin a more intelligent way.\n\nThe algorithm maintains a queue of nodes that might\nbe used for reducing the distances.\nFirst, the algorithm adds the starting node $x$\nto the queue.\nThen, the algorithm always processes the\nfirst node in the queue, and when an edge\n$a \\rightarrow b$ reduces a distance,\nnode $b$ is added to the queue.\n% \n% The following implementation uses a \n% \\texttt{queue} \\texttt{q}.\n% In addition, an array \\texttt{inqueue} indicates\n% if a node is already in the queue,\n% in which case the algorithm does not add\n% the node to the queue again.\n% \n% \\begin{lstlisting}\n% for (int i = 1; i <= n; i++) distance[i] = INF;\n% distance[x] = 0;\n% q.push(x);\n% while (!q.empty()) {\n%     int a = q.front(); q.pop();\n%     inqueue[a] = false;\n%     for (auto b : v[a]) {\n%         if (distance[a]+b.second < distance[b.first]) {\n%             distance[b.first] = distance[a]+b.second;\n%             if (!inqueue[b]) {q.push(b); inqueue[b] = true;}\n%         }\n%     }\n% }\n% \\end{lstlisting}\n\nThe efficiency of the SPFA algorithm depends\non the structure of the graph:\nthe algorithm is often efficient,\nbut its worst case time complexity is still\n$O(nm)$ and it is possible to create inputs\nthat make the algorithm as slow as the\noriginal Bellman\u2013Ford algorithm.\n\n", "chapter_name": "Shortest paths", "chapter_path": "cphb/chapter13.tex"}, {"section_name": "Dijkstra's algorithm", "section_content": "\\section{Dijkstra's algorithm}\n\n\\index{Dijkstra's algorithm}\n\n\\key{Dijkstra's algorithm}\\footnote{E. W. Dijkstra published the algorithm in 1959 \\cite{dij59};\nhowever, his original paper does not mention how to implement the algorithm efficiently.}\nfinds shortest\npaths from the starting node to all nodes of the graph,\nlike the Bellman\u2013Ford algorithm.\nThe benefit of Dijsktra's algorithm is that\nit is more efficient and can be used for\nprocessing large graphs.\nHowever, the algorithm requires that there\nare no negative weight edges in the graph.\n\nLike the Bellman\u2013Ford algorithm,\nDijkstra's algorithm maintains distances\nto the nodes and reduces them during the search.\nDijkstra's algorithm is efficient, because\nit only processes\neach edge in the graph once, using the fact\nthat there are no negative edges.\n\n\\subsubsection{Example}\n\nLet us consider how Dijkstra's algorithm\nworks in the following graph when the\nstarting node is node 1:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {3};\n\\node[draw, circle] (2) at (4,3) {4};\n\\node[draw, circle] (3) at (1,1) {2};\n\\node[draw, circle] (4) at (4,1) {1};\n\\node[draw, circle] (5) at (6,2) {5};\n\n\\node[color=red] at (1,3+0.6) {$\\infty$};\n\\node[color=red] at (4,3+0.6) {$\\infty$};\n\\node[color=red] at (1,1-0.6) {$\\infty$};\n\\node[color=red] at (4,1-0.6) {$0$};\n\\node[color=red] at (6,2-0.6) {$\\infty$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:6] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:2] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:5] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:9] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:1] {} (5);\n\\end{tikzpicture}\n\\end{center}\nLike in the Bellman\u2013Ford algorithm,\ninitially the distance to the starting node is 0\nand the distance to all other nodes is infinite.\n\nAt each step, Dijkstra's algorithm selects a node\nthat has not been processed yet and whose distance\nis as small as possible.\nThe first such node is node 1 with distance 0.\n\nWhen a node is selected, the algorithm\ngoes through all edges that start at the node\nand reduces the distances using them:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {3};\n\\node[draw, circle] (2) at (4,3) {4};\n\\node[draw, circle] (3) at (1,1) {2};\n\\node[draw, circle, fill=lightgray] (4) at (4,1) {1};\n\\node[draw, circle] (5) at (6,2) {5};\n\n\\node[color=red] at (1,3+0.6) {$\\infty$};\n\\node[color=red] at (4,3+0.6) {$9$};\n\\node[color=red] at (1,1-0.6) {$5$};\n\\node[color=red] at (4,1-0.6) {$0$};\n\\node[color=red] at (6,2-0.6) {$1$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:6] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:2] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:5] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:9] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:1] {} (5);\n\n\\path[draw=red,thick,->,line width=2pt] (4) -- (2);\n\\path[draw=red,thick,->,line width=2pt] (4) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\nIn this case,\nthe edges from node 1 reduced the distances of\nnodes 2, 4 and 5, whose distances are now 5, 9 and 1.\n\nThe next node to be processed is node 5 with distance 1.\nThis reduces the distance to node 4 from 9 to 3:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,3) {3};\n\\node[draw, circle] (2) at (4,3) {4};\n\\node[draw, circle] (3) at (1,1) {2};\n\\node[draw, circle, fill=lightgray] (4) at (4,1) {1};\n\\node[draw, circle, fill=lightgray] (5) at (6,2) {5};\n\n\\node[color=red] at (1,3+0.6) {$\\infty$};\n\\node[color=red] at (4,3+0.6) {$3$};\n\\node[color=red] at (1,1-0.6) {$5$};\n\\node[color=red] at (4,1-0.6) {$0$};\n\\node[color=red] at (6,2-0.6) {$1$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:6] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:2] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:5] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:9] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:1] {} (5);\n\n\\path[draw=red,thick,->,line width=2pt] (5) -- (2);\n\\end{tikzpicture}\n\\end{center}\nAfter this, the next node is node 4, which reduces\nthe distance to node 3 to 9:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {3};\n\\node[draw, circle, fill=lightgray] (2) at (4,3) {4};\n\\node[draw, circle] (3) at (1,1) {2};\n\\node[draw, circle, fill=lightgray] (4) at (4,1) {1};\n\\node[draw, circle, fill=lightgray] (5) at (6,2) {5};\n\n\\node[color=red] at (1,3+0.6) {$9$};\n\\node[color=red] at (4,3+0.6) {$3$};\n\\node[color=red] at (1,1-0.6) {$5$};\n\\node[color=red] at (4,1-0.6) {$0$};\n\\node[color=red] at (6,2-0.6) {$1$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:6] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:2] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:5] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:9] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:1] {} (5);\n\n\\path[draw=red,thick,->,line width=2pt] (2) -- (1);\n\\end{tikzpicture}\n\\end{center}\n\nA remarkable property in Dijkstra's algorithm is that\nwhenever a node is selected, its distance is final.\nFor example, at this point of the algorithm,\nthe distances 0, 1 and 3 are the final distances\nto nodes 1, 5 and 4.\n\nAfter this, the algorithm processes the two\nremaining nodes, and the final distances are as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle, fill=lightgray] (1) at (1,3) {3};\n\\node[draw, circle, fill=lightgray] (2) at (4,3) {4};\n\\node[draw, circle, fill=lightgray] (3) at (1,1) {2};\n\\node[draw, circle, fill=lightgray] (4) at (4,1) {1};\n\\node[draw, circle, fill=lightgray] (5) at (6,2) {5};\n\n\\node[color=red] at (1,3+0.6) {$7$};\n\\node[color=red] at (4,3+0.6) {$3$};\n\\node[color=red] at (1,1-0.6) {$5$};\n\\node[color=red] at (4,1-0.6) {$0$};\n\\node[color=red] at (6,2-0.6) {$1$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:6] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:2] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:5] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:9] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:1] {} (5);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Negative edges}\n\nThe efficiency of Dijkstra's algorithm is\nbased on the fact that the graph does not\ncontain negative edges.\nIf there is a negative edge,\nthe algorithm may give incorrect results.\nAs an example, consider the following graph:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (2,1) {$2$};\n\\node[draw, circle] (3) at (2,-1) {$3$};\n\\node[draw, circle] (4) at (4,0) {$4$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:2] {} (2);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:3] {} (4);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=below:6] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:$-5$] {} (4);\n\\end{tikzpicture}\n\\end{center}\n\\noindent\nThe shortest path from node 1 to node 4 is\n$1 \\rightarrow 3 \\rightarrow 4$\nand its length is 1.\nHowever, Dijkstra's algorithm\nfinds the path $1 \\rightarrow 2 \\rightarrow 4$\nby following the minimum weight edges.\nThe algorithm does not take into account that\non the other path, the weight $-5$\ncompensates the previous large weight $6$.\n\n\\subsubsection{Implementation}\n\nThe following implementation of Dijkstra's algorithm\ncalculates the minimum distances from a node $x$\nto other nodes of the graph.\nThe graph is stored as adjacency lists\nso that \\texttt{adj[$a$]} contains a pair $(b,w)$\nalways when there is an edge from node $a$ to node $b$\nwith weight $w$.\n\nAn efficient implementation of Dijkstra's algorithm\nrequires that it is possible to efficiently find the\nminimum distance node that has not been processed.\nAn appropriate data structure for this is a priority queue\nthat contains the nodes ordered by their distances.\nUsing a priority queue, the next node to be processed\ncan be retrieved in logarithmic time.\n\nIn the following code, the priority queue\n\\texttt{q} contains pairs of the form $(-d,x)$,\nmeaning that the current distance to node $x$ is $d$.\nThe array $\\texttt{distance}$ contains the distance to\neach node, and the array $\\texttt{processed}$ indicates\nwhether a node has been processed.\nInitially the distance is $0$ to $x$ and $\\infty$ to all other nodes.\n\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i++) distance[i] = INF;\ndistance[x] = 0;\nq.push({0,x});\nwhile (!q.empty()) {\n    int a = q.top().second; q.pop();\n    if (processed[a]) continue;\n    processed[a] = true;\n    for (auto u : adj[a]) {\n        int b = u.first, w = u.second;\n        if (distance[a]+w < distance[b]) {\n            distance[b] = distance[a]+w;\n            q.push({-distance[b],b});\n        }\n    }\n}\n\\end{lstlisting}\n\nNote that the priority queue contains \\emph{negative}\ndistances to nodes.\nThe reason for this is that the\ndefault version of the C++ priority queue finds maximum\nelements, while we want to find minimum elements.\nBy using negative distances,\nwe can directly use the default priority queue\\footnote{Of\ncourse, we could also declare the priority queue as in Chapter 4.5\nand use positive distances, but the implementation would be a bit longer.}.\nAlso note that there may be several instances of the same\nnode in the priority queue; however, only the instance with the\nminimum distance will be processed.\n\nThe time complexity of the above implementation is\n$O(n+m \\log m)$, because the algorithm goes through\nall nodes of the graph and adds for each edge\nat most one distance to the priority queue.\n\n", "chapter_name": "Shortest paths", "chapter_path": "cphb/chapter13.tex"}, {"section_name": "Floyd\u2013Warshall algorithm", "section_content": "\\section{Floyd\u2013Warshall algorithm}\n\n\\index{Floyd\u2013Warshall algorithm}\n\nThe \\key{Floyd\u2013Warshall algorithm}\\footnote{The algorithm\nis named after R. W. Floyd and S. Warshall\nwho published it independently in 1962 \\cite{flo62,war62}.}\nprovides an alternative way to approach the problem\nof finding shortest paths.\nUnlike the other algorithms of this chapter,\nit finds all shortest paths between the nodes\nin a single run.\n\nThe algorithm maintains a two-dimensional array\nthat contains distances between the nodes.\nFirst, distances are calculated only using\ndirect edges between the nodes,\nand after this, the algorithm reduces distances\nby using intermediate nodes in paths.\n\n\\subsubsection{Example}\n\nLet us consider how the Floyd\u2013Warshall algorithm\nworks in the following graph:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$3$};\n\\node[draw, circle] (2) at (4,3) {$4$};\n\\node[draw, circle] (3) at (1,1) {$2$};\n\\node[draw, circle] (4) at (4,1) {$1$};\n\\node[draw, circle] (5) at (6,2) {$5$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:7] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:2] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:5] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:9] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:1] {} (5);\n\\end{tikzpicture}\n\\end{center}\n\nInitially, the distance from each node to itself is $0$,\nand the distance between nodes $a$ and $b$ is $x$\nif there is an edge between nodes $a$ and $b$ with weight $x$.\nAll other distances are infinite.\n\nIn this graph, the initial array is as follows:\n\\begin{center}\n\\begin{tabular}{r|rrrrr}\n & 1 & 2 & 3 & 4 & 5 \\\\\n\\hline\n1 & 0 & 5 & $\\infty$ & 9 & 1 \\\\\n2 & 5 & 0 & 2 & $\\infty$ & $\\infty$ \\\\\n3 & $\\infty$ & 2 & 0 & 7 & $\\infty$ \\\\\n4 & 9 & $\\infty$ & 7 & 0 & 2 \\\\\n5 & 1 & $\\infty$ & $\\infty$ & 2 & 0 \\\\\n\\end{tabular}\n\\end{center}\n\\vspace{10pt}\nThe algorithm consists of consecutive rounds.\nOn each round, the algorithm selects a new node\nthat can act as an intermediate node in paths from now on,\nand distances are reduced using this node.\n\nOn the first round, node 1 is the new intermediate node.\nThere is a new path between nodes 2 and 4\nwith length 14, because node 1 connects them.\nThere is also a new path \nbetween nodes 2 and 5 with length 6.\n\n\\begin{center}\n\\begin{tabular}{r|rrrrr}\n & 1 & 2 & 3 & 4 & 5 \\\\\n\\hline\n1 & 0 & 5 & $\\infty$ & 9 & 1 \\\\\n2 & 5 & 0 & 2 & \\textbf{14} & \\textbf{6} \\\\\n3 & $\\infty$ & 2 & 0 & 7 & $\\infty$ \\\\\n4 & 9 & \\textbf{14} & 7 & 0 & 2 \\\\\n5 & 1 & \\textbf{6} & $\\infty$ & 2 & 0 \\\\\n\\end{tabular}\n\\end{center}\n\\vspace{10pt}\n\nOn the second round, node 2 is the new intermediate node.\nThis creates new paths between nodes 1 and 3\nand between nodes 3 and 5:\n\n\\begin{center}\n\\begin{tabular}{r|rrrrr}\n & 1 & 2 & 3 & 4 & 5 \\\\\n\\hline\n1 & 0 & 5 & \\textbf{7} & 9 & 1 \\\\\n2 & 5 & 0 & 2 & 14 & 6 \\\\\n3 & \\textbf{7} & 2 & 0 & 7 & \\textbf{8} \\\\\n4 & 9 & 14 & 7 & 0 & 2 \\\\\n5 & 1 & 6 & \\textbf{8} & 2 & 0 \\\\\n\\end{tabular}\n\\end{center}\n\\vspace{10pt}\n\nOn the third round, node 3 is the new intermediate round.\nThere is a new path between nodes 2 and 4:\n\n\\begin{center}\n\\begin{tabular}{r|rrrrr}\n & 1 & 2 & 3 & 4 & 5 \\\\\n\\hline\n1 & 0 & 5 & 7 & 9 & 1 \\\\\n2 & 5 & 0 & 2 & \\textbf{9} & 6 \\\\\n3 & 7 & 2 & 0 & 7 & 8 \\\\\n4 & 9 & \\textbf{9} & 7 & 0 & 2 \\\\\n5 & 1 & 6 & 8 & 2 & 0 \\\\\n\\end{tabular}\n\\end{center}\n\\vspace{10pt}\n\nThe algorithm continues like this,\nuntil all nodes have been appointed intermediate nodes.\nAfter the algorithm has finished, the array contains\nthe minimum distances between any two nodes:\n\n\\begin{center}\n\\begin{tabular}{r|rrrrr}\n & 1 & 2 & 3 & 4 & 5 \\\\\n\\hline\n1 & 0 & 5 & 7 & 3 & 1 \\\\\n2 & 5 & 0 & 2 & 8 & 6 \\\\\n3 & 7 & 2 & 0 & 7 & 8 \\\\\n4 & 3 & 8 & 7 & 0 & 2 \\\\\n5 & 1 & 6 & 8 & 2 & 0 \\\\\n\\end{tabular}\n\\end{center}\n\nFor example, the array tells us that the\nshortest distance between nodes 2 and 4 is 8.\nThis corresponds to the following path:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$3$};\n\\node[draw, circle] (2) at (4,3) {$4$};\n\\node[draw, circle] (3) at (1,1) {$2$};\n\\node[draw, circle] (4) at (4,1) {$1$};\n\\node[draw, circle] (5) at (6,2) {$5$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:7] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:2] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:5] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:9] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (5);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:1] {} (5);\n\n\\path[draw=red,thick,->,line width=2pt] (3) -- (4);\n\\path[draw=red,thick,->,line width=2pt] (4) -- (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- (2);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Implementation}\n\nThe advantage of the\nFloyd\u2013Warshall algorithm that it is\neasy to implement.\nThe following code constructs a\ndistance matrix where $\\texttt{distance}[a][b]$\nis the shortest distance between nodes $a$ and $b$.\nFirst, the algorithm initializes \\texttt{distance}\nusing the adjacency matrix \\texttt{adj} of the graph:\n\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n        if (i == j) distance[i][j] = 0;\n        else if (adj[i][j]) distance[i][j] = adj[i][j];\n        else distance[i][j] = INF;\n    }\n}\n\\end{lstlisting}\nAfter this, the shortest distances can be found as follows:\n\\begin{lstlisting}\nfor (int k = 1; k <= n; k++) {\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            distance[i][j] = min(distance[i][j],\n                                   distance[i][k]+distance[k][j]);\n        }\n    }\n}\n\\end{lstlisting}\n\nThe time complexity of the algorithm is $O(n^3)$,\nbecause it contains three nested loops\nthat go through the nodes of the graph.\n\nSince the implementation of the Floyd\u2013Warshall\nalgorithm is simple, the algorithm can be\na good choice even if it is only needed to find a\nsingle shortest path in the graph.\nHowever, the algorithm can only be used when the graph\nis so small that a cubic time complexity is fast enough.\n", "chapter_name": "Shortest paths", "chapter_path": "cphb/chapter13.tex"}, {"section_name": "Tree traversal", "section_content": "\\chapter{Tree algorithms}\n\n\\index{tree}\n\nA \\key{tree} is a connected, acyclic graph\nthat consists of $n$ nodes and $n-1$ edges.\nRemoving any edge from a tree divides it\ninto two components,\nand adding any edge to a tree creates a cycle.\nMoreover, there is always a unique path between any\ntwo nodes of a tree.\n\nFor example, the following tree consists of 8 nodes and 7 edges:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,3) {$4$};\n\\node[draw, circle] (3) at (0,1) {$2$};\n\\node[draw, circle] (4) at (2,1) {$3$};\n\\node[draw, circle] (5) at (4,1) {$7$};\n\\node[draw, circle] (6) at (-2,3) {$5$};\n\\node[draw, circle] (7) at (-2,1) {$6$};\n\\node[draw, circle] (8) at (-4,1) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\path[draw,thick,-] (7) -- (8);\n\\end{tikzpicture}\n\\end{center}\n\n\\index{leaf}\n\nThe \\key{leaves} of a tree are the nodes\nwith degree 1, i.e., with only one neighbor.\nFor example, the leaves of the above tree\nare nodes 3, 5, 7 and 8.\n\n\\index{root}\n\\index{rooted tree}\n\nIn a \\key{rooted} tree, one of the nodes\nis appointed the \\key{root} of the tree,\nand all other nodes are\nplaced underneath the root.\nFor example, in the following tree,\nnode 1 is the root node.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (4) at (2,1) {$4$};\n\\node[draw, circle] (2) at (-2,1) {$2$};\n\\node[draw, circle] (3) at (0,1) {$3$};\n\\node[draw, circle] (7) at (2,-1) {$7$};\n\\node[draw, circle] (5) at (-3,-1) {$5$};\n\\node[draw, circle] (6) at (-1,-1) {$6$};\n\\node[draw, circle] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (4) -- (7);\n\\path[draw,thick,-] (6) -- (8);\n\\end{tikzpicture}\n\\end{center}\n\\index{child}\n\\index{parent}\n\nIn a rooted tree, the \\key{children} of a node\nare its lower neighbors, and the \\key{parent} of a node\nis its upper neighbor.\nEach node has exactly one parent,\nexcept for the root that does not have a parent.\nFor example, in the above tree,\nthe children of node 2 are nodes 5 and 6,\nand its parent is node 1.\n\n\\index{subtree}\n\nThe structure of a rooted tree is \\emph{recursive}:\neach node of the tree acts as the root of a \\key{subtree}\nthat contains the node itself and all nodes\nthat are in the subtrees of its children.\nFor example, in the above tree, the subtree of node 2\nconsists of nodes 2, 5, 6 and 8:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (2) at (-2,1) {$2$};\n\\node[draw, circle] (5) at (-3,-1) {$5$};\n\\node[draw, circle] (6) at (-1,-1) {$6$};\n\\node[draw, circle] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (6) -- (8);\n\\end{tikzpicture}\n\\end{center}\n\n\\section{Tree traversal}\n\nGeneral graph traversal algorithms\ncan be used to traverse the nodes of a tree.\nHowever, the traversal of a tree is easier to implement than\nthat of a general graph, because\nthere are no cycles in the tree and it is not\npossible to reach a node from multiple directions.\n\nThe typical way to traverse a tree is to start\na depth-first search at an arbitrary node.\nThe following recursive function can be used:\n\n\\begin{lstlisting}\nvoid dfs(int s, int e) {\n    // process node s\n    for (auto u : adj[s]) {\n        if (u != e) dfs(u, s);\n    }\n}\n\\end{lstlisting}\n\nThe function is given two parameters: the current node $s$\nand the previous node $e$.\nThe purpose of the parameter $e$ is to make sure\nthat the search only moves to nodes\nthat have not been visited yet.\n\nThe following function call starts the search\nat node $x$:\n\n\\begin{lstlisting}\ndfs(x, 0);\n\\end{lstlisting}\n\nIn the first call $e=0$, because there is no\nprevious node, and it is allowed\nto proceed to any direction in the tree.\n\n\\subsubsection{Dynamic programming}\n\nDynamic programming can be used to calculate\nsome information during a tree traversal.\nUsing dynamic programming, we can, for example,\ncalculate in $O(n)$ time for each node of a rooted tree the\nnumber of nodes in its subtree\nor the length of the longest path from the node\nto a leaf.\n\nAs an example, let us calculate for each node $s$\na value $\\texttt{count}[s]$: the number of nodes in its subtree.\nThe subtree contains the node itself and\nall nodes in the subtrees of its children,\nso we can calculate the number of nodes\nrecursively using the following code:\n\n\\begin{lstlisting}\nvoid dfs(int s, int e) {\n    count[s] = 1;\n    for (auto u : adj[s]) {\n        if (u == e) continue;\n        dfs(u, s);\n        count[s] += count[u];\n    }\n}\n\\end{lstlisting}\n\n", "chapter_name": "Tree algorithms", "chapter_path": "cphb/chapter14.tex"}, {"section_name": "Diameter", "section_content": "\\section{Diameter}\n\n\\index{diameter}\n\nThe \\key{diameter} of a tree\nis the maximum length of a path between two nodes.\nFor example, consider the following tree:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,3) {$4$};\n\\node[draw, circle] (3) at (0,1) {$2$};\n\\node[draw, circle] (4) at (2,1) {$3$};\n\\node[draw, circle] (5) at (4,1) {$7$};\n\\node[draw, circle] (6) at (-2,3) {$5$};\n\\node[draw, circle] (7) at (-2,1) {$6$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\end{tikzpicture}\n\\end{center}\nThe diameter of this tree is 4,\nwhich corresponds to the following path:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,3) {$4$};\n\\node[draw, circle] (3) at (0,1) {$2$};\n\\node[draw, circle] (4) at (2,1) {$3$};\n\\node[draw, circle] (5) at (4,1) {$7$};\n\\node[draw, circle] (6) at (-2,3) {$5$};\n\\node[draw, circle] (7) at (-2,1) {$6$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\n\\path[draw,thick,-,color=red,line width=2pt] (7) -- (3);\n\\path[draw,thick,-,color=red,line width=2pt] (3) -- (1);\n\\path[draw,thick,-,color=red,line width=2pt] (1) -- (2);\n\\path[draw,thick,-,color=red,line width=2pt] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\nNote that there may be several maximum-length paths.\nIn the above path, we could replace node 6 with node 5\nto obtain another path with length 4.\n\nNext we will discuss two $O(n)$ time algorithms\nfor calculating the diameter of a tree.\nThe first algorithm is based on dynamic programming,\nand the second algorithm uses two depth-first searches.\n\n\\subsubsection{Algorithm 1}\n\nA general way to approach many tree problems\nis to first root the tree arbitrarily.\nAfter this, we can try to solve the problem\nseparately for each subtree.\nOur first algorithm for calculating the diameter\nis based on this idea.\n\nAn important observation is that every path\nin a rooted tree has a \\emph{highest point}:\nthe highest node that belongs to the path.\nThus, we can calculate for each node the length\nof the longest path whose highest point is the node.\nOne of those paths corresponds to the diameter of the tree.\n\nFor example, in the following tree,\nnode 1 is the highest point on the path\nthat corresponds to the diameter:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (5) at (2,-1) {$7$};\n\\node[draw, circle] (6) at (-3,-1) {$5$};\n\\node[draw, circle] (7) at (-1,-1) {$6$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\n\\path[draw,thick,-,color=red,line width=2pt] (7) -- (3);\n\\path[draw,thick,-,color=red,line width=2pt] (3) -- (1);\n\\path[draw,thick,-,color=red,line width=2pt] (1) -- (2);\n\\path[draw,thick,-,color=red,line width=2pt] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\nWe calculate for each node $x$ two values:\n\\begin{itemize}\n\\item $\\texttt{toLeaf}(x)$: the maximum length of a path from $x$ to any leaf\n\\item $\\texttt{maxLength}(x)$: the maximum length of a path\nwhose highest point is $x$\n\\end{itemize}\nFor example, in the above tree,\n$\\texttt{toLeaf}(1)=2$, because there is a path\n$1 \\rightarrow 2 \\rightarrow 6$,\nand $\\texttt{maxLength}(1)=4$,\nbecause there is a path\n$6 \\rightarrow 2 \\rightarrow 1 \\rightarrow 4 \\rightarrow 7$.\nIn this case, $\\texttt{maxLength}(1)$ equals the diameter.\n\nDynamic programming can be used to calculate the above\nvalues for all nodes in $O(n)$ time.\nFirst, to calculate $\\texttt{toLeaf}(x)$,\nwe go through the children of $x$,\nchoose a child $c$ with maximum $\\texttt{toLeaf}(c)$\nand add one to this value.\nThen, to calculate $\\texttt{maxLength}(x)$,\nwe choose two distinct children $a$ and $b$\nsuch that the sum $\\texttt{toLeaf}(a)+\\texttt{toLeaf}(b)$\nis maximum and add two to this sum.\n\n\\subsubsection{Algorithm 2}\n\nAnother efficient way to calculate the diameter\nof a tree is based on two depth-first searches.\nFirst, we choose an arbitrary node $a$ in the tree\nand find the farthest node $b$ from $a$.\nThen, we find the farthest node $c$ from $b$.\nThe diameter of the tree is the distance between $b$ and $c$.\n\nIn the following graph, $a$, $b$ and $c$ could be:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,3) {$4$};\n\\node[draw, circle] (3) at (0,1) {$2$};\n\\node[draw, circle] (4) at (2,1) {$3$};\n\\node[draw, circle] (5) at (4,1) {$7$};\n\\node[draw, circle] (6) at (-2,3) {$5$};\n\\node[draw, circle] (7) at (-2,1) {$6$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\node[color=red] at (2,1.6) {$a$};\n\\node[color=red] at (-2,1.6) {$b$};\n\\node[color=red] at (4,1.6) {$c$};\n\n\\path[draw,thick,-,color=red,line width=2pt] (7) -- (3);\n\\path[draw,thick,-,color=red,line width=2pt] (3) -- (1);\n\\path[draw,thick,-,color=red,line width=2pt] (1) -- (2);\n\\path[draw,thick,-,color=red,line width=2pt] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\nThis is an elegant method, but why does it work?\n\nIt helps to draw the tree differently so that\nthe path that corresponds to the diameter\nis horizontal, and all other\nnodes hang from it:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (2,1) {$1$};\n\\node[draw, circle] (2) at (4,1) {$4$};\n\\node[draw, circle] (3) at (0,1) {$2$};\n\\node[draw, circle] (4) at (2,-1) {$3$};\n\\node[draw, circle] (5) at (6,1) {$7$};\n\\node[draw, circle] (6) at (0,-1) {$5$};\n\\node[draw, circle] (7) at (-2,1) {$6$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\node[color=red] at (2,-1.6) {$a$};\n\\node[color=red] at (-2,1.6) {$b$};\n\\node[color=red] at (6,1.6) {$c$};\n\\node[color=red] at (2,1.6) {$x$};\n\n\\path[draw,thick,-,color=red,line width=2pt] (7) -- (3);\n\\path[draw,thick,-,color=red,line width=2pt] (3) -- (1);\n\\path[draw,thick,-,color=red,line width=2pt] (1) -- (2);\n\\path[draw,thick,-,color=red,line width=2pt] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\nNode $x$ indicates the place where the path\nfrom node $a$ joins the path that corresponds\nto the diameter.\nThe farthest node from $a$\nis node $b$, node $c$ or some other node\nthat is at least as far from node $x$.\nThus, this node is always a valid choice for\nan endpoint of a path that corresponds to the diameter.\n\n", "chapter_name": "Tree algorithms", "chapter_path": "cphb/chapter14.tex"}, {"section_name": "All longest paths", "section_content": "\\section{All longest paths}\n\nOur next problem is to calculate for every node\nin the tree the maximum length of a path\nthat begins at the node.\nThis can be seen as a generalization of the\ntree diameter problem, because the largest of those\nlengths equals the diameter of the tree.\nAlso this problem can be solved in $O(n)$ time.\n\nAs an example, consider the following tree:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (-1.5,-1) {$4$};\n\\node[draw, circle] (3) at (2,0) {$2$};\n\\node[draw, circle] (4) at (-1.5,1) {$3$};\n\\node[draw, circle] (6) at (3.5,-1) {$6$};\n\\node[draw, circle] (7) at (3.5,1) {$5$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nLet $\\texttt{maxLength}(x)$ denote the maximum length\nof a path that begins at node $x$.\nFor example, in the above tree,\n$\\texttt{maxLength}(4)=3$, because there\nis a path $4 \\rightarrow 1 \\rightarrow 2 \\rightarrow 6$.\nHere is a complete table of the values:\n\\begin{center}\n\\begin{tabular}{l|lllllll}\nnode $x$ & 1 & 2 & 3 & 4 & 5 & 6 \\\\\n$\\texttt{maxLength}(x)$ & 2 & 2 & 3 & 3 & 3 & 3 \\\\\n\\end{tabular}\n\\end{center}\n\nAlso in this problem, a good starting point\nfor solving the problem is to root the tree arbitrarily:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (6) at (-3,-1) {$5$};\n\\node[draw, circle] (7) at (-1,-1) {$6$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nThe first part of the problem is to calculate for every node $x$\nthe maximum length of a path that goes through a child of $x$.\nFor example, the longest path from node 1\ngoes through its child 2:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (6) at (-3,-1) {$5$};\n\\node[draw, circle] (7) at (-1,-1) {$6$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\n\\path[draw,thick,->,color=red,line width=2pt] (1) -- (3);\n\\path[draw,thick,->,color=red,line width=2pt] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\nThis part is easy to solve in $O(n)$ time, because we can use\ndynamic programming as we have done previously.\n\nThen, the second part of the problem is to calculate\nfor every node $x$ the maximum length of a path\nthrough its parent $p$.\nFor example, the longest path\nfrom node 3 goes through its parent 1:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (6) at (-3,-1) {$5$};\n\\node[draw, circle] (7) at (-1,-1) {$6$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\n\\path[draw,thick,->,color=red,line width=2pt] (4) -- (1);\n\\path[draw,thick,->,color=red,line width=2pt] (1) -- (3);\n\\path[draw,thick,->,color=red,line width=2pt] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nAt first glance, it seems that we should choose\nthe longest path from $p$.\nHowever, this \\emph{does not} always work,\nbecause the longest path from $p$\nmay go through $x$.\nHere is an example of this situation:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (6) at (-3,-1) {$5$};\n\\node[draw, circle] (7) at (-1,-1) {$6$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\n\\path[draw,thick,->,color=red,line width=2pt] (3) -- (1);\n\\path[draw,thick,->,color=red,line width=2pt] (1) -- (2);\n\\end{tikzpicture}\n\\end{center}\n\nStill, we can solve the second part in\n$O(n)$ time by storing \\emph{two} maximum lengths\nfor each node $x$:\n\\begin{itemize}\n\\item $\\texttt{maxLength}_1(x)$:\nthe maximum length of a path from $x$\n\\item $\\texttt{maxLength}_2(x)$\nthe maximum length of a path from $x$\nin another direction than the first path\n\\end{itemize}\nFor example, in the above graph,\n$\\texttt{maxLength}_1(1)=2$\nusing the path $1 \\rightarrow 2 \\rightarrow 5$,\nand $\\texttt{maxLength}_2(1)=1$\nusing the path $1 \\rightarrow 3$.\n\nFinally, if the path that corresponds to\n$\\texttt{maxLength}_1(p)$ goes through $x$,\nwe conclude that the maximum length is\n$\\texttt{maxLength}_2(p)+1$,\nand otherwise the maximum length is\n$\\texttt{maxLength}_1(p)+1$.\n\n\n", "chapter_name": "Tree algorithms", "chapter_path": "cphb/chapter14.tex"}, {"section_name": "Binary trees", "section_content": "\\section{Binary trees}\n\n\\index{binary tree}\n\n\\begin{samepage}\nA \\key{binary tree} is a rooted tree\nwhere each node has a left and right subtree.\nIt is possible that a subtree of a node is empty.\nThus, every node in a binary tree has\nzero, one or two children.\n\nFor example, the following tree is a binary tree:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (-1.5,-1.5) {$2$};\n\\node[draw, circle] (3) at (1.5,-1.5) {$3$};\n\\node[draw, circle] (4) at (-3,-3) {$4$};\n\\node[draw, circle] (5) at (0,-3) {$5$};\n\\node[draw, circle] (6) at (-1.5,-4.5) {$6$};\n\\node[draw, circle] (7) at (3,-3) {$7$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (5) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\n\\index{pre-order}\n\\index{in-order}\n\\index{post-order}\n\nThe nodes of a binary tree have three natural\norderings that correspond to different ways to \nrecursively traverse the tree:\n\n\\begin{itemize}\n\\item \\key{pre-order}: first process the root,\nthen traverse the left subtree, then traverse the right subtree\n\\item \\key{in-order}: first traverse the left subtree,\nthen process the root, then traverse the right subtree\n\\item \\key{post-order}: first traverse the left subtree,\nthen traverse the right subtree, then process the root\n\\end{itemize}\n\nFor the above tree, the nodes in\npre-order are\n$[1,2,4,5,6,3,7]$,\nin in-order $[4,2,6,5,1,3,7]$\nand in post-order $[4,6,5,2,7,3,1]$.\n\nIf we know the pre-order and in-order\nof a tree, we can reconstruct the exact structure of the tree.\nFor example, the above tree is the only possible tree\nwith pre-order $[1,2,4,5,6,3,7]$ and\nin-order $[4,2,6,5,1,3,7]$.\nIn a similar way, the post-order and in-order\nalso determine the structure of a tree.\n\nHowever, the situation is different if we only know\nthe pre-order and post-order of a tree.\nIn this case, there may be more than one tree\nthat match the orderings.\nFor example, in both of the trees\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (-1.5,-1.5) {$2$};\n\\path[draw,thick,-] (1) -- (2);\n\n\\node[draw, circle] (1b) at (0+4,0) {$1$};\n\\node[draw, circle] (2b) at (1.5+4,-1.5) {$2$};\n\\path[draw,thick,-] (1b) -- (2b);\n\\end{tikzpicture}\n\\end{center}\nthe pre-order is $[1,2]$ and the post-order is $[2,1]$,\nbut the structures of the trees are different.\n\n", "chapter_name": "Tree algorithms", "chapter_path": "cphb/chapter14.tex"}, {"section_name": "Kruskal's algorithm", "section_content": "\\chapter{Spanning trees}\n\n\\index{spanning tree}\n\nA \\key{spanning tree} of a graph consists of\nall nodes of the graph and some of the\nedges of the graph so that there is a path\nbetween any two nodes.\nLike trees in general, spanning trees are\nconnected and acyclic.\nUsually there are several ways to construct a spanning tree.\n\nFor example, consider the following graph:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\nOne spanning tree for the graph is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\nThe weight of a spanning tree is the sum of its edge weights.\nFor example, the weight of the above spanning tree is\n$3+5+9+3+2=22$.\n\n\\index{minimum spanning tree}\n\nA \\key{minimum spanning tree}\nis a spanning tree whose weight is as small as possible.\nThe weight of a minimum spanning tree for the example graph\nis 20, and such a tree can be constructed as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\n\\index{maximum spanning tree}\n\nIn a similar way, a \\key{maximum spanning tree}\nis a spanning tree whose weight is as large as possible.\nThe weight of a maximum spanning tree for the\nexample graph is 32:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n\\end{tikzpicture}\n\\end{center}\n\nNote that a graph may have several\nminimum and maximum spanning trees,\nso the trees are not unique.\n\nIt turns out that several greedy methods\ncan be used to construct minimum and maximum\nspanning trees.\nIn this chapter, we discuss two algorithms\nthat process\nthe edges of the graph ordered by their weights.\nWe focus on finding minimum spanning trees,\nbut the same algorithms can find\nmaximum spanning trees by processing the edges in reverse order.\n\n\\section{Kruskal's algorithm}\n\n\\index{Kruskal's algorithm}\n\nIn \\key{Kruskal's algorithm}\\footnote{The algorithm was published in 1956\nby J. B. Kruskal \\cite{kru56}.}, the initial spanning tree\nonly contains the nodes of the graph\nand does not contain any edges.\nThen the algorithm goes through the edges\nordered by their weights, and always adds an edge\nto the tree if it does not create a cycle.\n\nThe algorithm maintains the components\nof the tree.\nInitially, each node of the graph\nbelongs to a separate component.\nAlways when an edge is added to the tree,\ntwo components are joined.\nFinally, all nodes belong to the same component,\nand a minimum spanning tree has been found.\n\n\\subsubsection{Example}\n\n\\begin{samepage}\nLet us consider how Kruskal's algorithm processes the\nfollowing graph:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\n\\begin{samepage}\nThe first step of the algorithm is to sort the\nedges in increasing order of their weights.\nThe result is the following list:\n\n\\begin{tabular}{ll}\n\\\\\nedge & weight \\\\\n\\hline\n5--6 & 2 \\\\\n1--2 & 3 \\\\\n3--6 & 3 \\\\\n1--5 & 5 \\\\\n2--3 & 5 \\\\\n2--5 & 6 \\\\\n4--6 & 7 \\\\\n3--4 & 9 \\\\\n\\\\\n\\end{tabular}\n\\end{samepage}\n\nAfter this, the algorithm goes through the list\nand adds each edge to the tree if it joins\ntwo separate components.\n\nInitially, each node is in its own component:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n%\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n%\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n%\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n%\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\nThe first edge to be added to the tree is\nthe edge 5--6 that creates a component $\\{5,6\\}$\nby joining the components $\\{5\\}$ and $\\{6\\}$:\n\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\n%\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n%\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n%\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\nAfter this, the edges 1--2, 3--6 and 1--5 are added in a similar way:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n%\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\nAfter those steps, most components have been joined\nand there are two components in the tree:\n$\\{1,2,3,5,6\\}$ and $\\{4\\}$.\n\nThe next edge in the list is the edge 2--3,\nbut it will not be included in the tree, because\nnodes 2 and 3 are already in the same component.\nFor the same reason, the edge 2--5 will not be included in the tree.\n\n\\begin{samepage}\nFinally, the edge 4--6 will be included in the tree:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\nAfter this, the algorithm will not add any\nnew edges, because the graph is connected\nand there is a path between any two nodes.\nThe resulting graph is a minimum spanning tree\nwith weight $2+3+3+5+7=20$.\n\n\\subsubsection{Why does this work?}\n\nIt is a good question why Kruskal's algorithm works.\nWhy does the greedy strategy guarantee that we\nwill find a minimum spanning tree?\n\nLet us see what happens if the minimum weight edge of\nthe graph is \\emph{not} included in the spanning tree.\nFor example, suppose that a spanning tree\nfor the previous graph would not contain the\nminimum weight edge 5--6.\nWe do not know the exact structure of such a spanning tree,\nbut in any case it has to contain some edges.\nAssume that the tree would be as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\n\\path[draw,thick,-,dashed] (1) -- (2);\n\\path[draw,thick,-,dashed] (2) -- (5);\n\\path[draw,thick,-,dashed] (2) -- (3);\n\\path[draw,thick,-,dashed] (3) -- (4);\n\\path[draw,thick,-,dashed] (4) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nHowever, it is not possible that the above tree\nwould be a minimum spanning tree for the graph.\nThe reason for this is that we can remove an edge\nfrom the tree and replace it with the minimum weight edge 5--6.\nThis produces a spanning tree whose weight is\n\\emph{smaller}:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\n\\path[draw,thick,-,dashed] (1) -- (2);\n\\path[draw,thick,-,dashed] (2) -- (5);\n\\path[draw,thick,-,dashed] (3) -- (4);\n\\path[draw,thick,-,dashed] (4) -- (6);\n\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\nFor this reason, it is always optimal\nto include the minimum weight edge\nin the tree to produce a minimum spanning tree.\nUsing a similar argument, we can show that it\nis also optimal to add the next edge in weight order\nto the tree, and so on.\nHence, Kruskal's algorithm works correctly and\nalways produces a minimum spanning tree.\n\n\\subsubsection{Implementation}\n\nWhen implementing Kruskal's algorithm,\nit is convenient to use\nthe edge list representation of the graph.\nThe first phase of the algorithm sorts the\nedges in the list in $O(m \\log m)$ time.\nAfter this, the second phase of the algorithm\nbuilds the minimum spanning tree as follows:\n\n\\begin{lstlisting}\nfor (...) {\n  if (!same(a,b)) unite(a,b);\n}\n\\end{lstlisting}\n\nThe loop goes through the edges in the list\nand always processes an edge $a$--$b$\nwhere $a$ and $b$ are two nodes.\nTwo functions are needed:\nthe function \\texttt{same} determines\nif $a$ and $b$ are in the same component,\nand the function \\texttt{unite}\njoins the components that contain $a$ and $b$.\n\nThe problem is how to efficiently implement\nthe functions \\texttt{same} and \\texttt{unite}.\nOne possibility is to implement the function\n\\texttt{same} as a graph traversal and check if\nwe can get from node $a$ to node $b$.\nHowever, the time complexity of such a function\nwould be $O(n+m)$\nand the resulting algorithm would be slow,\nbecause the function \\texttt{same} will be called for each edge in the graph.\n\nWe will solve the problem using a union-find structure\nthat implements both functions in $O(\\log n)$ time.\nThus, the time complexity of Kruskal's algorithm\nwill be $O(m \\log n)$ after sorting the edge list.\n\n", "chapter_name": "Spanning trees", "chapter_path": "cphb/chapter15.tex"}, {"section_name": "Union-find structure", "section_content": "\\section{Union-find structure}\n\n\\index{union-find structure}\n\nA \\key{union-find structure} maintains\na collection of sets.\nThe sets are disjoint, so no element\nbelongs to more than one set.\nTwo $O(\\log n)$ time operations are supported:\nthe \\texttt{unite} operation joins two sets,\nand the \\texttt{find} operation finds the representative\nof the set that contains a given element\\footnote{The structure presented here\nwas introduced in 1971 by J. D. Hopcroft and J. D. Ullman \\cite{hop71}.\nLater, in 1975, R. E. Tarjan studied a more sophisticated variant\nof the structure \\cite{tar75} that is discussed in many algorithm\ntextbooks nowadays.}.\n\n\\subsubsection{Structure}\n\nIn a union-find structure, one element in each set\nis the representative of the set,\nand there is a chain from any other element of the\nset to the representative.\nFor example, assume that the sets are\n$\\{1,4,7\\}$, $\\{5\\}$ and $\\{2,3,6,8\\}$:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (0,-1) {$1$};\n\\node[draw, circle] (2) at (7,0) {$2$};\n\\node[draw, circle] (3) at (7,-1.5) {$3$};\n\\node[draw, circle] (4) at (1,0) {$4$};\n\\node[draw, circle] (5) at (4,0) {$5$};\n\\node[draw, circle] (6) at (6,-2.5) {$6$};\n\\node[draw, circle] (7) at (2,-1) {$7$};\n\\node[draw, circle] (8) at (8,-2.5) {$8$};\n\n\\path[draw,thick,->] (1) -- (4);\n\\path[draw,thick,->] (7) -- (4);\n\n\\path[draw,thick,->] (3) -- (2);\n\\path[draw,thick,->] (6) -- (3);\n\\path[draw,thick,->] (8) -- (3);\n\n\\end{tikzpicture}\n\\end{center}\nIn this case the representatives\nof the sets are 4, 5 and 2.\nWe can find the representative of any element\nby following the chain that begins at the element.\nFor example, the element 2 is the representative\nfor the element 6, because\nwe follow the chain $6 \\rightarrow 3 \\rightarrow 2$.\nTwo elements belong to the same set exactly when\ntheir representatives are the same.\n\nTwo sets can be joined by connecting the\nrepresentative of one set to the\nrepresentative of the other set.\nFor example, the sets\n$\\{1,4,7\\}$ and $\\{2,3,6,8\\}$\ncan be joined as follows:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (2,-1) {$1$};\n\\node[draw, circle] (2) at (7,0) {$2$};\n\\node[draw, circle] (3) at (7,-1.5) {$3$};\n\\node[draw, circle] (4) at (3,0) {$4$};\n\\node[draw, circle] (6) at (6,-2.5) {$6$};\n\\node[draw, circle] (7) at (4,-1) {$7$};\n\\node[draw, circle] (8) at (8,-2.5) {$8$};\n\n\\path[draw,thick,->] (1) -- (4);\n\\path[draw,thick,->] (7) -- (4);\n\n\\path[draw,thick,->] (3) -- (2);\n\\path[draw,thick,->] (6) -- (3);\n\\path[draw,thick,->] (8) -- (3);\n\n\\path[draw,thick,->] (4) -- (2);\n\\end{tikzpicture}\n\\end{center}\n\nThe resulting set contains the elements\n$\\{1,2,3,4,6,7,8\\}$.\nFrom this on, the element 2 is the representative\nfor the entire set and the old representative 4\npoints to the element 2.\n\nThe efficiency of the union-find structure depends on\nhow the sets are joined.\nIt turns out that we can follow a simple strategy:\nalways connect the representative of the\n\\emph{smaller} set to the representative of the \\emph{larger} set\n(or if the sets are of equal size,\nwe can make an arbitrary choice).\nUsing this strategy, the length of any chain\nwill be $O(\\log n)$, so we can\nfind the representative of any element\nefficiently by following the corresponding chain.\n\n\\subsubsection{Implementation}\n\nThe union-find structure can be implemented\nusing arrays.\nIn the following implementation,\nthe array \\texttt{link} contains for each element\nthe next element\nin the chain or the element itself if it is\na representative,\nand the array \\texttt{size} indicates for each representative\nthe size of the corresponding set.\n\nInitially, each element belongs to a separate set:\n\\begin{lstlisting}\nfor (int i = 1; i <= n; i++) link[i] = i;\nfor (int i = 1; i <= n; i++) size[i] = 1;\n\\end{lstlisting}\n\nThe function \\texttt{find} returns\nthe representative for an element $x$.\nThe representative can be found by following\nthe chain that begins at $x$.\n\n\\begin{lstlisting}\nint find(int x) {\n    while (x != link[x]) x = link[x];\n    return x;\n}\n\\end{lstlisting}\n\nThe function \\texttt{same} checks\nwhether elements $a$ and $b$ belong to the same set.\nThis can easily be done by using the\nfunction \\texttt{find}:\n\n\\begin{lstlisting}\nbool same(int a, int b) {\n    return find(a) == find(b);\n}\n\\end{lstlisting}\n\n\\begin{samepage}\nThe function \\texttt{unite} joins the sets\nthat contain elements $a$ and $b$\n(the elements have to be in different sets).\nThe function first finds the representatives\nof the sets and then connects the smaller\nset to the larger set.\n\n\\begin{lstlisting}\nvoid unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (size[a] < size[b]) swap(a,b);\n    size[a] += size[b];\n    link[b] = a;\n}\n\\end{lstlisting}\n\\end{samepage}\n\nThe time complexity of the function \\texttt{find}\nis $O(\\log n)$ assuming that the length of each\nchain is $O(\\log n)$.\nIn this case, the functions \\texttt{same} and \\texttt{unite}\nalso work in $O(\\log n)$ time.\nThe function \\texttt{unite} makes sure that the\nlength of each chain is $O(\\log n)$ by connecting\nthe smaller set to the larger set.\n\n", "chapter_name": "Spanning trees", "chapter_path": "cphb/chapter15.tex"}, {"section_name": "Prim's algorithm", "section_content": "\\section{Prim's algorithm}\n\n\\index{Prim's algorithm}\n\n\\key{Prim's algorithm}\\footnote{The algorithm is\nnamed after R. C. Prim who published it in 1957 \\cite{pri57}.\nHowever, the same algorithm was discovered already in 1930\nby V. Jarn\u00edk.} is an alternative method\nfor finding a minimum spanning tree.\nThe algorithm first adds an arbitrary node\nto the tree.\nAfter this, the algorithm always chooses\na minimum-weight edge that\nadds a new node to the tree.\nFinally, all nodes have been added to the tree\nand a minimum spanning tree has been found.\n\nPrim's algorithm resembles Dijkstra's algorithm.\nThe difference is that Dijkstra's algorithm always\nselects an edge whose distance from the starting\nnode is minimum, but Prim's algorithm simply selects\nthe minimum weight edge that adds a new node to the tree.\n\n\\subsubsection{Example}\n\nLet us consider how Prim's algorithm works\nin the following graph:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\n%\\path[draw=red,thick,-,line width=2pt] (5) -- (6);\n\\end{tikzpicture}\n\\end{center}\nInitially, there are no edges between the nodes:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n%\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n%\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n%\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n%\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\nAn arbitrary node can be the starting node,\nso let us choose node 1.\nFirst, we add node 2 that is connected by\nan edge of weight 3:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n%\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n%\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n%\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\nAfter this, there are two edges with weight 5,\nso we can add either node 3 or node 5 to the tree.\nLet us add node 3 first:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n%\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n%\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n%\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\n\\begin{samepage}\nThe process continues until all nodes have been included in the tree:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1.5,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (6.5,2) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:5] {} (3);\n%\\path[draw,thick,-] (3) -- node[font=\\small,label=above:9] {} (4);\n%\\path[draw,thick,-] (1) -- node[font=\\small,label=below:5] {} (5);\n\\path[draw,thick,-] (5) -- node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,-] (6) -- node[font=\\small,label=below:7] {} (4);\n%\\path[draw,thick,-] (2) -- node[font=\\small,label=left:6] {} (5);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=left:3] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\n\\subsubsection{Implementation}\n\nLike Dijkstra's algorithm, Prim's algorithm can be\nefficiently implemented using a priority queue.\nThe priority queue should contain all nodes\nthat can be connected to the current component using\na single edge, in increasing order of the weights\nof the corresponding edges.\n\nThe time complexity of Prim's algorithm is\n$O(n + m \\log m)$ that equals the time complexity\nof Dijkstra's algorithm.\nIn practice, Prim's and Kruskal's algorithms\nare both efficient, and the choice of the algorithm\nis a matter of taste.\nStill, most competitive programmers use Kruskal's algorithm.", "chapter_name": "Spanning trees", "chapter_path": "cphb/chapter15.tex"}, {"section_name": "Topological sorting", "section_content": "\\chapter{Directed graphs}\n\nIn this chapter, we focus on two classes of directed graphs:\n\\begin{itemize}\n\\item \\key{Acyclic graphs}:\nThere are no cycles in the graph,\nso there is no path from any node to itself\\footnote{Directed acyclic\ngraphs are sometimes called DAGs.}.\n\\item \\key{Successor graphs}:\nThe outdegree of each node is 1,\nso each node has a unique successor.\n\\end{itemize}\nIt turns out that in both cases,\nwe can design efficient algorithms that are based\non the special properties of the graphs.\n\n\\section{Topological sorting}\n\n\\index{topological sorting}\n\\index{cycle}\n\nA \\key{topological sort} is an ordering\nof the nodes of a directed graph\nsuch that if there is a path from node $a$ to node $b$,\nthen node $a$ appears before node $b$ in the ordering.\nFor example, for the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,5) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\\node[draw, circle] (6) at (5,3) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (5) -- (3);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\none topological sort is\n$[4,1,5,2,3,6]$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (-6,0) {$1$};\n\\node[draw, circle] (2) at (-3,0) {$2$};\n\\node[draw, circle] (3) at (-1.5,0) {$3$};\n\\node[draw, circle] (4) at (-7.5,0) {$4$};\n\\node[draw, circle] (5) at (-4.5,0) {$5$};\n\\node[draw, circle] (6) at (-0,0) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) edge [bend right=30] (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\path[draw,thick,->,>=latex] (4) edge [bend left=30] (5);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (5) edge [bend left=30]  (3);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nAn acyclic graph always has a topological sort.\nHowever, if the graph contains a cycle,\nit is not possible to form a topological sort,\nbecause no node of the cycle can appear\nbefore the other nodes of the cycle in the ordering.\nIt turns out that depth-first search can be used\nto both check if a directed graph contains a cycle\nand, if it does not contain a cycle, to construct a topological sort.\n\n\\subsubsection{Algorithm}\n\nThe idea is to go through the nodes of the graph\nand always begin a depth-first search at the current node\nif it has not been processed yet.\nDuring the searches, the nodes have three possible states:\n\n\\begin{itemize}\n\\item state 0: the node has not been processed (white)\n\\item state 1: the node is under processing (light gray)\n\\item state 2: the node has been processed (dark gray)\n\\end{itemize}\n\nInitially, the state of each node is 0.\nWhen a search reaches a node for the first time,\nits state becomes 1.\nFinally, after all successors of the node have\nbeen processed, its state becomes 2.\n\nIf the graph contains a cycle, we will find this out\nduring the search, because sooner or later\nwe will arrive at a node whose state is 1.\nIn this case, it is not possible to construct a topological sort.\n\nIf the graph does not contain a cycle, we can construct\na topological sort by \nadding each node to a list when the state of the node becomes 2.\nThis list in reverse order is a topological sort.\n\n\\subsubsection{Example 1}\n\nIn the example graph, the search first proceeds\nfrom node 1 to node 6:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle,fill=gray!20] (1) at (1,5) {$1$};\n\\node[draw, circle,fill=gray!20] (2) at (3,5) {$2$};\n\\node[draw, circle,fill=gray!20] (3) at (5,5) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\\node[draw, circle,fill=gray!80] (6) at (5,3) {$6$};\n\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (5) -- (3);\n%\\path[draw,thick,->,>=latex] (3) -- (6);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nNow node 6 has been processed, so it is added to the list.\nAfter this, also nodes 3, 2 and 1 are added to the list:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle,fill=gray!80] (1) at (1,5) {$1$};\n\\node[draw, circle,fill=gray!80] (2) at (3,5) {$2$};\n\\node[draw, circle,fill=gray!80] (3) at (5,5) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\\node[draw, circle,fill=gray!80] (6) at (5,3) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (5) -- (3);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nAt this point, the list is $[6,3,2,1]$.\nThe next search begins at node 4:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle,fill=gray!80] (1) at (1,5) {$1$};\n\\node[draw, circle,fill=gray!80] (2) at (3,5) {$2$};\n\\node[draw, circle,fill=gray!80] (3) at (5,5) {$3$};\n\\node[draw, circle,fill=gray!20] (4) at (1,3) {$4$};\n\\node[draw, circle,fill=gray!80] (5) at (3,3) {$5$};\n\\node[draw, circle,fill=gray!80] (6) at (5,3) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n%\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (5) -- (3);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\n\\path[draw=red,thick,->,line width=2pt] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\nThus, the final list is $[6,3,2,1,5,4]$.\nWe have processed all nodes, so a topological sort has\nbeen found.\nThe topological sort is the reverse list\n$[4,5,1,2,3,6]$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (3,0) {$1$};\n\\node[draw, circle] (2) at (4.5,0) {$2$};\n\\node[draw, circle] (3) at (6,0) {$3$};\n\\node[draw, circle] (4) at (0,0) {$4$};\n\\node[draw, circle] (5) at (1.5,0) {$5$};\n\\node[draw, circle] (6) at (7.5,0) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (4) edge [bend left=30] (1);\n\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (5) edge [bend right=30] (2);\n\\path[draw,thick,->,>=latex] (5) edge [bend right=40] (3);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nNote that a topological sort is not unique,\nand there can be several topological sorts for a graph.\n\n\\subsubsection{Example 2}\n\nLet us now consider a graph for which we\ncannot construct a topological sort,\nbecause the graph contains a cycle:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,5) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\\node[draw, circle] (6) at (5,3) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (3) -- (5);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\nThe search proceeds as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle,fill=gray!20] (1) at (1,5) {$1$};\n\\node[draw, circle,fill=gray!20] (2) at (3,5) {$2$};\n\\node[draw, circle,fill=gray!20] (3) at (5,5) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle,fill=gray!20] (5) at (3,3) {$5$};\n\\node[draw, circle] (6) at (5,3) {$6$};\n\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- (2);\n\\end{tikzpicture}\n\\end{center}\nThe search reaches node 2 whose state is 1,\nwhich means that the graph contains a cycle.\nIn this example, there is a cycle\n$2 \\rightarrow 3 \\rightarrow 5 \\rightarrow 2$.\n\n", "chapter_name": "Directed graphs", "chapter_path": "cphb/chapter16.tex"}, {"section_name": "Dynamic programming", "section_content": "\\section{Dynamic programming}\n\nIf a directed graph is acyclic,\ndynamic programming can be applied to it.\nFor example, we can efficiently solve the following\nproblems concerning paths from a starting node\nto an ending node:\n\n\\begin{itemize}\n\\item how many different paths are there?\n\\item what is the shortest/longest path?\n\\item what is the minimum/maximum number of edges in a path?\n\\item which nodes certainly appear in any path?\n\\end{itemize}\n\n\\subsubsection{Counting the number of paths}\n\nAs an example, let us calculate the number of paths\nfrom node 1 to node 6 in the following graph:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,5) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\\node[draw, circle] (6) at (5,3) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (1) -- (4);\n\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (5) -- (3);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\nThere are a total of three such paths:\n\\begin{itemize}\n\\item $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 6$\n\\item $1 \\rightarrow 4 \\rightarrow 5 \\rightarrow 2 \\rightarrow 3 \\rightarrow 6$\n\\item $1 \\rightarrow 4 \\rightarrow 5 \\rightarrow 3 \\rightarrow 6$\n\\end{itemize}\n\nLet $\\texttt{paths}(x)$ denote the number of paths from\nnode 1 to node $x$.\nAs a base case, $\\texttt{paths}(1)=1$.\nThen, to calculate other values of $\\texttt{paths}(x)$,\nwe may use the recursion\n\\[\\texttt{paths}(x) = \\texttt{paths}(a_1)+\\texttt{paths}(a_2)+\\cdots+\\texttt{paths}(a_k)\\]\nwhere $a_1,a_2,\\ldots,a_k$ are the nodes from which there\nis an edge to $x$.\nSince the graph is acyclic, the values of $\\texttt{paths}(x)$\ncan be calculated in the order of a topological sort.\nA topological sort for the above graph is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (4.5,0) {$2$};\n\\node[draw, circle] (3) at (6,0) {$3$};\n\\node[draw, circle] (4) at (1.5,0) {$4$};\n\\node[draw, circle] (5) at (3,0) {$5$};\n\\node[draw, circle] (6) at (7.5,0) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) edge [bend left=30] (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (1) -- (4);\n\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (5) edge [bend right=30] (3);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\nHence, the numbers of paths are as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,5) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\\node[draw, circle] (6) at (5,3) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (1) -- (4);\n\\path[draw,thick,->,>=latex] (4) -- (5);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (5) -- (3);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\n\\node[color=red] at (1,2.3) {$1$};\n\\node[color=red] at (3,2.3) {$1$};\n\\node[color=red] at (5,2.3) {$3$};\n\\node[color=red] at (1,5.7) {$1$};\n\\node[color=red] at (3,5.7) {$2$};\n\\node[color=red] at (5,5.7) {$3$};\n\\end{tikzpicture}\n\\end{center}\n\nFor example, to calculate the value of $\\texttt{paths}(3)$,\nwe can use the formula $\\texttt{paths}(2)+\\texttt{paths}(5)$,\nbecause there are edges from nodes 2 and 5\nto node 3.\nSince $\\texttt{paths}(2)=2$ and $\\texttt{paths}(5)=1$, we conclude that $\\texttt{paths}(3)=3$.\n\n\\subsubsection{Extending Dijkstra's algorithm}\n\n\\index{Dijkstra's algorithm}\n\nA by-product of Dijkstra's algorithm is a directed, acyclic\ngraph that indicates for each node of the original graph\nthe possible ways to reach the node using a shortest path\nfrom the starting node.\nDynamic programming can be applied to that graph.\nFor example, in the graph\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (2,0) {$2$};\n\\node[draw, circle] (3) at (0,-2) {$3$};\n\\node[draw, circle] (4) at (2,-2) {$4$};\n\\node[draw, circle] (5) at (4,-1) {$5$};\n\n\\path[draw,thick,-] (1) -- node[font=\\small,label=above:3] {} (2);\n\\path[draw,thick,-] (1) -- node[font=\\small,label=left:5] {} (3);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=right:4] {} (4);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:8] {} (5);\n\\path[draw,thick,-] (3) -- node[font=\\small,label=below:2] {} (4);\n\\path[draw,thick,-] (4) -- node[font=\\small,label=below:1] {} (5);\n\\path[draw,thick,-] (2) -- node[font=\\small,label=above:2] {} (3);\n\\end{tikzpicture}\n\\end{center}\nthe shortest paths from node 1 may use the following edges:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (2,0) {$2$};\n\\node[draw, circle] (3) at (0,-2) {$3$};\n\\node[draw, circle] (4) at (2,-2) {$4$};\n\\node[draw, circle] (5) at (4,-1) {$5$};\n\n\\path[draw,thick,->] (1) -- node[font=\\small,label=above:3] {} (2);\n\\path[draw,thick,->] (1) -- node[font=\\small,label=left:5] {} (3);\n\\path[draw,thick,->] (2) -- node[font=\\small,label=right:4] {} (4);\n\\path[draw,thick,->] (3) -- node[font=\\small,label=below:2] {} (4);\n\\path[draw,thick,->] (4) -- node[font=\\small,label=below:1] {} (5);\n\\path[draw,thick,->] (2) -- node[font=\\small,label=above:2] {} (3);\n\\end{tikzpicture}\n\\end{center}\n\nNow we can, for example, calculate the number of\nshortest paths from node 1 to node 5\nusing dynamic programming:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (2,0) {$2$};\n\\node[draw, circle] (3) at (0,-2) {$3$};\n\\node[draw, circle] (4) at (2,-2) {$4$};\n\\node[draw, circle] (5) at (4,-1) {$5$};\n\n\\path[draw,thick,->] (1) -- node[font=\\small,label=above:3] {} (2);\n\\path[draw,thick,->] (1) -- node[font=\\small,label=left:5] {} (3);\n\\path[draw,thick,->] (2) -- node[font=\\small,label=right:4] {} (4);\n\\path[draw,thick,->] (3) -- node[font=\\small,label=below:2] {} (4);\n\\path[draw,thick,->] (4) -- node[font=\\small,label=below:1] {} (5);\n\\path[draw,thick,->] (2) -- node[font=\\small,label=above:2] {} (3);\n\n\\node[color=red] at (0,0.7) {$1$};\n\\node[color=red] at (2,0.7) {$1$};\n\\node[color=red] at (0,-2.7) {$2$};\n\\node[color=red] at (2,-2.7) {$3$};\n\\node[color=red] at (4,-1.7) {$3$};\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Representing problems as graphs}\n\nActually, any dynamic programming problem\ncan be represented as a directed, acyclic graph.\nIn such a graph, each node corresponds to a dynamic programming state\nand the edges indicate how the states depend on each other.\n\nAs an example, consider the problem\nof forming a sum of money $n$\nusing coins\n$\\{c_1,c_2,\\ldots,c_k\\}$.\nIn this problem, we can construct a graph where\neach node corresponds to a sum of money,\nand the edges show how the coins can be chosen.\nFor example, for coins $\\{1,3,4\\}$ and $n=6$,\nthe graph is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (0) at (0,0) {$0$};\n\\node[draw, circle] (1) at (2,0) {$1$};\n\\node[draw, circle] (2) at (4,0) {$2$};\n\\node[draw, circle] (3) at (6,0) {$3$};\n\\node[draw, circle] (4) at (8,0) {$4$};\n\\node[draw, circle] (5) at (10,0) {$5$};\n\\node[draw, circle] (6) at (12,0) {$6$};\n\n\\path[draw,thick,->] (0) -- (1);\n\\path[draw,thick,->] (1) -- (2);\n\\path[draw,thick,->] (2) -- (3);\n\\path[draw,thick,->] (3) -- (4);\n\\path[draw,thick,->] (4) -- (5);\n\\path[draw,thick,->] (5) -- (6);\n\n\\path[draw,thick,->] (0) edge [bend right=30] (3);\n\\path[draw,thick,->] (1) edge [bend right=30] (4);\n\\path[draw,thick,->] (2) edge [bend right=30] (5);\n\\path[draw,thick,->] (3) edge [bend right=30] (6);\n\n\\path[draw,thick,->] (0) edge [bend left=30] (4);\n\\path[draw,thick,->] (1) edge [bend left=30] (5);\n\\path[draw,thick,->] (2) edge [bend left=30] (6);\n\\end{tikzpicture}\n\\end{center}\n\nUsing this representation,\nthe shortest path from node 0 to node $n$\ncorresponds to a solution with the minimum number of coins,\nand the total number of paths from node 0 to node $n$\nequals the total number of solutions.\n\n", "chapter_name": "Directed graphs", "chapter_path": "cphb/chapter16.tex"}, {"section_name": "Successor paths", "section_content": "\\section{Successor paths}\n\n\\index{successor graph}\n\\index{functional graph}\n\nFor the rest of the chapter,\nwe will focus on \\key{successor graphs}.\nIn those graphs,\nthe outdegree of each node is 1, i.e.,\nexactly one edge starts at each node.\nA successor graph consists of one or more\ncomponents, each of which contains\none cycle and some paths that lead to it.\n\nSuccessor graphs are sometimes called\n\\key{functional graphs}.\nThe reason for this is that any successor graph\ncorresponds to a function that defines\nthe edges of the graph.\nThe parameter for the function is a node of the graph,\nand the function gives the successor of that node.\n\nFor example, the function\n\\begin{center}\n\\begin{tabular}{r|rrrrrrrrr}\n$x$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n\\hline\n$\\texttt{succ}(x)$ & 3 & 5 & 7 & 6 & 2 & 2 & 1 & 6 & 3 \\\\\n\\end{tabular}\n\\end{center}\ndefines the following graph:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (2,0) {$2$};\n\\node[draw, circle] (3) at (-2,0) {$3$};\n\\node[draw, circle] (4) at (1,-3) {$4$};\n\\node[draw, circle] (5) at (4,0) {$5$};\n\\node[draw, circle] (6) at (2,-1.5) {$6$};\n\\node[draw, circle] (7) at (-2,-1.5) {$7$};\n\\node[draw, circle] (8) at (3,-3) {$8$};\n\\node[draw, circle] (9) at (-4,0) {$9$};\n\n\\path[draw,thick,->] (1) -- (3);\n\\path[draw,thick,->] (2)  edge [bend left=40] (5);\n\\path[draw,thick,->] (3) -- (7);\n\\path[draw,thick,->] (4) -- (6);\n\\path[draw,thick,->] (5)  edge [bend left=40] (2);\n\\path[draw,thick,->] (6) -- (2);\n\\path[draw,thick,->] (7) -- (1);\n\\path[draw,thick,->] (8) -- (6);\n\\path[draw,thick,->] (9) -- (3);\n\\end{tikzpicture}\n\\end{center}\n\nSince each node of a successor graph has a\nunique successor, we can also define a function $\\texttt{succ}(x,k)$\nthat gives the node that we will reach if\nwe begin at node $x$ and walk $k$ steps forward.\nFor example, in the above graph $\\texttt{succ}(4,6)=2$,\nbecause we will reach node 2 by walking 6 steps from node 4:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$4$};\n\\node[draw, circle] (2) at (1.5,0) {$6$};\n\\node[draw, circle] (3) at (3,0) {$2$};\n\\node[draw, circle] (4) at (4.5,0) {$5$};\n\\node[draw, circle] (5) at (6,0) {$2$};\n\\node[draw, circle] (6) at (7.5,0) {$5$};\n\\node[draw, circle] (7) at (9,0) {$2$};\n\n\\path[draw,thick,->] (1) -- (2);\n\\path[draw,thick,->] (2) -- (3);\n\\path[draw,thick,->] (3) -- (4);\n\\path[draw,thick,->] (4) -- (5);\n\\path[draw,thick,->] (5) -- (6);\n\\path[draw,thick,->] (6) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nA straightforward way to calculate a value of $\\texttt{succ}(x,k)$\nis to start at node $x$ and walk $k$ steps forward, which takes $O(k)$ time.\nHowever, using preprocessing, any value of $\\texttt{succ}(x,k)$\ncan be calculated in only $O(\\log k)$ time.\n\nThe idea is to precalculate all values of $\\texttt{succ}(x,k)$ where\n$k$ is a power of two and at most $u$, where $u$ is\nthe maximum number of steps we will ever walk.\nThis can be efficiently done, because\nwe can use the following recursion:\n\n\\begin{equation*}\n    \\texttt{succ}(x,k) = \\begin{cases}\n               \\texttt{succ}(x)              & k = 1\\\\\n               \\texttt{succ}(\\texttt{succ}(x,k/2),k/2)   & k > 1\\\\\n           \\end{cases}\n\\end{equation*}\n\nPrecalculating the values takes $O(n \\log u)$ time,\nbecause $O(\\log u)$ values are calculated for each node.\nIn the above graph, the first values are as follows:\n\n\\begin{center}\n\\begin{tabular}{r|rrrrrrrrr}\n$x$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n\\hline\n$\\texttt{succ}(x,1)$ & 3 & 5 & 7 & 6 & 2 & 2 & 1 & 6 & 3 \\\\\n$\\texttt{succ}(x,2)$ & 7 & 2 & 1 & 2 & 5 & 5 & 3 & 2 & 7 \\\\\n$\\texttt{succ}(x,4)$ & 3 & 2 & 7 & 2 & 5 & 5 & 1 & 2 & 3 \\\\\n$\\texttt{succ}(x,8)$ & 7 & 2 & 1 & 2 & 5 & 5 & 3 & 2 & 7 \\\\\n$\\cdots$ \\\\\n\\end{tabular}\n\\end{center}\n\nAfter this, any value of $\\texttt{succ}(x,k)$ can be calculated\nby presenting the number of steps $k$ as a sum of powers of two.\nFor example, if we want to calculate the value of $\\texttt{succ}(x,11)$,\nwe first form the representation $11=8+2+1$.\nUsing that,\n\\[\\texttt{succ}(x,11)=\\texttt{succ}(\\texttt{succ}(\\texttt{succ}(x,8),2),1).\\]\nFor example, in the previous graph\n\\[\\texttt{succ}(4,11)=\\texttt{succ}(\\texttt{succ}(\\texttt{succ}(4,8),2),1)=5.\\]\n\nSuch a representation always consists of\n$O(\\log k)$ parts, so calculating a value of $\\texttt{succ}(x,k)$\ntakes $O(\\log k)$ time.\n\n", "chapter_name": "Directed graphs", "chapter_path": "cphb/chapter16.tex"}, {"section_name": "Cycle detection", "section_content": "\\section{Cycle detection}\n\n\\index{cycle}\n\\index{cycle detection}\n\nConsider a successor graph that only contains\na path that ends in a cycle.\nWe may ask the following questions:\nif we begin our walk at the starting node,\nwhat is the first node in the cycle\nand how many nodes does the cycle contain?\n\nFor example, in the graph\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (5) at (0,0) {$5$};\n\\node[draw, circle] (4) at (-2,0) {$4$};\n\\node[draw, circle] (6) at (-1,1.5) {$6$};\n\\node[draw, circle] (3) at (-4,0) {$3$};\n\\node[draw, circle] (2) at (-6,0) {$2$};\n\\node[draw, circle] (1) at (-8,0) {$1$};\n\n\\path[draw,thick,->] (1) -- (2);\n\\path[draw,thick,->] (2) -- (3);\n\\path[draw,thick,->] (3) -- (4);\n\\path[draw,thick,->] (4) -- (5);\n\\path[draw,thick,->] (5) -- (6);\n\\path[draw,thick,->] (6) -- (4);\n\\end{tikzpicture}\n\\end{center}\nwe begin our walk at node 1,\nthe first node that belongs to the cycle is node 4, and the cycle consists\nof three nodes (4, 5 and 6).\n\nA simple way to detect the cycle is to walk in the\ngraph and keep track of\nall nodes that have been visited. Once a node is visited\nfor the second time, we can conclude\nthat the node is the first node in the cycle.\nThis method works in $O(n)$ time and also uses\n$O(n)$ memory.\n\nHowever, there are better algorithms for cycle detection.\nThe time complexity of such algorithms is still $O(n)$,\nbut they only use $O(1)$ memory.\nThis is an important improvement if $n$ is large.\nNext we will discuss Floyd's algorithm that\nachieves these properties.\n\n\\subsubsection{Floyd's algorithm}\n\n\\index{Floyd's algorithm}\n\n\\key{Floyd's algorithm}\\footnote{The idea of the algorithm is mentioned in \\cite{knu982}\nand attributed to R. W. Floyd; however, it is not known if Floyd actually\ndiscovered the algorithm.} walks forward \nin the graph using two pointers $a$ and $b$.\nBoth pointers begin at a node $x$ that\nis the starting node of the graph.\nThen, on each turn, the pointer $a$ walks\none step forward and the pointer $b$\nwalks two steps forward.\nThe process continues until\nthe pointers meet each other:\n\\begin{lstlisting}\na = succ(x);\nb = succ(succ(x));\nwhile (a != b) {\n    a = succ(a);\n    b = succ(succ(b));\n}\n\\end{lstlisting}\n\nAt this point, the pointer $a$ has walked $k$ steps\nand the pointer $b$ has walked $2k$ steps,\nso the length of the cycle divides $k$.\nThus, the first node that belongs to the cycle\ncan be found by moving the pointer $a$ to node $x$\nand advancing the pointers\nstep by step until they meet again.\n\\begin{lstlisting}\na = x;\nwhile (a != b) {\n    a = succ(a);\n    b = succ(b);\n}\nfirst = a;\n\\end{lstlisting}\n\nAfter this, the length of the cycle\ncan be calculated as follows:\n\\begin{lstlisting}\nb = succ(a);\nlength = 1;\nwhile (a != b) {\n    b = succ(b);\n    length++;\n}\n\\end{lstlisting}\n", "chapter_name": "Directed graphs", "chapter_path": "cphb/chapter16.tex"}, {"section_name": "Kosaraju's algorithm", "section_content": "\\chapter{Strong connectivity}\n\n\\index{strongly connected graph}\n\nIn a directed graph,\nthe edges can be traversed in one direction only,\nso even if the graph is connected,\nthis does not guarantee that there would be\na path from a node to another node.\nFor this reason, it is meaningful to define a new concept\nthat requires more than connectivity.\n\nA graph is \\key{strongly connected}\nif there is a path from any node to all\nother nodes in the graph.\nFor example, in the following picture,\nthe left graph is strongly connected\nwhile the right graph is not.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,1) {$1$};\n\\node[draw, circle] (2) at (3,1) {$2$};\n\\node[draw, circle] (3) at (1,-1) {$3$};\n\\node[draw, circle] (4) at (3,-1) {$4$};\n\n\\path[draw,thick,->] (1) -- (2);\n\\path[draw,thick,->] (2) -- (4);\n\\path[draw,thick,->] (4) -- (3);\n\\path[draw,thick,->] (3) -- (1);\n\n\\node[draw, circle] (1b) at (6,1) {$1$};\n\\node[draw, circle] (2b) at (8,1) {$2$};\n\\node[draw, circle] (3b) at (6,-1) {$3$};\n\\node[draw, circle] (4b) at (8,-1) {$4$};\n\n\\path[draw,thick,->] (1b) -- (2b);\n\\path[draw,thick,->] (2b) -- (4b);\n\\path[draw,thick,->] (4b) -- (3b);\n\\path[draw,thick,->] (1b) -- (3b);\n\\end{tikzpicture}\n\\end{center}\n\nThe right graph is not strongly connected\nbecause, for example, there is no path\nfrom node 2 to node 1.\n\n\\index{strongly connected component}\n\\index{component graph}\n\nThe \\key{strongly connected components}\nof a graph divide the graph into strongly connected\nparts that are as large as possible.\nThe strongly connected components form an\nacyclic \\key{component graph} that represents\nthe deep structure of the original graph.\n\nFor example, for the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (-1,1) {$7$};\n\\node[draw, circle] (2) at (-3,2) {$3$};\n\\node[draw, circle] (4) at (-5,2) {$2$};\n\\node[draw, circle] (6) at (-7,2) {$1$};\n\\node[draw, circle] (3) at (-3,0) {$6$};\n\\node[draw, circle] (5) at (-5,0) {$5$};\n\\node[draw, circle] (7) at (-7,0) {$4$};\n\n\\path[draw,thick,->] (2) -- (1);\n\\path[draw,thick,->] (1) -- (3);\n\\path[draw,thick,->] (3) -- (2);\n\\path[draw,thick,->] (2) -- (4);\n\\path[draw,thick,->] (3) -- (5);\n\\path[draw,thick,->] (4) edge [bend left] (6);\n\\path[draw,thick,->] (6) edge [bend left] (4);\n\\path[draw,thick,->] (4) -- (5);\n\\path[draw,thick,->] (5) -- (7);\n\\path[draw,thick,->] (6) -- (7);\n\\end{tikzpicture}\n\\end{center}\nthe strongly connected components are as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (-1,1) {$7$};\n\\node[draw, circle] (2) at (-3,2) {$3$};\n\\node[draw, circle] (4) at (-5,2) {$2$};\n\\node[draw, circle] (6) at (-7,2) {$1$};\n\\node[draw, circle] (3) at (-3,0) {$6$};\n\\node[draw, circle] (5) at (-5,0) {$5$};\n\\node[draw, circle] (7) at (-7,0) {$4$};\n\n\\path[draw,thick,->] (2) -- (1);\n\\path[draw,thick,->] (1) -- (3);\n\\path[draw,thick,->] (3) -- (2);\n\\path[draw,thick,->] (2) -- (4);\n\\path[draw,thick,->] (3) -- (5);\n\\path[draw,thick,->] (4) edge [bend left] (6);\n\\path[draw,thick,->] (6) edge [bend left] (4);\n\\path[draw,thick,->] (4) -- (5);\n\\path[draw,thick,->] (5) -- (7);\n\\path[draw,thick,->] (6) -- (7);\n\n\\draw [red,thick,dashed,line width=2pt] (-0.5,2.5) rectangle (-3.5,-0.5);\n\\draw [red,thick,dashed,line width=2pt] (-4.5,2.5) rectangle (-7.5,1.5);\n\\draw [red,thick,dashed,line width=2pt] (-4.5,0.5) rectangle (-5.5,-0.5);\n\\draw [red,thick,dashed,line width=2pt] (-6.5,0.5) rectangle (-7.5,-0.5);\n\\end{tikzpicture}\n\\end{center}\nThe corresponding component graph is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (-3,1) {$B$};\n\\node[draw, circle] (2) at (-6,2) {$A$};\n\\node[draw, circle] (3) at (-5,0) {$D$};\n\\node[draw, circle] (4) at (-7,0) {$C$};\n\n\\path[draw,thick,->] (1) -- (2);\n\\path[draw,thick,->] (1) -- (3);\n\\path[draw,thick,->] (2) -- (3);\n\\path[draw,thick,->] (2) -- (4);\n\\path[draw,thick,->] (3) -- (4);\n\\end{tikzpicture}\n\\end{center}\nThe components are $A=\\{1,2\\}$,\n$B=\\{3,6,7\\}$, $C=\\{4\\}$ and $D=\\{5\\}$.\n\nA component graph is an acyclic, directed graph,\nso it is easier to process than the original graph.\nSince the graph does not contain cycles,\nwe can always construct a topological sort and\nuse dynamic programming techniques like those\npresented in Chapter 16.\n\n\\section{Kosaraju's algorithm}\n\n\\index{Kosaraju's algorithm}\n\n\\key{Kosaraju's algorithm}\\footnote{According to \\cite{aho83},\nS. R. Kosaraju invented this algorithm in 1978\nbut did not publish it. In 1981, the same algorithm was rediscovered\nand published by M. Sharir \\cite{sha81}.} is an efficient\nmethod for finding the strongly connected components\nof a directed graph.\nThe algorithm performs two depth-first searches:\nthe first search constructs a list of nodes\naccording to the structure of the graph,\nand the second search forms the strongly connected components.\n\n\\subsubsection{Search 1}\n\nThe first phase of Kosaraju's algorithm constructs\na list of nodes in the order in which a\ndepth-first search processes them.\nThe algorithm goes through the nodes,\nand begins a depth-first search at each \nunprocessed node.\nEach node will be added to the list\nafter it has been processed.\n\nIn the example graph, the nodes are processed\nin the following order:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (-1,1) {$7$};\n\\node[draw, circle] (2) at (-3,2) {$3$};\n\\node[draw, circle] (4) at (-5,2) {$2$};\n\\node[draw, circle] (6) at (-7,2) {$1$};\n\\node[draw, circle] (3) at (-3,0) {$6$};\n\\node[draw, circle] (5) at (-5,0) {$5$};\n\\node[draw, circle] (7) at (-7,0) {$4$};\n\n\\node at (-7,2.75) {$1/8$};\n\\node at (-5,2.75) {$2/7$};\n\\node at (-3,2.75) {$9/14$};\n\\node at (-7,-0.75) {$4/5$};\n\\node at (-5,-0.75) {$3/6$};\n\\node at (-3,-0.75) {$11/12$};\n\\node at (-1,1.75) {$10/13$};\n\n\\path[draw,thick,->] (2) -- (1);\n\\path[draw,thick,->] (1) -- (3);\n\\path[draw,thick,->] (3) -- (2);\n\\path[draw,thick,->] (2) -- (4);\n\\path[draw,thick,->] (3) -- (5);\n\\path[draw,thick,->] (4) edge [bend left] (6);\n\\path[draw,thick,->] (6) edge [bend left] (4);\n\\path[draw,thick,->] (4) -- (5);\n\\path[draw,thick,->] (5) -- (7);\n\\path[draw,thick,->] (6) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nThe notation $x/y$ means that\nprocessing the node started\nat time $x$ and finished at time $y$.\nThus, the corresponding list is as follows:\n\n\\begin{tabular}{ll}\n\\\\\nnode & processing time \\\\\n\\hline\n4 & 5 \\\\\n5 & 6 \\\\\n2 & 7 \\\\\n1 & 8 \\\\\n6 & 12 \\\\\n7 & 13 \\\\\n3 & 14 \\\\\n\\\\\n\\end{tabular}\n% \n% In the second phase of the algorithm,\n% the nodes will be processed\n% in reverse order: $[3,7,6,1,2,5,4]$.\n\n\\subsubsection{Search 2}\n\nThe second phase of the algorithm\nforms the strongly connected components\nof the graph.\nFirst, the algorithm reverses every\nedge in the graph.\nThis guarantees that during the second search,\nwe will always find strongly connected\ncomponents that do not have extra nodes.\n\nAfter reversing the edges,\nthe example graph is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (-1,1) {$7$};\n\\node[draw, circle] (2) at (-3,2) {$3$};\n\\node[draw, circle] (4) at (-5,2) {$2$};\n\\node[draw, circle] (6) at (-7,2) {$1$};\n\\node[draw, circle] (3) at (-3,0) {$6$};\n\\node[draw, circle] (5) at (-5,0) {$5$};\n\\node[draw, circle] (7) at (-7,0) {$4$};\n\n\\path[draw,thick,<-] (2) -- (1);\n\\path[draw,thick,<-] (1) -- (3);\n\\path[draw,thick,<-] (3) -- (2);\n\\path[draw,thick,<-] (2) -- (4);\n\\path[draw,thick,<-] (3) -- (5);\n\\path[draw,thick,<-] (4) edge [bend left] (6);\n\\path[draw,thick,<-] (6) edge [bend left] (4);\n\\path[draw,thick,<-] (4) -- (5);\n\\path[draw,thick,<-] (5) -- (7);\n\\path[draw,thick,<-] (6) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nAfter this, the algorithm goes through\nthe list of nodes created by the first search,\nin \\emph{reverse} order.\nIf a node does not belong to a component,\nthe algorithm creates a new component\nand starts a depth-first search\nthat adds all new nodes found during the search\nto the new component.\n\nIn the example graph, the first component\nbegins at node 3:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (-1,1) {$7$};\n\\node[draw, circle] (2) at (-3,2) {$3$};\n\\node[draw, circle] (4) at (-5,2) {$2$};\n\\node[draw, circle] (6) at (-7,2) {$1$};\n\\node[draw, circle] (3) at (-3,0) {$6$};\n\\node[draw, circle] (5) at (-5,0) {$5$};\n\\node[draw, circle] (7) at (-7,0) {$4$};\n\n\\path[draw,thick,<-] (2) -- (1);\n\\path[draw,thick,<-] (1) -- (3);\n\\path[draw,thick,<-] (3) -- (2);\n\\path[draw,thick,<-] (2) -- (4);\n\\path[draw,thick,<-] (3) -- (5);\n\\path[draw,thick,<-] (4) edge [bend left] (6);\n\\path[draw,thick,<-] (6) edge [bend left] (4);\n\\path[draw,thick,<-] (4) -- (5);\n\\path[draw,thick,<-] (5) -- (7);\n\\path[draw,thick,<-] (6) -- (7);\n\n\\draw [red,thick,dashed,line width=2pt] (-0.5,2.5) rectangle (-3.5,-0.5);\n\\end{tikzpicture}\n\\end{center}\n\nNote that since all edges are reversed,\nthe component does not ''leak'' to other parts in the graph.\n\n\\begin{samepage}\nThe next nodes in the list are nodes 7 and 6,\nbut they already belong to a component,\nso the next new component begins at node 1:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (-1,1) {$7$};\n\\node[draw, circle] (2) at (-3,2) {$3$};\n\\node[draw, circle] (4) at (-5,2) {$2$};\n\\node[draw, circle] (6) at (-7,2) {$1$};\n\\node[draw, circle] (3) at (-3,0) {$6$};\n\\node[draw, circle] (5) at (-5,0) {$5$};\n\\node[draw, circle] (7) at (-7,0) {$4$};\n\n\\path[draw,thick,<-] (2) -- (1);\n\\path[draw,thick,<-] (1) -- (3);\n\\path[draw,thick,<-] (3) -- (2);\n\\path[draw,thick,<-] (2) -- (4);\n\\path[draw,thick,<-] (3) -- (5);\n\\path[draw,thick,<-] (4) edge [bend left] (6);\n\\path[draw,thick,<-] (6) edge [bend left] (4);\n\\path[draw,thick,<-] (4) -- (5);\n\\path[draw,thick,<-] (5) -- (7);\n\\path[draw,thick,<-] (6) -- (7);\n\n\\draw [red,thick,dashed,line width=2pt] (-0.5,2.5) rectangle (-3.5,-0.5);\n\\draw [red,thick,dashed,line width=2pt] (-4.5,2.5) rectangle (-7.5,1.5);\n%\\draw [red,thick,dashed,line width=2pt] (-4.5,0.5) rectangle (-5.5,-0.5);\n%\\draw [red,thick,dashed,line width=2pt] (-6.5,0.5) rectangle (-7.5,-0.5);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\n\\begin{samepage}\nFinally, the algorithm processes nodes 5 and 4\nthat create the remaining strongly connected components:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (-1,1) {$7$};\n\\node[draw, circle] (2) at (-3,2) {$3$};\n\\node[draw, circle] (4) at (-5,2) {$2$};\n\\node[draw, circle] (6) at (-7,2) {$1$};\n\\node[draw, circle] (3) at (-3,0) {$6$};\n\\node[draw, circle] (5) at (-5,0) {$5$};\n\\node[draw, circle] (7) at (-7,0) {$4$};\n\n\\path[draw,thick,<-] (2) -- (1);\n\\path[draw,thick,<-] (1) -- (3);\n\\path[draw,thick,<-] (3) -- (2);\n\\path[draw,thick,<-] (2) -- (4);\n\\path[draw,thick,<-] (3) -- (5);\n\\path[draw,thick,<-] (4) edge [bend left] (6);\n\\path[draw,thick,<-] (6) edge [bend left] (4);\n\\path[draw,thick,<-] (4) -- (5);\n\\path[draw,thick,<-] (5) -- (7);\n\\path[draw,thick,<-] (6) -- (7);\n\n\\draw [red,thick,dashed,line width=2pt] (-0.5,2.5) rectangle (-3.5,-0.5);\n\\draw [red,thick,dashed,line width=2pt] (-4.5,2.5) rectangle (-7.5,1.5);\n\\draw [red,thick,dashed,line width=2pt] (-4.5,0.5) rectangle (-5.5,-0.5);\n\\draw [red,thick,dashed,line width=2pt] (-6.5,0.5) rectangle (-7.5,-0.5);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\nThe time complexity of the algorithm is $O(n+m)$,\nbecause the algorithm\nperforms two depth-first searches.\n\n", "chapter_name": "Strong connectivity", "chapter_path": "cphb/chapter17.tex"}, {"section_name": "2SAT problem", "section_content": "\\section{2SAT problem}\n\n\\index{2SAT problem}\n\nStrong connectivity is also linked with the\n\\key{2SAT problem}\\footnote{The algorithm presented here was\nintroduced in \\cite{asp79}.\nThere is also another well-known linear-time algorithm \\cite{eve75}\nthat is based on backtracking.}.\nIn this problem, we are given a logical formula\n\\[\n(a_1 \\lor b_1) \\land (a_2 \\lor b_2) \\land \\cdots \\land (a_m \\lor b_m),\n\\]\nwhere each $a_i$ and $b_i$ is either a logical variable\n($x_1,x_2,\\ldots,x_n$)\nor a negation of a logical variable\n($\\lnot x_1, \\lnot x_2, \\ldots, \\lnot x_n$).\nThe symbols ''$\\land$'' and ''$\\lor$'' denote\nlogical operators ''and'' and ''or''.\nOur task is to assign each variable a value\nso that the formula is true, or state\nthat this is not possible.\n\nFor example, the formula\n\\[\nL_1 = (x_2 \\lor \\lnot x_1) \\land\n      (\\lnot x_1 \\lor \\lnot x_2) \\land\n      (x_1 \\lor x_3) \\land\n      (\\lnot x_2 \\lor \\lnot x_3) \\land\n      (x_1 \\lor x_4)\n\\]\nis true when the variables are assigned as follows:\n\n\\[\n\\begin{cases}\nx_1 = \\textrm{false} \\\\\nx_2 = \\textrm{false} \\\\\nx_3 = \\textrm{true} \\\\\nx_4 = \\textrm{true} \\\\\n\\end{cases}\n\\]\n\nHowever, the formula\n\\[\nL_2 = (x_1 \\lor x_2) \\land\n      (x_1 \\lor \\lnot x_2) \\land\n      (\\lnot x_1 \\lor x_3) \\land\n      (\\lnot x_1 \\lor \\lnot x_3)\n\\]\nis always false, regardless of how we\nassign the values.\nThe reason for this is that we cannot\nchoose a value for $x_1$\nwithout creating a contradiction.\nIf $x_1$ is false, both $x_2$ and $\\lnot x_2$\nshould be true which is impossible,\nand if $x_1$ is true, both $x_3$ and $\\lnot x_3$\nshould be true which is also impossible.\n\nThe 2SAT problem can be represented as a graph\nwhose nodes correspond to\nvariables $x_i$ and negations $\\lnot x_i$,\nand edges determine the connections\nbetween the variables.\nEach pair $(a_i \\lor b_i)$ generates two edges:\n$\\lnot a_i \\to b_i$ and $\\lnot b_i \\to a_i$.\nThis means that if $a_i$ does not hold,\n$b_i$ must hold, and vice versa.\n\nThe graph for the formula $L_1$ is:\n\\\\\n\\begin{center}\n\\begin{tikzpicture}[scale=1.0,minimum size=2pt]\n\\node[draw, circle, inner sep=1.3pt] (1) at (1,2) {$\\lnot x_3$};\n\\node[draw, circle] (2) at (3,2) {$x_2$};\n\\node[draw, circle, inner sep=1.3pt] (3) at (1,0) {$\\lnot x_4$};\n\\node[draw, circle] (4) at (3,0) {$x_1$};\n\\node[draw, circle, inner sep=1.3pt] (5) at (5,2) {$\\lnot x_1$};\n\\node[draw, circle] (6) at (7,2) {$x_4$};\n\\node[draw, circle, inner sep=1.3pt] (7) at (5,0) {$\\lnot x_2$};\n\\node[draw, circle] (8) at (7,0) {$x_3$};\n \n\\path[draw,thick,->] (1) -- (4);\n\\path[draw,thick,->] (4) -- (2);\n\\path[draw,thick,->] (2) -- (1);\n\\path[draw,thick,->] (3) -- (4);\n\\path[draw,thick,->] (2) -- (5);\n\\path[draw,thick,->] (4) -- (7);\n\\path[draw,thick,->] (5) -- (6);\n\\path[draw,thick,->] (5) -- (8);\n\\path[draw,thick,->] (8) -- (7);\n\\path[draw,thick,->] (7) -- (5);\n\\end{tikzpicture}\n\\end{center}\nAnd the graph for the formula $L_2$ is:\n\\\\\n\\begin{center}\n\\begin{tikzpicture}[scale=1.0,minimum size=2pt]\n\\node[draw, circle] (1) at (1,2) {$x_3$};\n\\node[draw, circle] (2) at (3,2) {$x_2$};\n\\node[draw, circle, inner sep=1.3pt] (3) at (5,2) {$\\lnot x_2$};\n\\node[draw, circle, inner sep=1.3pt] (4) at (7,2) {$\\lnot x_3$};\n\\node[draw, circle, inner sep=1.3pt] (5) at (4,3.5) {$\\lnot x_1$};\n\\node[draw, circle] (6) at (4,0.5) {$x_1$};\n\n\\path[draw,thick,->] (1) -- (5);\n\\path[draw,thick,->] (4) -- (5);\n\\path[draw,thick,->] (6) -- (1);\n\\path[draw,thick,->] (6) -- (4);\n\\path[draw,thick,->] (5) -- (2);\n\\path[draw,thick,->] (5) -- (3);\n\\path[draw,thick,->] (2) -- (6);\n\\path[draw,thick,->] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nThe structure of the graph tells us whether\nit is possible to assign the values\nof the variables so\nthat the formula is true.\nIt turns out that this can be done\nexactly when there are no nodes\n$x_i$ and $\\lnot x_i$ such that\nboth nodes belong to the\nsame strongly connected component.\nIf there are such nodes,\nthe graph contains\na path from $x_i$ to $\\lnot x_i$\nand also a path from $\\lnot x_i$ to $x_i$,\nso both $x_i$ and $\\lnot x_i$ should be true\nwhich is not possible.\n\nIn the graph of the formula $L_1$\nthere are no nodes $x_i$ and $\\lnot x_i$\nsuch that both nodes \nbelong to the same strongly connected component,\nso a solution exists.\nIn the graph of the formula $L_2$\nall nodes belong to the same strongly connected component,\nso a solution does not exist.\n\nIf a solution exists, the values for the variables\ncan be found by going through the nodes of the\ncomponent graph in a reverse topological sort order.\nAt each step, we process a component \nthat does not contain edges that lead to an\nunprocessed component.\nIf the variables in the component\nhave not been assigned values,\ntheir values will be determined\naccording to the values in the component,\nand if they already have values,\nthey remain unchanged.\nThe process continues until each variable\nhas been assigned a value.\n\nThe component graph for the formula $L_1$ is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=1.0]\n\\node[draw, circle] (1) at (0,0) {$A$};\n\\node[draw, circle] (2) at (2,0) {$B$};\n\\node[draw, circle] (3) at (4,0) {$C$};\n\\node[draw, circle] (4) at (6,0) {$D$};\n\n\\path[draw,thick,->] (1) -- (2);\n\\path[draw,thick,->] (2) -- (3);\n\\path[draw,thick,->] (3) -- (4);\n\\end{tikzpicture}\n\\end{center}\n\nThe components are\n$A = \\{\\lnot x_4\\}$,\n$B = \\{x_1, x_2, \\lnot x_3\\}$,\n$C = \\{\\lnot x_1, \\lnot x_2, x_3\\}$ and\n$D = \\{x_4\\}$.\nWhen constructing the solution,\nwe first process the component $D$\nwhere $x_4$ becomes true.\nAfter this, we process the component $C$\nwhere $x_1$ and $x_2$ become false\nand $x_3$ becomes true.\nAll variables have been assigned values,\nso the remaining components $A$ and $B$\ndo not change the variables.\n\nNote that this method works, because the\ngraph has a special structure:\nif there are paths from node $x_i$ to node $x_j$\nand from node $x_j$ to node $\\lnot x_j$,\nthen node $x_i$ never becomes true.\nThe reason for this is that there is also\na path from node $\\lnot x_j$ to node $\\lnot x_i$,\nand both $x_i$ and $x_j$ become false.\n\n\\index{3SAT problem}\n\nA more difficult problem is the \\key{3SAT problem},\nwhere each part of the formula is of the form\n$(a_i \\lor b_i \\lor c_i)$.\nThis problem is NP-hard, so no efficient algorithm\nfor solving the problem is known.\n", "chapter_name": "Strong connectivity", "chapter_path": "cphb/chapter17.tex"}, {"section_name": "Finding ancestors", "section_content": "\\chapter{Tree queries}\n\n\\index{tree query}\n\nThis chapter discusses techniques for\nprocessing queries on\nsubtrees and paths of a rooted tree.\nFor example, such queries are:\n\n\\begin{itemize}\n\\item what is the $k$th ancestor of a node?\n\\item what is the sum of values in the subtree of a node?\n\\item what is the sum of values on a path between two nodes?\n\\item what is the lowest common ancestor of two nodes?\n\\end{itemize}\n\n\\section{Finding ancestors}\n\n\\index{ancestor}\n\nThe $k$th \\key{ancestor} of a node $x$ in a rooted tree\nis the node that we will reach if we move $k$\nlevels up from $x$.\nLet $\\texttt{ancestor}(x,k)$ denote the $k$th ancestor of a node $x$\n(or $0$ if there is no such an ancestor).\nFor example, in the following tree,\n$\\texttt{ancestor}(2,1)=1$ and $\\texttt{ancestor}(8,2)=4$.\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$2$};\n\\node[draw, circle] (3) at (-2,1) {$4$};\n\\node[draw, circle] (4) at (0,1) {$5$};\n\\node[draw, circle] (5) at (2,-1) {$6$};\n\\node[draw, circle] (6) at (-3,-1) {$3$};\n\\node[draw, circle] (7) at (-1,-1) {$7$};\n\\node[draw, circle] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\path[draw,thick,-] (7) -- (8);\n\n\\path[draw=red,thick,->,line width=2pt] (8) edge [bend left] (3);\n\\path[draw=red,thick,->,line width=2pt] (2) edge [bend right] (1);\n\\end{tikzpicture}\n\\end{center}\n\nAn easy way to calculate any value of $\\texttt{ancestor}(x,k)$\nis to perform a sequence of $k$ moves in the tree.\nHowever, the time complexity of this method\nis $O(k)$, which may be slow, because a tree of $n$\nnodes may have a chain of $n$ nodes.\n\nFortunately, using a technique similar to that\nused in Chapter 16.3, any value of $\\texttt{ancestor}(x,k)$\ncan be efficiently calculated in $O(\\log k)$ time\nafter preprocessing.\nThe idea is to precalculate all values $\\texttt{ancestor}(x,k)$\nwhere $k \\le n$ is a power of two.\nFor example, the values for the above tree\nare as follows:\n\n\\begin{center}\n\\begin{tabular}{r|rrrrrrrrr}\n$x$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\\\\n\\hline\n$\\texttt{ancestor}(x,1)$ & 0 & 1 & 4 & 1 & 1 & 2 & 4 & 7 \\\\\n$\\texttt{ancestor}(x,2)$ & 0 & 0 & 1 & 0 & 0 & 1 & 1 & 4 \\\\\n$\\texttt{ancestor}(x,4)$ & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n$\\cdots$ \\\\\n\\end{tabular}\n\\end{center}\n\nThe preprocessing takes $O(n \\log n)$ time,\nbecause $O(\\log n)$ values are calculated for each node.\nAfter this, any value of $\\texttt{ancestor}(x,k)$ can be calculated\nin $O(\\log k)$ time by representing $k$\nas a sum where each term is a power of two.\n\n", "chapter_name": "Tree queries", "chapter_path": "cphb/chapter18.tex"}, {"section_name": "Subtrees and paths", "section_content": "\\section{Subtrees and paths}\n\n\\index{tree traversal array}\n\nA \\key{tree traversal array} contains the nodes of a rooted tree\nin the order in which a depth-first search\nfrom the root node visits them.\nFor example, in the tree\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (-3,1) {$2$};\n\\node[draw, circle] (3) at (-1,1) {$3$};\n\\node[draw, circle] (4) at (1,1) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (-3,-1) {$6$};\n\\node[draw, circle] (7) at (-0.5,-1) {$7$};\n\\node[draw, circle] (8) at (1,-1) {$8$};\n\\node[draw, circle] (9) at (2.5,-1) {$9$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (4) -- (7);\n\\path[draw,thick,-] (4) -- (8);\n\\path[draw,thick,-] (4) -- (9);\n\\end{tikzpicture}\n\\end{center}\na depth-first search proceeds as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (-3,1) {$2$};\n\\node[draw, circle] (3) at (-1,1) {$3$};\n\\node[draw, circle] (4) at (1,1) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (-3,-1) {$6$};\n\\node[draw, circle] (7) at (-0.5,-1) {$7$};\n\\node[draw, circle] (8) at (1,-1) {$8$};\n\\node[draw, circle] (9) at (2.5,-1) {$9$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (4) -- (7);\n\\path[draw,thick,-] (4) -- (8);\n\\path[draw,thick,-] (4) -- (9);\n\n\n\\path[draw=red,thick,->,line width=2pt] (1) edge [bend right=15] (2);\n\\path[draw=red,thick,->,line width=2pt] (2) edge [bend right=15] (6);\n\\path[draw=red,thick,->,line width=2pt] (6) edge [bend right=15] (2);\n\\path[draw=red,thick,->,line width=2pt] (2) edge [bend right=15] (1);\n\\path[draw=red,thick,->,line width=2pt] (1) edge [bend right=15] (3);\n\\path[draw=red,thick,->,line width=2pt] (3) edge [bend right=15] (1);\n\\path[draw=red,thick,->,line width=2pt] (1) edge [bend right=15] (4);\n\\path[draw=red,thick,->,line width=2pt] (4) edge [bend right=15] (7);\n\\path[draw=red,thick,->,line width=2pt] (7) edge [bend right=15] (4);\n\\path[draw=red,thick,->,line width=2pt] (4) edge [bend right=15] (8);\n\\path[draw=red,thick,->,line width=2pt] (8) edge [bend right=15] (4);\n\\path[draw=red,thick,->,line width=2pt] (4) edge [bend right=15] (9);\n\\path[draw=red,thick,->,line width=2pt] (9) edge [bend right=15] (4);\n\\path[draw=red,thick,->,line width=2pt] (4) edge [bend right=15] (1);\n\\path[draw=red,thick,->,line width=2pt] (1) edge [bend right=15] (5);\n\\path[draw=red,thick,->,line width=2pt] (5) edge [bend right=15] (1);\n\n\\end{tikzpicture}\n\\end{center}\nHence, the corresponding tree traversal array is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (9,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$6$};\n\\node at (3.5,0.5) {$3$};\n\\node at (4.5,0.5) {$4$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$9$};\n\\node at (8.5,0.5) {$5$};\n% \n% \\footnotesize\n% \\node at (0.5,1.4) {$1$};\n% \\node at (1.5,1.4) {$2$};\n% \\node at (2.5,1.4) {$3$};\n% \\node at (3.5,1.4) {$4$};\n% \\node at (4.5,1.4) {$5$};\n% \\node at (5.5,1.4) {$6$};\n% \\node at (6.5,1.4) {$7$};\n% \\node at (7.5,1.4) {$8$};\n% \\node at (8.5,1.4) {$9$};\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Subtree queries}\n\nEach subtree of a tree corresponds to a subarray\nof the tree traversal array such that\nthe first element of the subarray is the root node.\nFor example, the following subarray contains the\nnodes of the subtree of node $4$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (4,0) rectangle (8,1);\n\\draw (0,0) grid (9,1);\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$6$};\n\\node at (3.5,0.5) {$3$};\n\\node at (4.5,0.5) {$4$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$9$};\n\\node at (8.5,0.5) {$5$};\n% \n% \\footnotesize\n% \\node at (0.5,1.4) {$1$};\n% \\node at (1.5,1.4) {$2$};\n% \\node at (2.5,1.4) {$3$};\n% \\node at (3.5,1.4) {$4$};\n% \\node at (4.5,1.4) {$5$};\n% \\node at (5.5,1.4) {$6$};\n% \\node at (6.5,1.4) {$7$};\n% \\node at (7.5,1.4) {$8$};\n% \\node at (8.5,1.4) {$9$};\n\\end{tikzpicture}\n\\end{center}\nUsing this fact, we can efficiently process queries\nthat are related to subtrees of a tree.\nAs an example, consider a problem where each node\nis assigned a value, and our task is to support\nthe following queries:\n\\begin{itemize}\n\\item update the value of a node\n\\item calculate the sum of values in the subtree of a node\n\\end{itemize}\n\nConsider the following tree where the blue numbers\nare the values of the nodes.\nFor example, the sum of the subtree of node $4$\nis $3+4+3+1=11$.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (-3,1) {$2$};\n\\node[draw, circle] (3) at (-1,1) {$3$};\n\\node[draw, circle] (4) at (1,1) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (-3,-1) {$6$};\n\\node[draw, circle] (7) at (-0.5,-1) {$7$};\n\\node[draw, circle] (8) at (1,-1) {$8$};\n\\node[draw, circle] (9) at (2.5,-1) {$9$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (4) -- (7);\n\\path[draw,thick,-] (4) -- (8);\n\\path[draw,thick,-] (4) -- (9);\n\n\\node[color=blue] at (0,3+0.65) {2};\n\\node[color=blue] at (-3-0.65,1) {3};\n\\node[color=blue] at (-1-0.65,1) {5};\n\\node[color=blue] at (1+0.65,1) {3};\n\\node[color=blue] at (3+0.65,1) {1};\n\\node[color=blue] at (-3,-1-0.65) {4};\n\\node[color=blue] at (-0.5,-1-0.65) {4};\n\\node[color=blue] at (1,-1-0.65) {3};\n\\node[color=blue] at (2.5,-1-0.65) {1};\n\\end{tikzpicture}\n\\end{center}\n\nThe idea is to construct a tree traversal array that contains\nthree values for each node: the identifier of the node,\nthe size of the subtree, and the value of the node.\nFor example, the array for the above tree is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,1) grid (9,-2);\n\n\\node[left] at (-1,0.5) {node id};\n\\node[left] at (-1,-0.5) {subtree size};\n\\node[left] at (-1,-1.5) {node value};\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$6$};\n\\node at (3.5,0.5) {$3$};\n\\node at (4.5,0.5) {$4$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$9$};\n\\node at (8.5,0.5) {$5$};\n\n\\node at (0.5,-0.5) {$9$};\n\\node at (1.5,-0.5) {$2$};\n\\node at (2.5,-0.5) {$1$};\n\\node at (3.5,-0.5) {$1$};\n\\node at (4.5,-0.5) {$4$};\n\\node at (5.5,-0.5) {$1$};\n\\node at (6.5,-0.5) {$1$};\n\\node at (7.5,-0.5) {$1$};\n\\node at (8.5,-0.5) {$1$};\n\n\\node at (0.5,-1.5) {$2$};\n\\node at (1.5,-1.5) {$3$};\n\\node at (2.5,-1.5) {$4$};\n\\node at (3.5,-1.5) {$5$};\n\\node at (4.5,-1.5) {$3$};\n\\node at (5.5,-1.5) {$4$};\n\\node at (6.5,-1.5) {$3$};\n\\node at (7.5,-1.5) {$1$};\n\\node at (8.5,-1.5) {$1$};\n% \n% \\footnotesize\n% \\node at (0.5,1.4) {$1$};\n% \\node at (1.5,1.4) {$2$};\n% \\node at (2.5,1.4) {$3$};\n% \\node at (3.5,1.4) {$4$};\n% \\node at (4.5,1.4) {$5$};\n% \\node at (5.5,1.4) {$6$};\n% \\node at (6.5,1.4) {$7$};\n% \\node at (7.5,1.4) {$8$};\n% \\node at (8.5,1.4) {$9$};\n\\end{tikzpicture}\n\\end{center}\n\nUsing this array, we can calculate the sum of values\nin any subtree by first finding out the size of the subtree\nand then the values of the corresponding nodes.\nFor example, the values in the subtree of node $4$\ncan be found as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (4,1) rectangle (5,0);\n\\fill[color=lightgray] (4,0) rectangle (5,-1);\n\\fill[color=lightgray] (4,-1) rectangle (8,-2);\n\\draw (0,1) grid (9,-2);\n\n\\node[left] at (-1,0.5) {node id};\n\\node[left] at (-1,-0.5) {subtree size};\n\\node[left] at (-1,-1.5) {node value};\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$6$};\n\\node at (3.5,0.5) {$3$};\n\\node at (4.5,0.5) {$4$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$9$};\n\\node at (8.5,0.5) {$5$};\n\n\\node at (0.5,-0.5) {$9$};\n\\node at (1.5,-0.5) {$2$};\n\\node at (2.5,-0.5) {$1$};\n\\node at (3.5,-0.5) {$1$};\n\\node at (4.5,-0.5) {$4$};\n\\node at (5.5,-0.5) {$1$};\n\\node at (6.5,-0.5) {$1$};\n\\node at (7.5,-0.5) {$1$};\n\\node at (8.5,-0.5) {$1$};\n\n\\node at (0.5,-1.5) {$2$};\n\\node at (1.5,-1.5) {$3$};\n\\node at (2.5,-1.5) {$4$};\n\\node at (3.5,-1.5) {$5$};\n\\node at (4.5,-1.5) {$3$};\n\\node at (5.5,-1.5) {$4$};\n\\node at (6.5,-1.5) {$3$};\n\\node at (7.5,-1.5) {$1$};\n\\node at (8.5,-1.5) {$1$};\n% \n% \\footnotesize\n% \\node at (0.5,1.4) {$1$};\n% \\node at (1.5,1.4) {$2$};\n% \\node at (2.5,1.4) {$3$};\n% \\node at (3.5,1.4) {$4$};\n% \\node at (4.5,1.4) {$5$};\n% \\node at (5.5,1.4) {$6$};\n% \\node at (6.5,1.4) {$7$};\n% \\node at (7.5,1.4) {$8$};\n% \\node at (8.5,1.4) {$9$};\n\\end{tikzpicture}\n\\end{center}\n\nTo answer the queries efficiently,\nit suffices to store the values of the\nnodes in a binary indexed or segment tree.\nAfter this, we can both update a value\nand calculate the sum of values in $O(\\log n)$ time.\n\n\\subsubsection{Path queries}\n\nUsing a tree traversal array, we can also efficiently\ncalculate sums of values on\npaths from the root node to any\nnode of the tree.\nConsider a problem where our task\nis to support the following queries:\n\\begin{itemize}\n\\item change the value of a node\n\\item calculate the sum of values on a path from\nthe root to a node\n\\end{itemize}\n\nFor example, in the following tree,\nthe sum of values from the root node to node 7 is\n$4+5+5=14$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (-3,1) {$2$};\n\\node[draw, circle] (3) at (-1,1) {$3$};\n\\node[draw, circle] (4) at (1,1) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (-3,-1) {$6$};\n\\node[draw, circle] (7) at (-0.5,-1) {$7$};\n\\node[draw, circle] (8) at (1,-1) {$8$};\n\\node[draw, circle] (9) at (2.5,-1) {$9$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (4) -- (7);\n\\path[draw,thick,-] (4) -- (8);\n\\path[draw,thick,-] (4) -- (9);\n\n\\node[color=blue] at (0,3+0.65) {4};\n\\node[color=blue] at (-3-0.65,1) {5};\n\\node[color=blue] at (-1-0.65,1) {3};\n\\node[color=blue] at (1+0.65,1) {5};\n\\node[color=blue] at (3+0.65,1) {2};\n\\node[color=blue] at (-3,-1-0.65) {3};\n\\node[color=blue] at (-0.5,-1-0.65) {5};\n\\node[color=blue] at (1,-1-0.65) {3};\n\\node[color=blue] at (2.5,-1-0.65) {1};\n\\end{tikzpicture}\n\\end{center}\n\nWe can solve this problem like before,\nbut now each value in the last row of the array is the sum of values\non a path from the root to the node.\nFor example, the following array corresponds to the above tree:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,1) grid (9,-2);\n\n\\node[left] at (-1,0.5) {node id};\n\\node[left] at (-1,-0.5) {subtree size};\n\\node[left] at (-1,-1.5) {path sum};\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$6$};\n\\node at (3.5,0.5) {$3$};\n\\node at (4.5,0.5) {$4$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$9$};\n\\node at (8.5,0.5) {$5$};\n\n\\node at (0.5,-0.5) {$9$};\n\\node at (1.5,-0.5) {$2$};\n\\node at (2.5,-0.5) {$1$};\n\\node at (3.5,-0.5) {$1$};\n\\node at (4.5,-0.5) {$4$};\n\\node at (5.5,-0.5) {$1$};\n\\node at (6.5,-0.5) {$1$};\n\\node at (7.5,-0.5) {$1$};\n\\node at (8.5,-0.5) {$1$};\n\n\\node at (0.5,-1.5) {$4$};\n\\node at (1.5,-1.5) {$9$};\n\\node at (2.5,-1.5) {$12$};\n\\node at (3.5,-1.5) {$7$};\n\\node at (4.5,-1.5) {$9$};\n\\node at (5.5,-1.5) {$14$};\n\\node at (6.5,-1.5) {$12$};\n\\node at (7.5,-1.5) {$10$};\n\\node at (8.5,-1.5) {$6$};\n\\end{tikzpicture}\n\\end{center}\n\nWhen the value of a node increases by $x$,\nthe sums of all nodes in its subtree increase by $x$.\nFor example, if the value of node 4 increases by 1,\nthe array changes as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (4,-1) rectangle (8,-2);\n\\draw (0,1) grid (9,-2);\n\n\\node[left] at (-1,0.5) {node id};\n\\node[left] at (-1,-0.5) {subtree size};\n\\node[left] at (-1,-1.5) {path sum};\n\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$6$};\n\\node at (3.5,0.5) {$3$};\n\\node at (4.5,0.5) {$4$};\n\\node at (5.5,0.5) {$7$};\n\\node at (6.5,0.5) {$8$};\n\\node at (7.5,0.5) {$9$};\n\\node at (8.5,0.5) {$5$};\n\n\\node at (0.5,-0.5) {$9$};\n\\node at (1.5,-0.5) {$2$};\n\\node at (2.5,-0.5) {$1$};\n\\node at (3.5,-0.5) {$1$};\n\\node at (4.5,-0.5) {$4$};\n\\node at (5.5,-0.5) {$1$};\n\\node at (6.5,-0.5) {$1$};\n\\node at (7.5,-0.5) {$1$};\n\\node at (8.5,-0.5) {$1$};\n\n\\node at (0.5,-1.5) {$4$};\n\\node at (1.5,-1.5) {$9$};\n\\node at (2.5,-1.5) {$12$};\n\\node at (3.5,-1.5) {$7$};\n\\node at (4.5,-1.5) {$10$};\n\\node at (5.5,-1.5) {$15$};\n\\node at (6.5,-1.5) {$13$};\n\\node at (7.5,-1.5) {$11$};\n\\node at (8.5,-1.5) {$6$};\n\\end{tikzpicture}\n\\end{center}\n\nThus, to support both the operations,\nwe should be able to increase all values\nin a range and retrieve a single value.\nThis can be done in $O(\\log n)$ time\nusing a binary indexed\nor segment tree (see Chapter 9.4).\n\n", "chapter_name": "Tree queries", "chapter_path": "cphb/chapter18.tex"}, {"section_name": "Lowest common ancestor", "section_content": "\\section{Lowest common ancestor}\n\n\\index{lowest common ancestor}\n\nThe \\key{lowest common ancestor}\nof two nodes of a rooted tree is the lowest node\nwhose subtree contains both the nodes.\nA typical problem is to efficiently process\nqueries that ask to find the lowest\ncommon ancestor of two nodes.\n\nFor example, in the following tree,\nthe lowest common ancestor of nodes 5 and 8\nis node 2:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (5) at (2,-1) {$7$};\n\\node[draw, circle, fill=lightgray] (6) at (-3,-1) {$5$};\n\\node[draw, circle] (7) at (-1,-1) {$6$};\n\\node[draw, circle, fill=lightgray] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\path[draw,thick,-] (7) -- (8);\n\n\\path[draw=red,thick,->,line width=2pt] (6) edge [bend left] (3);\n\\path[draw=red,thick,->,line width=2pt] (8) edge [bend right=40] (3);\n\\end{tikzpicture}\n\\end{center}\n\nNext we will discuss two efficient techniques for\nfinding the lowest common ancestor of two nodes.\n\n\\subsubsection{Method 1}\n\nOne way to solve the problem is to use the fact\nthat we can efficiently find the $k$th\nancestor of any node in the tree.\nUsing this, we can divide the problem of\nfinding the lowest common ancestor into two parts.\n\nWe use two pointers that initially point to the\ntwo nodes whose lowest common ancestor we should find.\nFirst, we move one of the pointers upwards\nso that both pointers point to nodes at the same level.\n\nIn the example scenario, we move the second pointer one\nlevel up so that it points to node 6\nwhich is at the same level with node 5:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (5) at (2,-1) {$7$};\n\\node[draw, circle,fill=lightgray] (6) at (-3,-1) {$5$};\n\\node[draw, circle,fill=lightgray] (7) at (-1,-1) {$6$};\n\\node[draw, circle] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\path[draw,thick,-] (7) -- (8);\n\n\\path[draw=red,thick,->,line width=2pt] (8) edge [bend right] (7);\n\\end{tikzpicture}\n\\end{center}\n\nAfter this, we determine the minimum number of steps\nneeded to move both pointers upwards so that\nthey will point to the same node.\nThe node to which the pointers point after this\nis the lowest common ancestor.\n\nIn the example scenario, it suffices to move both pointers\none step upwards to node 2,\nwhich is the lowest common ancestor:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle,fill=lightgray] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (5) at (2,-1) {$7$};\n\\node[draw, circle] (6) at (-3,-1) {$5$};\n\\node[draw, circle] (7) at (-1,-1) {$6$};\n\\node[draw, circle] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\path[draw,thick,-] (7) -- (8);\n\n\\path[draw=red,thick,->,line width=2pt] (6) edge [bend left] (3);\n\\path[draw=red,thick,->,line width=2pt] (7) edge [bend right] (3);\n\\end{tikzpicture}\n\\end{center}\n\nSince both parts of the algorithm can be performed in\n$O(\\log n)$ time using precomputed information,\nwe can find the lowest common ancestor of any two\nnodes in $O(\\log n)$ time.\n\n\\subsubsection{Method 2}\n\nAnother way to solve the problem is based on\na tree traversal array\\footnote{This lowest common ancestor algorithm was presented in \\cite{ben00}.\nThis technique is sometimes called the \\index{Euler tour technique}\n\\key{Euler tour technique} \\cite{tar84}.}.\nOnce again, the idea is to traverse the nodes\nusing a depth-first search:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (5) at (2,-1) {$7$};\n\\node[draw, circle] (6) at (-3,-1) {$5$};\n\\node[draw, circle] (7) at (-1,-1) {$6$};\n\\node[draw, circle] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\path[draw,thick,-] (7) -- (8);\n\n\\path[draw=red,thick,->,line width=2pt] (1) edge [bend right=15] (3);\n\\path[draw=red,thick,->,line width=2pt] (3) edge [bend right=15] (6);\n\\path[draw=red,thick,->,line width=2pt] (6) edge [bend right=15] (3);\n\\path[draw=red,thick,->,line width=2pt] (3) edge [bend right=15] (7);\n\\path[draw=red,thick,->,line width=2pt] (7) edge [bend right=15] (8);\n\\path[draw=red,thick,->,line width=2pt] (8) edge [bend right=15] (7);\n\\path[draw=red,thick,->,line width=2pt] (7) edge [bend right=15] (3);\n\\path[draw=red,thick,->,line width=2pt] (3) edge [bend right=15] (1);\n\\path[draw=red,thick,->,line width=2pt] (1) edge [bend right=15] (4);\n\\path[draw=red,thick,->,line width=2pt] (4) edge [bend right=15] (1);\n\\path[draw=red,thick,->,line width=2pt] (1) edge [bend right=15] (2);\n\\path[draw=red,thick,->,line width=2pt] (2) edge [bend right=15] (5);\n\\path[draw=red,thick,->,line width=2pt] (5) edge [bend right=15] (2);\n\\path[draw=red,thick,->,line width=2pt] (2) edge [bend right=15] (1);\n\\end{tikzpicture}\n\\end{center}\n\nHowever, we use a different tree\ntraversal array than before:\nwe add each node to the array \\emph{always}\nwhen the depth-first search walks through the node,\nand not only at the first visit.\nHence, a node that has $k$ children appears $k+1$ times\nin the array and there are a total of $2n-1$\nnodes in the array.\n\nWe store two values in the array:\nthe identifier of the node and the depth of the \nnode in the tree.\nThe following array corresponds to the above tree:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\n\\node[left] at (-1,1.5) {node id};\n\\node[left] at (-1,0.5) {depth};\n\n\\draw (0,1) grid (15,2);\n\\node at (0.5,1.5) {$1$};\n\\node at (1.5,1.5) {$2$};\n\\node at (2.5,1.5) {$5$};\n\\node at (3.5,1.5) {$2$};\n\\node at (4.5,1.5) {$6$};\n\\node at (5.5,1.5) {$8$};\n\\node at (6.5,1.5) {$6$};\n\\node at (7.5,1.5) {$2$};\n\\node at (8.5,1.5) {$1$};\n\\node at (9.5,1.5) {$3$};\n\\node at (10.5,1.5) {$1$};\n\\node at (11.5,1.5) {$4$};\n\\node at (12.5,1.5) {$7$};\n\\node at (13.5,1.5) {$4$};\n\\node at (14.5,1.5) {$1$};\n\n\\draw (0,0) grid (15,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$3$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$3$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$3$};\n\\node at (7.5,0.5) {$2$};\n\\node at (8.5,0.5) {$1$};\n\\node at (9.5,0.5) {$2$};\n\\node at (10.5,0.5) {$1$};\n\\node at (11.5,0.5) {$2$};\n\\node at (12.5,0.5) {$3$};\n\\node at (13.5,0.5) {$2$};\n\\node at (14.5,0.5) {$1$};\n\n\\footnotesize\n\\node at (0.5,2.5) {$0$};\n\\node at (1.5,2.5) {$1$};\n\\node at (2.5,2.5) {$2$};\n\\node at (3.5,2.5) {$3$};\n\\node at (4.5,2.5) {$4$};\n\\node at (5.5,2.5) {$5$};\n\\node at (6.5,2.5) {$6$};\n\\node at (7.5,2.5) {$7$};\n\\node at (8.5,2.5) {$8$};\n\\node at (9.5,2.5) {$9$};\n\\node at (10.5,2.5) {$10$};\n\\node at (11.5,2.5) {$11$};\n\\node at (12.5,2.5) {$12$};\n\\node at (13.5,2.5) {$13$};\n\\node at (14.5,2.5) {$14$};\n\\end{tikzpicture}\n\\end{center}\n\nNow we can find the lowest common ancestor\nof nodes $a$ and $b$ by finding the node with the \\emph{minimum} depth\nbetween nodes $a$ and $b$ in the array.\nFor example, the lowest common ancestor of nodes $5$ and $8$\ncan be found as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\n\\node[left] at (-1,1.5) {node id};\n\\node[left] at (-1,0.5) {depth};\n\n\\fill[color=lightgray] (2,1) rectangle (3,2);\n\\fill[color=lightgray] (5,1) rectangle (6,2);\n\\fill[color=lightgray] (2,0) rectangle (6,1);\n\n\\node at (3.5,-0.5) {$\\uparrow$};\n\n\\draw (0,1) grid (15,2);\n\\node at (0.5,1.5) {$1$};\n\\node at (1.5,1.5) {$2$};\n\\node at (2.5,1.5) {$5$};\n\\node at (3.5,1.5) {$2$};\n\\node at (4.5,1.5) {$6$};\n\\node at (5.5,1.5) {$8$};\n\\node at (6.5,1.5) {$6$};\n\\node at (7.5,1.5) {$2$};\n\\node at (8.5,1.5) {$1$};\n\\node at (9.5,1.5) {$3$};\n\\node at (10.5,1.5) {$1$};\n\\node at (11.5,1.5) {$4$};\n\\node at (12.5,1.5) {$7$};\n\\node at (13.5,1.5) {$4$};\n\\node at (14.5,1.5) {$1$};\n\n\n\\draw (0,0) grid (15,1);\n\\node at (0.5,0.5) {$1$};\n\\node at (1.5,0.5) {$2$};\n\\node at (2.5,0.5) {$3$};\n\\node at (3.5,0.5) {$2$};\n\\node at (4.5,0.5) {$3$};\n\\node at (5.5,0.5) {$4$};\n\\node at (6.5,0.5) {$3$};\n\\node at (7.5,0.5) {$2$};\n\\node at (8.5,0.5) {$1$};\n\\node at (9.5,0.5) {$2$};\n\\node at (10.5,0.5) {$1$};\n\\node at (11.5,0.5) {$2$};\n\\node at (12.5,0.5) {$3$};\n\\node at (13.5,0.5) {$2$};\n\\node at (14.5,0.5) {$1$};\n\n\\footnotesize\n\\node at (0.5,2.5) {$0$};\n\\node at (1.5,2.5) {$1$};\n\\node at (2.5,2.5) {$2$};\n\\node at (3.5,2.5) {$3$};\n\\node at (4.5,2.5) {$4$};\n\\node at (5.5,2.5) {$5$};\n\\node at (6.5,2.5) {$6$};\n\\node at (7.5,2.5) {$7$};\n\\node at (8.5,2.5) {$8$};\n\\node at (9.5,2.5) {$9$};\n\\node at (10.5,2.5) {$10$};\n\\node at (11.5,2.5) {$11$};\n\\node at (12.5,2.5) {$12$};\n\\node at (13.5,2.5) {$13$};\n\\node at (14.5,2.5) {$14$};\n\\end{tikzpicture}\n\\end{center}\n\nNode 5 is at position 2, node 8 is at position 5,\nand the node with minimum depth between\npositions $2 \\ldots 5$ is node 2 at position 3\nwhose depth is 2.\nThus, the lowest common ancestor of\nnodes 5 and 8 is node 2.\n\nThus, to find the lowest common ancestor\nof two nodes it suffices to process a range\nminimum query.\nSince the array is static,\nwe can process such queries in $O(1)$ time\nafter an $O(n \\log n)$ time preprocessing.\n\n\\subsubsection{Distances of nodes}\n\nThe distance between nodes $a$ and $b$\nequals the length of the path from $a$ to $b$.\nIt turns out that the problem of calculating\nthe distance between nodes reduces to\nfinding their lowest common ancestor.\n\nFirst, we root the tree arbitrarily.\nAfter this, the distance of nodes $a$ and $b$\ncan be calculated using the formula\n\\[\\texttt{depth}(a)+\\texttt{depth}(b)-2 \\cdot \\texttt{depth}(c),\\]\nwhere $c$ is the lowest common ancestor of $a$ and $b$\nand $\\texttt{depth}(s)$ denotes the depth of node $s$.\nFor example, consider the distance of nodes 5 and 8:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (5) at (2,-1) {$7$};\n\\node[draw, circle] (6) at (-3,-1) {$5$};\n\\node[draw, circle] (7) at (-1,-1) {$6$};\n\\node[draw, circle] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\path[draw,thick,-] (7) -- (8);\n\n\\path[draw=red,thick,-,line width=2pt] (8) -- node[font=\\small] {} (7);\n\\path[draw=red,thick,-,line width=2pt] (7) -- node[font=\\small] {} (3);\n\\path[draw=red,thick,-,line width=2pt] (6) -- node[font=\\small] {} (3);\n\\end{tikzpicture}\n\\end{center}\n\nThe lowest common ancestor of nodes 5 and 8 is node 2.\nThe depths of the nodes are\n$\\texttt{depth}(5)=3$, $\\texttt{depth}(8)=4$ and $\\texttt{depth}(2)=2$,\nso the distance between nodes 5 and 8 is\n$3+4-2\\cdot2=3$.\n\n", "chapter_name": "Tree queries", "chapter_path": "cphb/chapter18.tex"}, {"section_name": "Offline algorithms", "section_content": "\\section{Offline algorithms}\n\nSo far, we have discussed \\emph{online} algorithms\nfor tree queries.\nThose algorithms are able to process\nqueries one after another so that\neach query is answered before receiving the next query.\n\nHowever, in many problems, the online\nproperty is not necessary.\nIn this section, we focus on \\emph{offline} algorithms.\nThose algorithms are given a set of queries which can\nbe answered in any order.\nIt is often easier to design an offline algorithm\ncompared to an online algorithm.\n\n\\subsubsection{Merging data structures}\n\nOne method to construct an offline algorithm\nis to perform a depth-first tree traversal\nand maintain data structures in nodes.\nAt each node $s$, we create a data structure\n$\\texttt{d}[s]$ that is based on the\ndata structures of the children of $s$.\nThen, using this data structure,\nall queries related to $s$ are processed.\n\nAs an example, consider the following problem:\nWe are given a tree where each node has some value.\nOur task is to process queries of the form\n''calculate the number of nodes with value $x$\nin the subtree of node $s$''.\nFor example, in the following tree,\nthe subtree of node $4$ contains two nodes\nwhose value is 3.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (-3,1) {$2$};\n\\node[draw, circle] (3) at (-1,1) {$3$};\n\\node[draw, circle] (4) at (1,1) {$4$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (-3,-1) {$6$};\n\\node[draw, circle] (7) at (-0.5,-1) {$7$};\n\\node[draw, circle] (8) at (1,-1) {$8$};\n\\node[draw, circle] (9) at (2.5,-1) {$9$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (4) -- (7);\n\\path[draw,thick,-] (4) -- (8);\n\\path[draw,thick,-] (4) -- (9);\n\n\\node[color=blue] at (0,3+0.65) {2};\n\\node[color=blue] at (-3-0.65,1) {3};\n\\node[color=blue] at (-1-0.65,1) {5};\n\\node[color=blue] at (1+0.65,1) {3};\n\\node[color=blue] at (3+0.65,1) {1};\n\\node[color=blue] at (-3,-1-0.65) {4};\n\\node[color=blue] at (-0.5,-1-0.65) {4};\n\\node[color=blue] at (1,-1-0.65) {3};\n\\node[color=blue] at (2.5,-1-0.65) {1};\n\\end{tikzpicture}\n\\end{center}\n\nIn this problem, we can use map structures\nto answer the queries.\nFor example, the maps for node 4 and\nits children are as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\n\\node[draw, rectangle] (a) at (4,5.5)\n{\n\\footnotesize\n\\begin{tabular}{rrr}\n4 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\n\\node[draw, rectangle] (b) at (8,5.5)\n{\n\\footnotesize\n\\begin{tabular}{rrr}\n3 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\n\n\\node[draw, rectangle] (c) at (12,5.5)\n{\n\\footnotesize\n\\begin{tabular}{rr}\n1 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\n\\node[draw, rectangle] (d) at (8,8.5)\n{\n\\footnotesize\n\\begin{tabular}{rrr}\n1 & 3 & 4 \\\\\n\\hline\n1 & 2 & 1 \\\\\n\\end{tabular}};\n\\path[draw,thick,-] (a) -- (d);\n\\path[draw,thick,-] (b) -- (d);\n\\path[draw,thick,-] (c) -- (d);\n\\end{tikzpicture}\n\\end{center}\n\nIf we create such a data structure for each node,\nwe can easily process all given queries,\nbecause we can handle all queries related\nto a node immediately after creating its\ndata structure. For example, the above\nmap structure for node 4\ntells us that its subtree\ncontains two nodes whose value is 3.\n\nHowever, it would be too slow to create\nall data structures from scratch.\nInstead, at each node $s$,\nwe create an initial data structure $\\texttt{d}[s]$ \nthat only contains the value of $s$.\nAfter this, we go through the children of $s$ and\n\\emph{merge} $\\texttt{d}[s]$ and\nall data structures\n$\\texttt{d}[u]$ where $u$ is a child of $s$.\n\nFor example, in the above tree, the map\nfor node $4$ is created by merging the following maps:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\n\\node[draw, rectangle] (a) at (4,5.5)\n{\n\\footnotesize\n\\begin{tabular}{rrr}\n4 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\n\\node[draw, rectangle] (b) at (7,5.5)\n{\n\\footnotesize\n\\begin{tabular}{rrr}\n3 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\n\\node[draw, rectangle] (c) at (10,5.5)\n{\n\\footnotesize\n\\begin{tabular}{rr}\n1 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\n\\node[draw, rectangle] (d) at (1,5.5)\n{\n\\footnotesize\n\\begin{tabular}{rr}\n3 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\n\\end{tikzpicture}\n\\end{center}\n\nHere the first map is the initial data structure\nfor node 4,\nand the other three maps correspond to nodes 7, 8 and 9.\n\nThe merging at node $s$ can be done as follows:\nWe go through the children of $s$\nand at each child $u$ merge $\\texttt{d}[s]$\nand $\\texttt{d}[u]$.\nWe always copy the contents from $\\texttt{d}[u]$\nto $\\texttt{d}[s]$.\nHowever, before this, we \\emph{swap}\nthe contents of $\\texttt{d}[s]$ and $\\texttt{d}[u]$\nif $\\texttt{d}[s]$ is smaller than $\\texttt{d}[u]$.\nBy doing this, each value is copied only $O(\\log n)$\ntimes during the tree traversal,\nwhich ensures that the algorithm is efficient.\n\nTo swap the contents of two data structures $a$ and $b$\nefficiently, we can just use the following code:\n\\begin{lstlisting}\nswap(a,b);\n\\end{lstlisting}\nIt is guaranteed that the above code works in constant time\nwhen $a$ and $b$ are C++ standard library data structures.\n\n\\subsubsection{Lowest common ancestors}\n\nThere is also an offline algorithm\nfor processing a set of\nlowest common ancestor queries\\footnote{This\nalgorithm was published by R. E. Tarjan in 1979 \\cite{tar79}.}.\nThe algorithm is based on the union-find data structure\n(see Chapter 15.2), and the benefit of the algorithm is\nthat it is easier to implement than the\nalgorithms discussed earlier in this chapter.\n\nThe algorithm is given as input a set of pairs of nodes,\nand it determines for each such pair the\nlowest common ancestor of the nodes.\nThe algorithm performs a depth-first tree traversal\nand maintains disjoint sets of nodes.\nInitially, each node belongs to a separate set.\nFor each set, we also store the highest node in the\ntree that belongs to the set.\n\nWhen the algorithm visits a node $x$,\nit goes through all nodes $y$ such that\nthe lowest common ancestor of $x$ and $y$\nhas to be found.\nIf $y$ has already been visited,\nthe algorithm reports that the \nlowest common ancestor of $x$ and $y$\nis the highest node in the set of $y$.\nThen, after processing node $x$,\nthe algorithm joins the sets of $x$ and its parent.\n\nFor example, suppose that we want to find the lowest\ncommon ancestors of node pairs $(5,8)$\nand $(2,7)$ in the following tree:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.85]\n\\node[draw, circle] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (5) at (2,-1) {$7$};\n\\node[draw, circle] (6) at (-3,-1) {$5$};\n\\node[draw, circle] (7) at (-1,-1) {$6$};\n\\node[draw, circle] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\path[draw,thick,-] (7) -- (8);\n\\end{tikzpicture}\n\\end{center}\n\nIn the following trees, gray nodes denote visited nodes\nand dashed groups of nodes belong to the same set.\nWhen the algorithm visits node 8, it notices that\nnode 5 has been visited and the highest node\nin its set is 2. Thus, the lowest common ancestor\nof nodes 5 and 8 is 2:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.85]\n\\node[draw, circle, fill=lightgray] (1) at (0,3) {$1$};\n\\node[draw, circle] (2) at (2,1) {$4$};\n\\node[draw, circle, fill=lightgray] (3) at (-2,1) {$2$};\n\\node[draw, circle] (4) at (0,1) {$3$};\n\\node[draw, circle] (5) at (2,-1) {$7$};\n\\node[draw, circle, fill=lightgray] (6) at (-3,-1) {$5$};\n\\node[draw, circle, fill=lightgray] (7) at (-1,-1) {$6$};\n\\node[draw, circle, fill=gray] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\path[draw,thick,-] (7) -- (8);\n\n\\draw [red,thick,dashed,line width=2pt,rotate around={-28:(-2,0)}] (-2.9,1.5) rectangle (-1.9,-2);\n\n\n\\draw [red,thick,dashed,line width=2pt] (-1.5,-0.5) rectangle (-0.5,-1.5);\n\\draw [red,thick,dashed,line width=2pt] (-1.5,-2.5) rectangle (-0.5,-3.5);\n\n\\draw [red,thick,dashed,line width=2pt] (0.5,3.5) rectangle (-0.5,2.5);\n\\draw [red,thick,dashed,line width=2pt] (0.5,1.5) rectangle (-0.5,0.5);\n\\draw [red,thick,dashed,line width=2pt] (2.5,1.5) rectangle (1.5,0.5);\n\\draw [red,thick,dashed,line width=2pt] (2.5,-0.5) rectangle (1.5,-1.5);\n\\end{tikzpicture}\n\\end{center}\n\nLater, when visiting node 7,\nthe algorithm determines that\nthe lowest common ancestor of nodes 2 and 7 is 1:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.85]\n\\node[draw, circle, fill=lightgray] (1) at (0,3) {$1$};\n\\node[draw, circle, fill=lightgray] (2) at (2,1) {$4$};\n\\node[draw, circle, fill=lightgray] (3) at (-2,1) {$2$};\n\\node[draw, circle, fill=lightgray] (4) at (0,1) {$3$};\n\\node[draw, circle, fill=gray] (5) at (2,-1) {$7$};\n\\node[draw, circle, fill=lightgray] (6) at (-3,-1) {$5$};\n\\node[draw, circle, fill=lightgray] (7) at (-1,-1) {$6$};\n\\node[draw, circle, fill=lightgray] (8) at (-1,-3) {$8$};\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (7);\n\\path[draw,thick,-] (7) -- (8);\n\n\\draw [red,thick,dashed,line width=2pt] (0.5,3.5) rectangle (-3.5,-3.5);\n\\draw [red,thick,dashed,line width=2pt] (2.5,1.5) rectangle (1.5,0.5);\n\\draw [red,thick,dashed,line width=2pt] (2.5,-0.5) rectangle (1.5,-1.5);\n\n\\end{tikzpicture}\n\\end{center}\n", "chapter_name": "Tree queries", "chapter_path": "cphb/chapter18.tex"}, {"section_name": "Eulerian paths", "section_content": "\\chapter{Paths and circuits}\n\nThis chapter focuses on two types of paths in graphs:\n\\begin{itemize}\n\\item An \\key{Eulerian path} is a path that\ngoes through each edge exactly once.\n\\item A \\key{Hamiltonian path} is a path\nthat visits each node exactly once.\n\\end{itemize}\n\nWhile Eulerian and Hamiltonian paths look like\nsimilar concepts at first glance,\nthe computational problems related to them\nare very different.\nIt turns out that there is a simple rule that\ndetermines whether a graph contains an Eulerian path,\nand there is also an efficient algorithm to\nfind such a path if it exists.\nOn the contrary, checking the existence of a Hamiltonian path is a NP-hard\nproblem, and no efficient algorithm is known for solving the problem.\n\n\\section{Eulerian paths}\n\n\\index{Eulerian path}\n\nAn \\key{Eulerian path}\\footnote{L. Euler studied such paths in 1736\nwhen he solved the famous K\u00f6nigsberg bridge problem.\nThis was the birth of graph theory.} is a path\nthat goes exactly once through each edge of the graph.\nFor example, the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\nhas an Eulerian path from node 2 to node 5:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]north:1.}] {} (1);\n\\path[draw=red,thick,->,line width=2pt] (1) -- node[font=\\small,label={[red]left:2.}] {} (4);\n\\path[draw=red,thick,->,line width=2pt] (4) -- node[font=\\small,label={[red]south:3.}] {} (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- node[font=\\small,label={[red]left:4.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]north:5.}] {} (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- node[font=\\small,label={[red]south:6.}] {} (5);\n\\end{tikzpicture}\n\\end{center}\n\\index{Eulerian circuit}\nAn \\key{Eulerian circuit}\nis an Eulerian path that starts and ends\nat the same node.\nFor example, the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (4);\n\\end{tikzpicture}\n\\end{center}\nhas an Eulerian circuit that starts and ends at node 1:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (4);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- node[font=\\small,label={[red]left:1.}] {} (4);\n\\path[draw=red,thick,->,line width=2pt] (4) -- node[font=\\small,label={[red]south:2.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]right:3.}] {} (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- node[font=\\small,label={[red]south:4.}] {} (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- node[font=\\small,label={[red]north:5.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]north:6.}] {} (1);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Existence}\n\nThe existence of Eulerian paths and circuits\ndepends on the degrees of the nodes.\nFirst, an undirected graph has an Eulerian path \nexactly when all the edges\nbelong to the same connected component and\n\\begin{itemize}\n\\item the degree of each node is even \\emph{or}\n\\item the degree of exactly two nodes is odd,\nand the degree of all other nodes is even.\n\\end{itemize}\n\nIn the first case, each Eulerian path is also an Eulerian circuit.\nIn the second case, the odd-degree nodes are the starting\nand ending nodes of an Eulerian path which is not an Eulerian circuit.\n\n\\begin{samepage}\nFor example, in the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\nnodes 1, 3 and 4 have a degree of 2,\nand nodes 2 and 5 have a degree of 3.\nExactly two nodes have an odd degree,\nso there is an Eulerian path between nodes 2 and 5,\nbut the graph does not contain an Eulerian circuit.\n\nIn a directed graph,\nwe focus on indegrees and outdegrees\nof the nodes.\nA directed graph contains an Eulerian path\nexactly when all the edges belong to the same\nconnected component and\n\\begin{itemize}\n\\item in each node, the indegree equals the outdegree, \\emph{or}\n\\item in one node, the indegree is one larger than the outdegree,\nin another node, the outdegree is one larger than the indegree,\nand in all other nodes, the indegree equals the outdegree.\n\\end{itemize}\n\nIn the first case, each Eulerian path\nis also an Eulerian circuit,\nand in the second case, the graph contains an Eulerian path\nthat begins at the node whose outdegree is larger\nand ends at the node whose indegree is larger.\n\nFor example, in the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\path[draw,thick,->,>=latex] (3) -- (5);\n\\path[draw,thick,->,>=latex] (2) -- (5);\n\\path[draw,thick,->,>=latex] (5) -- (4);\n\\end{tikzpicture}\n\\end{center}\nnodes 1, 3 and 4 have both indegree 1 and outdegree 1,\nnode 2 has indegree 1 and outdegree 2,\nand node 5 has indegree 2 and outdegree 1.\nHence, the graph contains an Eulerian path\nfrom node 2 to node 5:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]north:1.}] {} (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- node[font=\\small,label={[red]south:2.}] {} (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- node[font=\\small,label={[red]south:3.}] {} (4);\n\\path[draw=red,thick,->,line width=2pt] (4) -- node[font=\\small,label={[red]left:4.}] {} (1);\n\\path[draw=red,thick,->,line width=2pt] (1) -- node[font=\\small,label={[red]north:5.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]left:6.}] {} (5);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Hierholzer's algorithm}\n\n\\index{Hierholzer's algorithm}\n\n\\key{Hierholzer's algorithm}\\footnote{The algorithm was published\nin 1873 after Hierholzer's death \\cite{hie73}.} is an efficient\nmethod for constructing\nan Eulerian circuit.\nThe algorithm consists of several rounds,\neach of which adds new edges to the circuit.\nOf course, we assume that the graph contains\nan Eulerian circuit; otherwise Hierholzer's\nalgorithm cannot find it.\n\nFirst, the algorithm constructs a circuit that contains\nsome (not necessarily all) of the edges of the graph.\nAfter this, the algorithm extends the circuit\nstep by step by adding subcircuits to it.\nThe process continues until all edges have been added\nto the circuit.\n\nThe algorithm extends the circuit by always finding\na node $x$ that belongs to the circuit but has\nan outgoing edge that is not included in the circuit.\nThe algorithm constructs a new path from node $x$\nthat only contains edges that are not yet in the circuit.\nSooner or later,\nthe path will return to node $x$,\nwhich creates a subcircuit.\n\nIf the graph only contains an Eulerian path,\nwe can still use Hierholzer's algorithm\nto find it by adding an extra edge to the graph\nand removing the edge after the circuit\nhas been constructed.\nFor example, in an undirected graph,\nwe add the extra edge between the two\nodd-degree nodes.\n\nNext we will see how Hierholzer's algorithm\nconstructs an Eulerian circuit for an undirected graph.\n\n\\subsubsection{Example}\n\n\\begin{samepage}\nLet us consider the following graph:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (3,5) {$1$};\n\\node[draw, circle] (2) at (1,3) {$2$};\n\\node[draw, circle] (3) at (3,3) {$3$};\n\\node[draw, circle] (4) at (5,3) {$4$};\n\\node[draw, circle] (5) at (1,1) {$5$};\n\\node[draw, circle] (6) at (3,1) {$6$};\n\\node[draw, circle] (7) at (5,1) {$7$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (4) -- (7);\n\\path[draw,thick,-] (5) -- (6);\n\\path[draw,thick,-] (6) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\n\\begin{samepage}\nSuppose that the algorithm first creates a circuit\nthat begins at node 1.\nA possible circuit is\n$1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (3,5) {$1$};\n\\node[draw, circle] (2) at (1,3) {$2$};\n\\node[draw, circle] (3) at (3,3) {$3$};\n\\node[draw, circle] (4) at (5,3) {$4$};\n\\node[draw, circle] (5) at (1,1) {$5$};\n\\node[draw, circle] (6) at (3,1) {$6$};\n\\node[draw, circle] (7) at (5,1) {$7$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (4) -- (7);\n\\path[draw,thick,-] (5) -- (6);\n\\path[draw,thick,-] (6) -- (7);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- node[font=\\small,label={[red]north:1.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]north:2.}] {} (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- node[font=\\small,label={[red]east:3.}] {} (1);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\nAfter this, the algorithm adds\nthe subcircuit\n$2 \\rightarrow 5 \\rightarrow 6 \\rightarrow 2$\nto the circuit:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (3,5) {$1$};\n\\node[draw, circle] (2) at (1,3) {$2$};\n\\node[draw, circle] (3) at (3,3) {$3$};\n\\node[draw, circle] (4) at (5,3) {$4$};\n\\node[draw, circle] (5) at (1,1) {$5$};\n\\node[draw, circle] (6) at (3,1) {$6$};\n\\node[draw, circle] (7) at (5,1) {$7$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (4) -- (7);\n\\path[draw,thick,-] (5) -- (6);\n\\path[draw,thick,-] (6) -- (7);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- node[font=\\small,label={[red]north:1.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]west:2.}] {} (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- node[font=\\small,label={[red]south:3.}] {} (6);\n\\path[draw=red,thick,->,line width=2pt] (6) -- node[font=\\small,label={[red]north:4.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]north:5.}] {} (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- node[font=\\small,label={[red]east:6.}] {} (1);\n\\end{tikzpicture}\n\\end{center}\nFinally, the algorithm adds the subcircuit\n$6 \\rightarrow 3 \\rightarrow 4 \\rightarrow 7 \\rightarrow 6$\nto the circuit:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (3,5) {$1$};\n\\node[draw, circle] (2) at (1,3) {$2$};\n\\node[draw, circle] (3) at (3,3) {$3$};\n\\node[draw, circle] (4) at (5,3) {$4$};\n\\node[draw, circle] (5) at (1,1) {$5$};\n\\node[draw, circle] (6) at (3,1) {$6$};\n\\node[draw, circle] (7) at (5,1) {$7$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (2) -- (6);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (4) -- (7);\n\\path[draw,thick,-] (5) -- (6);\n\\path[draw,thick,-] (6) -- (7);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- node[font=\\small,label={[red]north:1.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]west:2.}] {} (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- node[font=\\small,label={[red]south:3.}] {} (6);\n\\path[draw=red,thick,->,line width=2pt] (6) -- node[font=\\small,label={[red]east:4.}] {} (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- node[font=\\small,label={[red]north:5.}] {} (4);\n\\path[draw=red,thick,->,line width=2pt] (4) -- node[font=\\small,label={[red]east:6.}] {} (7);\n\\path[draw=red,thick,->,line width=2pt] (7) -- node[font=\\small,label={[red]south:7.}] {} (6);\n\\path[draw=red,thick,->,line width=2pt] (6) -- node[font=\\small,label={[red]right:8.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]north:9.}] {} (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- node[font=\\small,label={[red]east:10.}] {} (1);\n\\end{tikzpicture}\n\\end{center}\nNow all edges are included in the circuit,\nso we have successfully constructed an Eulerian circuit.\n\n", "chapter_name": "Paths and circuits", "chapter_path": "cphb/chapter19.tex"}, {"section_name": "Hamiltonian paths", "section_content": "\\section{Hamiltonian paths}\n\n\\index{Hamiltonian path}\n\nA \\key{Hamiltonian path}\n%\\footnote{W. R. Hamilton (1805--1865) was an Irish mathematician.}\nis a path\nthat visits each node of the graph exactly once.\nFor example, the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\ncontains a Hamiltonian path from node 1 to node 3:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- node[font=\\small,label={[red]left:1.}] {} (4);\n\\path[draw=red,thick,->,line width=2pt] (4) -- node[font=\\small,label={[red]south:2.}] {} (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- node[font=\\small,label={[red]left:3.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]north:4.}] {} (3);\n\\end{tikzpicture}\n\\end{center}\n\n\\index{Hamiltonian circuit}\n\nIf a Hamiltonian path begins and ends at the same node,\nit is called a \\key{Hamiltonian circuit}.\nThe graph above also has an Hamiltonian circuit\nthat begins and ends at node 1:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,5) {$1$};\n\\node[draw, circle] (2) at (3,5) {$2$};\n\\node[draw, circle] (3) at (5,4) {$3$};\n\\node[draw, circle] (4) at (1,3) {$4$};\n\\node[draw, circle] (5) at (3,3) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (2) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- node[font=\\small,label={[red]north:1.}] {} (2);\n\\path[draw=red,thick,->,line width=2pt] (2) -- node[font=\\small,label={[red]north:2.}] {} (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- node[font=\\small,label={[red]south:3.}] {} (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- node[font=\\small,label={[red]south:4.}] {} (4);\n\\path[draw=red,thick,->,line width=2pt] (4) -- node[font=\\small,label={[red]left:5.}] {} (1);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Existence}\n\nNo efficient method is known for testing if a graph\ncontains a Hamiltonian path, and the problem is NP-hard.\nStill, in some special cases, we can be certain\nthat a graph contains a Hamiltonian path.\n\nA simple observation is that if the graph is complete,\ni.e., there is an edge between all pairs of nodes,\nit also contains a Hamiltonian path.\nAlso stronger results have been achieved:\n\n\\begin{itemize}\n\\item\n\\index{Dirac's theorem}\n\\key{Dirac's theorem}: %\\cite{dir52}\nIf the degree of each node is at least $n/2$,\nthe graph contains a Hamiltonian path.\n\\item\n\\index{Ore's theorem}\n\\key{Ore's theorem}: %\\cite{ore60}\nIf the sum of degrees of each non-adjacent pair of nodes\nis at least $n$,\nthe graph contains a Hamiltonian path.\n\\end{itemize}\n\nA common property in these theorems and other results is\nthat they guarantee the existence of a Hamiltonian path\nif the graph has \\emph{a large number} of edges.\nThis makes sense, because the more edges the graph contains,\nthe more possibilities there is to construct a Hamiltonian path.\n\n\\subsubsection{Construction}\n\nSince there is no efficient way to check if a Hamiltonian\npath exists, it is clear that there is also no method\nto efficiently construct the path, because otherwise\nwe could just try to construct the path and see\nwhether it exists.\n\nA simple way to search for a Hamiltonian path is\nto use a backtracking algorithm that goes through all\npossible ways to construct the path.\nThe time complexity of such an algorithm is at least $O(n!)$,\nbecause there are $n!$ different ways to choose the order of $n$ nodes.\n\nA more efficient solution is based on dynamic programming\n(see Chapter 10.5).\nThe idea is to calculate values\nof a function $\\texttt{possible}(S,x)$,\nwhere $S$ is a subset of nodes and $x$\nis one of the nodes.\nThe function indicates whether there is a Hamiltonian path\nthat visits the nodes of $S$ and ends at node $x$.\nIt is possible to implement this solution in $O(2^n n^2)$ time.\n\n", "chapter_name": "Paths and circuits", "chapter_path": "cphb/chapter19.tex"}, {"section_name": "De Bruijn sequences", "section_content": "\\section{De Bruijn sequences}\n\n\\index{De Bruijn sequence}\n\nA \\key{De Bruijn sequence}\nis a string that contains\nevery string of length $n$\nexactly once as a substring, for a fixed\nalphabet of $k$ characters.\nThe length of such a string is \n$k^n+n-1$ characters.\nFor example, when $n=3$ and $k=2$,\nan example of a De Bruijn sequence is\n\\[0001011100.\\]\nThe substrings of this string are all\ncombinations of three bits:\n000, 001, 010, 011, 100, 101, 110 and 111.\n\nIt turns out that each De Bruijn sequence\ncorresponds to an Eulerian path in a graph.\nThe idea is to construct a graph where\neach node contains a string of $n-1$ characters\nand each edge adds one character to the string.\nThe following graph corresponds to the above scenario:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.8]\n\\node[draw, circle] (00) at (-3,0) {00};\n\\node[draw, circle] (11) at (3,0) {11};\n\\node[draw, circle] (01) at (0,2) {01};\n\\node[draw, circle] (10) at (0,-2) {10};\n\n\\path[draw,thick,->] (00) edge [bend left=20] node[font=\\small,label=1] {} (01);\n\\path[draw,thick,->] (01) edge [bend left=20] node[font=\\small,label=1] {} (11);\n\\path[draw,thick,->] (11) edge [bend left=20] node[font=\\small,label=below:0] {} (10);\n\\path[draw,thick,->] (10) edge [bend left=20] node[font=\\small,label=below:0] {} (00);\n\n\\path[draw,thick,->] (01) edge [bend left=30] node[font=\\small,label=right:0] {} (10);\n\\path[draw,thick,->] (10) edge [bend left=30] node[font=\\small,label=left:1] {} (01);\n\n\\path[draw,thick,-] (00) edge [loop left] node[font=\\small,label=below:0] {} (00);\n\\path[draw,thick,-] (11) edge [loop right] node[font=\\small,label=below:1] {} (11);\n\\end{tikzpicture}\n\\end{center}\n\nAn Eulerian path in this graph corresponds to a string\nthat contains all strings of length $n$.\nThe string contains the characters of the starting node\nand all characters of the edges.\nThe starting node has $n-1$ characters\nand there are $k^n$ characters in the edges,\nso the length of the string is $k^n+n-1$.\n\n", "chapter_name": "Paths and circuits", "chapter_path": "cphb/chapter19.tex"}, {"section_name": "Knight's tours", "section_content": "\\section{Knight's tours}\n\n\\index{knight's tour}\n\nA \\key{knight's tour} is a sequence of moves\nof a knight on an $n \\times n$ chessboard\nfollowing the rules of chess such that the knight\nvisits each square exactly once.\nA knight's tour is called a \\emph{closed} tour\nif the knight finally returns to the starting square and\notherwise it is called an \\emph{open} tour.\n\nFor example, here is an open knight's tour on a $5 \\times 5$ board:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (5,5);\n\\node at (0.5,4.5) {$1$};\n\\node at (1.5,4.5) {$4$};\n\\node at (2.5,4.5) {$11$};\n\\node at (3.5,4.5) {$16$};\n\\node at (4.5,4.5) {$25$};\n\\node at (0.5,3.5) {$12$};\n\\node at (1.5,3.5) {$17$};\n\\node at (2.5,3.5) {$2$};\n\\node at (3.5,3.5) {$5$};\n\\node at (4.5,3.5) {$10$};\n\\node at (0.5,2.5) {$3$};\n\\node at (1.5,2.5) {$20$};\n\\node at (2.5,2.5) {$7$};\n\\node at (3.5,2.5) {$24$};\n\\node at (4.5,2.5) {$15$};\n\\node at (0.5,1.5) {$18$};\n\\node at (1.5,1.5) {$13$};\n\\node at (2.5,1.5) {$22$};\n\\node at (3.5,1.5) {$9$};\n\\node at (4.5,1.5) {$6$};\n\\node at (0.5,0.5) {$21$};\n\\node at (1.5,0.5) {$8$};\n\\node at (2.5,0.5) {$19$};\n\\node at (3.5,0.5) {$14$};\n\\node at (4.5,0.5) {$23$};\n\\end{tikzpicture}\n\\end{center}\n\nA knight's tour corresponds to a Hamiltonian path in a graph\nwhose nodes represent the squares of the board,\nand two nodes are connected with an edge if a knight\ncan move between the squares according to the rules of chess.\n\nA natural way to construct a knight's tour is to use backtracking.\nThe search can be made more efficient by using\n\\emph{heuristics} that attempt to guide the knight so that\na complete tour will be found quickly.\n\n\\subsubsection{Warnsdorf's rule}\n\n\\index{heuristic}\n\\index{Warnsdorf's rule}\n\n\\key{Warnsdorf's rule} is a simple and effective heuristic\nfor finding a knight's tour\\footnote{This heuristic was proposed\nin Warnsdorf's book \\cite{war23} in 1823. There are\nalso polynomial algorithms for finding knight's tours\n\\cite{par97}, but they are more complicated.}.\nUsing the rule, it is possible to efficiently construct a tour\neven on a large board.\nThe idea is to always move the knight so that it ends up\nin a square where the number of possible moves is as\n\\emph{small} as possible.\n\nFor example, in the following situation, there are five\npossible squares to which the knight can move (squares $a \\ldots e$):\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (5,5);\n\\node at (0.5,4.5) {$1$};\n\\node at (2.5,3.5) {$2$};\n\\node at (4.5,4.5) {$a$};\n\\node at (0.5,2.5) {$b$};\n\\node at (4.5,2.5) {$e$};\n\\node at (1.5,1.5) {$c$};\n\\node at (3.5,1.5) {$d$};\n\\end{tikzpicture}\n\\end{center}\nIn this situation, Warnsdorf's rule moves the knight to square $a$,\nbecause after this choice, there is only a single possible move.\nThe other choices would move the knight to squares where\nthere would be three moves available.\n\n\n", "chapter_name": "Paths and circuits", "chapter_path": "cphb/chapter19.tex"}, {"section_name": "Ford\u2013Fulkerson algorithm", "section_content": "\\chapter{Flows and cuts}\n\nIn this chapter, we focus on the following\ntwo problems:\n\n\\begin{itemize}\n\\item \\key{Finding a maximum flow}:\nWhat is the maximum amount of flow we can\nsend from a node to another node?\n\\item \\key{Finding a minimum cut}:\nWhat is a minimum-weight set of edges\nthat separates two nodes of the graph?\n\\end{itemize}\n\nThe input for both these problems is a directed,\nweighted graph that contains two special nodes:\nthe \\emph{source} is a node with no incoming edges,\nand the \\emph{sink} is a node with no outgoing edges.\n\nAs an example, we will use the following graph\nwhere node 1 is the source and node 6\nis the sink:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (7,2) {$6$};\n\\node[draw, circle] (5) at (3,1) {$4$};\n\\node[draw, circle] (6) at (5,1) {$5$};\n\\path[draw,thick,->] (1) -- node[font=\\small,label=5] {} (2);\n\\path[draw,thick,->] (2) -- node[font=\\small,label=6] {} (3);\n\\path[draw,thick,->] (3) -- node[font=\\small,label=5] {} (4);\n\\path[draw,thick,->] (1) -- node[font=\\small,label=below:4] {} (5);\n\\path[draw,thick,->] (5) -- node[font=\\small,label=below:1] {} (6);\n\\path[draw,thick,->] (6) -- node[font=\\small,label=below:2] {} (4);\n\\path[draw,thick,<-] (2) -- node[font=\\small,label=left:3] {} (5);\n\\path[draw,thick,->] (3) -- node[font=\\small,label=left:8] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Maximum flow}\n\n\\index{flow}\n\\index{maximum flow}\n\nIn the \\key{maximum flow} problem,\nour task is to send as much flow as possible\nfrom the source to the sink.\nThe weight of each edge is a capacity that\nrestricts the flow\nthat can go through the edge.\nIn each intermediate node,\nthe incoming and outgoing\nflow has to be equal.\n\nFor example, the maximum size of a flow\nin the example graph is 7.\nThe following picture shows how we can\nroute the flow:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (7,2) {$6$};\n\\node[draw, circle] (5) at (3,1) {$4$};\n\\node[draw, circle] (6) at (5,1) {$5$};\n\\path[draw,thick,->] (1) -- node[font=\\small,label=3/5] {} (2);\n\\path[draw,thick,->] (2) -- node[font=\\small,label=6/6] {} (3);\n\\path[draw,thick,->] (3) -- node[font=\\small,label=5/5] {} (4);\n\\path[draw,thick,->] (1) -- node[font=\\small,label=below:4/4] {} (5);\n\\path[draw,thick,->] (5) -- node[font=\\small,label=below:1/1] {} (6);\n\\path[draw,thick,->] (6) -- node[font=\\small,label=below:2/2] {} (4);\n\\path[draw,thick,<-] (2) -- node[font=\\small,label=left:3/3] {} (5);\n\\path[draw,thick,->] (3) -- node[font=\\small,label=left:1/8] {} (6);\n\\end{tikzpicture}\n\\end{center}\n\nThe notation $v/k$ means\nthat a flow of $v$ units is routed through\nan edge whose capacity is $k$ units.\nThe size of the flow is $7$,\nbecause the source sends $3+4$ units of flow\nand the sink receives $5+2$ units of flow.\nIt is easy see that this flow is maximum,\nbecause the total capacity of the edges\nleading to the sink is $7$.\n\n\\subsubsection{Minimum cut}\n\n\\index{cut}\n\\index{minimum cut}\n\nIn the \\key{minimum cut} problem,\nour task is to remove a set\nof edges from the graph\nsuch that there will be no path from the source\nto the sink after the removal\nand the total weight of the removed edges\nis minimum.\n\nThe minimum size of a cut in the example graph is 7.\nIt suffices to remove the edges $2 \\rightarrow 3$\nand $4 \\rightarrow 5$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (7,2) {$6$};\n\\node[draw, circle] (5) at (3,1) {$4$};\n\\node[draw, circle] (6) at (5,1) {$5$};\n\\path[draw,thick,->] (1) -- node[font=\\small,label=5] {} (2);\n\\path[draw,thick,->] (2) -- node[font=\\small,label=6] {} (3);\n\\path[draw,thick,->] (3) -- node[font=\\small,label=5] {} (4);\n\\path[draw,thick,->] (1) -- node[font=\\small,label=below:4] {} (5);\n\\path[draw,thick,->] (5) -- node[font=\\small,label=below:1] {} (6);\n\\path[draw,thick,->] (6) -- node[font=\\small,label=below:2] {} (4);\n\\path[draw,thick,<-] (2) -- node[font=\\small,label=left:3] {} (5);\n\\path[draw,thick,->] (3) -- node[font=\\small,label=left:8] {} (6);\n\n\\path[draw=red,thick,-,line width=2pt] (4-.3,3-.3) -- (4+.3,3+.3);\n\\path[draw=red,thick,-,line width=2pt] (4-.3,3+.3) -- (4+.3,3-.3);\n\\path[draw=red,thick,-,line width=2pt] (4-.3,1-.3) -- (4+.3,1+.3);\n\\path[draw=red,thick,-,line width=2pt] (4-.3,1+.3) -- (4+.3,1-.3);\n\\end{tikzpicture}\n\\end{center}\n\nAfter removing the edges,\nthere will be no path from the source to the sink.\nThe size of the cut is $7$,\nbecause the weights of the removed edges\nare $6$ and $1$.\nThe cut is minimum, because there is no valid\nway to remove edges from the graph such that\ntheir total weight would be less than $7$.\n\\\\\\\\\nIt is not a coincidence that\nthe maximum size of a flow\nand the minimum size of a cut\nare the same in the above example.\nIt turns out that a maximum flow\nand a minimum cut are\n\\emph{always} equally large,\nso the concepts are two sides of the same coin.\n\nNext we will discuss the Ford\u2013Fulkerson\nalgorithm that can be used to find\nthe maximum flow and minimum cut of a graph.\nThe algorithm also helps us to understand\n\\emph{why} they are equally large.\n\n\\section{Ford\u2013Fulkerson algorithm}\n\n\\index{Ford\u2013Fulkerson algorithm}\n\nThe \\key{Ford\u2013Fulkerson algorithm} \\cite{for56} finds\nthe maximum flow in a graph.\nThe algorithm begins with an empty flow,\nand at each step finds a path from the source\nto the sink that generates more flow.\nFinally, when the algorithm cannot increase the flow\nanymore, the maximum flow has been found.\n\nThe algorithm uses a special representation\nof the graph where each original edge has a reverse\nedge in another direction.\nThe weight of each edge indicates how much more flow\nwe could route through it.\nAt the beginning of the algorithm, the weight of each original edge\nequals the capacity of the edge\nand the weight of each reverse edge is zero.\n\n\\begin{samepage}\nThe new representation for the example graph is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (1,1.3) {$1$};\n\\node[draw, circle] (2) at (3,2.6) {$2$};\n\\node[draw, circle] (3) at (5,2.6) {$3$};\n\\node[draw, circle] (4) at (7,1.3) {$6$};\n\\node[draw, circle] (5) at (3,0) {$4$};\n\\node[draw, circle] (6) at (5,0) {$5$};\n\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=5] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=below:0] {} (1);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=6] {} (3);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=below:0] {} (2);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=5] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:0] {} (3);\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=4] {} (5);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=below:0] {} (1);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=1] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=below:0] {} (5);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=2] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:0] {} (6);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=left:3] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=right:0] {} (5);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=right:8] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=left:0] {} (3);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\n\\subsubsection{Algorithm description}\n\nThe Ford\u2013Fulkerson algorithm consists of several\nrounds.\nOn each round, the algorithm finds\na path from the source to the sink\nsuch that each edge on the path has a positive weight.\nIf there is more than one possible path available,\nwe can choose any of them.\n\nFor example, suppose we choose the following path:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (1,1.3) {$1$};\n\\node[draw, circle] (2) at (3,2.6) {$2$};\n\\node[draw, circle] (3) at (5,2.6) {$3$};\n\\node[draw, circle] (4) at (7,1.3) {$6$};\n\\node[draw, circle] (5) at (3,0) {$4$};\n\\node[draw, circle] (6) at (5,0) {$5$};\n\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=5] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=below:0] {} (1);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=6] {} (3);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=below:0] {} (2);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=5] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:0] {} (3);\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=4] {} (5);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=below:0] {} (1);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=1] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=below:0] {} (5);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=2] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:0] {} (6);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=left:3] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=right:0] {} (5);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=right:8] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=left:0] {} (3);\n\n\\path[draw=red,thick,->,line width=2pt] (1) edge [bend left=10] (2);\n\\path[draw=red,thick,->,line width=2pt] (2) edge [bend left=10] (3);\n\\path[draw=red,thick,->,line width=2pt] (3) edge [bend left=10] (6);\n\\path[draw=red,thick,->,line width=2pt] (6) edge [bend left=10] (4);\n\\end{tikzpicture}\n\\end{center}\n\nAfter choosing the path, the flow increases by $x$ units,\nwhere $x$ is the smallest edge weight on the path.\nIn addition, the weight of each edge on the path\ndecreases by $x$ and the weight of each reverse edge\nincreases by $x$.\n\nIn the above path, the weights of the\nedges are 5, 6, 8 and 2.\nThe smallest weight is 2,\nso the flow increases by 2\nand the new graph is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (1,1.3) {$1$};\n\\node[draw, circle] (2) at (3,2.6) {$2$};\n\\node[draw, circle] (3) at (5,2.6) {$3$};\n\\node[draw, circle] (4) at (7,1.3) {$6$};\n\\node[draw, circle] (5) at (3,0) {$4$};\n\\node[draw, circle] (6) at (5,0) {$5$};\n\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=3] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=below:2] {} (1);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=4] {} (3);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=below:2] {} (2);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=5] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:0] {} (3);\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=4] {} (5);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=below:0] {} (1);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=1] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=below:0] {} (5);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=0] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=left:3] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=right:0] {} (5);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=right:6] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=left:2] {} (3);\n\\end{tikzpicture}\n\\end{center}\n\nThe idea is that increasing the flow decreases the amount of\nflow that can go through the edges in the future.\nOn the other hand, it is possible to cancel\nflow later using the reverse edges of the graph\nif it turns out that\nit would be beneficial to route the flow in another way.\n\nThe algorithm increases the flow as long as\nthere is a path from the source\nto the sink through positive-weight edges.\nIn the present example, our next path can be as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (1,1.3) {$1$};\n\\node[draw, circle] (2) at (3,2.6) {$2$};\n\\node[draw, circle] (3) at (5,2.6) {$3$};\n\\node[draw, circle] (4) at (7,1.3) {$6$};\n\\node[draw, circle] (5) at (3,0) {$4$};\n\\node[draw, circle] (6) at (5,0) {$5$};\n\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=3] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=below:2] {} (1);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=4] {} (3);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=below:2] {} (2);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=5] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:0] {} (3);\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=4] {} (5);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=below:0] {} (1);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=1] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=below:0] {} (5);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=0] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=left:3] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=right:0] {} (5);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=right:6] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=left:2] {} (3);\n\n\\path[draw=red,thick,->,line width=2pt] (1) edge [bend left=10] (5);\n\\path[draw=red,thick,->,line width=2pt] (5) edge [bend left=10] (2);\n\\path[draw=red,thick,->,line width=2pt] (2) edge [bend left=10] (3);\n\\path[draw=red,thick,->,line width=2pt] (3) edge [bend left=10] (4);\n\\end{tikzpicture}\n\\end{center}\n\nThe minimum edge weight on this path is 3,\nso the path increases the flow by 3,\nand the total flow after processing the path is 5.\n\n\\begin{samepage}\nThe new graph will be as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (1,1.3) {$1$};\n\\node[draw, circle] (2) at (3,2.6) {$2$};\n\\node[draw, circle] (3) at (5,2.6) {$3$};\n\\node[draw, circle] (4) at (7,1.3) {$6$};\n\\node[draw, circle] (5) at (3,0) {$4$};\n\\node[draw, circle] (6) at (5,0) {$5$};\n\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=3] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=below:2] {} (1);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=1] {} (3);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=below:5] {} (2);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=2] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:3] {} (3);\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=1] {} (5);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=below:3] {} (1);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=1] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=below:0] {} (5);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=0] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=left:0] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=right:3] {} (5);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=right:6] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=left:2] {} (3);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\nWe still need two more rounds before reaching the maximum flow.\nFor example, we can choose the paths\n$1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 6$ and\n$1 \\rightarrow 4 \\rightarrow 5 \\rightarrow 3 \\rightarrow 6$.\nBoth paths increase the flow by 1,\nand the final graph is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle] (1) at (1,1.3) {$1$};\n\\node[draw, circle] (2) at (3,2.6) {$2$};\n\\node[draw, circle] (3) at (5,2.6) {$3$};\n\\node[draw, circle] (4) at (7,1.3) {$6$};\n\\node[draw, circle] (5) at (3,0) {$4$};\n\\node[draw, circle] (6) at (5,0) {$5$};\n\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=2] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=below:3] {} (1);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=0] {} (3);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=below:6] {} (2);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=0] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:5] {} (3);\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=0] {} (5);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=below:4] {} (1);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=0] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=below:1] {} (5);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=0] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=left:0] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=right:3] {} (5);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=right:7] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=left:1] {} (3);\n\\end{tikzpicture}\n\\end{center}\n\nIt is not possible to increase the flow anymore,\nbecause there is no path from the source\nto the sink with positive edge weights.\nHence, the algorithm terminates and the maximum flow is 7.\n\n\\subsubsection{Finding paths}\n\nThe Ford\u2013Fulkerson algorithm does not specify\nhow we should choose the paths that increase the flow.\nIn any case, the algorithm will terminate sooner or later\nand correctly find the maximum flow.\nHowever, the efficiency of the algorithm depends on\nthe way the paths are chosen.\n\nA simple way to find paths is to use depth-first search.\nUsually, this works well, but in the worst case,\neach path only increases the flow by 1\nand the algorithm is slow.\nFortunately, we can avoid this situation\nby using one of the following techniques:\n\n\\index{Edmonds\u2013Karp algorithm}\n\nThe \\key{Edmonds\u2013Karp algorithm} \\cite{edm72}\nchooses each path so that the number of edges\non the path is as small as possible.\nThis can be done by using breadth-first search\ninstead of depth-first search for finding paths.\nIt can be proven that this guarantees that\nthe flow increases quickly, and the time complexity\nof the algorithm is $O(m^2 n)$.\n\n\\index{scaling algorithm}\n\nThe \\key{scaling algorithm} \\cite{ahu91} uses depth-first\nsearch to find paths where each edge weight is\nat least a threshold value.\nInitially, the threshold value is\nsome large number, for example the sum of all\nedge weights of the graph.\nAlways when a path cannot be found,\nthe threshold value is divided by 2.\nThe time complexity of the algorithm is $O(m^2 \\log c)$,\nwhere $c$ is the initial threshold value.\n\nIn practice, the scaling algorithm is easier to implement,\nbecause depth-first search can be used for finding paths.\nBoth algorithms are efficient enough for problems\nthat typically appear in programming contests.\n\n\\subsubsection{Minimum cuts}\n\n\\index{minimum cut}\n\nIt turns out that once the Ford\u2013Fulkerson algorithm\nhas found a maximum flow,\nit has also determined a minimum cut.\nLet $A$ be the set of nodes\nthat can be reached from the source\nusing positive-weight edges.\nIn the example graph, $A$ contains nodes 1, 2 and 4:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9,label distance=-2mm]\n\\node[draw, circle,fill=lightgray] (1) at (1,1.3) {$1$};\n\\node[draw, circle,fill=lightgray] (2) at (3,2.6) {$2$};\n\\node[draw, circle] (3) at (5,2.6) {$3$};\n\\node[draw, circle] (4) at (7,1.3) {$6$};\n\\node[draw, circle,fill=lightgray] (5) at (3,0) {$4$};\n\\node[draw, circle] (6) at (5,0) {$5$};\n\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=2] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=below:3] {} (1);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=0] {} (3);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=below:6] {} (2);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=0] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:5] {} (3);\n\\path[draw,thick,->] (1) edge [bend left=10] node[font=\\small,label=0] {} (5);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=below:4] {} (1);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=0] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=below:1] {} (5);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=0] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=10] node[font=\\small,label=below:2] {} (6);\n\\path[draw,thick,->] (5) edge [bend left=10] node[font=\\small,label=left:0] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=10] node[font=\\small,label=right:3] {} (5);\n\\path[draw,thick,->] (3) edge [bend left=10] node[font=\\small,label=right:7] {} (6);\n\\path[draw,thick,->] (6) edge [bend left=10] node[font=\\small,label=left:1] {} (3);\n\\end{tikzpicture}\n\\end{center}\n\nNow the minimum cut consists of the edges of the original graph\nthat start at some node in $A$, end at some node outside $A$,\nand whose capacity is fully\nused in the maximum flow.\nIn the above graph, such edges are\n$2 \\rightarrow 3$ and $4 \\rightarrow 5$,\nthat correspond to the minimum cut $6+1=7$.\n\nWhy is the flow produced by the algorithm maximum\nand why is the cut minimum?\nThe reason is that a graph cannot\ncontain a flow whose size is larger\nthan the weight of any cut of the graph.\nHence, always when a flow and a cut are equally large,\nthey are a maximum flow and a minimum cut.\n\nLet us consider any cut of the graph\nsuch that the source belongs to $A$,\nthe sink belongs to $B$\nand there are some edges between the sets:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\draw[dashed] (-2,0) circle (1.5);\n\\draw[dashed] (2,0) circle (1.5);\n\n\\node at (-2,-1) {$A$};\n\\node at (2,-1) {$B$};\n\n\\node[draw, circle] (1) at (-1,0.5) {};\n\\node[draw, circle] (2) at (-1,0) {};\n\\node[draw, circle] (3) at (-1,-0.5) {};\n\\node[draw, circle] (4) at (1,0.5) {};\n\\node[draw, circle] (5) at (1,0) {};\n\\node[draw, circle] (6) at (1,-0.5) {};\n\n\\path[draw,thick,->] (1) -- (4);\n\\path[draw,thick,->] (5) -- (2);\n\\path[draw,thick,->] (3) -- (6);\n\n\\end{tikzpicture}\n\\end{center}\n\nThe size of the cut is the sum of the edges\nthat go from $A$ to $B$.\nThis is an upper bound for the flow\nin the graph, because the flow has to proceed\nfrom $A$ to $B$.\nThus, the size of a maximum flow is smaller than or equal to\nthe size of any cut in the graph.\n\nOn the other hand, the Ford\u2013Fulkerson algorithm\nproduces a flow whose size is \\emph{exactly} as large\nas the size of a cut in the graph.\nThus, the flow has to be a maximum flow\nand the cut has to be a minimum cut.\n\n", "chapter_name": "Flows and cuts", "chapter_path": "cphb/chapter20.tex"}, {"section_name": "Disjoint paths", "section_content": "\\section{Disjoint paths}\n\nMany graph problems can be solved by reducing\nthem to the maximum flow problem.\nOur first example of such a problem is\nas follows: we are given a directed graph\nwith a source and a sink,\nand our task is to find the maximum number\nof disjoint paths from the source to the sink.\n\n\\subsubsection{Edge-disjoint paths}\n\nWe will first focus on the problem of\nfinding the maximum number of\n\\key{edge-disjoint paths} from the source to the sink.\nThis means that we should construct a set of paths\nsuch that each edge appears in at most one path.\n\nFor example, consider the following graph:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (3,1) {$4$};\n\\node[draw, circle] (5) at (5,1) {$5$};\n\\node[draw, circle] (6) at (7,2) {$6$};\n\\path[draw,thick,->] (1) -- (2);\n\\path[draw,thick,->] (1) -- (4);\n\\path[draw,thick,->] (2) -- (4);\n\\path[draw,thick,->] (3) -- (2);\n\\path[draw,thick,->] (3) -- (5);\n\\path[draw,thick,->] (3) -- (6);\n\\path[draw,thick,->] (4) -- (3);\n\\path[draw,thick,->] (4) -- (5);\n\\path[draw,thick,->] (5) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nIn this graph, the maximum number of edge-disjoint\npaths is 2.\nWe can choose the paths\n$1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 3 \\rightarrow 6$\nand $1 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$ as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (3,1) {$4$};\n\\node[draw, circle] (5) at (5,1) {$5$};\n\\node[draw, circle] (6) at (7,2) {$6$};\n\\path[draw,thick,->] (1) -- (2);\n\\path[draw,thick,->] (1) -- (4);\n\\path[draw,thick,->] (2) -- (4);\n\\path[draw,thick,->] (3) -- (2);\n\\path[draw,thick,->] (3) -- (5);\n\\path[draw,thick,->] (3) -- (6);\n\\path[draw,thick,->] (4) -- (3);\n\\path[draw,thick,->] (4) -- (5);\n\\path[draw,thick,->] (5) -- (6);\n\n\\path[draw=green,thick,->,line width=2pt] (1) -- (2);\n\\path[draw=green,thick,->,line width=2pt] (2) -- (4);\n\\path[draw=green,thick,->,line width=2pt] (4) -- (3);\n\\path[draw=green,thick,->,line width=2pt] (3) -- (6);\n\n\\path[draw=blue,thick,->,line width=2pt] (1) -- (4);\n\\path[draw=blue,thick,->,line width=2pt] (4) -- (5);\n\\path[draw=blue,thick,->,line width=2pt] (5) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nIt turns out that the maximum number of\nedge-disjoint paths\nequals the maximum flow of the graph,\nassuming that the capacity of each edge is one.\nAfter the maximum flow has been constructed,\nthe edge-disjoint paths can be found greedily\nby following paths from the source to the sink.\n\n\\subsubsection{Node-disjoint paths}\n\nLet us now consider another problem:\nfinding the maximum number of\n\\key{node-disjoint paths} from the source\nto the sink.\nIn this problem, every node,\nexcept for the source and sink,\nmay appear in at most one path.\nThe number of node-disjoint paths\nmay be smaller than the number of\nedge-disjoint paths.\n\nFor example, in the previous graph,\nthe maximum number of node-disjoint paths is 1:\n\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,2) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (5,3) {$3$};\n\\node[draw, circle] (4) at (3,1) {$4$};\n\\node[draw, circle] (5) at (5,1) {$5$};\n\\node[draw, circle] (6) at (7,2) {$6$};\n\\path[draw,thick,->] (1) -- (2);\n\\path[draw,thick,->] (1) -- (4);\n\\path[draw,thick,->] (2) -- (4);\n\\path[draw,thick,->] (3) -- (2);\n\\path[draw,thick,->] (3) -- (5);\n\\path[draw,thick,->] (3) -- (6);\n\\path[draw,thick,->] (4) -- (3);\n\\path[draw,thick,->] (4) -- (5);\n\\path[draw,thick,->] (5) -- (6);\n\n\\path[draw=green,thick,->,line width=2pt] (1) -- (2);\n\\path[draw=green,thick,->,line width=2pt] (2) -- (4);\n\\path[draw=green,thick,->,line width=2pt] (4) -- (3);\n\\path[draw=green,thick,->,line width=2pt] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nWe can reduce also this problem to the maximum flow problem.\nSince each node can appear in at most one path,\nwe have to limit the flow that goes through the nodes.\nA standard method for this is to divide each node into\ntwo nodes such that the first node has the incoming edges\nof the original node, the second node has the outgoing\nedges of the original node, and\nthere is a new edge from the first node\nto the second node.\n\nIn our example, the graph becomes as follows:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,2) {$1$};\n\n\\node[draw, circle] (2a) at (3,3) {$2$};\n\\node[draw, circle] (3a) at (6,3) {$3$};\n\\node[draw, circle] (4a) at (3,1) {$4$};\n\\node[draw, circle] (5a) at (6,1) {$5$};\n\n\\node[draw, circle] (2b) at (4,3) {$2$};\n\\node[draw, circle] (3b) at (7,3) {$3$};\n\\node[draw, circle] (4b) at (4,1) {$4$};\n\\node[draw, circle] (5b) at (7,1) {$5$};\n\n\\node[draw, circle] (6) at (9,2) {$6$};\n\n\\path[draw,thick,->] (2a) -- (2b);\n\\path[draw,thick,->] (3a) -- (3b);\n\\path[draw,thick,->] (4a) -- (4b);\n\\path[draw,thick,->] (5a) -- (5b);\n\n\\path[draw,thick,->] (1) -- (2a);\n\\path[draw,thick,->] (1) -- (4a);\n\\path[draw,thick,->] (2b) -- (4a);\n\\path[draw,thick,->] (3b) edge [bend right=30] (2a);\n\\path[draw,thick,->] (3b) -- (5a);\n\\path[draw,thick,->] (3b) -- (6);\n\\path[draw,thick,->] (4b) -- (3a);\n\\path[draw,thick,->] (4b) -- (5a);\n\\path[draw,thick,->] (5b) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nThe maximum flow for the graph is as follows:\n\\begin{center}\n\\begin{tikzpicture}\n\\node[draw, circle] (1) at (1,2) {$1$};\n\n\\node[draw, circle] (2a) at (3,3) {$2$};\n\\node[draw, circle] (3a) at (6,3) {$3$};\n\\node[draw, circle] (4a) at (3,1) {$4$};\n\\node[draw, circle] (5a) at (6,1) {$5$};\n\n\\node[draw, circle] (2b) at (4,3) {$2$};\n\\node[draw, circle] (3b) at (7,3) {$3$};\n\\node[draw, circle] (4b) at (4,1) {$4$};\n\\node[draw, circle] (5b) at (7,1) {$5$};\n\n\\node[draw, circle] (6) at (9,2) {$6$};\n\n\\path[draw,thick,->] (2a) -- (2b);\n\\path[draw,thick,->] (3a) -- (3b);\n\\path[draw,thick,->] (4a) -- (4b);\n\\path[draw,thick,->] (5a) -- (5b);\n\n\\path[draw,thick,->] (1) -- (2a);\n\\path[draw,thick,->] (1) -- (4a);\n\\path[draw,thick,->] (2b) -- (4a);\n\\path[draw,thick,->] (3b) edge [bend right=30] (2a);\n\\path[draw,thick,->] (3b) -- (5a);\n\\path[draw,thick,->] (3b) -- (6);\n\\path[draw,thick,->] (4b) -- (3a);\n\\path[draw,thick,->] (4b) -- (5a);\n\\path[draw,thick,->] (5b) -- (6);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (2a);\n\\path[draw=red,thick,->,line width=2pt] (2a) -- (2b);\n\\path[draw=red,thick,->,line width=2pt] (2b) -- (4a);\n\\path[draw=red,thick,->,line width=2pt] (4a) -- (4b);\n\\path[draw=red,thick,->,line width=2pt] (4b) -- (3a);\n\\path[draw=red,thick,->,line width=2pt] (3a) -- (3b);\n\\path[draw=red,thick,->,line width=2pt] (3b) -- (6);\n\\end{tikzpicture}\n\\end{center}\n\nThus, the maximum number of node-disjoint paths\nfrom the source to the sink is 1.\n\n", "chapter_name": "Flows and cuts", "chapter_path": "cphb/chapter20.tex"}, {"section_name": "Maximum matchings", "section_content": "\\section{Maximum matchings}\n\n\\index{matching}\n\\index{maximum matching}\n\nThe \\key{maximum matching} problem asks to find\na maximum-size set of node pairs in an undirected graph\nsuch that each pair is connected with an edge and\neach node belongs to at most one pair.\n\nThere are polynomial algorithms for finding\nmaximum matchings in general graphs \\cite{edm65},\nbut such algorithms are complex and\nrarely seen in programming contests.\nHowever, in bipartite graphs,\nthe maximum matching problem is much easier\nto solve, because we can reduce it to the\nmaximum flow problem.\n\n\\subsubsection{Finding maximum matchings}\n\nThe nodes of a bipartite graph can be always\ndivided into two groups such that all edges\nof the graph go from the left group to the right group.\nFor example, in the following bipartite graph,\nthe groups are $\\{1,2,3,4\\}$ and $\\{5,6,7,8\\}$.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.60]\n\\node[draw, circle] (1) at (2,4.5) {1};\n\\node[draw, circle] (2) at (2,3) {2};\n\\node[draw, circle] (3) at (2,1.5) {3};\n\\node[draw, circle] (4) at (2,0) {4};\n\\node[draw, circle] (5) at (8,4.5) {5};\n\\node[draw, circle] (6) at (8,3) {6};\n\\node[draw, circle] (7) at (8,1.5) {7};\n\\node[draw, circle] (8) at (8,0) {8};\n\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (7);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (8);\n\\path[draw,thick,-] (4) -- (7);\n\\end{tikzpicture}\n\\end{center}\nThe size of a maximum matching of this graph is 3:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.60]\n\\node[draw, circle] (1) at (2,4.5) {1};\n\\node[draw, circle] (2) at (2,3) {2};\n\\node[draw, circle] (3) at (2,1.5) {3};\n\\node[draw, circle] (4) at (2,0) {4};\n\\node[draw, circle] (5) at (8,4.5) {5};\n\\node[draw, circle] (6) at (8,3) {6};\n\\node[draw, circle] (7) at (8,1.5) {7};\n\\node[draw, circle] (8) at (8,0) {8};\n\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (7);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (8);\n\\path[draw,thick,-] (4) -- (7);\n\n\\path[draw=red,thick,-,line width=2pt] (1) -- (5);\n\\path[draw=red,thick,-,line width=2pt] (2) -- (7);\n\\path[draw=red,thick,-,line width=2pt] (3) -- (8);\n\\end{tikzpicture}\n\\end{center}\n\nWe can reduce the bipartite maximum matching problem\nto the maximum flow problem by adding two new nodes\nto the graph: a source and a sink.\nWe also add edges from the source\nto each left node and from each right node to the sink.\nAfter this, the size of a maximum flow in the graph\nequals the size of a maximum matching in the original graph.\n\nFor example, the reduction for the above\ngraph is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.60]\n\\node[draw, circle] (1) at (2,4.5) {1};\n\\node[draw, circle] (2) at (2,3) {2};\n\\node[draw, circle] (3) at (2,1.5) {3};\n\\node[draw, circle] (4) at (2,0) {4};\n\\node[draw, circle] (5) at (8,4.5) {5};\n\\node[draw, circle] (6) at (8,3) {6};\n\\node[draw, circle] (7) at (8,1.5) {7};\n\\node[draw, circle] (8) at (8,0) {8};\n\n\\node[draw, circle] (a) at (-2,2.25) {\\phantom{0}};\n\\node[draw, circle] (b) at (12,2.25) {\\phantom{0}};\n\n\\path[draw,thick,->] (1) -- (5);\n\\path[draw,thick,->] (2) -- (7);\n\\path[draw,thick,->] (3) -- (5);\n\\path[draw,thick,->] (3) -- (6);\n\\path[draw,thick,->] (3) -- (8);\n\\path[draw,thick,->] (4) -- (7);\n\n\\path[draw,thick,->] (a) -- (1);\n\\path[draw,thick,->] (a) -- (2);\n\\path[draw,thick,->] (a) -- (3);\n\\path[draw,thick,->] (a) -- (4);\n\\path[draw,thick,->] (5) -- (b);\n\\path[draw,thick,->] (6) -- (b);\n\\path[draw,thick,->] (7) -- (b);\n\\path[draw,thick,->] (8) -- (b);\n\\end{tikzpicture}\n\\end{center}\n\nThe maximum flow of this graph is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.60]\n\\node[draw, circle] (1) at (2,4.5) {1};\n\\node[draw, circle] (2) at (2,3) {2};\n\\node[draw, circle] (3) at (2,1.5) {3};\n\\node[draw, circle] (4) at (2,0) {4};\n\\node[draw, circle] (5) at (8,4.5) {5};\n\\node[draw, circle] (6) at (8,3) {6};\n\\node[draw, circle] (7) at (8,1.5) {7};\n\\node[draw, circle] (8) at (8,0) {8};\n\n\\node[draw, circle] (a) at (-2,2.25) {\\phantom{0}};\n\\node[draw, circle] (b) at (12,2.25) {\\phantom{0}};\n\n\\path[draw,thick,->] (3) -- (5);\n\\path[draw,thick,->] (3) -- (6);\n\\path[draw,thick,->] (4) -- (7);\n\n\\path[draw,thick,->] (a) -- (1);\n\\path[draw,thick,->] (a) -- (2);\n\\path[draw,thick,->] (a) -- (3);\n\\path[draw,thick,->] (a) -- (4);\n\\path[draw,thick,->] (5) -- (b);\n\\path[draw,thick,->] (6) -- (b);\n\\path[draw,thick,->] (7) -- (b);\n\\path[draw,thick,->] (8) -- (b);\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (5);\n\\path[draw=red,thick,->,line width=2pt] (2) -- (7);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (8);\n\n\\path[draw=red,thick,->,line width=2pt] (a) -- (1);\n\\path[draw=red,thick,->,line width=2pt] (a) -- (2);\n\\path[draw=red,thick,->,line width=2pt] (a) -- (3);\n\n\\path[draw=red,thick,->,line width=2pt] (5) -- (b);\n\\path[draw=red,thick,->,line width=2pt] (7) -- (b);\n\\path[draw=red,thick,->,line width=2pt] (8) -- (b);\n\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Hall's theorem}\n\n\\index{Hall's theorem}\n\\index{perfect matching}\n\n\\key{Hall's theorem} can be used to find out\nwhether a bipartite graph has a matching\nthat contains all left or right nodes.\nIf the number of left and right nodes is the same,\nHall's theorem tells us if it is possible to\nconstruct a \\key{perfect matching} that\ncontains all nodes of the graph.\n\nAssume that we want to find a matching\nthat contains all left nodes.\nLet $X$ be any set of left nodes\nand let $f(X)$ be the set of their neighbors.\nAccording to Hall's theorem, a matching\nthat contains all left nodes exists\nexactly when for each $X$, the condition $|X| \\le |f(X)|$ holds.\n\nLet us study Hall's theorem in the example graph.\nFirst, let $X=\\{1,3\\}$ which yields $f(X)=\\{5,6,8\\}$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.60]\n\\node[draw, circle, fill=lightgray] (1) at (2,4.5) {1};\n\\node[draw, circle] (2) at (2,3) {2};\n\\node[draw, circle, fill=lightgray] (3) at (2,1.5) {3};\n\\node[draw, circle] (4) at (2,0) {4};\n\\node[draw, circle, fill=lightgray] (5) at (8,4.5) {5};\n\\node[draw, circle, fill=lightgray] (6) at (8,3) {6};\n\\node[draw, circle] (7) at (8,1.5) {7};\n\\node[draw, circle, fill=lightgray] (8) at (8,0) {8};\n\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (7);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (8);\n\\path[draw,thick,-] (4) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nThe condition of Hall's theorem holds, because\n$|X|=2$ and $|f(X)|=3$.\nNext, let $X=\\{2,4\\}$ which yields $f(X)=\\{7\\}$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.60]\n\\node[draw, circle] (1) at (2,4.5) {1};\n\\node[draw, circle, fill=lightgray] (2) at (2,3) {2};\n\\node[draw, circle] (3) at (2,1.5) {3};\n\\node[draw, circle, fill=lightgray] (4) at (2,0) {4};\n\\node[draw, circle] (5) at (8,4.5) {5};\n\\node[draw, circle] (6) at (8,3) {6};\n\\node[draw, circle, fill=lightgray] (7) at (8,1.5) {7};\n\\node[draw, circle] (8) at (8,0) {8};\n\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (7);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (8);\n\\path[draw,thick,-] (4) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nIn this case, $|X|=2$ and $|f(X)|=1$,\nso the condition of Hall's theorem does not hold.\nThis means that it is not possible to form\na perfect matching for the graph.\nThis result is not surprising, because we already\nknow that the maximum matching of the graph is 3 and not 4.\n\nIf the condition of Hall's theorem does not hold,\nthe set $X$ provides an explanation \\emph{why}\nwe cannot form such a matching.\nSince $X$ contains more nodes than $f(X)$,\nthere are no pairs for all nodes in $X$.\nFor example, in the above graph, both nodes 2 and 4\nshould be connected with node 7 which is not possible.\n\n\\subsubsection{K\u0151nig's theorem}\n\n\\index{K\u0151nig's theorem}\n\\index{node cover}\n\\index{minimum node cover}\n\nA \\key{minimum node cover} of a graph\nis a minimum set of nodes such that each edge of the graph\nhas at least one endpoint in the set.\nIn a general graph, finding a minimum node cover\nis a NP-hard problem.\nHowever, if the graph is bipartite,\n\\key{K\u0151nig's theorem} tells us that\nthe size of a minimum node cover\nand the size of a maximum matching are always equal.\nThus, we can calculate the size of a minimum node cover\nusing a maximum flow algorithm.\n\nLet us consider the following graph\nwith a maximum matching of size 3:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.60]\n\\node[draw, circle] (1) at (2,4.5) {1};\n\\node[draw, circle] (2) at (2,3) {2};\n\\node[draw, circle] (3) at (2,1.5) {3};\n\\node[draw, circle] (4) at (2,0) {4};\n\\node[draw, circle] (5) at (8,4.5) {5};\n\\node[draw, circle] (6) at (8,3) {6};\n\\node[draw, circle] (7) at (8,1.5) {7};\n\\node[draw, circle] (8) at (8,0) {8};\n\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (7);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (8);\n\\path[draw,thick,-] (4) -- (7);\n\n\\path[draw=red,thick,-,line width=2pt] (1) -- (5);\n\\path[draw=red,thick,-,line width=2pt] (2) -- (7);\n\\path[draw=red,thick,-,line width=2pt] (3) -- (6);\n\\end{tikzpicture}\n\\end{center}\nNow K\u0151nig's theorem tells us that the size\nof a minimum node cover is also 3.\nSuch a cover can be constructed as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.60]\n\\node[draw, circle, fill=lightgray] (1) at (2,4.5) {1};\n\\node[draw, circle] (2) at (2,3) {2};\n\\node[draw, circle, fill=lightgray] (3) at (2,1.5) {3};\n\\node[draw, circle] (4) at (2,0) {4};\n\\node[draw, circle] (5) at (8,4.5) {5};\n\\node[draw, circle] (6) at (8,3) {6};\n\\node[draw, circle, fill=lightgray] (7) at (8,1.5) {7};\n\\node[draw, circle] (8) at (8,0) {8};\n\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (7);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (8);\n\\path[draw,thick,-] (4) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\n\\index{independent set}\n\\index{maximum independent set}\n\nThe nodes that do \\emph{not}\nbelong to a minimum node cover\nform a \\key{maximum independent set}.\nThis is the largest possible set of nodes\nsuch that no two nodes in the set\nare connected with an edge.\nOnce again, finding a maximum independent\nset in a general graph is a NP-hard problem,\nbut in a bipartite graph we can use\nK\u0151nig's theorem to solve the problem efficiently.\nIn the example graph, the maximum independent\nset is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.60]\n\\node[draw, circle] (1) at (2,4.5) {1};\n\\node[draw, circle, fill=lightgray] (2) at (2,3) {2};\n\\node[draw, circle] (3) at (2,1.5) {3};\n\\node[draw, circle, fill=lightgray] (4) at (2,0) {4};\n\\node[draw, circle, fill=lightgray] (5) at (8,4.5) {5};\n\\node[draw, circle, fill=lightgray] (6) at (8,3) {6};\n\\node[draw, circle] (7) at (8,1.5) {7};\n\\node[draw, circle, fill=lightgray] (8) at (8,0) {8};\n\n\\path[draw,thick,-] (1) -- (5);\n\\path[draw,thick,-] (2) -- (7);\n\\path[draw,thick,-] (3) -- (5);\n\\path[draw,thick,-] (3) -- (6);\n\\path[draw,thick,-] (3) -- (8);\n\\path[draw,thick,-] (4) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\n", "chapter_name": "Flows and cuts", "chapter_path": "cphb/chapter20.tex"}, {"section_name": "Path covers", "section_content": "\\section{Path covers}\n\n\\index{path cover}\n\nA \\key{path cover} is a set of paths in a graph\nsuch that each node of the graph belongs to at least one path.\nIt turns out that in directed, acyclic graphs,\nwe can reduce the problem of finding a minimum\npath cover to the problem of finding a maximum\nflow in another graph.\n\n\\subsubsection{Node-disjoint path cover}\n\nIn a \\key{node-disjoint path cover},\neach node belongs to exactly one path.\nAs an example, consider the following graph:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {1};\n\\node[draw, circle] (2) at (2,0) {2};\n\\node[draw, circle] (3) at (4,0) {3};\n\\node[draw, circle] (4) at (6,0) {4};\n\\node[draw, circle] (5) at (0,-2) {5};\n\\node[draw, circle] (6) at (2,-2) {6};\n\\node[draw, circle] (7) at (4,-2) {7};\n\n\\path[draw,thick,->,>=latex] (1) -- (5);\n\\path[draw,thick,->,>=latex] (2) -- (6);\n\\path[draw,thick,->,>=latex] (3) -- (4);\n\\path[draw,thick,->,>=latex] (5) -- (6);\n\\path[draw,thick,->,>=latex] (6) -- (3);\n\\path[draw,thick,->,>=latex] (6) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nA minimum node-disjoint path cover\nof this graph\nconsists of three paths.\nFor example, we can choose the following paths:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {1};\n\\node[draw, circle] (2) at (2,0) {2};\n\\node[draw, circle] (3) at (4,0) {3};\n\\node[draw, circle] (4) at (6,0) {4};\n\\node[draw, circle] (5) at (0,-2) {5};\n\\node[draw, circle] (6) at (2,-2) {6};\n\\node[draw, circle] (7) at (4,-2) {7};\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- (6);\n\\path[draw=red,thick,->,line width=2pt] (6) -- (7);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (4);\n\\end{tikzpicture}\n\\end{center}\n\nNote that one of the paths only contains node 2,\nso it is possible that a path does not contain any edges.\n\nWe can find a minimum node-disjoint path cover\nby constructing a \\emph{matching graph} where each node\nof the original graph is represented by\ntwo nodes: a left node and a right node.\nThere is an edge from a left node to a right node\nif there is such an edge in the original graph.\nIn addition, the matching graph contains a source and a sink,\nand there are edges from the source to all\nleft nodes and from all right nodes to the sink.\n\nA maximum matching in the resulting graph corresponds\nto a minimum node-disjoint path cover in\nthe original graph.\nFor example, the following matching graph\nfor the above graph contains\na maximum matching of size 4:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1a) at (0,6) {1};\n\\node[draw, circle] (2a) at (0,5) {2};\n\\node[draw, circle] (3a) at (0,4) {3};\n\\node[draw, circle] (4a) at (0,3) {4};\n\\node[draw, circle] (5a) at (0,2) {5};\n\\node[draw, circle] (6a) at (0,1) {6};\n\\node[draw, circle] (7a) at (0,0) {7};\n\n\\node[draw, circle] (1b) at (4,6) {1};\n\\node[draw, circle] (2b) at (4,5) {2};\n\\node[draw, circle] (3b) at (4,4) {3};\n\\node[draw, circle] (4b) at (4,3) {4};\n\\node[draw, circle] (5b) at (4,2) {5};\n\\node[draw, circle] (6b) at (4,1) {6};\n\\node[draw, circle] (7b) at (4,0) {7};\n\n\\node[draw, circle] (a) at (-3,3) {\\phantom{0}};\n\\node[draw, circle] (b) at (7,3) {\\phantom{0}};\n\n%\\path[draw,thick,->,>=latex] (1a) -- (5b);\n\\path[draw,thick,->,>=latex] (2a) -- (6b);\n%\\path[draw,thick,->,>=latex] (3a) -- (4b);\n%\\path[draw,thick,->,>=latex] (5a) -- (6b);\n\\path[draw,thick,->,>=latex] (6a) -- (3b);\n%\\path[draw,thick,->,>=latex] (6a) -- (7b);\n\n\\path[draw,thick,->,>=latex] (a) -- (1a);\n\\path[draw,thick,->,>=latex] (a) -- (2a);\n\\path[draw,thick,->,>=latex] (a) -- (3a);\n\\path[draw,thick,->,>=latex] (a) -- (4a);\n\\path[draw,thick,->,>=latex] (a) -- (5a);\n\\path[draw,thick,->,>=latex] (a) -- (6a);\n\\path[draw,thick,->,>=latex] (a) -- (7a);\n\n\\path[draw,thick,->,>=latex] (1b) -- (b);\n\\path[draw,thick,->,>=latex] (2b) -- (b);\n\\path[draw,thick,->,>=latex] (3b) -- (b);\n\\path[draw,thick,->,>=latex] (4b) -- (b);\n\\path[draw,thick,->,>=latex] (5b) -- (b);\n\\path[draw,thick,->,>=latex] (6b) -- (b);\n\\path[draw,thick,->,>=latex] (7b) -- (b);\n\n\\path[draw=red,thick,->,line width=2pt] (1a) -- (5b);\n\\path[draw=red,thick,->,line width=2pt] (5a) -- (6b);\n\\path[draw=red,thick,->,line width=2pt] (6a) -- (7b);\n\\path[draw=red,thick,->,line width=2pt] (3a) -- (4b);\n\n\\end{tikzpicture}\n\\end{center}\n\nEach edge in the maximum matching of the matching graph corresponds\nto an edge in the minimum node-disjoint path cover\nof the original graph.\nThus, the size of the minimum node-disjoint path cover is $n-c$,\nwhere $n$ is the number of nodes in the original graph\nand $c$ is the size of the maximum matching.\n\n\\subsubsection{General path cover}\n\nA \\key{general path cover} is a path cover\nwhere a node can belong to more than one path.\nA minimum general path cover may be smaller\nthan a minimum node-disjoint path cover,\nbecause a node can be used multiple times in paths.\nConsider again the following graph:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {1};\n\\node[draw, circle] (2) at (2,0) {2};\n\\node[draw, circle] (3) at (4,0) {3};\n\\node[draw, circle] (4) at (6,0) {4};\n\\node[draw, circle] (5) at (0,-2) {5};\n\\node[draw, circle] (6) at (2,-2) {6};\n\\node[draw, circle] (7) at (4,-2) {7};\n\n\\path[draw,thick,->,>=latex] (1) -- (5);\n\\path[draw,thick,->,>=latex] (2) -- (6);\n\\path[draw,thick,->,>=latex] (3) -- (4);\n\\path[draw,thick,->,>=latex] (5) -- (6);\n\\path[draw,thick,->,>=latex] (6) -- (3);\n\\path[draw,thick,->,>=latex] (6) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nThe minimum general path cover of this graph\nconsists of two paths.\nFor example, the first path may be as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {1};\n\\node[draw, circle] (2) at (2,0) {2};\n\\node[draw, circle] (3) at (4,0) {3};\n\\node[draw, circle] (4) at (6,0) {4};\n\\node[draw, circle] (5) at (0,-2) {5};\n\\node[draw, circle] (6) at (2,-2) {6};\n\\node[draw, circle] (7) at (4,-2) {7};\n\n\\path[draw=red,thick,->,line width=2pt] (1) -- (5);\n\\path[draw=red,thick,->,line width=2pt] (5) -- (6);\n\\path[draw=red,thick,->,line width=2pt] (6) -- (3);\n\\path[draw=red,thick,->,line width=2pt] (3) -- (4);\n\\end{tikzpicture}\n\\end{center}\nAnd the second path may be as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {1};\n\\node[draw, circle] (2) at (2,0) {2};\n\\node[draw, circle] (3) at (4,0) {3};\n\\node[draw, circle] (4) at (6,0) {4};\n\\node[draw, circle] (5) at (0,-2) {5};\n\\node[draw, circle] (6) at (2,-2) {6};\n\\node[draw, circle] (7) at (4,-2) {7};\n\n\\path[draw=red,thick,->,line width=2pt] (2) -- (6);\n\\path[draw=red,thick,->,line width=2pt] (6) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nA minimum general path cover can be found\nalmost like a minimum node-disjoint path cover.\nIt suffices to add some new edges to the matching graph\nso that there is an edge $a \\rightarrow b$\nalways when there is a path from $a$ to $b$\nin the original graph (possibly through several edges).\n\nThe matching graph for the above graph is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1a) at (0,6) {1};\n\\node[draw, circle] (2a) at (0,5) {2};\n\\node[draw, circle] (3a) at (0,4) {3};\n\\node[draw, circle] (4a) at (0,3) {4};\n\\node[draw, circle] (5a) at (0,2) {5};\n\\node[draw, circle] (6a) at (0,1) {6};\n\\node[draw, circle] (7a) at (0,0) {7};\n\n\\node[draw, circle] (1b) at (4,6) {1};\n\\node[draw, circle] (2b) at (4,5) {2};\n\\node[draw, circle] (3b) at (4,4) {3};\n\\node[draw, circle] (4b) at (4,3) {4};\n\\node[draw, circle] (5b) at (4,2) {5};\n\\node[draw, circle] (6b) at (4,1) {6};\n\\node[draw, circle] (7b) at (4,0) {7};\n\n\\node[draw, circle] (a) at (-3,3) {\\phantom{0}};\n\\node[draw, circle] (b) at (7,3) {\\phantom{0}};\n\n\n%\\path[draw,thick,->,>=latex] (1a) -- (5b);\n\\path[draw,thick,->,>=latex] (1a) -- (6b);\n\\path[draw,thick,->,>=latex] (1a) -- (7b);\n\\path[draw,thick,->,>=latex] (1a) -- (3b);\n\\path[draw,thick,->,>=latex] (1a) -- (4b);\n\\path[draw,thick,->,>=latex] (5a) -- (6b);\n\\path[draw,thick,->,>=latex] (5a) -- (7b);\n%\\path[draw,thick,->,>=latex] (5a) -- (3b);\n\\path[draw,thick,->,>=latex] (5a) -- (4b);\n\\path[draw,thick,->,>=latex] (6a) -- (7b);\n%\\path[draw,thick,->,>=latex] (6a) -- (7b);\n\\path[draw,thick,->,>=latex] (6a) -- (3b);\n%\\path[draw,thick,->,>=latex] (3a) -- (4b);\n%\\path[draw,thick,->,>=latex] (2a) -- (6b);\n\\path[draw,thick,->,>=latex] (2a) -- (7b);\n\\path[draw,thick,->,>=latex] (2a) -- (3b);\n\\path[draw,thick,->,>=latex] (2a) -- (4b);\n\n\n\\path[draw,thick,->,>=latex] (a) -- (1a);\n\\path[draw,thick,->,>=latex] (a) -- (2a);\n\\path[draw,thick,->,>=latex] (a) -- (3a);\n\\path[draw,thick,->,>=latex] (a) -- (4a);\n\\path[draw,thick,->,>=latex] (a) -- (5a);\n\\path[draw,thick,->,>=latex] (a) -- (6a);\n\\path[draw,thick,->,>=latex] (a) -- (7a);\n\n\\path[draw,thick,->,>=latex] (1b) -- (b);\n\\path[draw,thick,->,>=latex] (2b) -- (b);\n\\path[draw,thick,->,>=latex] (3b) -- (b);\n\\path[draw,thick,->,>=latex] (4b) -- (b);\n\\path[draw,thick,->,>=latex] (5b) -- (b);\n\\path[draw,thick,->,>=latex] (6b) -- (b);\n\\path[draw,thick,->,>=latex] (7b) -- (b);\n\n\\path[draw=red,thick,->,line width=2pt] (1a) -- (5b);\n\\path[draw=red,thick,->,line width=2pt] (5a) -- (3b);\n\\path[draw=red,thick,->,line width=2pt] (3a) -- (4b);\n\\path[draw=red,thick,->,line width=2pt] (2a) -- (6b);\n\\path[draw=red,thick,->,line width=2pt] (6a) -- (7b);\n\n\n% \\path[draw=red,thick,->,line width=2pt] (1a) -- (6b);\n% \\path[draw=red,thick,->,line width=2pt] (1a) -- (7b);\n% \\path[draw=red,thick,->,line width=2pt] (1a) -- (3b);\n% \\path[draw=red,thick,->,line width=2pt] (1a) -- (4b);\n% \\path[draw=red,thick,->,line width=2pt] (5a) -- (6b);\n% \\path[draw=red,thick,->,line width=2pt] (5a) -- (7b);\n% \\path[draw=red,thick,->,line width=2pt] (5a) -- (3b);\n% \\path[draw=red,thick,->,line width=2pt] (5a) -- (4b);\n% \\path[draw=red,thick,->,line width=2pt] (6a) -- (7b);\n% \\path[draw=red,thick,->,line width=2pt] (6a) -- (7b);\n% \\path[draw=red,thick,->,line width=2pt] (6a) -- (3b);\n% \\path[draw=red,thick,->,line width=2pt] (3a) -- (4b);\n% \\path[draw=red,thick,->,line width=2pt] (2a) -- (6b);\n% \\path[draw=red,thick,->,line width=2pt] (2a) -- (7b);\n% \\path[draw=red,thick,->,line width=2pt] (2a) -- (3b);\n% \\path[draw=red,thick,->,line width=2pt] (2a) -- (4b);\n\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Dilworth's theorem}\n\n\\index{Dilworth's theorem}\n\\index{antichain}\n\nAn \\key{antichain} is a set of nodes of a graph\nsuch that there is no path\nfrom any node to another node\nusing the edges of the graph.\n\\key{Dilworth's theorem} states that\nin a directed acyclic graph, the size of\na minimum general path cover\nequals the size of a maximum antichain.\n\nFor example, nodes 3 and 7 form an antichain\nin the following graph:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {1};\n\\node[draw, circle] (2) at (2,0) {2};\n\\node[draw, circle, fill=lightgray] (3) at (4,0) {3};\n\\node[draw, circle] (4) at (6,0) {4};\n\\node[draw, circle] (5) at (0,-2) {5};\n\\node[draw, circle] (6) at (2,-2) {6};\n\\node[draw, circle, fill=lightgray] (7) at (4,-2) {7};\n\n\\path[draw,thick,->,>=latex] (1) -- (5);\n\\path[draw,thick,->,>=latex] (2) -- (6);\n\\path[draw,thick,->,>=latex] (3) -- (4);\n\\path[draw,thick,->,>=latex] (5) -- (6);\n\\path[draw,thick,->,>=latex] (6) -- (3);\n\\path[draw,thick,->,>=latex] (6) -- (7);\n\\end{tikzpicture}\n\\end{center}\n\nThis is a maximum antichain, because it is not possible\nto construct any antichain that would contain three nodes.\nWe have seen before that the size of a minimum\ngeneral path cover of this graph consists of two paths.\n", "chapter_name": "Flows and cuts", "chapter_path": "cphb/chapter20.tex"}, {"section_name": "Primes and factors", "section_content": "\\chapter{Number theory}\n\n\\index{number theory}\n\n\\key{Number theory} is a branch of mathematics\nthat studies integers.\nNumber theory is a fascinating field,\nbecause many questions involving integers\nare very difficult to solve even if they\nseem simple at first glance.\n\nAs an example, consider the following equation:\n\\[x^3 + y^3 + z^3 = 33\\]\nIt is easy to find three real numbers $x$, $y$ and $z$\nthat satisfy the equation.\nFor example, we can choose\n\\[\n\\begin{array}{lcl}\nx = 3, \\\\\ny = \\sqrt[3]{3}, \\\\\nz = \\sqrt[3]{3}.\\\\\n\\end{array}\n\\]\nHowever, it is an open problem in number theory\nif there are any three\n\\emph{integers} $x$, $y$ and $z$\nthat would satisfy the equation \\cite{bec07}.\n\nIn this chapter, we will focus on basic concepts\nand algorithms in number theory.\nThroughout the chapter, we will assume that all numbers\nare integers, if not otherwise stated.\n\n\\section{Primes and factors}\n\n\\index{divisibility}\n\\index{factor}\n\\index{divisor}\n\nA number $a$ is called a \\key{factor} or a \\key{divisor} of a number $b$\nif $a$ divides $b$.\nIf $a$ is a factor of $b$,\nwe write $a \\mid b$, and otherwise we write $a \\nmid b$.\nFor example, the factors of 24 are\n1, 2, 3, 4, 6, 8, 12 and 24.\n\n\\index{prime}\n\\index{prime decomposition}\n\nA number $n>1$ is a \\key{prime}\nif its only positive factors are 1 and $n$.\nFor example, 7, 19 and 41 are primes,\nbut 35 is not a prime, because $5 \\cdot 7 = 35$.\nFor every number $n>1$, there is a unique\n\\key{prime factorization}\n\\[ n = p_1^{\\alpha_1} p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k},\\]\nwhere $p_1,p_2,\\ldots,p_k$ are distinct primes and\n$\\alpha_1,\\alpha_2,\\ldots,\\alpha_k$ are positive numbers.\nFor example, the prime factorization for 84 is\n\\[84 = 2^2 \\cdot 3^1 \\cdot 7^1.\\]\n\nThe \\key{number of factors} of a number $n$ is\n\\[\\tau(n)=\\prod_{i=1}^k (\\alpha_i+1),\\]\nbecause for each prime $p_i$, there are\n$\\alpha_i+1$ ways to choose how many times\nit appears in the factor.\nFor example, the number of factors\nof 84 is\n$\\tau(84)=3 \\cdot 2 \\cdot 2 = 12$.\nThe factors are\n1, 2, 3, 4, 6, 7, 12, 14, 21, 28, 42 and 84.\n\nThe \\key{sum of factors} of $n$ is\n\\[\\sigma(n)=\\prod_{i=1}^k (1+p_i+\\ldots+p_i^{\\alpha_i}) = \\prod_{i=1}^k \\frac{p_i^{a_i+1}-1}{p_i-1},\\]\nwhere the latter formula is based on the geometric progression formula.\nFor example, the sum of factors of 84 is\n\\[\\sigma(84)=\\frac{2^3-1}{2-1} \\cdot \\frac{3^2-1}{3-1} \\cdot \\frac{7^2-1}{7-1} = 7 \\cdot 4 \\cdot 8 = 224.\\]\n\nThe \\key{product of factors} of $n$ is\n\\[\\mu(n)=n^{\\tau(n)/2},\\]\nbecause we can form $\\tau(n)/2$ pairs from the factors,\neach with product $n$.\nFor example, the factors of 84\nproduce the pairs\n$1 \\cdot 84$, $2 \\cdot 42$, $3 \\cdot 28$, etc.,\nand the product of the factors is $\\mu(84)=84^6=351298031616$.\n\n\\index{perfect number}\n\nA number $n$ is called a \\key{perfect number} if $n=\\sigma(n)-n$,\ni.e., $n$ equals the sum of its factors\nbetween $1$ and $n-1$.\nFor example, 28 is a perfect number,\nbecause $28=1+2+4+7+14$.\n\n\\subsubsection{Number of primes}\n\nIt is easy to show that there is an infinite number\nof primes.\nIf the number of primes would be finite,\nwe could construct a set $P=\\{p_1,p_2,\\ldots,p_n\\}$\nthat would contain all the primes.\nFor example, $p_1=2$, $p_2=3$, $p_3=5$, and so on.\nHowever, using $P$, we could form a new prime\n\\[p_1 p_2 \\cdots p_n+1\\]\nthat is larger than all elements in $P$.\nThis is a contradiction, and the number of primes\nhas to be infinite.\n\n\\subsubsection{Density of primes}\n\nThe density of primes means how often there are primes\namong the numbers.\nLet $\\pi(n)$ denote the number of primes between\n$1$ and $n$. For example, $\\pi(10)=4$, because\nthere are 4 primes between $1$ and $10$: 2, 3, 5 and 7.\n\nIt is possible to show that\n\\[\\pi(n) \\approx \\frac{n}{\\ln n},\\]\nwhich means that primes are quite frequent.\nFor example, the number of primes between\n$1$ and $10^6$ is $\\pi(10^6)=78498$,\nand $10^6 / \\ln 10^6 \\approx 72382$.\n\n\\subsubsection{Conjectures}\n\nThere are many \\emph{conjectures} involving primes.\nMost people think that the conjectures are true,\nbut nobody has been able to prove them.\nFor example, the following conjectures are famous:\n\n\\begin{itemize}\n\\index{Goldbach's conjecture}\n\\item \\key{Goldbach's conjecture}:\nEach even integer $n>2$ can be represented as a\nsum $n=a+b$ so that both $a$ and $b$ are primes.\n\\index{twin prime}\n\\item \\key{Twin prime conjecture}:\nThere is an infinite number of pairs\nof the form $\\{p,p+2\\}$,\nwhere both $p$ and $p+2$ are primes.\n\\index{Legendre's conjecture}\n\\item \\key{Legendre's conjecture}:\nThere is always a prime between numbers\n$n^2$ and $(n+1)^2$, where $n$ is any positive integer.\n\\end{itemize}\n\n\\subsubsection{Basic algorithms}\n\nIf a number $n$ is not prime,\nit can be represented as a product $a \\cdot b$,\nwhere $a \\le \\sqrt n$ or $b \\le \\sqrt n$,\nso it certainly has a factor between $2$ and $\\lfloor \\sqrt n \\rfloor$.\nUsing this observation, we can both test\nif a number is prime and find the prime factorization\nof a number in $O(\\sqrt n)$ time.\n\nThe following function \\texttt{prime} checks\nif the given number $n$ is prime.\nThe function attempts to divide $n$ by\nall numbers between $2$ and $\\lfloor \\sqrt n \\rfloor$,\nand if none of them divides $n$, then $n$ is prime.\n\n\\begin{lstlisting}\nbool prime(int n) {\n    if (n < 2) return false;\n    for (int x = 2; x*x <= n; x++) {\n        if (n%x == 0) return false;\n    }\n    return true;\n}\n\\end{lstlisting}\n\n\\noindent\nThe following function \\texttt{factors}\nconstructs a vector that contains the prime\nfactorization of $n$.\nThe function divides $n$ by its prime factors,\nand adds them to the vector.\nThe process ends when the remaining number $n$\nhas no factors between $2$ and $\\lfloor \\sqrt n \\rfloor$.\nIf $n>1$, it is prime and the last factor.\n\n\\begin{lstlisting}\nvector<int> factors(int n) {\n    vector<int> f;\n    for (int x = 2; x*x <= n; x++) {\n        while (n%x == 0) {\n            f.push_back(x);\n            n /= x;\n        }\n    }\n    if (n > 1) f.push_back(n);\n    return f;\n}\n\\end{lstlisting}\n\nNote that each prime factor appears in the vector\nas many times as it divides the number.\nFor example, $24=2^3 \\cdot 3$,\nso the result of the function is $[2,2,2,3]$.\n\n\\subsubsection{Sieve of Eratosthenes}\n\n\\index{sieve of Eratosthenes}\n\nThe \\key{sieve of Eratosthenes}\n%\\footnote{Eratosthenes (c. 276 BC -- c. 194 BC) was a Greek mathematician.}\nis a preprocessing\nalgorithm that builds an array using which we\ncan efficiently check if a given number between $2 \\ldots n$\nis prime and, if it is not, find one prime factor of the number.\n\nThe algorithm builds an array $\\texttt{sieve}$\nwhose positions $2,3,\\ldots,n$ are used.\nThe value $\\texttt{sieve}[k]=0$ means\nthat $k$ is prime,\nand the value $\\texttt{sieve}[k] \\neq 0$\nmeans that $k$ is not a prime and one\nof its prime factors is $\\texttt{sieve}[k]$.\n\nThe algorithm iterates through the numbers\n$2 \\ldots n$ one by one.\nAlways when a new prime $x$ is found,\nthe algorithm records that the multiples\nof $x$ ($2x,3x,4x,\\ldots$) are not primes,\nbecause the number $x$ divides them.\n\nFor example, if $n=20$, the array is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (19,1);\n\n\\node at (0.5,0.5) {$0$};\n\\node at (1.5,0.5) {$0$};\n\\node at (2.5,0.5) {$2$};\n\\node at (3.5,0.5) {$0$};\n\\node at (4.5,0.5) {$3$};\n\\node at (5.5,0.5) {$0$};\n\\node at (6.5,0.5) {$2$};\n\\node at (7.5,0.5) {$3$};\n\\node at (8.5,0.5) {$5$};\n\\node at (9.5,0.5) {$0$};\n\\node at (10.5,0.5) {$3$};\n\\node at (11.5,0.5) {$0$};\n\\node at (12.5,0.5) {$7$};\n\\node at (13.5,0.5) {$5$};\n\\node at (14.5,0.5) {$2$};\n\\node at (15.5,0.5) {$0$};\n\\node at (16.5,0.5) {$3$};\n\\node at (17.5,0.5) {$0$};\n\\node at (18.5,0.5) {$5$};\n\n\\footnotesize\n\n\\node at (0.5,1.5) {$2$};\n\\node at (1.5,1.5) {$3$};\n\\node at (2.5,1.5) {$4$};\n\\node at (3.5,1.5) {$5$};\n\\node at (4.5,1.5) {$6$};\n\\node at (5.5,1.5) {$7$};\n\\node at (6.5,1.5) {$8$};\n\\node at (7.5,1.5) {$9$};\n\\node at (8.5,1.5) {$10$};\n\\node at (9.5,1.5) {$11$};\n\\node at (10.5,1.5) {$12$};\n\\node at (11.5,1.5) {$13$};\n\\node at (12.5,1.5) {$14$};\n\\node at (13.5,1.5) {$15$};\n\\node at (14.5,1.5) {$16$};\n\\node at (15.5,1.5) {$17$};\n\\node at (16.5,1.5) {$18$};\n\\node at (17.5,1.5) {$19$};\n\\node at (18.5,1.5) {$20$};\n\n\\end{tikzpicture}\n\\end{center}\n\nThe following code implements the sieve of\nEratosthenes.\nThe code assumes that each element of\n\\texttt{sieve} is initially zero.\n\n\\begin{lstlisting}\nfor (int x = 2; x <= n; x++) {\n    if (sieve[x]) continue;\n    for (int u = 2*x; u <= n; u += x) {\n        sieve[u] = x;\n    }\n}\n\\end{lstlisting}\n\nThe inner loop of the algorithm is executed\n$n/x$ times for each value of $x$.\nThus, an upper bound for the running time\nof the algorithm is the harmonic sum\n\\[\\sum_{x=2}^n n/x = n/2 + n/3 + n/4 + \\cdots + n/n = O(n \\log n).\\]\n\n\\index{harmonic sum}\n\nIn fact, the algorithm is more efficient,\nbecause the inner loop will be executed only if\nthe number $x$ is prime.\nIt can be shown that the running time of the\nalgorithm is only $O(n \\log \\log n)$,\na complexity very near to $O(n)$. \n\n\\subsubsection{Euclid's algorithm}\n\n\\index{greatest common divisor}\n\\index{least common multiple}\n\\index{Euclid's algorithm}\n\nThe \\key{greatest common divisor} of\nnumbers $a$ and $b$, $\\gcd(a,b)$,\nis the greatest number that divides both $a$ and $b$,\nand the \\key{least common multiple} of\n$a$ and $b$, $\\textrm{lcm}(a,b)$,\nis the smallest number that is divisible by\nboth $a$ and $b$.\nFor example,\n$\\gcd(24,36)=12$ and\n$\\textrm{lcm}(24,36)=72$.\n\nThe greatest common divisor and the least common multiple\nare connected as follows:\n\\[\\textrm{lcm}(a,b)=\\frac{ab}{\\textrm{gcd}(a,b)}\\]\n\n\\key{Euclid's algorithm}\\footnote{Euclid was a Greek mathematician who\nlived in about 300 BC. This is perhaps the first known algorithm in history.} provides an efficient way\nto find the greatest common divisor of two numbers.\nThe algorithm is based on the following formula:\n\\begin{equation*}\n    \\textrm{gcd}(a,b) = \\begin{cases}\n               a        & b = 0\\\\\n               \\textrm{gcd}(b,a \\bmod b) & b \\neq 0\\\\\n           \\end{cases}\n\\end{equation*}\n\nFor example,\n\\[\\textrm{gcd}(24,36) = \\textrm{gcd}(36,24)\n= \\textrm{gcd}(24,12) = \\textrm{gcd}(12,0)=12.\\]\n\nThe algorithm can be implemented as follows:\n\\begin{lstlisting}\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a%b);\n}\n\\end{lstlisting}\n\nIt can be shown that Euclid's algorithm works\nin $O(\\log n)$ time, where $n=\\min(a,b)$.\nThe worst case for the algorithm is\nthe case when $a$ and $b$ are consecutive Fibonacci numbers.\nFor example,\n\\[\\textrm{gcd}(13,8)=\\textrm{gcd}(8,5)\n=\\textrm{gcd}(5,3)=\\textrm{gcd}(3,2)=\\textrm{gcd}(2,1)=\\textrm{gcd}(1,0)=1.\\]\n\n\\subsubsection{Euler's totient function}\n\n\\index{coprime}\n\\index{Euler's totient function}\n\nNumbers $a$ and $b$ are \\key{coprime}\nif $\\textrm{gcd}(a,b)=1$.\n\\key{Euler's totient function} $\\varphi(n)$\n%\\footnote{Euler presented this function in 1763.}\ngives the number of coprime numbers to $n$\nbetween $1$ and $n$.\nFor example, $\\varphi(12)=4$,\nbecause 1, 5, 7 and 11\nare coprime to 12.\n\nThe value of $\\varphi(n)$ can be calculated\nfrom the prime factorization of $n$\nusing the formula\n\\[ \\varphi(n) = \\prod_{i=1}^k p_i^{\\alpha_i-1}(p_i-1). \\]\nFor example, $\\varphi(12)=2^1 \\cdot (2-1) \\cdot 3^0 \\cdot (3-1)=4$.\nNote that $\\varphi(n)=n-1$ if $n$ is prime.\n\n", "chapter_name": "Number theory", "chapter_path": "cphb/chapter21.tex"}, {"section_name": "Modular arithmetic", "section_content": "\\section{Modular arithmetic}\n\n\\index{modular arithmetic}\n\nIn \\key{modular arithmetic},\nthe set of numbers is limited so\nthat only numbers $0,1,2,\\ldots,m-1$ are used,\nwhere $m$ is a constant.\nEach number $x$ is\nrepresented by the number $x \\bmod m$:\nthe remainder after dividing $x$ by $m$.\nFor example, if $m=17$, then $75$\nis represented by $75 \\bmod 17 = 7$.\n\nOften we can take remainders before doing\ncalculations.\nIn particular, the following formulas hold:\n\\[\n\\begin{array}{rcl}\n(x+y) \\bmod m & = & (x \\bmod m + y \\bmod m) \\bmod m \\\\\n(x-y) \\bmod m & = & (x \\bmod m - y \\bmod m) \\bmod m \\\\\n(x \\cdot y) \\bmod m & = & (x \\bmod m \\cdot y \\bmod m) \\bmod m \\\\\nx^n \\bmod m & = & (x \\bmod m)^n \\bmod m \\\\\n\\end{array}\n\\]\n\n\\subsubsection{Modular exponentiation}\n\nThere is often need to efficiently calculate\nthe value of $x^n \\bmod m$.\nThis can be done in $O(\\log n)$ time\nusing the following recursion:\n\\begin{equation*}\n    x^n = \\begin{cases}\n               1        & n = 0\\\\\n               x^{n/2} \\cdot x^{n/2} & \\text{$n$ is even}\\\\\n               x^{n-1} \\cdot x & \\text{$n$ is odd}\n           \\end{cases}\n\\end{equation*}\n\nIt is important that in the case of an even $n$,\nthe value of $x^{n/2}$ is calculated only once.\nThis guarantees that the time complexity of the\nalgorithm is $O(\\log n)$, because $n$ is always halved\nwhen it is even.\n\nThe following function calculates the value of\n$x^n \\bmod m$:\n\n\\begin{lstlisting}\nint modpow(int x, int n, int m) {\n    if (n == 0) return 1%m;\n    long long u = modpow(x,n/2,m);\n    u = (u*u)%m;\n    if (n%2 == 1) u = (u*x)%m;\n    return u;\n}\n\\end{lstlisting}\n\n\\subsubsection{Fermat's theorem and Euler's theorem}\n\n\\index{Fermat's theorem}\n\\index{Euler's theorem}\n\n\\key{Fermat's theorem}\n%\\footnote{Fermat discovered this theorem in 1640.}\nstates that\n\\[x^{m-1} \\bmod m = 1\\]\nwhen $m$ is prime and $x$ and $m$ are coprime.\nThis also yields\n\\[x^k \\bmod m = x^{k \\bmod (m-1)} \\bmod m.\\]\nMore generally, \\key{Euler's theorem}\n%\\footnote{Euler published this theorem in 1763.}\nstates that\n\\[x^{\\varphi(m)} \\bmod m = 1\\]\nwhen $x$ and $m$ are coprime.\nFermat's theorem follows from Euler's theorem,\nbecause if $m$ is a prime, then $\\varphi(m)=m-1$.\n\n\\subsubsection{Modular inverse}\n\n\\index{modular inverse}\n\nThe inverse of $x$ modulo $m$\nis a number $x^{-1}$ such that\n\\[ x x^{-1} \\bmod m = 1. \\]\nFor example, if $x=6$ and $m=17$,\nthen $x^{-1}=3$, because $6\\cdot3 \\bmod 17=1$.\n\nUsing modular inverses, we can divide numbers\nmodulo $m$, because division by $x$\ncorresponds to multiplication by $x^{-1}$.\nFor example, to evaluate the value of $36/6 \\bmod 17$,\nwe can use the formula $2 \\cdot 3 \\bmod 17$,\nbecause $36 \\bmod 17 = 2$ and $6^{-1} \\bmod 17 = 3$.\n\nHowever, a modular inverse does not always exist.\nFor example, if $x=2$ and $m=4$, the equation\n\\[ x x^{-1} \\bmod m = 1 \\]\ncannot be solved, because all multiples of 2\nare even and the remainder can never be 1 when $m=4$.\nIt turns out that the value of $x^{-1} \\bmod m$\ncan be calculated exactly when $x$ and $m$ are coprime.\n\nIf a modular inverse exists, it can be\ncalculated using the formula\n\\[\nx^{-1} = x^{\\varphi(m)-1}.\n\\]\nIf $m$ is prime, the formula becomes\n\\[\nx^{-1} = x^{m-2}.\n\\]\nFor example,\n\\[6^{-1} \\bmod 17 =6^{17-2} \\bmod 17 = 3.\\]\n\nThis formula allows us to efficiently calculate\nmodular inverses using the modular exponentation algorithm.\nThe formula can be derived using Euler's theorem.\nFirst, the modular inverse should satisfy the following equation:\n\\[\nx x^{-1} \\bmod m = 1.\n\\]\nOn the other hand, according to Euler's theorem,\n\\[\nx^{\\varphi(m)} \\bmod m =  xx^{\\varphi(m)-1} \\bmod m = 1,\n\\]\nso the numbers $x^{-1}$ and $x^{\\varphi(m)-1}$ are equal.\n\n\\subsubsection{Computer arithmetic}\n\nIn programming, unsigned integers are represented modulo $2^k$,\nwhere $k$ is the number of bits of the data type.\nA usual consequence of this is that a number wraps around\nif it becomes too large.\n\nFor example, in C++, numbers of type \\texttt{unsigned int}\nare represented modulo $2^{32}$.\nThe following code declares an \\texttt{unsigned int}\nvariable whose value is $123456789$.\nAfter this, the value will be multiplied by itself,\nand the result is\n$123456789^2 \\bmod 2^{32} = 2537071545$.\n\n\\begin{lstlisting}\nunsigned int x = 123456789;\ncout << x*x << \"\\n\"; // 2537071545\n\\end{lstlisting}\n\n", "chapter_name": "Number theory", "chapter_path": "cphb/chapter21.tex"}, {"section_name": "Solving equations", "section_content": "\\section{Solving equations}\n\n\\subsubsection*{Diophantine equations}\n\n\\index{Diophantine equation}\n\nA \\key{Diophantine equation}\n%\\footnote{Diophantus of Alexandria was a Greek mathematician who lived in the 3th century.}\nis an equation of the form\n\\[ ax + by = c, \\]\nwhere $a$, $b$ and $c$ are constants\nand the values of $x$ and $y$ should be found.\nEach number in the equation has to be an integer.\nFor example, one solution for the equation\n$5x+2y=11$ is $x=3$ and $y=-2$.\n\n\\index{extended Euclid's algorithm}\n\nWe can efficiently solve a Diophantine equation\nby using Euclid's algorithm.\nIt turns out that we can extend Euclid's algorithm\nso that it will find numbers $x$ and $y$\nthat satisfy the following equation:\n\\[\nax + by = \\textrm{gcd}(a,b)\n\\]\n\nA Diophantine equation can be solved if\n$c$ is divisible by\n$\\textrm{gcd}(a,b)$,\nand otherwise it cannot be solved.\n\nAs an example, let us find numbers $x$ and $y$\nthat satisfy the following equation:\n\\[\n39x + 15y = 12\n\\]\nThe equation can be solved, because\n$\\textrm{gcd}(39,15)=3$ and $3 \\mid 12$.\nWhen Euclid's algorithm calculates the\ngreatest common divisor of 39 and 15,\nit produces the following sequence of function calls:\n\\[\n\\textrm{gcd}(39,15) = \\textrm{gcd}(15,9)\n= \\textrm{gcd}(9,6) = \\textrm{gcd}(6,3)\n= \\textrm{gcd}(3,0) = 3 \\]\nThis corresponds to the following equations:\n\\[\n\\begin{array}{lcl}\n39 - 2 \\cdot 15 & = & 9 \\\\\n15 - 1 \\cdot 9 & = & 6 \\\\\n9 - 1 \\cdot 6 & = & 3 \\\\\n\\end{array}\n\\]\nUsing these equations, we can derive\n\\[\n39 \\cdot 2 + 15 \\cdot (-5) = 3\n\\]\nand by multiplying this by 4, the result is\n\\[\n39 \\cdot 8 + 15 \\cdot (-20) = 12,\n\\]\nso a solution to the equation is\n$x=8$ and $y=-20$.\n\nA solution to a Diophantine equation is not unique,\nbecause we can form an infinite number of solutions\nif we know one solution.\nIf a pair $(x,y)$ is a solution, then also all pairs\n\\[(x+\\frac{kb}{\\textrm{gcd}(a,b)},y-\\frac{ka}{\\textrm{gcd}(a,b)})\\]\nare solutions, where $k$ is any integer.\n\n\\subsubsection{Chinese remainder theorem}\n\n\\index{Chinese remainder theorem}\n\nThe \\key{Chinese remainder theorem} solves\na group of equations of the form\n\\[\n\\begin{array}{lcl}\nx & = & a_1 \\bmod m_1 \\\\\nx & = & a_2 \\bmod m_2 \\\\\n\\cdots \\\\\nx & = & a_n \\bmod m_n \\\\\n\\end{array}\n\\]\nwhere all pairs of $m_1,m_2,\\ldots,m_n$ are coprime.\n\nLet $x^{-1}_m$ be the inverse of $x$ modulo $m$, and\n\\[ X_k = \\frac{m_1 m_2 \\cdots m_n}{m_k}.\\]\nUsing this notation, a solution to the equations is\n\\[x = a_1 X_1 {X_1}^{-1}_{m_1} + a_2 X_2 {X_2}^{-1}_{m_2} + \\cdots + a_n X_n {X_n}^{-1}_{m_n}.\\]\nIn this solution, for each $k=1,2,\\ldots,n$,\n\\[a_k X_k {X_k}^{-1}_{m_k} \\bmod m_k = a_k,\\]\nbecause\n\\[X_k {X_k}^{-1}_{m_k} \\bmod m_k = 1.\\]\nSince all other terms in the sum are divisible by $m_k$,\nthey have no effect on the remainder,\nand $x \\bmod m_k = a_k$.\n\nFor example, a solution for\n\\[\n\\begin{array}{lcl}\nx & = & 3 \\bmod 5 \\\\\nx & = & 4 \\bmod 7 \\\\\nx & = & 2 \\bmod 3 \\\\\n\\end{array}\n\\]\nis\n\\[ 3 \\cdot 21 \\cdot 1 + 4 \\cdot 15 \\cdot 1 + 2 \\cdot 35 \\cdot 2 = 263.\\]\n\nOnce we have found a solution $x$,\nwe can create an infinite number of other solutions,\nbecause all numbers of the form\n\\[x+m_1 m_2 \\cdots m_n\\]\nare solutions.\n\n", "chapter_name": "Number theory", "chapter_path": "cphb/chapter21.tex"}, {"section_name": "Other results", "section_content": "\\section{Other results}\n\n\\subsubsection{Lagrange's theorem}\n\n\\index{Lagrange's theorem}\n\n\\key{Lagrange's theorem}\n%\\footnote{J.-L. Lagrange (1736--1813) was an Italian mathematician.}\nstates that every positive integer\ncan be represented as a sum of four squares, i.e.,\n$a^2+b^2+c^2+d^2$.\nFor example, the number 123 can be represented\nas the sum $8^2+5^2+5^2+3^2$.\n\n\\subsubsection{Zeckendorf's theorem}\n\n\\index{Zeckendorf's theorem}\n\\index{Fibonacci number}\n\n\\key{Zeckendorf's theorem}\n%\\footnote{E. Zeckendorf published the theorem in 1972 \\cite{zec72}; however, this was not a new result.}\nstates that every\npositive integer has a unique representation\nas a sum of Fibonacci numbers such that\nno two numbers are equal or consecutive\nFibonacci numbers.\nFor example, the number 74 can be represented\nas the sum $55+13+5+1$.\n\n\\subsubsection{Pythagorean triples}\n\n\\index{Pythagorean triple}\n\\index{Euclid's formula}\n\nA \\key{Pythagorean triple} is a triple $(a,b,c)$\nthat satisfies the Pythagorean theorem\n$a^2+b^2=c^2$, which means that there is a right triangle\nwith side lengths $a$, $b$ and $c$.\nFor example, $(3,4,5)$ is a Pythagorean triple.\n\nIf $(a,b,c)$ is a Pythagorean triple,\nall triples of the form $(ka,kb,kc)$\nare also Pythagorean triples where $k>1$.\nA Pythagorean triple is \\emph{primitive} if\n$a$, $b$ and $c$ are coprime,\nand all Pythagorean triples can be constructed\nfrom primitive triples using a multiplier $k$.\n\n\\key{Euclid's formula} can be used to produce\nall primitive Pythagorean triples.\nEach such triple is of the form\n\\[(n^2-m^2,2nm,n^2+m^2),\\]\nwhere $0<m<n$, $n$ and $m$ are coprime\nand at least one of $n$ and $m$ is even.\nFor example, when $m=1$ and $n=2$, the formula\nproduces the smallest Pythagorean triple\n\\[(2^2-1^2,2\\cdot2\\cdot1,2^2+1^2)=(3,4,5).\\]\n\n\\subsubsection{Wilson's theorem}\n\n\\index{Wilson's theorem}\n\n\\key{Wilson's theorem}\n%\\footnote{J. Wilson (1741--1793) was an English mathematician.}\nstates that a number $n$\nis prime exactly when\n\\[(n-1)! \\bmod n = n-1.\\]\nFor example, the number 11 is prime, because\n\\[10! \\bmod 11 = 10,\\]\nand the number 12 is not prime, because\n\\[11! \\bmod 12 = 0 \\neq 11.\\]\n\nHence, Wilson's theorem can be used to find out\nwhether a number is prime. However, in practice, the theorem cannot be\napplied to large values of $n$, because it is difficult\nto calculate values of $(n-1)!$ when $n$ is large.\n\n\n", "chapter_name": "Number theory", "chapter_path": "cphb/chapter21.tex"}, {"section_name": "Binomial coefficients", "section_content": "\\chapter{Combinatorics}\n\n\\index{combinatorics}\n\n\\key{Combinatorics} studies methods for counting\ncombinations of objects.\nUsually, the goal is to find a way to\ncount the combinations efficiently\nwithout generating each combination separately.\n\nAs an example, consider the problem\nof counting the number of ways to\nrepresent an integer $n$ as a sum of positive integers.\nFor example, there are 8 representations\nfor $4$:\n\\begin{multicols}{2}\n\\begin{itemize}\n\\item $1+1+1+1$\n\\item $1+1+2$\n\\item $1+2+1$\n\\item $2+1+1$\n\\item $2+2$\n\\item $3+1$\n\\item $1+3$\n\\item $4$\n\\end{itemize}\n\\end{multicols}\n\nA combinatorial problem can often be solved\nusing a recursive function.\nIn this problem, we can define a function $f(n)$\nthat gives the number of representations for $n$.\nFor example, $f(4)=8$ according to the above example.\nThe values of the function\ncan be recursively calculated as follows:\n\\begin{equation*}\n    f(n) = \\begin{cases}\n               1               & n = 0\\\\\n               f(0)+f(1)+\\cdots+f(n-1) & n > 0\\\\\n           \\end{cases}\n\\end{equation*}\nThe base case is $f(0)=1$,\nbecause the empty sum represents the number 0.\nThen, if $n>0$, we consider all ways to\nchoose the first number of the sum.\nIf the first number is $k$,\nthere are $f(n-k)$ representations\nfor the remaining part of the sum.\nThus, we calculate the sum of all values\nof the form $f(n-k)$ where $k<n$.\n\nThe first values for the function are:\n\\[\n\\begin{array}{lcl}\nf(0) & = & 1 \\\\\nf(1) & = & 1 \\\\\nf(2) & = & 2 \\\\\nf(3) & = & 4 \\\\\nf(4) & = & 8 \\\\\n\\end{array}\n\\]\n\nSometimes, a recursive formula can be replaced\nwith a closed-form formula.\nIn this problem,\n\\[\nf(n)=2^{n-1},\n\\]\nwhich is based on the fact that there are $n-1$\npossible positions for +-signs in the sum\nand we can choose any subset of them.\n\n\\section{Binomial coefficients}\n\n\\index{binomial coefficient}\n\nThe \\key{binomial coefficient} ${n \\choose k}$\nequals the number of ways we can choose a subset\nof $k$ elements from a set of $n$ elements.\nFor example, ${5 \\choose 3}=10$,\nbecause the set $\\{1,2,3,4,5\\}$\nhas 10 subsets of 3 elements:\n\\[ \\{1,2,3\\}, \\{1,2,4\\}, \\{1,2,5\\}, \\{1,3,4\\}, \\{1,3,5\\}, \n\\{1,4,5\\}, \\{2,3,4\\}, \\{2,3,5\\}, \\{2,4,5\\}, \\{3,4,5\\} \\]\n\n\\subsubsection{Formula 1}\n\nBinomial coefficients can be\nrecursively calculated as follows:\n\n\\[\n{n \\choose k}  =  {n-1 \\choose k-1} + {n-1 \\choose k}\n\\]\n\nThe idea is to fix an element $x$ in the set.\nIf $x$ is included in the subset,\nwe have to choose $k-1$\nelements from $n-1$ elements,\nand if $x$ is not included in the subset,\nwe have to choose $k$ elements from $n-1$ elements.\n\nThe base cases for the recursion are\n\\[\n{n \\choose 0}  =  {n \\choose n} = 1,\n\\]\nbecause there is always exactly\none way to construct an empty subset\nand a subset that contains all the elements.\n\n\\subsubsection{Formula 2}\n\nAnother way to calculate binomial coefficients is as follows:\n\\[\n{n \\choose k}  =  \\frac{n!}{k!(n-k)!}.\n\\]\n\nThere are $n!$ permutations of $n$ elements.\nWe go through all permutations and always\ninclude the first $k$ elements of the permutation\nin the subset.\nSince the order of the elements in the subset\nand outside the subset does not matter,\nthe result is divided by $k!$ and $(n-k)!$\n\n\\subsubsection{Properties}\n\nFor binomial coefficients,\n\\[\n{n \\choose k}  =  {n \\choose n-k},\n\\]\nbecause we actually divide a set of $n$ elements into\ntwo subsets: the first contains $k$ elements\nand the second contains $n-k$ elements.\n\nThe sum of binomial coefficients is\n\\[\n{n \\choose 0}+{n \\choose 1}+{n \\choose 2}+\\ldots+{n \\choose n}=2^n.\n\\]\n\nThe reason for the name ''binomial coefficient''\ncan be seen when the binomial $(a+b)$ is raised to\nthe $n$th power:\n\n\\[ (a+b)^n =\n{n \\choose 0} a^n b^0 + \n{n \\choose 1} a^{n-1} b^1 +\n\\ldots + \n{n \\choose n-1} a^1 b^{n-1} +\n{n \\choose n} a^0 b^n. \\]\n\n\\index{Pascal's triangle}\n\nBinomial coefficients also appear in\n\\key{Pascal's triangle}\nwhere each value equals the sum of two\nabove values:\n\\begin{center}\n\\begin{tikzpicture}{0.9}\n\\node at (0,0) {1};\n\\node at (-0.5,-0.5) {1};\n\\node at (0.5,-0.5) {1};\n\\node at (-1,-1) {1};\n\\node at (0,-1) {2};\n\\node at (1,-1) {1};\n\\node at (-1.5,-1.5) {1};\n\\node at (-0.5,-1.5) {3};\n\\node at (0.5,-1.5) {3};\n\\node at (1.5,-1.5) {1};\n\\node at (-2,-2) {1};\n\\node at (-1,-2) {4};\n\\node at (0,-2) {6};\n\\node at (1,-2) {4};\n\\node at (2,-2) {1};\n\\node at (-2,-2.5) {$\\ldots$};\n\\node at (-1,-2.5) {$\\ldots$};\n\\node at (0,-2.5) {$\\ldots$};\n\\node at (1,-2.5) {$\\ldots$};\n\\node at (2,-2.5) {$\\ldots$};\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Boxes and balls}\n\n''Boxes and balls'' is a useful model,\nwhere we count the ways to\nplace $k$ balls in $n$ boxes.\nLet us consider three scenarios:\n\n\\textit{Scenario 1}: Each box can contain\nat most one ball.\nFor example, when $n=5$ and $k=2$,\nthere are 10 solutions:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.5]\n\\newcommand\\lax[3]{\n\\path[draw,thick,-] (#1-0.5,#2+0.5) -- (#1-0.5,#2-0.5) --\n                    (#1+0.5,#2-0.5) -- (#1+0.5,#2+0.5);\n\\ifthenelse{\\equal{#3}{1}}{\\draw[fill=black] (#1,#2-0.3) circle (0.15);}{}\n\\ifthenelse{\\equal{#3}{2}}{\\draw[fill=black] (#1-0.2,#2-0.3) circle (0.15);}{}\n\\ifthenelse{\\equal{#3}{2}}{\\draw[fill=black] (#1+0.2,#2-0.3) circle (0.15);}{}\n}\n\\newcommand\\laa[7]{\n    \\lax{#1}{#2}{#3}\n    \\lax{#1+1.2}{#2}{#4}\n    \\lax{#1+2.4}{#2}{#5}\n    \\lax{#1+3.6}{#2}{#6}\n    \\lax{#1+4.8}{#2}{#7}\n}\n\n\\laa{0}{0}{1}{1}{0}{0}{0}\n\\laa{0}{-2}{1}{0}{1}{0}{0}\n\\laa{0}{-4}{1}{0}{0}{1}{0}\n\\laa{0}{-6}{1}{0}{0}{0}{1}\n\\laa{8}{0}{0}{1}{1}{0}{0}\n\\laa{8}{-2}{0}{1}{0}{1}{0}\n\\laa{8}{-4}{0}{1}{0}{0}{1}\n\\laa{16}{0}{0}{0}{1}{1}{0}\n\\laa{16}{-2}{0}{0}{1}{0}{1}\n\\laa{16}{-4}{0}{0}{0}{1}{1}\n\n\\end{tikzpicture}\n\\end{center}\n\nIn this scenario, the answer is directly the\nbinomial coefficient ${n \\choose k}$.\n\n\\textit{Scenario 2}: A box can contain multiple balls.\nFor example, when $n=5$ and $k=2$,\nthere are 15 solutions:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.5]\n\\newcommand\\lax[3]{\n\\path[draw,thick,-] (#1-0.5,#2+0.5) -- (#1-0.5,#2-0.5) --\n                    (#1+0.5,#2-0.5) -- (#1+0.5,#2+0.5);\n\\ifthenelse{\\equal{#3}{1}}{\\draw[fill=black] (#1,#2-0.3) circle (0.15);}{}\n\\ifthenelse{\\equal{#3}{2}}{\\draw[fill=black] (#1-0.2,#2-0.3) circle (0.15);}{}\n\\ifthenelse{\\equal{#3}{2}}{\\draw[fill=black] (#1+0.2,#2-0.3) circle (0.15);}{}\n}\n\\newcommand\\laa[7]{\n    \\lax{#1}{#2}{#3}\n    \\lax{#1+1.2}{#2}{#4}\n    \\lax{#1+2.4}{#2}{#5}\n    \\lax{#1+3.6}{#2}{#6}\n    \\lax{#1+4.8}{#2}{#7}\n}\n\n\\laa{0}{0}{2}{0}{0}{0}{0}\n\\laa{0}{-2}{1}{1}{0}{0}{0}\n\\laa{0}{-4}{1}{0}{1}{0}{0}\n\\laa{0}{-6}{1}{0}{0}{1}{0}\n\\laa{0}{-8}{1}{0}{0}{0}{1}\n\\laa{8}{0}{0}{2}{0}{0}{0}\n\\laa{8}{-2}{0}{1}{1}{0}{0}\n\\laa{8}{-4}{0}{1}{0}{1}{0}\n\\laa{8}{-6}{0}{1}{0}{0}{1}\n\\laa{8}{-8}{0}{0}{2}{0}{0}\n\\laa{16}{0}{0}{0}{1}{1}{0}\n\\laa{16}{-2}{0}{0}{1}{0}{1}\n\\laa{16}{-4}{0}{0}{0}{2}{0}\n\\laa{16}{-6}{0}{0}{0}{1}{1}\n\\laa{16}{-8}{0}{0}{0}{0}{2}\n\n\\end{tikzpicture}\n\\end{center}\n\nThe process of placing the balls in the boxes\ncan be represented as a string\nthat consists of symbols\n''o'' and ''$\\rightarrow$''.\nInitially, assume that we are standing at the leftmost box.\nThe symbol ''o'' means that we place a ball\nin the current box, and the symbol\n''$\\rightarrow$'' means that we move to\nthe next box to the right.\n\nUsing this notation, each solution is a string\nthat contains $k$ times the symbol ''o'' and\n$n-1$ times the symbol ''$\\rightarrow$''.\nFor example, the upper-right solution\nin the above picture corresponds to the string\n''$\\rightarrow$ $\\rightarrow$ o $\\rightarrow$ o $\\rightarrow$''.\nThus, the number of solutions is\n${k+n-1 \\choose k}$.\n\n\\textit{Scenario 3}: Each box may contain at most one ball,\nand in addition, no two adjacent boxes may both contain a ball.\nFor example, when $n=5$ and $k=2$,\nthere are 6 solutions:\n\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.5]\n\\newcommand\\lax[3]{\n\\path[draw,thick,-] (#1-0.5,#2+0.5) -- (#1-0.5,#2-0.5) --\n                    (#1+0.5,#2-0.5) -- (#1+0.5,#2+0.5);\n\\ifthenelse{\\equal{#3}{1}}{\\draw[fill=black] (#1,#2-0.3) circle (0.15);}{}\n\\ifthenelse{\\equal{#3}{2}}{\\draw[fill=black] (#1-0.2,#2-0.3) circle (0.15);}{}\n\\ifthenelse{\\equal{#3}{2}}{\\draw[fill=black] (#1+0.2,#2-0.3) circle (0.15);}{}\n}\n\\newcommand\\laa[7]{\n    \\lax{#1}{#2}{#3}\n    \\lax{#1+1.2}{#2}{#4}\n    \\lax{#1+2.4}{#2}{#5}\n    \\lax{#1+3.6}{#2}{#6}\n    \\lax{#1+4.8}{#2}{#7}\n}\n\n\\laa{0}{0}{1}{0}{1}{0}{0}\n\\laa{0}{-2}{1}{0}{0}{1}{0}\n\\laa{8}{0}{1}{0}{0}{0}{1}\n\\laa{8}{-2}{0}{1}{0}{1}{0}\n\\laa{16}{0}{0}{1}{0}{0}{1}\n\\laa{16}{-2}{0}{0}{1}{0}{1}\n\\end{tikzpicture}\n\\end{center}\n\nIn this scenario, we can assume that\n$k$ balls are initially placed in boxes\nand there is an empty box between each\ntwo adjacent boxes.\nThe remaining task is to choose the\npositions for the remaining empty boxes.\nThere are $n-2k+1$ such boxes and\n$k+1$ positions for them.\nThus, using the formula of scenario 2,\nthe number of solutions is\n${n-k+1 \\choose n-2k+1}$.\n\n\\subsubsection{Multinomial coefficients}\n\n\\index{multinomial coefficient}\n\nThe \\key{multinomial coefficient}\n\\[ {n \\choose k_1,k_2,\\ldots,k_m} = \\frac{n!}{k_1! k_2! \\cdots k_m!}, \\]\nequals the number of ways\nwe can divide $n$ elements into subsets\nof sizes $k_1,k_2,\\ldots,k_m$,\nwhere $k_1+k_2+\\cdots+k_m=n$.\nMultinomial coefficients can be seen as a\ngeneralization of binomial cofficients;\nif $m=2$, the above formula\ncorresponds to the binomial coefficient formula.\n\n", "chapter_name": "Combinatorics", "chapter_path": "cphb/chapter22.tex"}, {"section_name": "Catalan numbers", "section_content": "\\section{Catalan numbers}\n\n\\index{Catalan number}\n\nThe \\key{Catalan number}\n%\\footnote{E. C. Catalan (1814--1894) was a Belgian mathematician.}\n$C_n$ equals the\nnumber of valid\nparenthesis expressions that consist of\n$n$ left parentheses and $n$ right parentheses.\n\nFor example, $C_3=5$, because\nwe can construct the following parenthesis\nexpressions using three\nleft and right parentheses:\n\n\\begin{itemize}[noitemsep]\n\\item \\texttt{()()()}\n\\item \\texttt{(())()}\n\\item \\texttt{()(())}\n\\item \\texttt{((()))}\n\\item \\texttt{(()())}\n\\end{itemize}\n\n\\subsubsection{Parenthesis expressions}\n\n\\index{parenthesis expression}\n\nWhat is exactly a \\emph{valid parenthesis expression}?\nThe following rules precisely define all\nvalid parenthesis expressions:\n\n\\begin{itemize}\n\\item An empty parenthesis expression is valid.\n\\item If an expression $A$ is valid,\nthen also the expression\n\\texttt{(}$A$\\texttt{)} is valid.\n\\item If expressions $A$ and $B$ are valid,\nthen also the expression $AB$ is valid.\n\\end{itemize}\n\nAnother way to characterize valid \nparenthesis expressions is that if\nwe choose any prefix of such an expression,\nit has to contain at least as many left\nparentheses as right parentheses.\nIn addition, the complete expression has to\ncontain an equal number of left and right\nparentheses.\n\n\\subsubsection{Formula 1}\n\nCatalan numbers can be calculated using the formula\n\\[ C_n = \\sum_{i=0}^{n-1} C_{i} C_{n-i-1}.\\]\n\nThe sum goes through the ways to divide the\nexpression into two parts\nsuch that both parts are valid\nexpressions and the first part is as short as possible\nbut not empty.\nFor any $i$, the first part contains $i+1$ pairs\nof parentheses and the number of expressions\nis the product of the following values:\n\n\\begin{itemize}\n\\item $C_{i}$: the number of ways to construct an expression\nusing the parentheses of the first part,\nnot counting the outermost parentheses\n\\item $C_{n-i-1}$: the number of ways to construct an\nexpression using the parentheses of the second part\n\\end{itemize}\n\nThe base case is $C_0=1$,\nbecause we can construct an empty parenthesis\nexpression using zero pairs of parentheses.\n\n\\subsubsection{Formula 2}\n\nCatalan numbers can also be calculated\nusing binomial coefficients:\n\\[ C_n = \\frac{1}{n+1} {2n \\choose n}\\]\nThe formula can be explained as follows:\n\nThere are a total of ${2n \\choose n}$ ways\nto construct a (not necessarily valid)\nparenthesis expression that contains $n$ left\nparentheses and $n$ right parentheses.\nLet us calculate the number of such\nexpressions that are \\emph{not} valid.\n\nIf a parenthesis expression is not valid,\nit has to contain a prefix where the\nnumber of right parentheses exceeds the\nnumber of left parentheses.\nThe idea is to reverse each parenthesis\nthat belongs to such a prefix.\nFor example, the expression\n\\texttt{())()(} contains a prefix \\texttt{())},\nand after reversing the prefix,\nthe expression becomes \\texttt{)((()(}.\n\nThe resulting expression consists of $n+1$\nleft parentheses and $n-1$ right parentheses.\nThe number of such expressions is ${2n \\choose n+1}$,\nwhich equals the number of non-valid\nparenthesis expressions.\nThus, the number of valid parenthesis\nexpressions can be calculated using the formula\n\\[{2n \\choose n}-{2n \\choose n+1} = {2n \\choose n} - \\frac{n}{n+1} {2n \\choose n} = \\frac{1}{n+1} {2n \\choose n}.\\]\n\n\\subsubsection{Counting trees}\n\nCatalan numbers are also related to trees:\n\n\\begin{itemize}\n\\item there are $C_n$ binary trees of $n$ nodes\n\\item there are $C_{n-1}$ rooted trees of $n$ nodes\n\\end{itemize}\n\\noindent\nFor example, for $C_3=5$, the binary trees are\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\path[draw,thick,-] (0,0) -- (-1,-1);\n\\path[draw,thick,-] (0,0) -- (1,-1);\n\\draw[fill=white] (0,0) circle (0.3);\n\\draw[fill=white] (-1,-1) circle (0.3);\n\\draw[fill=white] (1,-1) circle (0.3);\n\n\\path[draw,thick,-] (4,0) -- (4-0.75,-1) -- (4-1.5,-2);\n\\draw[fill=white] (4,0) circle (0.3);\n\\draw[fill=white] (4-0.75,-1) circle (0.3);\n\\draw[fill=white] (4-1.5,-2) circle (0.3);\n\n\\path[draw,thick,-] (6.5,0) -- (6.5-0.75,-1) -- (6.5-0,-2);\n\\draw[fill=white] (6.5,0) circle (0.3);\n\\draw[fill=white] (6.5-0.75,-1) circle (0.3);\n\\draw[fill=white] (6.5-0,-2) circle (0.3);\n\n\\path[draw,thick,-] (9,0) -- (9+0.75,-1) -- (9-0,-2);\n\\draw[fill=white] (9,0) circle (0.3);\n\\draw[fill=white] (9+0.75,-1) circle (0.3);\n\\draw[fill=white] (9-0,-2) circle (0.3);\n\n\\path[draw,thick,-] (11.5,0) -- (11.5+0.75,-1) -- (11.5+1.5,-2);\n\\draw[fill=white] (11.5,0) circle (0.3);\n\\draw[fill=white] (11.5+0.75,-1) circle (0.3);\n\\draw[fill=white] (11.5+1.5,-2) circle (0.3);\n\\end{tikzpicture}\n\\end{center}\nand the rooted trees are\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\path[draw,thick,-] (0,0) -- (-1,-1);\n\\path[draw,thick,-] (0,0) -- (0,-1);\n\\path[draw,thick,-] (0,0) -- (1,-1);\n\\draw[fill=white] (0,0) circle (0.3);\n\\draw[fill=white] (-1,-1) circle (0.3);\n\\draw[fill=white] (0,-1) circle (0.3);\n\\draw[fill=white] (1,-1) circle (0.3);\n\n\\path[draw,thick,-] (3,0) -- (3,-1) -- (3,-2) -- (3,-3);\n\\draw[fill=white] (3,0) circle (0.3);\n\\draw[fill=white] (3,-1) circle (0.3);\n\\draw[fill=white] (3,-2) circle (0.3);\n\\draw[fill=white] (3,-3) circle (0.3);\n\n\\path[draw,thick,-] (6+0,0) -- (6-1,-1);\n\\path[draw,thick,-] (6+0,0) -- (6+1,-1) -- (6+1,-2);\n\\draw[fill=white] (6+0,0) circle (0.3);\n\\draw[fill=white] (6-1,-1) circle (0.3);\n\\draw[fill=white] (6+1,-1) circle (0.3);\n\\draw[fill=white] (6+1,-2) circle (0.3);\n\n\\path[draw,thick,-] (9+0,0) -- (9+1,-1);\n\\path[draw,thick,-] (9+0,0) -- (9-1,-1) -- (9-1,-2);\n\\draw[fill=white] (9+0,0) circle (0.3);\n\\draw[fill=white] (9+1,-1) circle (0.3);\n\\draw[fill=white] (9-1,-1) circle (0.3);\n\\draw[fill=white] (9-1,-2) circle (0.3);\n\n\\path[draw,thick,-] (12+0,0) -- (12+0,-1) -- (12-1,-2);\n\\path[draw,thick,-] (12+0,0) -- (12+0,-1) -- (12+1,-2);\n\\draw[fill=white] (12+0,0) circle (0.3);\n\\draw[fill=white] (12+0,-1) circle (0.3);\n\\draw[fill=white] (12-1,-2) circle (0.3);\n\\draw[fill=white] (12+1,-2) circle (0.3);\n\n\\end{tikzpicture}\n\\end{center}\n\n", "chapter_name": "Combinatorics", "chapter_path": "cphb/chapter22.tex"}, {"section_name": "Inclusion-exclusion", "section_content": "\\section{Inclusion-exclusion}\n\n\\index{inclusion-exclusion}\n\n\\key{Inclusion-exclusion} is a technique\nthat can be used for counting the size\nof a union of sets when the sizes of\nthe intersections are known, and vice versa.\nA simple example of the technique is the formula\n\\[ |A \\cup B| = |A| + |B| - |A \\cap B|,\\]\nwhere $A$ and $B$ are sets and $|X|$\ndenotes the size of $X$.\nThe formula can be illustrated as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.8]\n\n\\draw (0,0) circle (1.5);\n\\draw (1.5,0) circle (1.5);\n\n\\node at (-0.75,0) {\\small $A$};\n\\node at (2.25,0) {\\small $B$};\n\\node at (0.75,0) {\\small $A \\cap B$};\n\n\\end{tikzpicture}\n\\end{center}\n\nOur goal is to calculate\nthe size of the union $A \\cup B$\nthat corresponds to the area of the region\nthat belongs to at least one circle.\nThe picture shows that we can calculate\nthe area of $A \\cup B$ by first summing the\nareas of $A$ and $B$ and then subtracting\nthe area of $A \\cap B$.\n\nThe same idea can be applied when the number\nof sets is larger.\nWhen there are three sets, the inclusion-exclusion formula is\n\\[ |A \\cup B \\cup C| = |A| + |B| + |C| - |A \\cap B|  - |A \\cap C|  - |B \\cap C| + |A \\cap B \\cap C| \\]\nand the corresponding picture is\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.8]\n\n\\draw (0,0) circle (1.75);\n\\draw (2,0) circle (1.75);\n\\draw (1,1.5) circle (1.75);\n\n\\node at (-0.75,-0.25) {\\small $A$};\n\\node at (2.75,-0.25) {\\small $B$};\n\\node at (1,2.5) {\\small $C$};\n\\node at (1,-0.5) {\\small $A \\cap B$};\n\\node at (0,1.25) {\\small $A \\cap C$};\n\\node at (2,1.25) {\\small $B \\cap C$};\n\\node at (1,0.5) {\\scriptsize $A \\cap B \\cap C$};\n\n\\end{tikzpicture}\n\\end{center}\n\nIn the general case, the size of the \nunion $X_1 \\cup X_2 \\cup \\cdots \\cup X_n$\ncan be calculated by going through all possible\nintersections that contain some of the sets $X_1,X_2,\\ldots,X_n$.\nIf the intersection contains an odd number of sets,\nits size is added to the answer,\nand otherwise its size is subtracted from the answer.\n\nNote that there are similar formulas\nfor calculating\nthe size of an intersection from the sizes of\nunions. For example,\n\\[ |A \\cap B| = |A| + |B| - |A \\cup B|\\]\nand\n\\[ |A \\cap B \\cap C| = |A| + |B| + |C| - |A \\cup B|  - |A \\cup C|  - |B \\cup C| + |A \\cup B \\cup C| .\\]\n\n\\subsubsection{Derangements}\n\n\\index{derangement}\n\nAs an example, let us count the number of \\key{derangements}\nof elements $\\{1,2,\\ldots,n\\}$, i.e., permutations\nwhere no element remains in its original place.\nFor example, when $n=3$, there are\ntwo derangements: $(2,3,1)$ and $(3,1,2)$.\n\nOne approach for solving the problem is to use\ninclusion-exclusion.\nLet $X_k$ be the set of permutations\nthat contain the element $k$ at position $k$.\nFor example, when $n=3$, the sets are as follows:\n\\[\n\\begin{array}{lcl}\nX_1 & = & \\{(1,2,3),(1,3,2)\\} \\\\\nX_2 & = & \\{(1,2,3),(3,2,1)\\} \\\\\nX_3 & = & \\{(1,2,3),(2,1,3)\\} \\\\\n\\end{array}\n\\]\nUsing these sets, the number of derangements equals\n\\[ n! - |X_1 \\cup X_2 \\cup \\cdots \\cup X_n|, \\]\nso it suffices to calculate the size of the union.\nUsing inclusion-exclusion, this reduces to\ncalculating sizes of intersections which can be\ndone efficiently.\nFor example, when $n=3$, the size of\n$|X_1 \\cup X_2 \\cup X_3|$ is\n\\[\n\\begin{array}{lcl}\n & & |X_1| + |X_2| + |X_3| - |X_1 \\cap X_2|  - |X_1 \\cap X_3|  - |X_2 \\cap X_3| + |X_1 \\cap X_2 \\cap X_3| \\\\\n & = & 2+2+2-1-1-1+1 \\\\\n & = & 4, \\\\\n\\end{array}\n\\]\nso the number of solutions is $3!-4=2$.\n\nIt turns out that the problem can also be solved\nwithout using inclusion-exclusion.\nLet $f(n)$ denote the number of derangements\nfor $\\{1,2,\\ldots,n\\}$. We can use the following\nrecursive formula:\n\n\\begin{equation*}\n    f(n) = \\begin{cases}\n               0               & n = 1\\\\\n               1               & n = 2\\\\\n               (n-1)(f(n-2) + f(n-1)) & n>2 \\\\\n           \\end{cases}\n\\end{equation*}\n\nThe formula can be derived by considering\nthe possibilities how the element 1 changes\nin the derangement.\nThere are $n-1$ ways to choose an element $x$\nthat replaces the element 1.\nIn each such choice, there are two options:\n\n\\textit{Option 1:} We also replace the element $x$\nwith the element 1.\nAfter this, the remaining task is to construct\na derangement of $n-2$ elements.\n\n\\textit{Option 2:} We replace the element $x$\nwith some other element than 1.\nNow we have to construct a derangement\nof $n-1$ element, because we cannot replace\nthe element $x$ with the element $1$, and all other\nelements must be changed.\n\n", "chapter_name": "Combinatorics", "chapter_path": "cphb/chapter22.tex"}, {"section_name": "Burnside's lemma", "section_content": "\\section{Burnside's lemma}\n\n\\index{Burnside's lemma}\n\n\\key{Burnside's lemma}\n%\\footnote{Actually, Burnside did not discover this lemma; he only mentioned it in his book \\cite{bur97}.}\ncan be used to count\nthe number of combinations so that\nonly one representative is counted\nfor each group of symmetric combinations.\nBurnside's lemma states that the number of\ncombinations is\n\\[\\sum_{k=1}^n \\frac{c(k)}{n},\\]\nwhere there are $n$ ways to change the\nposition of a combination,\nand there are $c(k)$ combinations that\nremain unchanged when the $k$th way is applied.\n\nAs an example, let us calculate the number of\nnecklaces of $n$ pearls,\nwhere each pearl has $m$ possible colors.\nTwo necklaces are symmetric if they are\nsimilar after rotating them.\nFor example, the necklace\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw[fill=white] (0,0) circle (1);\n\\draw[fill=red] (0,1) circle (0.3);\n\\draw[fill=blue] (1,0) circle (0.3);\n\\draw[fill=red] (0,-1) circle (0.3);\n\\draw[fill=green] (-1,0) circle (0.3);\n\\end{tikzpicture}\n\\end{center}\nhas the following symmetric necklaces:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw[fill=white] (0,0) circle (1);\n\\draw[fill=red] (0,1) circle (0.3);\n\\draw[fill=blue] (1,0) circle (0.3);\n\\draw[fill=red] (0,-1) circle (0.3);\n\\draw[fill=green] (-1,0) circle (0.3);\n\n\\draw[fill=white] (4,0) circle (1);\n\\draw[fill=green] (4+0,1) circle (0.3);\n\\draw[fill=red] (4+1,0) circle (0.3);\n\\draw[fill=blue] (4+0,-1) circle (0.3);\n\\draw[fill=red] (4+-1,0) circle (0.3);\n\n\\draw[fill=white] (8,0) circle (1);\n\\draw[fill=red] (8+0,1) circle (0.3);\n\\draw[fill=green] (8+1,0) circle (0.3);\n\\draw[fill=red] (8+0,-1) circle (0.3);\n\\draw[fill=blue] (8+-1,0) circle (0.3);\n\n\\draw[fill=white] (12,0) circle (1);\n\\draw[fill=blue] (12+0,1) circle (0.3);\n\\draw[fill=red] (12+1,0) circle (0.3);\n\\draw[fill=green] (12+0,-1) circle (0.3);\n\\draw[fill=red] (12+-1,0) circle (0.3);\n\\end{tikzpicture}\n\\end{center}\nThere are $n$ ways to change the position\nof a necklace,\nbecause we can rotate it\n$0,1,\\ldots,n-1$ steps clockwise.\nIf the number of steps is 0,\nall $m^n$ necklaces remain the same,\nand if the number of steps is 1,\nonly the $m$ necklaces where each\npearl has the same color remain the same.\n\nMore generally, when the number of steps is $k$,\na total of\n\\[m^{\\textrm{gcd}(k,n)}\\]\nnecklaces remain the same,\nwhere $\\textrm{gcd}(k,n)$ is the greatest common\ndivisor of $k$ and $n$.\nThe reason for this is that blocks\nof pearls of size $\\textrm{gcd}(k,n)$\nwill replace each other.\nThus, according to Burnside's lemma,\nthe number of necklaces is\n\\[\\sum_{i=0}^{n-1} \\frac{m^{\\textrm{gcd}(i,n)}}{n}. \\]\nFor example, the number of necklaces of length 4\nwith 3 colors is\n\\[\\frac{3^4+3+3^2+3}{4} = 24. \\]\n\n", "chapter_name": "Combinatorics", "chapter_path": "cphb/chapter22.tex"}, {"section_name": "Cayley's formula", "section_content": "\\section{Cayley's formula}\n\n\\index{Cayley's formula}\n\n\\key{Cayley's formula}\n% \\footnote{While the formula is named after A. Cayley,\n% who studied it in 1889, it was discovered earlier by C. W. Borchardt in 1860.}\nstates that\nthere are $n^{n-2}$ labeled trees\nthat contain $n$ nodes.\nThe nodes are labeled $1,2,\\ldots,n$,\nand two trees are different\nif either their structure or\nlabeling is different.\n\n\\begin{samepage}\nFor example, when $n=4$, the number of labeled\ntrees is $4^{4-2}=16$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.8]\n\\footnotesize\n\n\\newcommand\\puua[6]{\n\\path[draw,thick,-] (#1,#2) -- (#1-1.25,#2-1.5);\n\\path[draw,thick,-] (#1,#2) -- (#1,#2-1.5);\n\\path[draw,thick,-] (#1,#2) -- (#1+1.25,#2-1.5);\n\\node[draw, circle, fill=white] at (#1,#2) {#3};\n\\node[draw, circle, fill=white] at (#1-1.25,#2-1.5) {#4};\n\\node[draw, circle, fill=white] at (#1,#2-1.5) {#5};\n\\node[draw, circle, fill=white] at (#1+1.25,#2-1.5) {#6};\n}\n\\newcommand\\puub[6]{\n\\path[draw,thick,-] (#1,#2) -- (#1+1,#2);\n\\path[draw,thick,-] (#1+1,#2) -- (#1+2,#2);\n\\path[draw,thick,-] (#1+2,#2) -- (#1+3,#2);\n\\node[draw, circle, fill=white] at (#1,#2) {#3};\n\\node[draw, circle, fill=white] at (#1+1,#2) {#4};\n\\node[draw, circle, fill=white] at (#1+2,#2) {#5};\n\\node[draw, circle, fill=white] at (#1+3,#2) {#6};\n}\n\n\\puua{0}{0}{1}{2}{3}{4}\n\\puua{4}{0}{2}{1}{3}{4}\n\\puua{8}{0}{3}{1}{2}{4}\n\\puua{12}{0}{4}{1}{2}{3}\n\n\\puub{0}{-3}{1}{2}{3}{4}\n\\puub{4.5}{-3}{1}{2}{4}{3}\n\\puub{9}{-3}{1}{3}{2}{4}\n\\puub{0}{-4.5}{1}{3}{4}{2}\n\\puub{4.5}{-4.5}{1}{4}{2}{3}\n\\puub{9}{-4.5}{1}{4}{3}{2}\n\\puub{0}{-6}{2}{1}{3}{4}\n\\puub{4.5}{-6}{2}{1}{4}{3}\n\\puub{9}{-6}{2}{3}{1}{4}\n\\puub{0}{-7.5}{2}{4}{1}{3}\n\\puub{4.5}{-7.5}{3}{1}{2}{4}\n\\puub{9}{-7.5}{3}{2}{1}{4}\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\nNext we will see how Cayley's formula can\nbe derived using Pr\u00fcfer codes.\n\n\\subsubsection{Pr\u00fcfer code}\n\n\\index{Pr\u00fcfer code}\n\nA \\key{Pr\u00fcfer code}\n%\\footnote{In 1918, H. Pr\u00fcfer proved Cayley's theorem using Pr\u00fcfer codes \\cite{pru18}.}\nis a sequence of\n$n-2$ numbers that describes a labeled tree.\nThe code is constructed by following a process\nthat removes $n-2$ leaves from the tree.\nAt each step, the leaf with the smallest label is removed,\nand the label of its only neighbor is added to the code.\n\nFor example, let us calculate the Pr\u00fcfer code\nof the following graph:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (2,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (2,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (5.5,2) {$5$};\n\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\nFirst we remove node 1 and add node 4 to the code:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n%\\node[draw, circle] (1) at (2,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (2,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (5.5,2) {$5$};\n\n%\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\nThen we remove node 3 and add node 4 to the code:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n%\\node[draw, circle] (1) at (2,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n%\\node[draw, circle] (3) at (2,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (5.5,2) {$5$};\n\n%\\path[draw,thick,-] (1) -- (4);\n%\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\nFinally we remove node 4 and add node 2 to the code:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n%\\node[draw, circle] (1) at (2,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n%\\node[draw, circle] (3) at (2,1) {$3$};\n%\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (5.5,2) {$5$};\n\n%\\path[draw,thick,-] (1) -- (4);\n%\\path[draw,thick,-] (3) -- (4);\n%\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\end{tikzpicture}\n\\end{center}\n\nThus, the Pr\u00fcfer code of the graph is $[4,4,2]$.\n\nWe can construct a Pr\u00fcfer code for any tree,\nand more importantly,\nthe original tree can be reconstructed\nfrom a Pr\u00fcfer code.\nHence, the number of labeled trees\nof $n$ nodes equals\n$n^{n-2}$, the number of Pr\u00fcfer codes\nof size $n$.\n", "chapter_name": "Combinatorics", "chapter_path": "cphb/chapter22.tex"}, {"section_name": "Operations", "section_content": "\\chapter{Matrices}\n\n\\index{matrix}\n\nA \\key{matrix} is a mathematical concept\nthat corresponds to a two-dimensional array\nin programming. For example,\n\\[\nA = \n \\begin{bmatrix}\n  6 & 13 & 7 & 4 \\\\\n  7 & 0 & 8 & 2 \\\\\n  9 & 5 & 4 & 18 \\\\\n \\end{bmatrix}\n\\]\nis a matrix of size $3 \\times 4$, i.e.,\nit has 3 rows and 4 columns.\nThe notation $[i,j]$ refers to\nthe element in row $i$ and column $j$\nin a matrix.\nFor example, in the above matrix,\n$A[2,3]=8$ and $A[3,1]=9$.\n\n\\index{vector}\n\nA special case of a matrix is a \\key{vector}\nthat is a one-dimensional matrix of size $n \\times 1$.\nFor example,\n\\[\nV =\n\\begin{bmatrix}\n4 \\\\\n7 \\\\\n5 \\\\\n\\end{bmatrix}\n\\]\nis a vector that contains three elements.\n\n\\index{transpose}\n\nThe \\key{transpose} $A^T$ of a matrix $A$\nis obtained when the rows and columns of $A$\nare swapped, i.e., $A^T[i,j]=A[j,i]$:\n\\[\nA^T = \n \\begin{bmatrix}\n  6 & 7 & 9 \\\\\n  13 & 0 & 5 \\\\\n  7 & 8 & 4 \\\\\n  4 & 2 & 18 \\\\\n \\end{bmatrix}\n\\]\n\n\\index{square matrix}\n\nA matrix is a \\key{square matrix} if it\nhas the same number of rows and columns.\nFor example, the following matrix is a\nsquare matrix:\n\n\\[\nS = \n \\begin{bmatrix}\n  3 & 12 & 4  \\\\\n  5 & 9 & 15  \\\\\n  0 & 2 & 4 \\\\\n \\end{bmatrix}\n\\]\n\n\\section{Operations}\n\nThe sum $A+B$ of matrices $A$ and $B$\nis defined if the matrices are of the same size.\nThe result is a matrix where each element\nis the sum of the corresponding elements\nin $A$ and $B$.\n\nFor example,\n\\[\n \\begin{bmatrix}\n  6 & 1 & 4 \\\\\n  3 & 9 & 2 \\\\\n \\end{bmatrix}\n+\n \\begin{bmatrix}\n  4 & 9 & 3 \\\\\n  8 & 1 & 3 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  6+4 & 1+9 & 4+3 \\\\\n  3+8 & 9+1 & 2+3 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  10 & 10 & 7 \\\\\n  11 & 10 & 5 \\\\\n \\end{bmatrix}.\n\\]\n\nMultiplying a matrix $A$ by a value $x$ means\nthat each element of $A$ is multiplied by $x$.\nFor example,\n\\[\n 2 \\cdot \\begin{bmatrix}\n  6 & 1 & 4 \\\\\n  3 & 9 & 2 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  2 \\cdot 6 & 2\\cdot1 & 2\\cdot4 \\\\\n  2\\cdot3 & 2\\cdot9 & 2\\cdot2 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  12 & 2 & 8 \\\\\n  6 & 18 & 4 \\\\\n \\end{bmatrix}.\n\\]\n\n\\subsubsection{Matrix multiplication}\n\n\\index{matrix multiplication}\n\nThe product $AB$ of matrices $A$ and $B$\nis defined if $A$ is of size $a \\times n$\nand $B$ is of size $n \\times b$, i.e.,\nthe width of $A$ equals the height of $B$.\nThe result is a matrix of size $a \\times b$\nwhose elements are calculated using the formula\n\\[\nAB[i,j] = \\sum_{k=1}^n A[i,k] \\cdot B[k,j].\n\\]\n\nThe idea is that each element of $AB$\nis a sum of products of elements of $A$ and $B$\naccording to the following picture:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.5]\n\\draw (0,0) grid (4,3);\n\\draw (5,0) grid (10,3);\n\\draw (5,4) grid (10,8);\n\n\\node at (2,-1) {$A$};\n\\node at (7.5,-1) {$AB$};\n\\node at (11,6) {$B$};\n\n\\draw[thick,->,red,line width=2pt] (0,1.5) -- (4,1.5);\n\\draw[thick,->,red,line width=2pt] (6.5,8) -- (6.5,4);\n\\draw[thick,red,line width=2pt] (6.5,1.5) circle (0.4);\n\\end{tikzpicture}\n\\end{center}\n\nFor example,\n\n\\[\n \\begin{bmatrix}\n  1 & 4 \\\\\n  3 & 9 \\\\\n  8 & 6 \\\\\n \\end{bmatrix}\n\\cdot\n \\begin{bmatrix}\n  1 & 6 \\\\\n  2 & 9 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  1 \\cdot 1 + 4 \\cdot 2 & 1 \\cdot 6 + 4 \\cdot 9 \\\\\n  3 \\cdot 1 + 9 \\cdot 2 & 3 \\cdot 6 + 9 \\cdot 9 \\\\\n  8 \\cdot 1 + 6 \\cdot 2 & 8 \\cdot 6 + 6 \\cdot 9 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  9 & 42 \\\\\n  21 & 99 \\\\\n  20 & 102 \\\\\n \\end{bmatrix}.\n\\]\n\nMatrix multiplication is associative,\nso $A(BC)=(AB)C$ holds,\nbut it is not commutative,\nso $AB = BA$ does not usually hold.\n\n\\index{identity matrix}\n\nAn \\key{identity matrix} is a square matrix\nwhere each element on the diagonal is 1\nand all other elements are 0.\nFor example, the following matrix\nis the $3 \\times 3$ identity matrix:\n\\[\n I = \\begin{bmatrix}\n  1 & 0 & 0 \\\\\n  0 & 1 & 0 \\\\\n  0 & 0 & 1 \\\\\n \\end{bmatrix}\n\\]\n\n\\begin{samepage}\nMultiplying a matrix by an identity matrix\ndoes not change it. For example,\n\\[\n \\begin{bmatrix}\n  1 & 0 & 0 \\\\\n  0 & 1 & 0 \\\\\n  0 & 0 & 1 \\\\\n \\end{bmatrix}\n\\cdot\n \\begin{bmatrix}\n  1 & 4 \\\\\n  3 & 9 \\\\\n  8 & 6 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  1 & 4 \\\\\n  3 & 9 \\\\\n  8 & 6 \\\\\n \\end{bmatrix} \\hspace{10px} \\textrm{and} \\hspace{10px}\n \\begin{bmatrix}\n  1 & 4 \\\\\n  3 & 9 \\\\\n  8 & 6 \\\\\n \\end{bmatrix}\n\\cdot\n \\begin{bmatrix}\n  1 & 0 \\\\\n  0 & 1 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  1 & 4 \\\\\n  3 & 9 \\\\\n  8 & 6 \\\\\n \\end{bmatrix}.\n\\]\n\\end{samepage}\n\nUsing a straightforward algorithm,\nwe can calculate the product of\ntwo $n \\times n$ matrices\nin $O(n^3)$ time.\nThere are also more efficient algorithms\nfor matrix multiplication\\footnote{The first such\nalgorithm was Strassen's algorithm,\npublished in 1969 \\cite{str69},\nwhose time complexity is $O(n^{2.80735})$;\nthe best current algorithm \\cite{gal14}\nworks in $O(n^{2.37286})$ time.},\nbut they are mostly of theoretical interest\nand such algorithms are not necessary\nin competitive programming.\n\n\n\\subsubsection{Matrix power}\n\n\\index{matrix power}\n\nThe power $A^k$ of a matrix $A$ is defined\nif $A$ is a square matrix.\nThe definition is based on matrix multiplication:\n\\[ A^k = \\underbrace{A \\cdot A \\cdot A \\cdots A}_{\\textrm{$k$ times}} \\]\nFor example,\n\n\\[\n \\begin{bmatrix}\n  2 & 5 \\\\\n  1 & 4 \\\\\n \\end{bmatrix}^3 =\n \\begin{bmatrix}\n  2 & 5 \\\\\n  1 & 4 \\\\\n \\end{bmatrix} \\cdot\n \\begin{bmatrix}\n  2 & 5 \\\\\n  1 & 4 \\\\\n \\end{bmatrix} \\cdot\n \\begin{bmatrix}\n  2 & 5 \\\\\n  1 & 4 \\\\\n \\end{bmatrix} =\n \\begin{bmatrix}\n  48 & 165 \\\\\n  33 & 114 \\\\\n \\end{bmatrix}.\n\\]\nIn addition, $A^0$ is an identity matrix. For example,\n\\[\n \\begin{bmatrix}\n  2 & 5 \\\\\n  1 & 4 \\\\\n \\end{bmatrix}^0 =\n \\begin{bmatrix}\n  1 & 0 \\\\\n  0 & 1 \\\\\n \\end{bmatrix}.\n\\]\n\nThe matrix $A^k$ can be efficiently calculated\nin $O(n^3 \\log k)$ time using the\nalgorithm in Chapter 21.2. For example,\n\\[\n \\begin{bmatrix}\n  2 & 5 \\\\\n  1 & 4 \\\\\n \\end{bmatrix}^8 =\n \\begin{bmatrix}\n  2 & 5 \\\\\n  1 & 4 \\\\\n \\end{bmatrix}^4 \\cdot\n \\begin{bmatrix}\n  2 & 5 \\\\\n  1 & 4 \\\\\n \\end{bmatrix}^4.\n\\]\n\n\\subsubsection{Determinant}\n\n\\index{determinant}\n\nThe \\key{determinant} $\\det(A)$ of a matrix $A$\nis defined if $A$ is a square matrix.\nIf $A$ is of size $1 \\times 1$,\nthen $\\det(A)=A[1,1]$.\nThe determinant of a larger matrix is\ncalculated recursively using the formula \\index{cofactor}\n\\[\\det(A)=\\sum_{j=1}^n A[1,j] C[1,j],\\]\nwhere $C[i,j]$ is the \\key{cofactor} of $A$\nat $[i,j]$.\nThe cofactor is calculated using the formula\n\\[C[i,j] = (-1)^{i+j} \\det(M[i,j]),\\]\nwhere $M[i,j]$ is obtained by removing\nrow $i$ and column $j$ from $A$.\nDue to the coefficient $(-1)^{i+j}$ in the cofactor,\nevery other determinant is positive\nand negative.\nFor example,\n\\[\n\\det(\n \\begin{bmatrix}\n  3 & 4 \\\\\n  1 & 6 \\\\\n \\end{bmatrix}\n) = 3 \\cdot 6 - 4 \\cdot 1 = 14 \n\\]\nand\n\\[\n\\det(\n \\begin{bmatrix}\n  2 & 4 & 3 \\\\\n  5 & 1 & 6 \\\\\n  7 & 2 & 4 \\\\\n \\end{bmatrix}\n) = \n2 \\cdot\n\\det(\n \\begin{bmatrix}\n  1 & 6 \\\\\n  2 & 4 \\\\\n \\end{bmatrix}\n)\n-4 \\cdot\n\\det(\n \\begin{bmatrix}\n  5 & 6 \\\\\n  7 & 4 \\\\\n \\end{bmatrix}\n)\n+3 \\cdot\n\\det(\n \\begin{bmatrix}\n  5 & 1 \\\\\n  7 & 2 \\\\\n \\end{bmatrix}\n) = 81.\n\\]\n\n\\index{inverse matrix}\n\nThe determinant of $A$ tells us\nwhether there is an \\key{inverse matrix}\n$A^{-1}$ such that $A \\cdot A^{-1} = I$,\nwhere $I$ is an identity matrix.\nIt turns out that $A^{-1}$ exists\nexactly when $\\det(A) \\neq 0$,\nand it can be calculated using the formula\n\n\\[A^{-1}[i,j] = \\frac{C[j,i]}{det(A)}.\\]\n\nFor example,\n\n\\[\n\\underbrace{\n \\begin{bmatrix}\n  2 & 4 & 3\\\\\n  5 & 1 & 6\\\\\n  7 & 2 & 4\\\\\n \\end{bmatrix}\n}_{A}\n\\cdot\n\\underbrace{\n \\frac{1}{81}\n \\begin{bmatrix}\n   -8 & -10 & 21 \\\\\n   22 & -13 & 3 \\\\\n   3 & 24 & -18 \\\\\n \\end{bmatrix}\n}_{A^{-1}}\n=\n\\underbrace{\n \\begin{bmatrix}\n  1 & 0 & 0 \\\\\n  0 & 1 & 0 \\\\\n  0 & 0 & 1 \\\\\n \\end{bmatrix}\n}_{I}.\n\\]\n\n", "chapter_name": "Matrices", "chapter_path": "cphb/chapter23.tex"}, {"section_name": "Linear recurrences", "section_content": "\\section{Linear recurrences}\n\n\\index{linear recurrence}\n\nA \\key{linear recurrence}\nis a function $f(n)$\nwhose initial values are\n$f(0),f(1),\\ldots,f(k-1)$\nand larger values\nare calculated recursively using the formula\n\\[f(n) = c_1 f(n-1) + c_2 f(n-2) + \\ldots + c_k f (n-k),\\]\nwhere $c_1,c_2,\\ldots,c_k$ are constant coefficients.\n\nDynamic programming can be used to calculate\nany value of $f(n)$ in $O(kn)$ time by calculating\nall values of $f(0),f(1),\\ldots,f(n)$ one after another.\nHowever, if $k$ is small, it is possible to calculate\n$f(n)$ much more efficiently in $O(k^3 \\log n)$\ntime using matrix operations.\n\n\\subsubsection{Fibonacci numbers}\n\n\\index{Fibonacci number}\n\nA simple example of a linear recurrence is the\nfollowing function that defines the Fibonacci numbers:\n\\[\n\\begin{array}{lcl}\nf(0) & = & 0 \\\\\nf(1) & = & 1 \\\\\nf(n) & = & f(n-1)+f(n-2) \\\\\n\\end{array}\n\\]\nIn this case, $k=2$ and $c_1=c_2=1$.\n\n\\begin{samepage}\nTo efficiently calculate Fibonacci numbers,\nwe represent the\nFibonacci formula as a\nsquare matrix $X$ of size $2 \\times 2$,\nfor which the following holds:\n\\[ X \\cdot\n \\begin{bmatrix}\n  f(i) \\\\\n  f(i+1) \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  f(i+1) \\\\\n  f(i+2) \\\\\n \\end{bmatrix}\n \\]\nThus, values $f(i)$ and $f(i+1)$ are given as\n''input'' for $X$,\nand $X$ calculates values $f(i+1)$ and $f(i+2)$\nfrom them.\nIt turns out that such a matrix is\n\n\\[ X = \n \\begin{bmatrix}\n  0 & 1 \\\\\n  1 & 1 \\\\\n \\end{bmatrix}.\n\\]\n\\end{samepage}\n\\noindent\nFor example,\n\\[\n \\begin{bmatrix}\n  0 & 1 \\\\\n  1 & 1 \\\\\n \\end{bmatrix}\n\\cdot\n \\begin{bmatrix}\n  f(5) \\\\\n  f(6) \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  0 & 1 \\\\\n  1 & 1 \\\\\n \\end{bmatrix}\n\\cdot\n \\begin{bmatrix}\n  5 \\\\\n  8 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  8 \\\\\n  13 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  f(6) \\\\\n  f(7) \\\\\n \\end{bmatrix}.\n\\]\nThus, we can calculate $f(n)$ using the formula\n\\[\n \\begin{bmatrix}\n  f(n) \\\\\n  f(n+1) \\\\\n \\end{bmatrix}\n=\nX^n \\cdot\n \\begin{bmatrix}\n  f(0) \\\\\n  f(1) \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  0 & 1 \\\\\n  1 & 1 \\\\\n \\end{bmatrix}^n\n\\cdot\n \\begin{bmatrix}\n  0 \\\\\n  1 \\\\\n \\end{bmatrix}.\n\\]\nThe value of $X^n$ can be calculated in\n$O(\\log n)$ time,\nso the value of $f(n)$ can also be calculated\nin $O(\\log n)$ time.\n\n\\subsubsection{General case}\n\nLet us now consider the general case where\n$f(n)$ is any linear recurrence.\nAgain, our goal is to construct a matrix $X$\nfor which\n\n\\[ X \\cdot\n \\begin{bmatrix}\n  f(i) \\\\\n  f(i+1) \\\\\n  \\vdots \\\\\n  f(i+k-1) \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  f(i+1) \\\\\n  f(i+2) \\\\\n  \\vdots \\\\\n  f(i+k) \\\\\n \\end{bmatrix}.\n\\]\nSuch a matrix is\n\\[\nX =\n \\begin{bmatrix}\n  0 & 1 & 0 & 0 & \\cdots & 0 \\\\\n  0 & 0 & 1 & 0 & \\cdots & 0 \\\\\n  0 & 0 & 0 & 1 & \\cdots & 0 \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n  0 & 0 & 0 & 0 & \\cdots & 1 \\\\\n  c_k & c_{k-1} & c_{k-2} & c_{k-3} & \\cdots & c_1 \\\\\n \\end{bmatrix}.\n\\]\nIn the first $k-1$ rows, each element is 0\nexcept that one element is 1.\nThese rows replace $f(i)$ with $f(i+1)$,\n$f(i+1)$ with $f(i+2)$, and so on.\nThe last row contains the coefficients of the recurrence\nto calculate the new value $f(i+k)$.\n\n\\begin{samepage}\nNow, $f(n)$ can be calculated in\n$O(k^3 \\log n)$ time using the formula\n\\[\n \\begin{bmatrix}\n  f(n) \\\\\n  f(n+1) \\\\\n  \\vdots \\\\\n  f(n+k-1) \\\\\n \\end{bmatrix}\n=\nX^n \\cdot\n \\begin{bmatrix}\n  f(0) \\\\\n  f(1) \\\\\n  \\vdots \\\\\n  f(k-1) \\\\\n \\end{bmatrix}.\n\\]\n\\end{samepage}\n\n", "chapter_name": "Matrices", "chapter_path": "cphb/chapter23.tex"}, {"section_name": "Graphs and matrices", "section_content": "\\section{Graphs and matrices}\n\n\\subsubsection{Counting paths}\n\nThe powers of an adjacency matrix of a graph\nhave an interesting property.\nWhen $V$ is an adjacency matrix of an unweighted graph,\nthe matrix $V^n$ contains the numbers of paths of\n$n$ edges between the nodes in the graph.\n\nFor example, for the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (1,1) {$4$};\n\\node[draw, circle] (3) at (3,3) {$2$};\n\\node[draw, circle] (4) at (5,3) {$3$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) -- (2);\n\\path[draw,thick,->,>=latex] (2) -- (3);\n\\path[draw,thick,->,>=latex] (3) -- (1);\n\\path[draw,thick,->,>=latex] (4) -- (3);\n\\path[draw,thick,->,>=latex] (3) -- (5);\n\\path[draw,thick,->,>=latex] (3) -- (6);\n\\path[draw,thick,->,>=latex] (6) -- (4);\n\\path[draw,thick,->,>=latex] (6) -- (5);\n\\end{tikzpicture}\n\\end{center}\nthe adjacency matrix is\n\\[\nV= \\begin{bmatrix}\n  0 & 0 & 0 & 1 & 0 & 0 \\\\\n  1 & 0 & 0 & 0 & 1 & 1 \\\\\n  0 & 1 & 0 & 0 & 0 & 0 \\\\\n  0 & 1 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 1 & 0 & 1 & 0 \\\\\n \\end{bmatrix}.\n\\]\nNow, for example, the matrix\n\\[\nV^4= \\begin{bmatrix}\n  0 & 0 & 1 & 1 & 1 & 0 \\\\\n  2 & 0 & 0 & 0 & 2 & 2 \\\\\n  0 & 2 & 0 & 0 & 0 & 0 \\\\\n  0 & 2 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 1 & 1 & 1 & 0 \\\\\n \\end{bmatrix}\n\\]\ncontains the numbers of paths of 4 edges\nbetween the nodes.\nFor example, $V^4[2,5]=2$,\nbecause there are two paths of 4 edges\nfrom node 2 to node 5:\n$2 \\rightarrow 1 \\rightarrow 4 \\rightarrow 2 \\rightarrow 5$\nand \n$2 \\rightarrow 6 \\rightarrow 3 \\rightarrow 2 \\rightarrow 5$.\n\n\\subsubsection{Shortest paths}\n\nUsing a similar idea in a weighted graph,\nwe can calculate for each pair of nodes the minimum\nlength of a path\nbetween them that contains exactly $n$ edges.\nTo calculate this, we have to define matrix multiplication\nin a new way, so that we do not calculate the numbers\nof paths but minimize the lengths of paths.\n\n\\begin{samepage}\nAs an example, consider the following graph:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (1,1) {$4$};\n\\node[draw, circle] (3) at (3,3) {$2$};\n\\node[draw, circle] (4) at (5,3) {$3$};\n\\node[draw, circle] (5) at (3,1) {$5$};\n\\node[draw, circle] (6) at (5,1) {$6$};\n\n\\path[draw,thick,->,>=latex] (1) -- node[font=\\small,label=left:4] {} (2);\n\\path[draw,thick,->,>=latex] (2) -- node[font=\\small,label=left:1] {} (3);\n\\path[draw,thick,->,>=latex] (3) -- node[font=\\small,label=north:2] {} (1);\n\\path[draw,thick,->,>=latex] (4) -- node[font=\\small,label=north:4] {} (3);\n\\path[draw,thick,->,>=latex] (3) -- node[font=\\small,label=left:1] {} (5);\n\\path[draw,thick,->,>=latex] (3) -- node[font=\\small,label=left:2] {} (6);\n\\path[draw,thick,->,>=latex] (6) -- node[font=\\small,label=right:3] {} (4);\n\\path[draw,thick,->,>=latex] (6) -- node[font=\\small,label=below:2] {} (5);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\nLet us construct an adjacency matrix where\n$\\infty$ means that an edge does not exist,\nand other values correspond to edge weights.\nThe matrix is\n\\[\nV= \\begin{bmatrix}\n  \\infty & \\infty & \\infty & 4 & \\infty & \\infty \\\\\n  2 & \\infty & \\infty & \\infty & 1 & 2 \\\\\n  \\infty & 4 & \\infty & \\infty & \\infty & \\infty \\\\\n  \\infty & 1 & \\infty & \\infty & \\infty & \\infty \\\\\n  \\infty & \\infty & \\infty & \\infty & \\infty & \\infty \\\\\n  \\infty & \\infty & 3 & \\infty & 2 & \\infty \\\\\n \\end{bmatrix}.\n\\]\n\nInstead of the formula\n\\[\nAB[i,j] = \\sum_{k=1}^n A[i,k] \\cdot B[k,j]\n\\]\nwe now use the formula\n\\[\nAB[i,j] = \\min_{k=1}^n A[i,k] + B[k,j]\n\\]\nfor matrix multiplication, so we calculate\na minimum instead of a sum,\nand a sum of elements instead of a product.\nAfter this modification,\nmatrix powers correspond to\nshortest paths in the graph.\n\nFor example, as\n\\[\nV^4= \\begin{bmatrix}\n  \\infty & \\infty & 10 & 11 & 9 & \\infty \\\\\n  9 & \\infty & \\infty & \\infty & 8 & 9 \\\\\n  \\infty & 11 & \\infty & \\infty & \\infty & \\infty \\\\\n  \\infty & 8 & \\infty & \\infty & \\infty & \\infty \\\\\n  \\infty & \\infty & \\infty & \\infty & \\infty & \\infty \\\\\n  \\infty & \\infty & 12 & 13 & 11 & \\infty \\\\\n \\end{bmatrix},\n\\]\nwe can conclude that the minimum length of a path\nof 4 edges\nfrom node 2 to node 5 is 8.\nSuch a path is\n$2 \\rightarrow 1 \\rightarrow 4 \\rightarrow 2 \\rightarrow 5$.\n\n\\subsubsection{Kirchhoff's theorem}\n\n\\index{Kirchhoff's theorem}\n\\index{spanning tree}\n\n\\key{Kirchhoff's theorem}\n%\\footnote{G. R. Kirchhoff (1824--1887) was a German physicist.}\nprovides a way\nto calculate the number of spanning trees\nof a graph as a determinant of a special matrix.\nFor example, the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (3,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (3,1) {$4$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (1) -- (4);\n\\end{tikzpicture}\n\\end{center}\nhas three spanning trees:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1a) at (1,3) {$1$};\n\\node[draw, circle] (2a) at (3,3) {$2$};\n\\node[draw, circle] (3a) at (1,1) {$3$};\n\\node[draw, circle] (4a) at (3,1) {$4$};\n\n\\path[draw,thick,-] (1a) -- (2a);\n%\\path[draw,thick,-] (1a) -- (3a);\n\\path[draw,thick,-] (3a) -- (4a);\n\\path[draw,thick,-] (1a) -- (4a);\n\n\\node[draw, circle] (1b) at (1+4,3) {$1$};\n\\node[draw, circle] (2b) at (3+4,3) {$2$};\n\\node[draw, circle] (3b) at (1+4,1) {$3$};\n\\node[draw, circle] (4b) at (3+4,1) {$4$};\n\n\\path[draw,thick,-] (1b) -- (2b);\n\\path[draw,thick,-] (1b) -- (3b);\n%\\path[draw,thick,-] (3b) -- (4b);\n\\path[draw,thick,-] (1b) -- (4b);\n\n\\node[draw, circle] (1c) at (1+8,3) {$1$};\n\\node[draw, circle] (2c) at (3+8,3) {$2$};\n\\node[draw, circle] (3c) at (1+8,1) {$3$};\n\\node[draw, circle] (4c) at (3+8,1) {$4$};\n\n\\path[draw,thick,-] (1c) -- (2c);\n\\path[draw,thick,-] (1c) -- (3c);\n\\path[draw,thick,-] (3c) -- (4c);\n%\\path[draw,thick,-] (1c) -- (4c);\n\\end{tikzpicture}\n\\end{center}\n\\index{Laplacean matrix}\nTo calculate the number of spanning trees,\nwe construct a \\key{Laplacean matrix} $L$,\nwhere $L[i,i]$ is the degree of node $i$\nand $L[i,j]=-1$ if there is an edge between\nnodes $i$ and $j$, and otherwise $L[i,j]=0$.\nThe Laplacean matrix for the above graph is as follows:\n\\[\nL= \\begin{bmatrix}\n  3 & -1 & -1 & -1 \\\\\n  -1 & 1 & 0 & 0 \\\\\n  -1 & 0 & 2 & -1 \\\\\n  -1 & 0 & -1 & 2 \\\\\n \\end{bmatrix}\n\\]\n\nIt can be shown that\nthe number of spanning trees equals\nthe determinant of a matrix that is obtained\nwhen we remove any row and any column from $L$.\nFor example, if we remove the first row\nand column, the result is\n\n\\[ \\det(\n\\begin{bmatrix}\n  1 & 0 & 0 \\\\\n  0 & 2 & -1 \\\\\n  0 & -1 & 2 \\\\\n \\end{bmatrix}\n) =3.\\]\nThe determinant is always the same,\nregardless of which row and column we remove from $L$.\n\nNote that Cayley's formula in Chapter 22.5 is\na special case of Kirchhoff's theorem,\nbecause in a complete graph of $n$ nodes\n\n\\[ \\det(\n\\begin{bmatrix}\n  n-1 & -1 & \\cdots & -1 \\\\\n  -1 & n-1 & \\cdots & -1 \\\\\n  \\vdots & \\vdots & \\ddots & \\vdots \\\\\n  -1 & -1 & \\cdots & n-1 \\\\\n \\end{bmatrix}\n) =n^{n-2}.\\]\n\n\n\n", "chapter_name": "Matrices", "chapter_path": "cphb/chapter23.tex"}, {"section_name": "Calculation", "section_content": "\\chapter{Probability}\n\n\\index{probability}\n\nA \\key{probability} is a real number between $0$ and $1$\nthat indicates how probable an event is.\nIf an event is certain to happen,\nits probability is 1,\nand if an event is impossible,\nits probability is 0.\nThe probability of an event is denoted $P(\\cdots)$\nwhere the three dots describe the event.\n\nFor example, when throwing a dice,\nthe outcome is an integer between $1$ and $6$,\nand the probability of each outcome is $1/6$.\nFor example, we can calculate the following probabilities:\n\n\\begin{itemize}[noitemsep]\n\\item $P(\\textrm{''the outcome is 4''})=1/6$\n\\item $P(\\textrm{''the outcome is not 6''})=5/6$\n\\item $P(\\textrm{''the outcome is even''})=1/2$\n\\end{itemize}\n\n\\section{Calculation}\n\nTo calculate the probability of an event,\nwe can either use combinatorics\nor simulate the process that generates the event.\nAs an example, let us calculate the probability\nof drawing three cards with the same value\nfrom a shuffled deck of cards\n(for example, $\\spadesuit 8$, $\\clubsuit 8$ and $\\diamondsuit 8$).\n\n\\subsubsection*{Method 1}\n\nWe can calculate the probability using the formula\n\n\\[\\frac{\\textrm{number of desired outcomes}}{\\textrm{total number of outcomes}}.\\]\n\nIn this problem, the desired outcomes are those\nin which the value of each card is the same.\nThere are $13 {4 \\choose 3}$ such outcomes,\nbecause there are $13$ possibilities for the\nvalue of the cards and ${4 \\choose 3}$ ways to\nchoose $3$ suits from $4$ possible suits.\n\nThere are a total of ${52 \\choose 3}$ outcomes,\nbecause we choose 3 cards from 52 cards.\nThus, the probability of the event is\n\n\\[\\frac{13 {4 \\choose 3}}{{52 \\choose 3}} = \\frac{1}{425}.\\]\n\n\\subsubsection*{Method 2}\n\nAnother way to calculate the probability is\nto simulate the process that generates the event.\nIn this example, we draw three cards, so the process\nconsists of three steps.\nWe require that each step of the process is successful.\n\nDrawing the first card certainly succeeds,\nbecause there are no restrictions.\nThe second step succeeds with probability $3/51$,\nbecause there are 51 cards left and 3 of them\nhave the same value as the first card.\nIn a similar way, the third step succeeds with probability $2/50$.\n\nThe probability that the entire process succeeds is\n\n\\[1 \\cdot \\frac{3}{51} \\cdot \\frac{2}{50} = \\frac{1}{425}.\\]\n\n", "chapter_name": "Probability", "chapter_path": "cphb/chapter24.tex"}, {"section_name": "Events", "section_content": "\\section{Events}\n\nAn event in probability theory can be represented as a set\n\\[A \\subset X,\\]\nwhere $X$ contains all possible outcomes\nand $A$ is a subset of outcomes.\nFor example, when drawing a dice, the outcomes are\n\\[X = \\{1,2,3,4,5,6\\}.\\]\nNow, for example, the event ''the outcome is even''\ncorresponds to the set\n\\[A = \\{2,4,6\\}.\\]\n\nEach outcome $x$ is assigned a probability $p(x)$.\nThen, the probability $P(A)$ of an event\n$A$ can be calculated as a sum\nof probabilities of outcomes using the formula\n\\[P(A) = \\sum_{x \\in A} p(x).\\]\nFor example, when throwing a dice,\n$p(x)=1/6$ for each outcome $x$,\nso the probability of the event\n''the outcome is even'' is\n\\[p(2)+p(4)+p(6)=1/2.\\]\n\nThe total probability of the outcomes in $X$ must\nbe 1, i.e., $P(X)=1$.\n\nSince the events in probability theory are sets,\nwe can manipulate them using standard set operations:\n\n\\begin{itemize}\n\\item The \\key{complement} $\\bar A$ means\n''$A$ does not happen''.\nFor example, when throwing a dice, \nthe complement of $A=\\{2,4,6\\}$ is\n$\\bar A = \\{1,3,5\\}$.\n\\item The \\key{union} $A \\cup B$ means\n''$A$ or $B$ happen''.\nFor example, the union of\n$A=\\{2,5\\}$\nand $B=\\{4,5,6\\}$ is\n$A \\cup B = \\{2,4,5,6\\}$.\n\\item The \\key{intersection} $A \\cap B$ means\n''$A$ and $B$ happen''.\nFor example, the intersection of\n$A=\\{2,5\\}$ and $B=\\{4,5,6\\}$ is\n$A \\cap B = \\{5\\}$.\n\\end{itemize}\n\n\\subsubsection{Complement}\n\nThe probability of the complement\n$\\bar A$ is calculated using the formula\n\\[P(\\bar A)=1-P(A).\\]\n\nSometimes, we can solve a problem easily\nusing complements by solving the opposite problem.\nFor example, the probability of getting\nat least one six when throwing a dice ten times is\n\\[1-(5/6)^{10}.\\]\n\nHere $5/6$ is the probability that the outcome\nof a single throw is not six, and\n$(5/6)^{10}$ is the probability that none of\nthe ten throws is a six.\nThe complement of this is the answer to the problem.\n\n\\subsubsection{Union}\n\nThe probability of the union $A \\cup B$\nis calculated using the formula\n\\[P(A \\cup B)=P(A)+P(B)-P(A \\cap B).\\]\nFor example, when throwing a dice,\nthe union of the events\n\\[A=\\textrm{''the outcome is even''}\\]\nand\n\\[B=\\textrm{''the outcome is less than 4''}\\]\nis\n\\[A \\cup B=\\textrm{''the outcome is even or less than 4''},\\]\nand its probability is\n\\[P(A \\cup B) = P(A)+P(B)-P(A \\cap B)=1/2+1/2-1/6=5/6.\\]\n\nIf the events $A$ and $B$ are \\key{disjoint}, i.e.,\n$A \\cap B$ is empty,\nthe probability of the event $A \\cup B$ is simply\n\n\\[P(A \\cup B)=P(A)+P(B).\\]\n\n\\subsubsection{Conditional probability}\n\n\\index{conditional probability}\n\nThe \\key{conditional probability}\n\\[P(A | B) = \\frac{P(A \\cap B)}{P(B)}\\]\nis the probability of $A$\nassuming that $B$ happens.\nHence, when calculating the\nprobability of $A$, we only consider the outcomes\nthat also belong to $B$.\n\nUsing the previous sets,\n\\[P(A | B)= 1/3,\\]\nbecause the outcomes of $B$ are\n$\\{1,2,3\\}$, and one of them is even.\nThis is the probability of an even outcome\nif we know that the outcome is between $1 \\ldots 3$.\n\n\\subsubsection{Intersection}\n\n\\index{independence}\n\nUsing conditional probability,\nthe probability of the intersection\n$A \\cap B$ can be calculated using the formula\n\\[P(A \\cap B)=P(A)P(B|A).\\]\nEvents $A$ and $B$ are \\key{independent} if\n\\[P(A|B)=P(A) \\hspace{10px}\\textrm{and}\\hspace{10px} P(B|A)=P(B),\\]\nwhich means that the fact that $B$ happens does not\nchange the probability of $A$, and vice versa.\nIn this case, the probability of the intersection is\n\\[P(A \\cap B)=P(A)P(B).\\]\nFor example, when drawing a card from a deck, the events\n\\[A = \\textrm{''the suit is clubs''}\\]\nand\n\\[B = \\textrm{''the value is four''}\\]\nare independent. Hence the event\n\\[A \\cap B = \\textrm{''the card is the four of clubs''}\\]\nhappens with probability\n\\[P(A \\cap B)=P(A)P(B)=1/4 \\cdot 1/13 = 1/52.\\]\n\n", "chapter_name": "Probability", "chapter_path": "cphb/chapter24.tex"}, {"section_name": "Random variables", "section_content": "\\section{Random variables}\n\n\\index{random variable}\n\nA \\key{random variable} is a value that is generated\nby a random process.\nFor example, when throwing two dice,\na possible random variable is\n\\[X=\\textrm{''the sum of the outcomes''}.\\]\nFor example, if the outcomes are $[4,6]$\n(meaning that we first throw a four and then a six),\nthen the value of $X$ is 10.\n\nWe denote $P(X=x)$ the probability that\nthe value of a random variable $X$ is $x$.\nFor example, when throwing two dice,\n$P(X=10)=3/36$,\nbecause the total number of outcomes is 36\nand there are three possible ways to obtain\nthe sum 10: $[4,6]$, $[5,5]$ and $[6,4]$.\n\n\\subsubsection{Expected value}\n\n\\index{expected value}\n\nThe \\key{expected value} $E[X]$ indicates the\naverage value of a random variable $X$.\nThe expected value can be calculated as the sum\n\\[\\sum_x P(X=x)x,\\]\nwhere $x$ goes through all possible values of $X$.\n\nFor example, when throwing a dice,\nthe expected outcome is\n\\[1/6 \\cdot 1 + 1/6 \\cdot 2 + 1/6 \\cdot 3 + 1/6 \\cdot 4 + 1/6 \\cdot 5 + 1/6 \\cdot 6 = 7/2.\\]\n\nA useful property of expected values is \\key{linearity}.\nIt means that the sum\n$E[X_1+X_2+\\cdots+X_n]$\nalways equals the sum\n$E[X_1]+E[X_2]+\\cdots+E[X_n]$.\nThis formula holds even if random variables\ndepend on each other.\n\nFor example, when throwing two dice,\nthe expected sum is\n\\[E[X_1+X_2]=E[X_1]+E[X_2]=7/2+7/2=7.\\]\n\nLet us now consider a problem where\n$n$ balls are randomly placed in $n$ boxes,\nand our task is to calculate the expected\nnumber of empty boxes.\nEach ball has an equal probability to\nbe placed in any of the boxes.\nFor example, if $n=2$, the possibilities\nare as follows:\n\\begin{center}\n\\begin{tikzpicture}\n\\draw (0,0) rectangle (1,1);\n\\draw (1.2,0) rectangle (2.2,1);\n\\draw (3,0) rectangle (4,1);\n\\draw (4.2,0) rectangle (5.2,1);\n\\draw (6,0) rectangle (7,1);\n\\draw (7.2,0) rectangle (8.2,1);\n\\draw (9,0) rectangle (10,1);\n\\draw (10.2,0) rectangle (11.2,1);\n\n\\draw[fill=blue] (0.5,0.2) circle (0.1);\n\\draw[fill=red] (1.7,0.2) circle (0.1);\n\\draw[fill=red] (3.5,0.2) circle (0.1);\n\\draw[fill=blue] (4.7,0.2) circle (0.1);\n\\draw[fill=blue] (6.25,0.2) circle (0.1);\n\\draw[fill=red] (6.75,0.2) circle (0.1);\n\\draw[fill=blue] (10.45,0.2) circle (0.1);\n\\draw[fill=red] (10.95,0.2) circle (0.1);\n\\end{tikzpicture}\n\\end{center}\nIn this case, the expected number of\nempty boxes is\n\\[\\frac{0+0+1+1}{4} = \\frac{1}{2}.\\]\nIn the general case, the probability that a\nsingle box is empty is\n\\[\\Big(\\frac{n-1}{n}\\Big)^n,\\]\nbecause no ball should be placed in it.\nHence, using linearity, the expected number of\nempty boxes is\n\\[n \\cdot \\Big(\\frac{n-1}{n}\\Big)^n.\\]\n\n\\subsubsection{Distributions}\n\n\\index{distribution}\n\nThe \\key{distribution} of a random variable $X$\nshows the probability of each value that\n$X$ may have.\nThe distribution consists of values $P(X=x)$.\nFor example, when throwing two dice,\nthe distribution for their sum is:\n\\begin{center}\n\\small {\n\\begin{tabular}{r|rrrrrrrrrrrrr}\n$x$ & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\\\\n$P(X=x)$ & $1/36$ & $2/36$ & $3/36$ & $4/36$ & $5/36$ & $6/36$ & $5/36$ & $4/36$ & $3/36$ & $2/36$ & $1/36$ \\\\\n\\end{tabular}\n}\n\\end{center}\n\n\\index{uniform distribution}\nIn a \\key{uniform distribution},\nthe random variable $X$ has $n$ possible\nvalues $a,a+1,\\ldots,b$ and the probability of each value is $1/n$.\nFor example, when throwing a dice,\n$a=1$, $b=6$ and $P(X=x)=1/6$ for each value $x$.\n\nThe expected value of $X$ in a uniform distribution is\n\\[E[X] = \\frac{a+b}{2}.\\]\n\n\\index{binomial distribution}\nIn a \\key{binomial distribution}, $n$ attempts\nare made\nand the probability that a single attempt succeeds\nis $p$.\nThe random variable $X$ counts the number of\nsuccessful attempts,\nand the probability of a value $x$ is\n\\[P(X=x)=p^x (1-p)^{n-x} {n \\choose x},\\]\nwhere $p^x$ and $(1-p)^{n-x}$ correspond to\nsuccessful and unsuccessful attemps,\nand ${n \\choose x}$ is the number of ways\nwe can choose the order of the attempts.\n\nFor example, when throwing a dice ten times,\nthe probability of throwing a six exactly\nthree times is $(1/6)^3 (5/6)^7 {10 \\choose 3}$.\n\nThe expected value of $X$ in a binomial distribution is\n\\[E[X] = pn.\\]\n\n\\index{geometric distribution}\nIn a \\key{geometric distribution},\nthe probability that an attempt succeeds is $p$,\nand we continue until the first success happens.\nThe random variable $X$ counts the number\nof attempts needed, and the probability of\na value $x$ is\n\\[P(X=x)=(1-p)^{x-1} p,\\]\nwhere $(1-p)^{x-1}$ corresponds to the unsuccessful attemps\nand $p$ corresponds to the first successful attempt.\n\nFor example, if we throw a dice until we throw a six,\nthe probability that the number of throws\nis exactly 4 is $(5/6)^3 1/6$.\n\nThe expected value of $X$ in a geometric distribution is\n\\[E[X]=\\frac{1}{p}.\\]\n\n", "chapter_name": "Probability", "chapter_path": "cphb/chapter24.tex"}, {"section_name": "Markov chains", "section_content": "\\section{Markov chains}\n\n\\index{Markov chain}\n\nA \\key{Markov chain}\n% \\footnote{A. A. Markov (1856--1922)\n% was a Russian mathematician.}\nis a random process\nthat consists of states and transitions between them.\nFor each state, we know the probabilities\nfor moving to other states.\nA Markov chain can be represented as a graph\nwhose nodes are states and edges are transitions.\n\nAs an example, consider a problem\nwhere we are in floor 1 in an $n$ floor building.\nAt each step, we randomly walk either one floor\nup or one floor down, except that we always\nwalk one floor up from floor 1 and one floor down\nfrom floor $n$.\nWhat is the probability of being in floor $m$\nafter $k$ steps?\n\nIn this problem, each floor of the building\ncorresponds to a state in a Markov chain.\nFor example, if $n=5$, the graph is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (2,0) {$2$};\n\\node[draw, circle] (3) at (4,0) {$3$};\n\\node[draw, circle] (4) at (6,0) {$4$};\n\\node[draw, circle] (5) at (8,0) {$5$};\n\n\\path[draw,thick,->] (1) edge [bend left=40] node[font=\\small,label=$1$] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=40] node[font=\\small,label=$1/2$] {} (3);\n\\path[draw,thick,->] (3) edge [bend left=40] node[font=\\small,label=$1/2$] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=40] node[font=\\small,label=$1/2$] {} (5);\n\n\\path[draw,thick,->] (5) edge [bend left=40] node[font=\\small,label=below:$1$] {} (4);\n\\path[draw,thick,->] (4) edge [bend left=40] node[font=\\small,label=below:$1/2$] {} (3);\n\\path[draw,thick,->] (3) edge [bend left=40] node[font=\\small,label=below:$1/2$] {} (2);\n\\path[draw,thick,->] (2) edge [bend left=40] node[font=\\small,label=below:$1/2$] {} (1);\n\n%\\path[draw,thick,->] (1) edge [bend left=40] node[font=\\small,label=below:$1$] {} (2);\n\\end{tikzpicture}\n\\end{center}\n\nThe probability distribution\nof a Markov chain is a vector\n$[p_1,p_2,\\ldots,p_n]$, where $p_k$ is the\nprobability that the current state is $k$.\nThe formula $p_1+p_2+\\cdots+p_n=1$ always holds.\n\nIn the above scenario, the initial distribution is\n$[1,0,0,0,0]$, because we always begin in floor 1.\nThe next distribution is $[0,1,0,0,0]$,\nbecause we can only move from floor 1 to floor 2.\nAfter this, we can either move one floor up\nor one floor down, so the next distribution is\n$[1/2,0,1/2,0,0]$, and so on.\n\nAn efficient way to simulate the walk in\na Markov chain is to use dynamic programming.\nThe idea is to maintain the probability distribution,\nand at each step go through all possibilities\nhow we can move.\nUsing this method, we can simulate\na walk of $m$ steps in $O(n^2 m)$ time.\n\nThe transitions of a Markov chain can also be\nrepresented as a matrix that updates the\nprobability distribution.\nIn the above scenario, the matrix is\n\n\\[ \n \\begin{bmatrix}\n  0 & 1/2 & 0 & 0 & 0 \\\\\n  1 & 0 & 1/2 & 0 & 0 \\\\\n  0 & 1/2 & 0 & 1/2 & 0 \\\\\n  0 & 0 & 1/2 & 0 & 1 \\\\\n  0 & 0 & 0 & 1/2 & 0 \\\\\n \\end{bmatrix}.\n\\]\n\nWhen we multiply a probability distribution by this matrix,\nwe get the new distribution after moving one step.\nFor example, we can move from the distribution\n$[1,0,0,0,0]$ to the distribution\n$[0,1,0,0,0]$ as follows:\n\n\\[ \n \\begin{bmatrix}\n  0 & 1/2 & 0 & 0 & 0 \\\\\n  1 & 0 & 1/2 & 0 & 0 \\\\\n  0 & 1/2 & 0 & 1/2 & 0 \\\\\n  0 & 0 & 1/2 & 0 & 1 \\\\\n  0 & 0 & 0 & 1/2 & 0 \\\\\n \\end{bmatrix}\n \\begin{bmatrix}\n  1 \\\\\n  0 \\\\\n  0 \\\\\n  0 \\\\\n  0 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  0 \\\\\n  1 \\\\\n  0 \\\\\n  0 \\\\\n  0 \\\\\n \\end{bmatrix}.\n\\]\n\nBy calculating matrix powers efficiently,\nwe can calculate the distribution after $m$ steps\nin $O(n^3 \\log m)$ time.\n\n", "chapter_name": "Probability", "chapter_path": "cphb/chapter24.tex"}, {"section_name": "Randomized algorithms", "section_content": "\\section{Randomized algorithms}\n\n\\index{randomized algorithm}\n\nSometimes we can use randomness for solving a problem,\neven if the problem is not related to probabilities.\nA \\key{randomized algorithm} is an algorithm that\nis based on randomness.\n\n\\index{Monte Carlo algorithm}\n\nA \\key{Monte Carlo algorithm} is a randomized algorithm\nthat may sometimes give a wrong answer.\nFor such an algorithm to be useful,\nthe probability of a wrong answer should be small.\n\n\\index{Las Vegas algorithm}\n\nA \\key{Las Vegas algorithm} is a randomized algorithm\nthat always gives the correct answer,\nbut its running time varies randomly.\nThe goal is to design an algorithm that is\nefficient with high probability.\n\nNext we will go through three example problems that\ncan be solved using randomness.\n\n\\subsubsection{Order statistics}\n\n\\index{order statistic}\n\nThe $kth$ \\key{order statistic} of an array\nis the element at position $k$ after sorting\nthe array in increasing order.\nIt is easy to calculate any order statistic\nin $O(n \\log n)$ time by first sorting the array,\nbut is it really needed to sort the entire array\njust to find one element?\n\nIt turns out that we can find order statistics\nusing a randomized algorithm without sorting the array.\nThe algorithm, called \\key{quickselect}\\footnote{In 1961,\nC. A. R. Hoare published two algorithms that\nare efficient on average: \\index{quicksort} \\index{quickselect}\n\\key{quicksort} \\cite{hoa61a} for sorting arrays and\n\\key{quickselect} \\cite{hoa61b} for finding order statistics.}, is a Las Vegas algorithm:\nits running time is usually $O(n)$\nbut $O(n^2)$ in the worst case.\n\nThe algorithm chooses a random element $x$\nof the array, and moves elements smaller than $x$\nto the left part of the array,\nand all other elements to the right part of the array.\nThis takes $O(n)$ time when there are $n$ elements.\nAssume that the left part contains $a$ elements\nand the right part contains $b$ elements.\nIf $a=k$, element $x$ is the $k$th order statistic.\nOtherwise, if $a>k$, we recursively find the $k$th order\nstatistic for the left part,\nand if $a<k$, we recursively find the $r$th order\nstatistic for the right part where $r=k-a$.\nThe search continues in a similar way, until the element\nhas been found.\n\nWhen each element $x$ is randomly chosen,\nthe size of the array about halves at each step,\nso the time complexity for\nfinding the $k$th order statistic is about\n\\[n+n/2+n/4+n/8+\\cdots < 2n = O(n).\\]\n\nThe worst case of the algorithm requires still $O(n^2)$ time,\nbecause it is possible that $x$ is always chosen\nin such a way that it is one of the smallest or largest\nelements in the array and $O(n)$ steps are needed.\nHowever, the probability for this is so small\nthat this never happens in practice.\n\n\\subsubsection{Verifying matrix multiplication}\n\n\\index{matrix multiplication}\n\nOur next problem is to \\emph{verify}\nif $AB=C$ holds when $A$, $B$ and $C$\nare matrices of size $n \\times n$.\nOf course, we can solve the problem\nby calculating the product $AB$ again\n(in $O(n^3)$ time using the basic algorithm),\nbut one could hope that verifying the\nanswer would by easier than to calculate it from scratch.\n\nIt turns out that we can solve the problem\nusing a Monte Carlo algorithm\\footnote{R. M. Freivalds published\nthis algorithm in 1977 \\cite{fre77}, and it is sometimes\ncalled \\index{Freivalds' algoritm} \\key{Freivalds' algorithm}.} whose\ntime complexity is only $O(n^2)$.\nThe idea is simple: we choose a random vector\n$X$ of $n$ elements, and calculate the matrices\n$ABX$ and $CX$. If $ABX=CX$, we report that $AB=C$,\nand otherwise we report that $AB \\neq C$.\n\nThe time complexity of the algorithm is\n$O(n^2)$, because we can calculate the matrices\n$ABX$ and $CX$ in $O(n^2)$ time.\nWe can calculate the matrix $ABX$ efficiently\nby using the representation $A(BX)$, so only two\nmultiplications of $n \\times n$ and $n \\times 1$\nsize matrices are needed.\n\nThe drawback of the algorithm is\nthat there is a small chance that the algorithm\nmakes a mistake when it reports that $AB=C$.\nFor example, \n\\[\n \\begin{bmatrix}\n  6 & 8 \\\\\n  1 & 3 \\\\\n \\end{bmatrix}\n\\neq\n \\begin{bmatrix}\n  8 & 7 \\\\\n  3 & 2 \\\\\n \\end{bmatrix},\n\\]\nbut\n\\[\n \\begin{bmatrix}\n  6 & 8 \\\\\n  1 & 3 \\\\\n \\end{bmatrix}\n \\begin{bmatrix}\n  3 \\\\\n  6 \\\\\n \\end{bmatrix}\n=\n \\begin{bmatrix}\n  8 & 7 \\\\\n  3 & 2 \\\\\n \\end{bmatrix}\n \\begin{bmatrix}\n  3 \\\\\n  6 \\\\\n \\end{bmatrix}.\n\\]\nHowever, in practice, the probability that the\nalgorithm makes a mistake is small,\nand we can decrease the probability by\nverifying the result using multiple random vectors $X$\nbefore reporting that $AB=C$.\n\n\\subsubsection{Graph coloring}\n\n\\index{coloring}\n\nGiven a graph that contains $n$ nodes and $m$ edges,\nour task is to find a way to color the nodes\nof the graph using two colors so that\nfor at least $m/2$ edges, the endpoints \nhave different colors.\nFor example, in the graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (1,3) {$1$};\n\\node[draw, circle] (2) at (4,3) {$2$};\n\\node[draw, circle] (3) at (1,1) {$3$};\n\\node[draw, circle] (4) at (4,1) {$4$};\n\\node[draw, circle] (5) at (6,2) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\na valid coloring is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle, fill=blue!40] (1) at (1,3) {$1$};\n\\node[draw, circle, fill=red!40] (2) at (4,3) {$2$};\n\\node[draw, circle, fill=red!40] (3) at (1,1) {$3$};\n\\node[draw, circle, fill=blue!40] (4) at (4,1) {$4$};\n\\node[draw, circle, fill=blue!40] (5) at (6,2) {$5$};\n\n\\path[draw,thick,-] (1) -- (2);\n\\path[draw,thick,-] (1) -- (3);\n\\path[draw,thick,-] (1) -- (4);\n\\path[draw,thick,-] (3) -- (4);\n\\path[draw,thick,-] (2) -- (4);\n\\path[draw,thick,-] (2) -- (5);\n\\path[draw,thick,-] (4) -- (5);\n\\end{tikzpicture}\n\\end{center}\nThe above graph contains 7 edges, and for 5 of them,\nthe endpoints have different colors,\nso the coloring is valid.\n\nThe problem can be solved using a Las Vegas algorithm\nthat generates random colorings until a valid coloring\nhas been found.\nIn a random coloring, the color of each node is\nindependently chosen so that the probability of\nboth colors is $1/2$.\n\nIn a random coloring, the probability that the endpoints\nof a single edge have different colors is $1/2$.\nHence, the expected number of edges whose endpoints\nhave different colors is $m/2$.\nSince it is expected that a random coloring is valid,\nwe will quickly find a valid coloring in practice.\n\n", "chapter_name": "Probability", "chapter_path": "cphb/chapter24.tex"}, {"section_name": "Game states", "section_content": "\\chapter{Game theory}\n\nIn this chapter, we will focus on two-player\ngames that do not contain random elements.\nOur goal is to find a strategy that we can\nfollow to win the game\nno matter what the opponent does,\nif such a strategy exists.\n\nIt turns out that there is a general strategy\nfor such games,\nand we can analyze the games using the \\key{nim theory}.\nFirst, we will analyze simple games where\nplayers remove sticks from heaps,\nand after this, we will generalize the strategy\nused in those games to other games.\n\n\\section{Game states}\n\nLet us consider a game where there is initially\na heap of $n$ sticks.\nPlayers $A$ and $B$ move alternately,\nand player $A$ begins.\nOn each move, the player has to remove\n1, 2 or 3 sticks from the heap,\nand the player who removes the last stick wins the game.\n\nFor example, if $n=10$, the game may proceed as follows:\n\\begin{itemize}[noitemsep]\n\\item Player $A$ removes 2 sticks (8 sticks left).\n\\item Player $B$ removes 3 sticks (5 sticks left).\n\\item Player $A$ removes 1 stick (4 sticks left).\n\\item Player $B$ removes 2 sticks (2 sticks left).\n\\item Player $A$ removes 2 sticks and wins.\n\\end{itemize}\n\nThis game consists of states $0,1,2,\\ldots,n$,\nwhere the number of the state corresponds to\nthe number of sticks left.\n\n\\subsubsection{Winning and losing states}\n\n\\index{winning state}\n\\index{losing state}\n\nA \\key{winning state} is a state where\nthe player will win the game if they\nplay optimally,\nand a \\key{losing state} is a state\nwhere the player will lose the game if the\nopponent plays optimally.\nIt turns out that we can classify all states\nof a game so that each state is either\na winning state or a losing state.\n\nIn the above game, state 0 is clearly a\nlosing state, because the player cannot make\nany moves.\nStates 1, 2 and 3 are winning states,\nbecause we can remove 1, 2 or 3 sticks\nand win the game.\nState 4, in turn, is a losing state,\nbecause any move leads to a state that\nis a winning state for the opponent.\n\nMore generally, if there is a move that leads\nfrom the current state to a losing state,\nthe current state is a winning state,\nand otherwise the current state is a losing state.\nUsing this observation, we can classify all states\nof a game starting with losing states where\nthere are no possible moves.\n\nThe states $0 \\ldots 15$ of the above game\ncan be classified as follows\n($W$ denotes a winning state and $L$ denotes a losing state):\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (16,1);\n\n\\node at (0.5,0.5) {$L$};\n\\node at (1.5,0.5) {$W$};\n\\node at (2.5,0.5) {$W$};\n\\node at (3.5,0.5) {$W$};\n\\node at (4.5,0.5) {$L$};\n\\node at (5.5,0.5) {$W$};\n\\node at (6.5,0.5) {$W$};\n\\node at (7.5,0.5) {$W$};\n\\node at (8.5,0.5) {$L$};\n\\node at (9.5,0.5) {$W$};\n\\node at (10.5,0.5) {$W$};\n\\node at (11.5,0.5) {$W$};\n\\node at (12.5,0.5) {$L$};\n\\node at (13.5,0.5) {$W$};\n\\node at (14.5,0.5) {$W$};\n\\node at (15.5,0.5) {$W$};\n\n\\footnotesize\n\\node at (0.5,1.4) {$0$};\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\node at (8.5,1.4) {$8$};\n\\node at (9.5,1.4) {$9$};\n\\node at (10.5,1.4) {$10$};\n\\node at (11.5,1.4) {$11$};\n\\node at (12.5,1.4) {$12$};\n\\node at (13.5,1.4) {$13$};\n\\node at (14.5,1.4) {$14$};\n\\node at (15.5,1.4) {$15$};\n\\end{tikzpicture}\n\\end{center}\n\nIt is easy to analyze this game:\na state $k$ is a losing state if $k$ is\ndivisible by 4, and otherwise it\nis a winning state.\nAn optimal way to play the game is\nto always choose a move after which\nthe number of sticks in the heap\nis divisible by 4.\nFinally, there are no sticks left and\nthe opponent has lost.\n\nOf course, this strategy requires that\nthe number of sticks is \\emph{not} divisible by 4\nwhen it is our move.\nIf it is, there is nothing we can do,\nand the opponent will win the game if\nthey play optimally.\n\n\\subsubsection{State graph}\n\nLet us now consider another stick game,\nwhere in each state $k$, it is allowed to remove\nany number $x$ of sticks such that $x$\nis smaller than $k$ and divides $k$.\nFor example, in state 8 we may remove\n1, 2 or 4 sticks, but in state 7 the only\nallowed move is to remove 1 stick.\n\nThe following picture shows the states\n$1 \\ldots 9$ of the game as a \\key{state graph},\nwhose nodes are the states and edges are the moves between them:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {$1$};\n\\node[draw, circle] (2) at (2,0) {$2$};\n\\node[draw, circle] (3) at (3.5,-1) {$3$};\n\\node[draw, circle] (4) at (1.5,-2) {$4$};\n\\node[draw, circle] (5) at (3,-2.75) {$5$};\n\\node[draw, circle] (6) at (2.5,-4.5) {$6$};\n\\node[draw, circle] (7) at (0.5,-3.25) {$7$};\n\\node[draw, circle] (8) at (-1,-4) {$8$};\n\\node[draw, circle] (9) at (1,-5.5) {$9$};\n\n\\path[draw,thick,->,>=latex] (2) -- (1);\n\\path[draw,thick,->,>=latex] (3) edge [bend right=20] (2);\n\\path[draw,thick,->,>=latex] (4) edge [bend left=20] (2);\n\\path[draw,thick,->,>=latex] (4) edge [bend left=20] (3);\n\\path[draw,thick,->,>=latex] (5) edge [bend right=20] (4);\n\\path[draw,thick,->,>=latex] (6) edge [bend left=20] (5);\n\\path[draw,thick,->,>=latex] (6) edge [bend left=20] (4);\n\\path[draw,thick,->,>=latex] (6) edge [bend right=40] (3);\n\\path[draw,thick,->,>=latex] (7) edge [bend right=20] (6);\n\\path[draw,thick,->,>=latex] (8) edge [bend right=20] (7);\n\\path[draw,thick,->,>=latex] (8) edge [bend right=20] (6);\n\\path[draw,thick,->,>=latex] (8) edge [bend left=20] (4);\n\\path[draw,thick,->,>=latex] (9) edge [bend left=20] (8);\n\\path[draw,thick,->,>=latex] (9) edge [bend right=20] (6);\n\\end{tikzpicture}\n\\end{center}\n\nThe final state in this game is always state 1,\nwhich is a losing state, because there are no\nvalid moves.\nThe classification of states $1 \\ldots 9$\nis as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (1,0) grid (10,1);\n\n\\node at (1.5,0.5) {$L$};\n\\node at (2.5,0.5) {$W$};\n\\node at (3.5,0.5) {$L$};\n\\node at (4.5,0.5) {$W$};\n\\node at (5.5,0.5) {$L$};\n\\node at (6.5,0.5) {$W$};\n\\node at (7.5,0.5) {$L$};\n\\node at (8.5,0.5) {$W$};\n\\node at (9.5,0.5) {$L$};\n\n\\footnotesize\n\\node at (1.5,1.4) {$1$};\n\\node at (2.5,1.4) {$2$};\n\\node at (3.5,1.4) {$3$};\n\\node at (4.5,1.4) {$4$};\n\\node at (5.5,1.4) {$5$};\n\\node at (6.5,1.4) {$6$};\n\\node at (7.5,1.4) {$7$};\n\\node at (8.5,1.4) {$8$};\n\\node at (9.5,1.4) {$9$};\n\\end{tikzpicture}\n\\end{center}\n\nSurprisingly, in this game,\nall even-numbered states are winning states,\nand all odd-numbered states are losing states.\n\n", "chapter_name": "Game theory", "chapter_path": "cphb/chapter25.tex"}, {"section_name": "Nim game", "section_content": "\\section{Nim game}\n\n\\index{nim game}\n\nThe \\key{nim game} is a simple game that\nhas an important role in game theory,\nbecause many other games can be played using\nthe same strategy.\nFirst, we focus on nim,\nand then we generalize the strategy\nto other games.\n\nThere are $n$ heaps in nim,\nand each heap contains some number of sticks.\nThe players move alternately,\nand on each turn, the player chooses\na heap that still contains sticks\nand removes any number of sticks from it.\nThe winner is the player who removes the last stick.\n\nThe states in nim are of the form\n$[x_1,x_2,\\ldots,x_n]$,\nwhere $x_k$ denotes the number of sticks in heap $k$.\nFor example, $[10,12,5]$ is a game where\nthere are three heaps with 10, 12 and 5 sticks.\nThe state $[0,0,\\ldots,0]$ is a losing state,\nbecause it is not possible to remove any sticks,\nand this is always the final state.\n\n\\subsubsection{Analysis}\n\\index{nim sum}\n\nIt turns out that we can easily classify\nany nim state by calculating\nthe \\key{nim sum} $s = x_1 \\oplus x_2 \\oplus \\cdots \\oplus x_n$,\nwhere $\\oplus$ is the xor operation\\footnote{The optimal strategy\nfor nim was published in 1901 by C. L. Bouton \\cite{bou01}.}.\nThe states whose nim sum is 0 are losing states,\nand all other states are winning states.\nFor example, the nim sum of\n$[10,12,5]$ is $10 \\oplus 12 \\oplus 5 = 3$,\nso the state is a winning state.\n\nBut how is the nim sum related to the nim game?\nWe can explain this by looking at how the nim\nsum changes when the nim state changes.\n\n\\textit{Losing states:}\nThe final state $[0,0,\\ldots,0]$ is a losing state,\nand its nim sum is 0, as expected.\nIn other losing states, any move leads to\na winning state, because when a single value $x_k$ changes,\nthe nim sum also changes, so the nim sum\nis different from 0 after the move.\n\n\\textit{Winning states:}\nWe can move to a losing state if\nthere is any heap $k$ for which $x_k \\oplus s < x_k$.\nIn this case, we can remove sticks from\nheap $k$ so that it will contain $x_k \\oplus s$ sticks,\nwhich will lead to a losing state.\nThere is always such a heap, where $x_k$\nhas a one bit at the position of the leftmost\none bit of $s$.\n\nAs an example, consider the state $[10,12,5]$.\nThis state is a winning state,\nbecause its nim sum is 3.\nThus, there has to be a move which\nleads to a losing state.\nNext we will find out such a move.\n\nThe nim sum of the state is as follows:\n\n\\begin{center}\n\\begin{tabular}{r|r}\n10 & \\texttt{1010} \\\\\n12 & \\texttt{1100} \\\\\n5 & \\texttt{0101} \\\\\n\\hline\n3 & \\texttt{0011} \\\\\n\\end{tabular}\n\\end{center}\n\nIn this case, the heap with 10 sticks\nis the only heap that has a one bit\nat the position of the leftmost\none bit of the nim sum:\n\n\\begin{center}\n\\begin{tabular}{r|r}\n10 & \\texttt{10\\underline{1}0} \\\\\n12 & \\texttt{1100} \\\\\n5 & \\texttt{0101} \\\\\n\\hline\n3 & \\texttt{00\\underline{1}1} \\\\\n\\end{tabular}\n\\end{center}\n\nThe new size of the heap has to be\n$10 \\oplus 3 = 9$,\nso we will remove just one stick.\nAfter this, the state will be $[9,12,5]$,\nwhich is a losing state:\n\n\\begin{center}\n\\begin{tabular}{r|r}\n9 & \\texttt{1001} \\\\\n12 & \\texttt{1100} \\\\\n5 & \\texttt{0101} \\\\\n\\hline\n0 & \\texttt{0000} \\\\\n\\end{tabular}\n\\end{center}\n\n\\subsubsection{Mis\u00e8re game}\n\n\\index{mis\u00e8re game}\n\nIn a \\key{mis\u00e8re game}, the goal of the game\nis opposite,\nso the player who removes the last stick\nloses the game.\nIt turns out that the mis\u00e8re nim game can be\noptimally played almost like the standard nim game.\n\nThe idea is to first play the mis\u00e8re game\nlike the standard game, but change the strategy\nat the end of the game.\nThe new strategy will be introduced in a situation\nwhere each heap would contain at most one stick\nafter the next move.\n\nIn the standard game, we should choose a move\nafter which there is an even number of heaps with one stick.\nHowever, in the mis\u00e8re game, we choose a move so that\nthere is an odd number of heaps with one stick.\n\nThis strategy works because a state where the\nstrategy changes always appears in the game,\nand this state is a winning state, because\nit contains exactly one heap that has more than one stick\nso the nim sum is not 0.\n\n", "chapter_name": "Game theory", "chapter_path": "cphb/chapter25.tex"}, {"section_name": "Sprague\u2013Grundy theorem", "section_content": "\\section{Sprague\u2013Grundy theorem}\n\n\\index{Sprague\u2013Grundy theorem}\n\nThe \\key{Sprague\u2013Grundy theorem}\\footnote{The theorem was\nindependently discovered by R. Sprague \\cite{spr35} and P. M. Grundy \\cite{gru39}.} generalizes the\nstrategy used in nim to all games that fulfil\nthe following requirements:\n\n\\begin{itemize}[noitemsep]\n\\item There are two players who move alternately.\n\\item The game consists of states, and the possible moves\nin a state do not depend on whose turn it is.\n\\item The game ends when a player cannot make a move.\n\\item The game surely ends sooner or later.\n\\item The players have complete information about\nthe states and allowed moves, and there is no randomness in the game.\n\\end{itemize}\nThe idea is to calculate for each game state\na Grundy number that corresponds to the number of\nsticks in a nim heap.\nWhen we know the Grundy numbers of all states,\nwe can play the game like the nim game.\n\n\\subsubsection{Grundy numbers}\n\n\\index{Grundy number}\n\\index{mex function}\n\nThe \\key{Grundy number} of a game state is\n\\[\\textrm{mex}(\\{g_1,g_2,\\ldots,g_n\\}),\\]\nwhere $g_1,g_2,\\ldots,g_n$ are the Grundy numbers of the\nstates to which we can move,\nand the mex function gives the smallest\nnonnegative number that is not in the set.\nFor example, $\\textrm{mex}(\\{0,1,3\\})=2$.\nIf there are no possible moves in a state,\nits Grundy number is 0, because\n$\\textrm{mex}(\\emptyset)=0$.\n\nFor example, in the state graph\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {\\phantom{0}};\n\\node[draw, circle] (2) at (2,0) {\\phantom{0}};\n\\node[draw, circle] (3) at (4,0) {\\phantom{0}};\n\\node[draw, circle] (4) at (1,-2) {\\phantom{0}};\n\\node[draw, circle] (5) at (3,-2) {\\phantom{0}};\n\\node[draw, circle] (6) at (5,-2) {\\phantom{0}};\n\n\\path[draw,thick,->,>=latex] (2) -- (1);\n\\path[draw,thick,->,>=latex] (3) -- (2);\n\\path[draw,thick,->,>=latex] (5) -- (4);\n\\path[draw,thick,->,>=latex] (6) -- (5);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\path[draw,thick,->,>=latex] (4) -- (2);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (6) -- (2);\n\\end{tikzpicture}\n\\end{center}\nthe Grundy numbers are as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,0) {0};\n\\node[draw, circle] (2) at (2,0) {1};\n\\node[draw, circle] (3) at (4,0) {0};\n\\node[draw, circle] (4) at (1,-2) {2};\n\\node[draw, circle] (5) at (3,-2) {0};\n\\node[draw, circle] (6) at (5,-2) {2};\n\n\\path[draw,thick,->,>=latex] (2) -- (1);\n\\path[draw,thick,->,>=latex] (3) -- (2);\n\\path[draw,thick,->,>=latex] (5) -- (4);\n\\path[draw,thick,->,>=latex] (6) -- (5);\n\\path[draw,thick,->,>=latex] (4) -- (1);\n\\path[draw,thick,->,>=latex] (4) -- (2);\n\\path[draw,thick,->,>=latex] (5) -- (2);\n\\path[draw,thick,->,>=latex] (6) -- (2);\n\\end{tikzpicture}\n\\end{center}\nThe Grundy number of a losing state is 0,\nand the Grundy number of a winning state is\na positive number.\n\nThe Grundy number of a state corresponds to\nthe number of sticks in a nim heap.\nIf the Grundy number is 0, we can only move to\nstates whose Grundy numbers are positive,\nand if the Grundy number is $x>0$, we can move\nto states whose Grundy numbers include all numbers\n$0,1,\\ldots,x-1$.\n\nAs an example, consider a game where\nthe players move a figure in a maze.\nEach square in the maze is either floor or wall.\nOn each turn, the player has to move\nthe figure some number\nof steps left or up.\nThe winner of the game is the player who\nmakes the last move.\n\nThe following picture shows a possible initial state\nof the game, where @ denotes the figure and *\ndenotes a square where it can move.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n  \\begin{scope}\n    \\fill [color=black] (0, 1) rectangle (1, 2);\n    \\fill [color=black] (0, 3) rectangle (1, 4);\n    \\fill [color=black] (2, 2) rectangle (3, 3);\n    \\fill [color=black] (2, 4) rectangle (3, 5);\n    \\fill [color=black] (4, 3) rectangle (5, 4);\n\n    \\draw (0, 0) grid (5, 5);\n    \n    \\node at (4.5,0.5) {@};\n    \\node at (3.5,0.5) {*};\n    \\node at (2.5,0.5) {*};\n    \\node at (1.5,0.5) {*};\n    \\node at (0.5,0.5) {*};\n    \\node at (4.5,1.5) {*};\n    \\node at (4.5,2.5) {*};\n    \n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nThe states of the game are all floor squares\nof the maze.\nIn the above maze, the Grundy numbers\nare as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=.65]\n  \\begin{scope}\n    \\fill [color=black] (0, 1) rectangle (1, 2);\n    \\fill [color=black] (0, 3) rectangle (1, 4);\n    \\fill [color=black] (2, 2) rectangle (3, 3);\n    \\fill [color=black] (2, 4) rectangle (3, 5);\n    \\fill [color=black] (4, 3) rectangle (5, 4);\n\n    \\draw (0, 0) grid (5, 5);\n    \n    \\node at (0.5,4.5) {0};\n    \\node at (1.5,4.5) {1};\n    \\node at (2.5,4.5) {};\n    \\node at (3.5,4.5) {0};\n    \\node at (4.5,4.5) {1};\n\n    \\node at (0.5,3.5) {};\n    \\node at (1.5,3.5) {0};\n    \\node at (2.5,3.5) {1};\n    \\node at (3.5,3.5) {2};\n    \\node at (4.5,3.5) {};\n\n    \\node at (0.5,2.5) {0};\n    \\node at (1.5,2.5) {2};\n    \\node at (2.5,2.5) {};\n    \\node at (3.5,2.5) {1};\n    \\node at (4.5,2.5) {0};\n\n    \\node at (0.5,1.5) {};\n    \\node at (1.5,1.5) {3};\n    \\node at (2.5,1.5) {0};\n    \\node at (3.5,1.5) {4};\n    \\node at (4.5,1.5) {1};\n\n    \\node at (0.5,0.5) {0};\n    \\node at (1.5,0.5) {4};\n    \\node at (2.5,0.5) {1};\n    \\node at (3.5,0.5) {3};\n    \\node at (4.5,0.5) {2};\n  \\end{scope}\n\\end{tikzpicture}\n\\end{center}\n\nThus, each state of the maze game\ncorresponds to a heap in the nim game.\nFor example, the Grundy number for\nthe lower-right square is 2,\nso it is a winning state.\nWe can reach a losing state and\nwin the game by moving\neither four steps left or\ntwo steps up.\n\nNote that unlike in the original nim game,\nit may be possible to move to a state whose\nGrundy number is larger than the Grundy number\nof the current state.\nHowever, the opponent can always choose a move\nthat cancels such a move, so it is not possible\nto escape from a losing state.\n\n\\subsubsection{Subgames}\n\nNext we will assume that our game consists\nof subgames, and on each turn, the player\nfirst chooses a subgame and then a move in the subgame.\nThe game ends when it is not possible to make any move\nin any subgame.\n\nIn this case, the Grundy number of a game\nis the nim sum of the Grundy numbers of the subgames.\nThe game can be played like a nim game by calculating\nall Grundy numbers for subgames and then their nim sum.\n\nAs an example, consider a game that consists\nof three mazes.\nIn this game, on each turn, the player chooses one\nof the mazes and then moves the figure in the maze.\nAssume that the initial state of the game is as follows:\n\n\\begin{center}\n\\begin{tabular}{ccc}\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\fill [color=black] (0, 1) rectangle (1, 2);\n    \\fill [color=black] (0, 3) rectangle (1, 4);\n    \\fill [color=black] (2, 2) rectangle (3, 3);\n    \\fill [color=black] (2, 4) rectangle (3, 5);\n    \\fill [color=black] (4, 3) rectangle (5, 4);\n\n    \\draw (0, 0) grid (5, 5);\n\n    \\node at (4.5,0.5) {@};\n\n    \\end{scope}\n\\end{tikzpicture}\n&\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\fill [color=black] (1, 1) rectangle (2, 3);\n    \\fill [color=black] (2, 3) rectangle (3, 4);\n    \\fill [color=black] (4, 4) rectangle (5, 5);\n\n    \\draw (0, 0) grid (5, 5);\n    \n    \\node at (4.5,0.5) {@};\n\n  \\end{scope}\n\\end{tikzpicture}\n&\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\fill [color=black] (1, 1) rectangle (4, 4);\n\n    \\draw (0, 0) grid (5, 5);\n    \n    \\node at (4.5,0.5) {@};\n  \\end{scope}\n\\end{tikzpicture}\n\\end{tabular}\n\\end{center}\n\nThe Grundy numbers for the mazes are as follows:\n\n\\begin{center}\n\\begin{tabular}{ccc}\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\fill [color=black] (0, 1) rectangle (1, 2);\n    \\fill [color=black] (0, 3) rectangle (1, 4);\n    \\fill [color=black] (2, 2) rectangle (3, 3);\n    \\fill [color=black] (2, 4) rectangle (3, 5);\n    \\fill [color=black] (4, 3) rectangle (5, 4);\n\n    \\draw (0, 0) grid (5, 5);\n\n    \\node at (0.5,4.5) {0};\n    \\node at (1.5,4.5) {1};\n    \\node at (2.5,4.5) {};\n    \\node at (3.5,4.5) {0};\n    \\node at (4.5,4.5) {1};\n\n    \\node at (0.5,3.5) {};\n    \\node at (1.5,3.5) {0};\n    \\node at (2.5,3.5) {1};\n    \\node at (3.5,3.5) {2};\n    \\node at (4.5,3.5) {};\n\n    \\node at (0.5,2.5) {0};\n    \\node at (1.5,2.5) {2};\n    \\node at (2.5,2.5) {};\n    \\node at (3.5,2.5) {1};\n    \\node at (4.5,2.5) {0};\n\n    \\node at (0.5,1.5) {};\n    \\node at (1.5,1.5) {3};\n    \\node at (2.5,1.5) {0};\n    \\node at (3.5,1.5) {4};\n    \\node at (4.5,1.5) {1};\n\n    \\node at (0.5,0.5) {0};\n    \\node at (1.5,0.5) {4};\n    \\node at (2.5,0.5) {1};\n    \\node at (3.5,0.5) {3};\n    \\node at (4.5,0.5) {2};\n    \\end{scope}\n\\end{tikzpicture}\n&\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\fill [color=black] (1, 1) rectangle (2, 3);\n    \\fill [color=black] (2, 3) rectangle (3, 4);\n    \\fill [color=black] (4, 4) rectangle (5, 5);\n\n    \\draw (0, 0) grid (5, 5);\n\n    \\node at (0.5,4.5) {0};\n    \\node at (1.5,4.5) {1};\n    \\node at (2.5,4.5) {2};\n    \\node at (3.5,4.5) {3};\n    \\node at (4.5,4.5) {};\n\n    \\node at (0.5,3.5) {1};\n    \\node at (1.5,3.5) {0};\n    \\node at (2.5,3.5) {};\n    \\node at (3.5,3.5) {0};\n    \\node at (4.5,3.5) {1};\n\n    \\node at (0.5,2.5) {2};\n    \\node at (1.5,2.5) {};\n    \\node at (2.5,2.5) {0};\n    \\node at (3.5,2.5) {1};\n    \\node at (4.5,2.5) {2};\n\n    \\node at (0.5,1.5) {3};\n    \\node at (1.5,1.5) {};\n    \\node at (2.5,1.5) {1};\n    \\node at (3.5,1.5) {2};\n    \\node at (4.5,1.5) {0};\n\n    \\node at (0.5,0.5) {4};\n    \\node at (1.5,0.5) {0};\n    \\node at (2.5,0.5) {2};\n    \\node at (3.5,0.5) {5};\n    \\node at (4.5,0.5) {3};\n  \\end{scope}\n\\end{tikzpicture}\n&\n\\begin{tikzpicture}[scale=.55]\n  \\begin{scope}\n    \\fill [color=black] (1, 1) rectangle (4, 4);\n\n    \\draw (0, 0) grid (5, 5);\n\n    \\node at (0.5,4.5) {0};\n    \\node at (1.5,4.5) {1};\n    \\node at (2.5,4.5) {2};\n    \\node at (3.5,4.5) {3};\n    \\node at (4.5,4.5) {4};\n\n    \\node at (0.5,3.5) {1};\n    \\node at (1.5,3.5) {};\n    \\node at (2.5,3.5) {};\n    \\node at (3.5,3.5) {};\n    \\node at (4.5,3.5) {0};\n\n    \\node at (0.5,2.5) {2};\n    \\node at (1.5,2.5) {};\n    \\node at (2.5,2.5) {};\n    \\node at (3.5,2.5) {};\n    \\node at (4.5,2.5) {1};\n\n    \\node at (0.5,1.5) {3};\n    \\node at (1.5,1.5) {};\n    \\node at (2.5,1.5) {};\n    \\node at (3.5,1.5) {};\n    \\node at (4.5,1.5) {2};\n\n    \\node at (0.5,0.5) {4};\n    \\node at (1.5,0.5) {0};\n    \\node at (2.5,0.5) {1};\n    \\node at (3.5,0.5) {2};\n    \\node at (4.5,0.5) {3};\n  \\end{scope}\n\\end{tikzpicture}\n\\end{tabular}\n\\end{center}\n\nIn the initial state, the nim sum of the Grundy numbers\nis $2 \\oplus 3 \\oplus 3 = 2$, so\nthe first player can win the game.\nOne optimal move is to move two steps up\nin the first maze, which produces the nim sum\n$0 \\oplus 3 \\oplus 3 = 0$.\n\n\\subsubsection{Grundy's game}\n\nSometimes a move in a game divides the game\ninto subgames that are independent of each other.\nIn this case, the Grundy number of the game is\n\n\\[\\textrm{mex}(\\{g_1, g_2, \\ldots, g_n \\}),\\]\nwhere $n$ is the number of possible moves and\n\\[g_k = a_{k,1} \\oplus a_{k,2} \\oplus \\ldots \\oplus a_{k,m},\\]\nwhere move $k$ generates subgames with\nGrundy numbers $a_{k,1},a_{k,2},\\ldots,a_{k,m}$.\n\n\\index{Grundy's game}\n\nAn example of such a game is \\key{Grundy's game}.\nInitially, there is a single heap that contains $n$ sticks.\nOn each turn, the player chooses a heap and divides\nit into two nonempty heaps such that the heaps\nare of different size.\nThe player who makes the last move wins the game.\n\nLet $f(n)$ be the Grundy number of a heap\nthat contains $n$ sticks.\nThe Grundy number can be calculated by going\nthrough all ways to divide the heap into\ntwo heaps.\nFor example, when $n=8$, the possibilities\nare $1+7$, $2+6$ and $3+5$, so\n\\[f(8)=\\textrm{mex}(\\{f(1) \\oplus f(7), f(2) \\oplus f(6), f(3) \\oplus f(5)\\}).\\]\n\nIn this game, the value of $f(n)$ is based on the values\nof $f(1),\\ldots,f(n-1)$.\nThe base cases are $f(1)=f(2)=0$,\nbecause it is not possible to divide the heaps\nof 1 and 2 sticks.\nThe first Grundy numbers are:\n\\[\n\\begin{array}{lcl}\nf(1) & = & 0 \\\\\nf(2) & = & 0 \\\\\nf(3) & = & 1 \\\\\nf(4) & = & 0 \\\\\nf(5) & = & 2 \\\\\nf(6) & = & 1 \\\\\nf(7) & = & 0 \\\\\nf(8) & = & 2 \\\\\n\\end{array}\n\\]\nThe Grundy number for $n=8$ is 2,\nso it is possible to win the game.\nThe winning move is to create heaps\n$1+7$, because $f(1) \\oplus f(7) = 0$.\n\n", "chapter_name": "Game theory", "chapter_path": "cphb/chapter25.tex"}, {"section_name": "String terminology", "section_content": "\\chapter{String algorithms}\n\nThis chapter deals with efficient algorithms\nfor string processing.\nMany string problems can be easily solved\nin $O(n^2)$ time, but the challenge is to\nfind algorithms that work in $O(n)$ or $O(n \\log n)$\ntime.\n\n\\index{pattern matching}\n\nFor example, a fundamental string processing\nproblem is the \\key{pattern matching} problem:\ngiven a string of length $n$ and a pattern of length $m$,\nour task is to find the occurrences of the pattern\nin the string.\nFor example, the pattern \\texttt{ABC} occurs two\ntimes in the string \\texttt{ABABCBABC}.\n\nThe pattern matching problem can be easily solved\nin $O(nm)$ time by a brute force algorithm that\ntests all positions where the pattern may\noccur in the string.\nHowever, in this chapter, we will see that there\nare more efficient algorithms that require only\n$O(n+m)$ time.\n\n\\index{string}\n\n\\section{String terminology}\n\n\\index{alphabet}\n\nThroughout the chapter, we assume that\nzero-based indexing is used in strings.\nThus, a string \\texttt{s} of length $n$\nconsists of characters\n$\\texttt{s}[0],\\texttt{s}[1],\\ldots,\\texttt{s}[n-1]$.\nThe set of characters that may appear\nin strings is called an \\key{alphabet}.\nFor example, the alphabet\n$\\{\\texttt{A},\\texttt{B},\\ldots,\\texttt{Z}\\}$\nconsists of the capital letters of English.\n\n\\index{substring}\n\nA \\key{substring} is a sequence of consecutive\ncharacters in a string.\nWe use the notation $\\texttt{s}[a \\ldots b]$\nto refer to a substring of \\texttt{s}\nthat begins at position $a$ and ends at position $b$.\nA string of length $n$ has $n(n+1)/2$ substrings.\nFor example, the substrings of\n\\texttt{ABCD} are\n\\texttt{A}, \\texttt{B}, \\texttt{C}, \\texttt{D},\n\\texttt{AB}, \\texttt{BC}, \\texttt{CD},\n\\texttt{ABC}, \\texttt{BCD} and \\texttt{ABCD}.\n\n\\index{subsequence}\n\nA \\key{subsequence} is a sequence of\n(not necessarily consecutive) characters\nin a string in their original order.\nA string of length $n$ has $2^n-1$ subsequences.\nFor example, the subsequences of\n\\texttt{ABCD} are\n\\texttt{A}, \\texttt{B}, \\texttt{C}, \\texttt{D},\n\\texttt{AB}, \\texttt{AC}, \\texttt{AD},\n\\texttt{BC}, \\texttt{BD}, \\texttt{CD},\n\\texttt{ABC}, \\texttt{ABD}, \\texttt{ACD},\n\\texttt{BCD} and \\texttt{ABCD}.\n\n\\index{prefix}\n\\index{suffix}\n\nA \\key{prefix} is a substring that starts at the beginning\nof a string,\nand a \\key{suffix} is a substring that ends at the end\nof a string.\nFor example,\nthe prefixes of \\texttt{ABCD} are\n\\texttt{A}, \\texttt{AB}, \\texttt{ABC} and \\texttt{ABCD},\nand the suffixes of \\texttt{ABCD} are\n\\texttt{D}, \\texttt{CD}, \\texttt{BCD} and \\texttt{ABCD}.\n\n\\index{rotation}\n\nA \\key{rotation} can be generated by moving\nthe characters of a string one by one from the beginning\nto the end (or vice versa).\nFor example, the rotations of \\texttt{ABCD} are\n\\texttt{ABCD}, \\texttt{BCDA}, \\texttt{CDAB} and \\texttt{DABC}.\n\n\\index{period}\n\nA \\key{period} is a prefix of a string such that\nthe string can be constructed by repeating the period.\nThe last repetition may be partial and contain\nonly a prefix of the period.\nFor example, the shortest period of\n\\texttt{ABCABCA} is \\texttt{ABC}.\n\n\\index{border}\n\nA \\key{border} is a string that is both\na prefix and a suffix of a string.\nFor example, the borders of \\texttt{ABACABA}\nare \\texttt{A}, \\texttt{ABA} and \\texttt{ABACABA}.\n\n\\index{lexicographical order}\n\nStrings are compared using the \\key{lexicographical order}\n(which corresponds to the alphabetical order).\nIt means that $x<y$ if either $x \\neq y$ and $x$ is a prefix of $y$,\nor there is a position $k$ such that\n$x[i]=y[i]$ when $i<k$ and $x[k]<y[k]$.\n\n", "chapter_name": "String algorithms", "chapter_path": "cphb/chapter26.tex"}, {"section_name": "Trie structure", "section_content": "\\section{Trie structure}\n\n\\index{trie}\n\nA \\key{trie} is a rooted tree that\nmaintains a set of strings.\nEach string in the set is stored as\na chain of characters that starts at the root.\nIf two strings have a common prefix,\nthey also have a common chain in the tree.\n\nFor example, consider the following trie:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\node[draw, circle] (1) at (0,20) {$\\phantom{1}$};\n\\node[draw, circle] (2) at (-1.5,19) {$\\phantom{1}$};\n\\node[draw, circle] (3) at (1.5,19) {$\\phantom{1}$};\n\\node[draw, circle] (4) at (-1.5,17.5) {$\\phantom{1}$};\n\\node[draw, circle] (5) at (-1.5,16) {$\\phantom{1}$};\n\\node[draw, circle] (6) at (-2.5,14.5) {$\\phantom{1}$};\n\\node[draw, circle] (7) at (-0.5,14.5) {$\\phantom{1}$};\n\\node[draw, circle] (8) at (-2.5,13) {*};\n\\node[draw, circle] (9) at (-0.5,13) {*};\n\\node[draw, circle] (10) at (1.5,17.5) {$\\phantom{1}$};\n\\node[draw, circle] (11) at (1.5,16) {*};\n\\node[draw, circle] (12) at (1.5,14.5) {$\\phantom{1}$};\n\\node[draw, circle] (13) at (1.5,13) {*};\n\n\\path[draw,thick,->] (1) -- node[font=\\small,label=\\texttt{C}] {} (2);\n\\path[draw,thick,->] (1) -- node[font=\\small,label=\\texttt{T}] {} (3);\n\\path[draw,thick,->] (2) -- node[font=\\small,label=left:\\texttt{A}] {} (4);\n\\path[draw,thick,->] (4) -- node[font=\\small,label=left:\\texttt{N}] {} (5);\n\\path[draw,thick,->] (5) -- node[font=\\small,label=left:\\texttt{A}] {} (6);\n\\path[draw,thick,->] (5) -- node[font=\\small,label=right:\\texttt{D}] {} (7);\n\\path[draw,thick,->] (6) -- node[font=\\small,label=left:\\texttt{L}] {}(8);\n\\path[draw,thick,->] (7) -- node[font=\\small,label=right:\\texttt{Y}] {} (9);\n\\path[draw,thick,->] (3) -- node[font=\\small,label=right:\\texttt{H}] {} (10);\n\\path[draw,thick,->] (10) -- node[font=\\small,label=right:\\texttt{E}] {} (11);\n\\path[draw,thick,->] (11) -- node[font=\\small,label=right:\\texttt{R}] {} (12);\n\\path[draw,thick,->] (12) -- node[font=\\small,label=right:\\texttt{E}] {} (13);\n\\end{tikzpicture}\n\\end{center}\n\nThis trie corresponds to the set\n$\\{\\texttt{CANAL},\\texttt{CANDY},\\texttt{THE},\\texttt{THERE}\\}$.\nThe character * in a node means that\na string in the set ends at the node.\nSuch a character is needed, because a string\nmay be a prefix of another string.\nFor example, in the above trie, \\texttt{THE}\nis a prefix of \\texttt{THERE}.\n\nWe can check in $O(n)$ time whether a trie\ncontains a string of length $n$,\nbecause we can follow the chain that starts at the root node.\nWe can also add a string of length $n$ to the trie\nin $O(n)$ time by first following the chain\nand then adding new nodes to the trie if necessary.\n\nUsing a trie, we can find\nthe longest prefix of a given string\nsuch that the prefix belongs to the set.\nMoreover, by storing additional information\nin each node,\nwe can calculate the number of\nstrings that belong to the set and have a\ngiven string as a prefix.\n\nA trie can be stored in an array\n\\begin{lstlisting}\nint trie[N][A];\n\\end{lstlisting}\nwhere $N$ is the maximum number of nodes\n(the maximum total length of the strings in the set)\nand $A$ is the size of the alphabet.\nThe nodes of a trie are numbered\n$0,1,2,\\ldots$ so that the number of the root is 0,\nand $\\texttt{trie}[s][c]$ is the next node in the chain\nwhen we move from node $s$ using character $c$.\n\n", "chapter_name": "String algorithms", "chapter_path": "cphb/chapter26.tex"}, {"section_name": "String hashing", "section_content": "\\section{String hashing}\n\n\\index{hashing}\n\\index{string hashing}\n\n\\key{String hashing} is a technique that\nallows us to efficiently check whether two\nstrings are equal\\footnote{The technique\nwas popularized by the Karp\u2013Rabin pattern matching\nalgorithm \\cite{kar87}.}.\nThe idea in string hashing is to compare hash values of\nstrings instead of their individual characters.\n\n\\subsubsection*{Calculating hash values}\n\n\\index{hash value}\n\\index{polynomial hashing}\n\nA \\key{hash value} of a string is\na number that is calculated from the characters\nof the string.\nIf two strings are the same,\ntheir hash values are also the same,\nwhich makes it possible to compare strings\nbased on their hash values.\n\nA usual way to implement string hashing\nis \\key{polynomial hashing}, which means\nthat the hash value of a string \\texttt{s}\nof length $n$ is\n\\[(\\texttt{s}[0] A^{n-1} + \\texttt{s}[1] A^{n-2} + \\cdots + \\texttt{s}[n-1] A^0) \\bmod B  ,\\]\nwhere $s[0],s[1],\\ldots,s[n-1]$\nare interpreted as the codes of the characters of \\texttt{s},\nand $A$ and $B$ are pre-chosen constants.\n\nFor example, the codes of the characters\nof \\texttt{ALLEY} are:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (5,2);\n\n\\node at (0.5, 1.5) {\\texttt{A}};\n\\node at (1.5, 1.5) {\\texttt{L}};\n\\node at (2.5, 1.5) {\\texttt{L}};\n\\node at (3.5, 1.5) {\\texttt{E}};\n\\node at (4.5, 1.5) {\\texttt{Y}};\n\n\\node at (0.5, 0.5) {65};\n\\node at (1.5, 0.5) {76};\n\\node at (2.5, 0.5) {76};\n\\node at (3.5, 0.5) {69};\n\\node at (4.5, 0.5) {89};\n\n\\end{tikzpicture}\n\\end{center}\n\nThus, if $A=3$ and $B=97$, the hash value\nof \\texttt{ALLEY} is\n\\[(65 \\cdot 3^4 + 76 \\cdot 3^3 + 76 \\cdot 3^2 + 69 \\cdot 3^1 + 89 \\cdot 3^0) \\bmod 97 = 52.\\]\n\n\\subsubsection*{Preprocessing}\n\nUsing polynomial hashing, we can calculate the hash value of any substring\nof a string \\texttt{s} in $O(1)$ time after an $O(n)$ time preprocessing.\nThe idea is to construct an array \\texttt{h} such that\n$\\texttt{h}[k]$ contains the hash value of the prefix $\\texttt{s}[0 \\ldots k]$.\nThe array values can be recursively calculated as follows:\n\\[\n\\begin{array}{lcl}\n\\texttt{h}[0] & = & \\texttt{s}[0] \\\\\n\\texttt{h}[k] & = & (\\texttt{h}[k-1] A + \\texttt{s}[k]) \\bmod B \\\\\n\\end{array}\n\\]\nIn addition, we construct an array $\\texttt{p}$\nwhere $\\texttt{p}[k]=A^k \\bmod B$:\n\\[\n\\begin{array}{lcl}\n\\texttt{p}[0] & = & 1 \\\\\n\\texttt{p}[k] & = & (\\texttt{p}[k-1] A) \\bmod B. \\\\\n\\end{array}\n\\]\nConstructing these arrays takes $O(n)$ time.\nAfter this, the hash value of any substring\n$\\texttt{s}[a \\ldots b]$\ncan be calculated in $O(1)$ time using the formula\n\\[(\\texttt{h}[b]-\\texttt{h}[a-1] \\texttt{p}[b-a+1]) \\bmod B\\]\nassuming that $a>0$.\nIf $a=0$, the hash value is simply $\\texttt{h}[b]$.\n\n\\subsubsection*{Using hash values}\n\nWe can efficiently compare strings using hash values.\nInstead of comparing the individual characters of the strings,\nthe idea is to compare their hash values.\nIf the hash values are equal,\nthe strings are \\emph{probably} equal,\nand if the hash values are different,\nthe strings are \\emph{certainly} different.\n\nUsing hashing, we can often make a brute force\nalgorithm efficient.\nAs an example, consider the pattern matching problem:\ngiven a string $s$ and a pattern $p$,\nfind the positions where $p$ occurs in $s$.\nA brute force algorithm goes through all positions\nwhere $p$ may occur and compares the strings\ncharacter by character.\nThe time complexity of such an algorithm is $O(n^2)$.\n\nWe can make the brute force algorithm more efficient\nby using hashing, because the algorithm compares\nsubstrings of strings.\nUsing hashing, each comparison only takes $O(1)$ time,\nbecause only hash values of substrings are compared.\nThis results in an algorithm with time complexity $O(n)$,\nwhich is the best possible time complexity for this problem.\n\nBy combining hashing and \\emph{binary search},\nit is also possible to find out the lexicographic order of\ntwo strings in logarithmic time.\nThis can be done by calculating the length\nof the common prefix of the strings using binary search.\nOnce we know the length of the common prefix,\nwe can just check the next character after the prefix,\nbecause this determines the order of the strings.\n\n\\subsubsection*{Collisions and parameters}\n\n\\index{collision}\n\nAn evident risk when comparing hash values is\na \\key{collision}, which means that two strings have\ndifferent contents but equal hash values.\nIn this case, an algorithm that relies on\nthe hash values concludes that the strings are equal,\nbut in reality they are not,\nand the algorithm may give incorrect results.\n\nCollisions are always possible,\nbecause the number of different strings is larger\nthan the number of different hash values.\nHowever, the probability of a collision is small\nif the constants $A$ and $B$ are carefully chosen.\nA usual way is to choose random constants\nnear $10^9$, for example as follows:\n\\[\n\\begin{array}{lcl}\nA & = & 911382323 \\\\\nB & = & 972663749 \\\\\n\\end{array}\n\\]\n\nUsing such constants,\nthe \\texttt{long long} type can be used\nwhen calculating hash values,\nbecause the products $AB$ and $BB$ will fit in \\texttt{long long}.\nBut is it enough to have about $10^9$ different hash values?\n\nLet us consider three scenarios where hashing can be used:\n\n\\textit{Scenario 1:} Strings $x$ and $y$ are compared with\neach other.\nThe probability of a collision is $1/B$ assuming that\nall hash values are equally probable.\n\n\\textit{Scenario 2:} A string $x$ is compared with strings\n$y_1,y_2,\\ldots,y_n$.\nThe probability of one or more collisions is\n\n\\[1-(1-\\frac{1}{B})^n.\\]\n\n\\textit{Scenario 3:} All pairs of strings $x_1,x_2,\\ldots,x_n$\nare compared with each other.\nThe probability of one or more collisions is\n\\[ 1 - \\frac{B \\cdot (B-1) \\cdot (B-2) \\cdots (B-n+1)}{B^n}.\\]\n\nThe following table shows the collision probabilities\nwhen $n=10^6$ and the value of $B$ varies:\n\n\\begin{center}\n\\begin{tabular}{rrrr}\nconstant $B$ & scenario 1 & scenario 2 & scenario 3 \\\\\n\\hline\n$10^3$ & $0.001000$ & $1.000000$ & $1.000000$ \\\\\n$10^6$ & $0.000001$ & $0.632121$ & $1.000000$ \\\\\n$10^9$ & $0.000000$ & $0.001000$ & $1.000000$ \\\\\n$10^{12}$ & $0.000000$ & $0.000000$ & $0.393469$ \\\\\n$10^{15}$ & $0.000000$ & $0.000000$ & $0.000500$ \\\\\n$10^{18}$ & $0.000000$ & $0.000000$ & $0.000001$ \\\\\n\\end{tabular}\n\\end{center}\n\nThe table shows that in scenario 1,\nthe probability of a collision is negligible\nwhen $B \\approx 10^9$.\nIn scenario 2, a collision is possible but the\nprobability is still quite small.\nHowever, in scenario 3 the situation is very different:\na collision will almost always happen when\n$B \\approx 10^9$.\n\n\\index{birthday paradox}\n\nThe phenomenon in scenario 3 is known as the\n\\key{birthday paradox}: if there are $n$ people\nin a room, the probability that \\emph{some} two people\nhave the same birthday is large even if $n$ is quite small.\nIn hashing, correspondingly, when all hash values are compared\nwith each other, the probability that some two\nhash values are equal is large.\n\nWe can make the probability of a collision\nsmaller by calculating \\emph{multiple} hash values\nusing different parameters.\nIt is unlikely that a collision would occur\nin all hash values at the same time.\nFor example, two hash values with parameter\n$B \\approx 10^9$ correspond to one hash\nvalue with parameter $B \\approx 10^{18}$,\nwhich makes the probability of a collision very small.\n\nSome people use constants $B=2^{32}$ and $B=2^{64}$,\nwhich is convenient, because operations with 32 and 64\nbit integers are calculated modulo $2^{32}$ and $2^{64}$.\nHowever, this is \\emph{not} a good choice, because it is possible\nto construct inputs that always generate collisions when\nconstants of the form $2^x$ are used \\cite{pac13}.\n\n", "chapter_name": "String algorithms", "chapter_path": "cphb/chapter26.tex"}, {"section_name": "Z-algorithm", "section_content": "\\section{Z-algorithm}\n\n\\index{Z-algorithm}\n\\index{Z-array}\n\nThe \\key{Z-array} \\texttt{z} of a string \\texttt{s}\nof length $n$ contains for each $k=0,1,\\ldots,n-1$\nthe length of the longest substring of \\texttt{s}\nthat begins at position $k$ and is a prefix of \\texttt{s}.\nThus, $\\texttt{z}[k]=p$ tells us that\n$\\texttt{s}[0 \\ldots p-1]$ equals $\\texttt{s}[k \\ldots k+p-1]$.\nMany string processing problems can be efficiently solved\nusing the Z-array.\n\nFor example, the Z-array of\n\\texttt{ACBACDACBACBACDA} is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (16,2);\n\n\\node at (0.5, 1.5) {\\texttt{A}};\n\\node at (1.5, 1.5) {\\texttt{C}};\n\\node at (2.5, 1.5) {\\texttt{B}};\n\\node at (3.5, 1.5) {\\texttt{A}};\n\\node at (4.5, 1.5) {\\texttt{C}};\n\\node at (5.5, 1.5) {\\texttt{D}};\n\\node at (6.5, 1.5) {\\texttt{A}};\n\\node at (7.5, 1.5) {\\texttt{C}};\n\\node at (8.5, 1.5) {\\texttt{B}};\n\\node at (9.5, 1.5) {\\texttt{A}};\n\\node at (10.5, 1.5) {\\texttt{C}};\n\\node at (11.5, 1.5) {\\texttt{B}};\n\\node at (12.5, 1.5) {\\texttt{A}};\n\\node at (13.5, 1.5) {\\texttt{C}};\n\\node at (14.5, 1.5) {\\texttt{D}};\n\\node at (15.5, 1.5) {\\texttt{A}};\n\n\\node at (0.5, 0.5) {--};\n\\node at (1.5, 0.5) {0};\n\\node at (2.5, 0.5) {0};\n\\node at (3.5, 0.5) {2};\n\\node at (4.5, 0.5) {0};\n\\node at (5.5, 0.5) {0};\n\\node at (6.5, 0.5) {5};\n\\node at (7.5, 0.5) {0};\n\\node at (8.5, 0.5) {0};\n\\node at (9.5, 0.5) {7};\n\\node at (10.5, 0.5) {0};\n\\node at (11.5, 0.5) {0};\n\\node at (12.5, 0.5) {2};\n\\node at (13.5, 0.5) {0};\n\\node at (14.5, 0.5) {0};\n\\node at (15.5, 0.5) {1};\n\n\\footnotesize\n\\node at (0.5, 2.5) {0};\n\\node at (1.5, 2.5) {1};\n\\node at (2.5, 2.5) {2};\n\\node at (3.5, 2.5) {3};\n\\node at (4.5, 2.5) {4};\n\\node at (5.5, 2.5) {5};\n\\node at (6.5, 2.5) {6};\n\\node at (7.5, 2.5) {7};\n\\node at (8.5, 2.5) {8};\n\\node at (9.5, 2.5) {9};\n\\node at (10.5, 2.5) {10};\n\\node at (11.5, 2.5) {11};\n\\node at (12.5, 2.5) {12};\n\\node at (13.5, 2.5) {13};\n\\node at (14.5, 2.5) {14};\n\\node at (15.5, 2.5) {15};\n\n\\end{tikzpicture}\n\\end{center}\n\nIn this case, for example, $\\texttt{z}[6]=5$,\nbecause the substring \\texttt{ACBAC} of length 5\nis a prefix of \\texttt{s},\nbut the substring \\texttt{ACBACB} of length 6\nis not a prefix of \\texttt{s}.\n\n\\subsubsection*{Algorithm description}\n\nNext we describe an algorithm,\ncalled the \\key{Z-algorithm}\\footnote{The Z-algorithm\nwas presented in \\cite{gus97} as the simplest known\nmethod for linear-time pattern matching, and the original idea\nwas attributed to \\cite{mai84}.},\nthat efficiently constructs the Z-array in $O(n)$ time.\nThe algorithm calculates the Z-array values\nfrom left to right by both using information\nalready stored in the Z-array and comparing substrings\ncharacter by character.\n\nTo efficiently calculate the Z-array values,\nthe algorithm maintains a range $[x,y]$ such that\n$\\texttt{s}[x \\ldots y]$ is a prefix of \\texttt{s}\nand $y$ is as large as possible.\nSince we know that $\\texttt{s}[0 \\ldots y-x]$\nand $\\texttt{s}[x \\ldots y]$ are equal,\nwe can use this information when calculating\nZ-values for positions $x+1,x+2,\\ldots,y$.\n\nAt each position $k$, we first\ncheck the value of $\\texttt{z}[k-x]$.\nIf $k+\\texttt{z}[k-x]<y$, we know that $\\texttt{z}[k]=\\texttt{z}[k-x]$.\nHowever, if $k+\\texttt{z}[k-x] \\ge y$,\n$\\texttt{s}[0 \\ldots y-k]$ equals\n$\\texttt{s}[k \\ldots y]$, and to determine the\nvalue of $\\texttt{z}[k]$ we need to compare\nthe substrings character by character.\nStill, the algorithm works in $O(n)$ time,\nbecause we start comparing at positions\n$y-k+1$ and $y+1$.\n\nFor example, let us construct the following Z-array:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (16,2);\n\n\\node at (0.5, 1.5) {A};\n\\node at (1.5, 1.5) {C};\n\\node at (2.5, 1.5) {B};\n\\node at (3.5, 1.5) {A};\n\\node at (4.5, 1.5) {C};\n\\node at (5.5, 1.5) {D};\n\\node at (6.5, 1.5) {A};\n\\node at (7.5, 1.5) {C};\n\\node at (8.5, 1.5) {B};\n\\node at (9.5, 1.5) {A};\n\\node at (10.5, 1.5) {C};\n\\node at (11.5, 1.5) {B};\n\\node at (12.5, 1.5) {A};\n\\node at (13.5, 1.5) {C};\n\\node at (14.5, 1.5) {D};\n\\node at (15.5, 1.5) {A};\n\n\\node at (0.5, 0.5) {--};\n\\node at (1.5, 0.5) {?};\n\\node at (2.5, 0.5) {?};\n\\node at (3.5, 0.5) {?};\n\\node at (4.5, 0.5) {?};\n\\node at (5.5, 0.5) {?};\n\\node at (6.5, 0.5) {?};\n\\node at (7.5, 0.5) {?};\n\\node at (8.5, 0.5) {?};\n\\node at (9.5, 0.5) {?};\n\\node at (10.5, 0.5) {?};\n\\node at (11.5, 0.5) {?};\n\\node at (12.5, 0.5) {?};\n\\node at (13.5, 0.5) {?};\n\\node at (14.5, 0.5) {?};\n\\node at (15.5, 0.5) {?};\n\n\\footnotesize\n\\node at (0.5, 2.5) {0};\n\\node at (1.5, 2.5) {1};\n\\node at (2.5, 2.5) {2};\n\\node at (3.5, 2.5) {3};\n\\node at (4.5, 2.5) {4};\n\\node at (5.5, 2.5) {5};\n\\node at (6.5, 2.5) {6};\n\\node at (7.5, 2.5) {7};\n\\node at (8.5, 2.5) {8};\n\\node at (9.5, 2.5) {9};\n\\node at (10.5, 2.5) {10};\n\\node at (11.5, 2.5) {11};\n\\node at (12.5, 2.5) {12};\n\\node at (13.5, 2.5) {13};\n\\node at (14.5, 2.5) {14};\n\\node at (15.5, 2.5) {15};\n\n\\end{tikzpicture}\n\\end{center}\n\nAfter calculating the value $\\texttt{z}[6]=5$,\nthe current $[x,y]$ range is $[6,10]$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (6,0) rectangle (7,1);\n\\draw (0,0) grid (16,2);\n\n\\node at (0.5, 1.5) {A};\n\\node at (1.5, 1.5) {C};\n\\node at (2.5, 1.5) {B};\n\\node at (3.5, 1.5) {A};\n\\node at (4.5, 1.5) {C};\n\\node at (5.5, 1.5) {D};\n\\node at (6.5, 1.5) {A};\n\\node at (7.5, 1.5) {C};\n\\node at (8.5, 1.5) {B};\n\\node at (9.5, 1.5) {A};\n\\node at (10.5, 1.5) {C};\n\\node at (11.5, 1.5) {B};\n\\node at (12.5, 1.5) {A};\n\\node at (13.5, 1.5) {C};\n\\node at (14.5, 1.5) {D};\n\\node at (15.5, 1.5) {A};\n\n\\node at (0.5, 0.5) {--};\n\\node at (1.5, 0.5) {0};\n\\node at (2.5, 0.5) {0};\n\\node at (3.5, 0.5) {2};\n\\node at (4.5, 0.5) {0};\n\\node at (5.5, 0.5) {0};\n\\node at (6.5, 0.5) {5};\n\\node at (7.5, 0.5) {?};\n\\node at (8.5, 0.5) {?};\n\\node at (9.5, 0.5) {?};\n\\node at (10.5, 0.5) {?};\n\\node at (11.5, 0.5) {?};\n\\node at (12.5, 0.5) {?};\n\\node at (13.5, 0.5) {?};\n\\node at (14.5, 0.5) {?};\n\\node at (15.5, 0.5) {?};\n\n\\draw [decoration={brace}, decorate, line width=0.5mm] (6,3.00) -- (11,3.00);\n\n\\node at (6.5,3.50) {$x$};\n\\node at (10.5,3.50) {$y$};\n\n\n\\footnotesize\n\\node at (0.5, 2.5) {0};\n\\node at (1.5, 2.5) {1};\n\\node at (2.5, 2.5) {2};\n\\node at (3.5, 2.5) {3};\n\\node at (4.5, 2.5) {4};\n\\node at (5.5, 2.5) {5};\n\\node at (6.5, 2.5) {6};\n\\node at (7.5, 2.5) {7};\n\\node at (8.5, 2.5) {8};\n\\node at (9.5, 2.5) {9};\n\\node at (10.5, 2.5) {10};\n\\node at (11.5, 2.5) {11};\n\\node at (12.5, 2.5) {12};\n\\node at (13.5, 2.5) {13};\n\\node at (14.5, 2.5) {14};\n\\node at (15.5, 2.5) {15};\n\n\\end{tikzpicture}\n\\end{center}\n\nNow we can calculate\nsubsequent Z-array values\nefficiently,\nbecause we know that\n$\\texttt{s}[0 \\ldots 4]$ and\n$\\texttt{s}[6 \\ldots 10]$ are equal.\nFirst, since $\\texttt{z}[1] = \\texttt{z}[2] = 0$,\nwe immediately know that also\n$\\texttt{z}[7] = \\texttt{z}[8] = 0$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (7,0) rectangle (9,1);\n\\draw (0,0) grid (16,2);\n\n\\node at (0.5, 1.5) {A};\n\\node at (1.5, 1.5) {C};\n\\node at (2.5, 1.5) {B};\n\\node at (3.5, 1.5) {A};\n\\node at (4.5, 1.5) {C};\n\\node at (5.5, 1.5) {D};\n\\node at (6.5, 1.5) {A};\n\\node at (7.5, 1.5) {C};\n\\node at (8.5, 1.5) {B};\n\\node at (9.5, 1.5) {A};\n\\node at (10.5, 1.5) {C};\n\\node at (11.5, 1.5) {B};\n\\node at (12.5, 1.5) {A};\n\\node at (13.5, 1.5) {C};\n\\node at (14.5, 1.5) {D};\n\\node at (15.5, 1.5) {A};\n\n\\node at (0.5, 0.5) {--};\n\\node at (1.5, 0.5) {0};\n\\node at (2.5, 0.5) {0};\n\\node at (3.5, 0.5) {2};\n\\node at (4.5, 0.5) {0};\n\\node at (5.5, 0.5) {0};\n\\node at (6.5, 0.5) {5};\n\\node at (7.5, 0.5) {0};\n\\node at (8.5, 0.5) {0};\n\\node at (9.5, 0.5) {?};\n\\node at (10.5, 0.5) {?};\n\\node at (11.5, 0.5) {?};\n\\node at (12.5, 0.5) {?};\n\\node at (13.5, 0.5) {?};\n\\node at (14.5, 0.5) {?};\n\\node at (15.5, 0.5) {?};\n\n\n\\draw [decoration={brace}, decorate, line width=0.5mm] (6,3.00) -- (11,3.00);\n\n\\node at (6.5,3.50) {$x$};\n\\node at (10.5,3.50) {$y$};\n\n\n\\footnotesize\n\\node at (0.5, 2.5) {0};\n\\node at (1.5, 2.5) {1};\n\\node at (2.5, 2.5) {2};\n\\node at (3.5, 2.5) {3};\n\\node at (4.5, 2.5) {4};\n\\node at (5.5, 2.5) {5};\n\\node at (6.5, 2.5) {6};\n\\node at (7.5, 2.5) {7};\n\\node at (8.5, 2.5) {8};\n\\node at (9.5, 2.5) {9};\n\\node at (10.5, 2.5) {10};\n\\node at (11.5, 2.5) {11};\n\\node at (12.5, 2.5) {12};\n\\node at (13.5, 2.5) {13};\n\\node at (14.5, 2.5) {14};\n\\node at (15.5, 2.5) {15};\n\n\n\\draw[thick,<->] (7.5,-0.25) .. controls (7,-1.25) and (2,-1.25) .. (1.5,-0.25);\n\\draw[thick,<->] (8.5,-0.25) .. controls (8,-1.25) and (3,-1.25) .. (2.5,-0.25);\n\\end{tikzpicture}\n\\end{center}\n\nThen, since $\\texttt{z}[3]=2$, we know that $\\texttt{z}[9] \\ge 2$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (9,0) rectangle (10,1);\n\\draw (0,0) grid (16,2);\n\n\\node at (0.5, 1.5) {A};\n\\node at (1.5, 1.5) {C};\n\\node at (2.5, 1.5) {B};\n\\node at (3.5, 1.5) {A};\n\\node at (4.5, 1.5) {C};\n\\node at (5.5, 1.5) {D};\n\\node at (6.5, 1.5) {A};\n\\node at (7.5, 1.5) {C};\n\\node at (8.5, 1.5) {B};\n\\node at (9.5, 1.5) {A};\n\\node at (10.5, 1.5) {C};\n\\node at (11.5, 1.5) {B};\n\\node at (12.5, 1.5) {A};\n\\node at (13.5, 1.5) {C};\n\\node at (14.5, 1.5) {D};\n\\node at (15.5, 1.5) {A};\n\n\\node at (0.5, 0.5) {--};\n\\node at (1.5, 0.5) {0};\n\\node at (2.5, 0.5) {0};\n\\node at (3.5, 0.5) {2};\n\\node at (4.5, 0.5) {0};\n\\node at (5.5, 0.5) {0};\n\\node at (6.5, 0.5) {5};\n\\node at (7.5, 0.5) {0};\n\\node at (8.5, 0.5) {0};\n\\node at (9.5, 0.5) {?};\n\\node at (10.5, 0.5) {?};\n\\node at (11.5, 0.5) {?};\n\\node at (12.5, 0.5) {?};\n\\node at (13.5, 0.5) {?};\n\\node at (14.5, 0.5) {?};\n\\node at (15.5, 0.5) {?};\n\n\\draw [decoration={brace}, decorate, line width=0.5mm] (6,3.00) -- (11,3.00);\n\n\\node at (6.5,3.50) {$x$};\n\\node at (10.5,3.50) {$y$};\n\n\n\\footnotesize\n\\node at (0.5, 2.5) {0};\n\\node at (1.5, 2.5) {1};\n\\node at (2.5, 2.5) {2};\n\\node at (3.5, 2.5) {3};\n\\node at (4.5, 2.5) {4};\n\\node at (5.5, 2.5) {5};\n\\node at (6.5, 2.5) {6};\n\\node at (7.5, 2.5) {7};\n\\node at (8.5, 2.5) {8};\n\\node at (9.5, 2.5) {9};\n\\node at (10.5, 2.5) {10};\n\\node at (11.5, 2.5) {11};\n\\node at (12.5, 2.5) {12};\n\\node at (13.5, 2.5) {13};\n\\node at (14.5, 2.5) {14};\n\\node at (15.5, 2.5) {15};\n\n\\draw[thick,<->] (9.5,-0.25) .. controls (9,-1.25) and (4,-1.25) .. (3.5,-0.25);\n\\end{tikzpicture}\n\\end{center}\n\nHowever, we have no information about the string\nafter position 10, so we need to compare the substrings\ncharacter by character:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (9,0) rectangle (10,1);\n\\fill[color=lightgray] (2,1) rectangle (7,2);\n\\fill[color=lightgray] (11,1) rectangle (16,2);\n\n\n\\draw (0,0) grid (16,2);\n\n\\node at (0.5, 1.5) {A};\n\\node at (1.5, 1.5) {C};\n\\node at (2.5, 1.5) {B};\n\\node at (3.5, 1.5) {A};\n\\node at (4.5, 1.5) {C};\n\\node at (5.5, 1.5) {D};\n\\node at (6.5, 1.5) {A};\n\\node at (7.5, 1.5) {C};\n\\node at (8.5, 1.5) {B};\n\\node at (9.5, 1.5) {A};\n\\node at (10.5, 1.5) {C};\n\\node at (11.5, 1.5) {B};\n\\node at (12.5, 1.5) {A};\n\\node at (13.5, 1.5) {C};\n\\node at (14.5, 1.5) {D};\n\\node at (15.5, 1.5) {A};\n\n\\node at (0.5, 0.5) {--};\n\\node at (1.5, 0.5) {0};\n\\node at (2.5, 0.5) {0};\n\\node at (3.5, 0.5) {2};\n\\node at (4.5, 0.5) {0};\n\\node at (5.5, 0.5) {0};\n\\node at (6.5, 0.5) {5};\n\\node at (7.5, 0.5) {0};\n\\node at (8.5, 0.5) {0};\n\\node at (9.5, 0.5) {?};\n\\node at (10.5, 0.5) {?};\n\\node at (11.5, 0.5) {?};\n\\node at (12.5, 0.5) {?};\n\\node at (13.5, 0.5) {?};\n\\node at (14.5, 0.5) {?};\n\\node at (15.5, 0.5) {?};\n\n\\draw [decoration={brace}, decorate, line width=0.5mm] (6,3.00) -- (11,3.00);\n\n\\node at (6.5,3.50) {$x$};\n\\node at (10.5,3.50) {$y$};\n\n\n\\footnotesize\n\\node at (0.5, 2.5) {0};\n\\node at (1.5, 2.5) {1};\n\\node at (2.5, 2.5) {2};\n\\node at (3.5, 2.5) {3};\n\\node at (4.5, 2.5) {4};\n\\node at (5.5, 2.5) {5};\n\\node at (6.5, 2.5) {6};\n\\node at (7.5, 2.5) {7};\n\\node at (8.5, 2.5) {8};\n\\node at (9.5, 2.5) {9};\n\\node at (10.5, 2.5) {10};\n\\node at (11.5, 2.5) {11};\n\\node at (12.5, 2.5) {12};\n\\node at (13.5, 2.5) {13};\n\\node at (14.5, 2.5) {14};\n\\node at (15.5, 2.5) {15};\n\n%\\draw[thick,<->] (11.5,-0.25) .. controls (11,-1.25) and (3,-1.25) .. (2.5,-0.25);\n\\end{tikzpicture}\n\\end{center}\n\nIt turns out that $\\texttt{z}[9]=7$,\nso the new $[x,y]$ range is $[9,15]$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (9,0) rectangle (10,1);\n\\draw (0,0) grid (16,2);\n\n\\node at (0.5, 1.5) {A};\n\\node at (1.5, 1.5) {C};\n\\node at (2.5, 1.5) {B};\n\\node at (3.5, 1.5) {A};\n\\node at (4.5, 1.5) {C};\n\\node at (5.5, 1.5) {D};\n\\node at (6.5, 1.5) {A};\n\\node at (7.5, 1.5) {C};\n\\node at (8.5, 1.5) {B};\n\\node at (9.5, 1.5) {A};\n\\node at (10.5, 1.5) {C};\n\\node at (11.5, 1.5) {B};\n\\node at (12.5, 1.5) {A};\n\\node at (13.5, 1.5) {C};\n\\node at (14.5, 1.5) {D};\n\\node at (15.5, 1.5) {A};\n\n\\node at (0.5, 0.5) {--};\n\\node at (1.5, 0.5) {0};\n\\node at (2.5, 0.5) {0};\n\\node at (3.5, 0.5) {2};\n\\node at (4.5, 0.5) {0};\n\\node at (5.5, 0.5) {0};\n\\node at (6.5, 0.5) {5};\n\\node at (7.5, 0.5) {0};\n\\node at (8.5, 0.5) {0};\n\\node at (9.5, 0.5) {7};\n\\node at (10.5, 0.5) {?};\n\\node at (11.5, 0.5) {?};\n\\node at (12.5, 0.5) {?};\n\\node at (13.5, 0.5) {?};\n\\node at (14.5, 0.5) {?};\n\\node at (15.5, 0.5) {?};\n\n\\draw [decoration={brace}, decorate, line width=0.5mm] (9,3.00) -- (16,3.00);\n\n\\node at (9.5,3.50) {$x$};\n\\node at (15.5,3.50) {$y$};\n\n\n\\footnotesize\n\\node at (0.5, 2.5) {0};\n\\node at (1.5, 2.5) {1};\n\\node at (2.5, 2.5) {2};\n\\node at (3.5, 2.5) {3};\n\\node at (4.5, 2.5) {4};\n\\node at (5.5, 2.5) {5};\n\\node at (6.5, 2.5) {6};\n\\node at (7.5, 2.5) {7};\n\\node at (8.5, 2.5) {8};\n\\node at (9.5, 2.5) {9};\n\\node at (10.5, 2.5) {10};\n\\node at (11.5, 2.5) {11};\n\\node at (12.5, 2.5) {12};\n\\node at (13.5, 2.5) {13};\n\\node at (14.5, 2.5) {14};\n\\node at (15.5, 2.5) {15};\n\n% \\draw[thick,<->] (9.5,-0.25) .. controls (9,-1.25) and (4,-1.25) .. (3.5,-0.25);\n\\end{tikzpicture}\n\\end{center}\n\nAfter this, all the remaining Z-array values\ncan be determined by using the information\nalready stored in the Z-array:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (16,2);\n\n\\node at (0.5, 1.5) {A};\n\\node at (1.5, 1.5) {C};\n\\node at (2.5, 1.5) {B};\n\\node at (3.5, 1.5) {A};\n\\node at (4.5, 1.5) {C};\n\\node at (5.5, 1.5) {D};\n\\node at (6.5, 1.5) {A};\n\\node at (7.5, 1.5) {C};\n\\node at (8.5, 1.5) {B};\n\\node at (9.5, 1.5) {A};\n\\node at (10.5, 1.5) {C};\n\\node at (11.5, 1.5) {B};\n\\node at (12.5, 1.5) {A};\n\\node at (13.5, 1.5) {C};\n\\node at (14.5, 1.5) {D};\n\\node at (15.5, 1.5) {A};\n\n\\node at (0.5, 0.5) {--};\n\\node at (1.5, 0.5) {0};\n\\node at (2.5, 0.5) {0};\n\\node at (3.5, 0.5) {2};\n\\node at (4.5, 0.5) {0};\n\\node at (5.5, 0.5) {0};\n\\node at (6.5, 0.5) {5};\n\\node at (7.5, 0.5) {0};\n\\node at (8.5, 0.5) {0};\n\\node at (9.5, 0.5) {7};\n\\node at (10.5, 0.5) {0};\n\\node at (11.5, 0.5) {0};\n\\node at (12.5, 0.5) {2};\n\\node at (13.5, 0.5) {0};\n\\node at (14.5, 0.5) {0};\n\\node at (15.5, 0.5) {1};\n\n\\draw [decoration={brace}, decorate, line width=0.5mm] (9,3.00) -- (16,3.00);\n\n\\node at (9.5,3.50) {$x$};\n\\node at (15.5,3.50) {$y$};\n\n\n\\footnotesize\n\\node at (0.5, 2.5) {0};\n\\node at (1.5, 2.5) {1};\n\\node at (2.5, 2.5) {2};\n\\node at (3.5, 2.5) {3};\n\\node at (4.5, 2.5) {4};\n\\node at (5.5, 2.5) {5};\n\\node at (6.5, 2.5) {6};\n\\node at (7.5, 2.5) {7};\n\\node at (8.5, 2.5) {8};\n\\node at (9.5, 2.5) {9};\n\\node at (10.5, 2.5) {10};\n\\node at (11.5, 2.5) {11};\n\\node at (12.5, 2.5) {12};\n\\node at (13.5, 2.5) {13};\n\\node at (14.5, 2.5) {14};\n\\node at (15.5, 2.5) {15};\n\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Using the Z-array}\n\nIt is often a matter of taste whether to use\nstring hashing or the Z-algorithm.\nUnlike hashing, the Z-algorithm always works\nand there is no risk for collisions.\nOn the other hand, the Z-algorithm is more difficult\nto implement and some problems can only be solved\nusing hashing.\n\nAs an example, consider again\nthe pattern matching problem,\nwhere our task is to find the occurrences\nof a pattern $p$ in a string $s$.\nWe already solved this problem efficiently\nusing string hashing, but the Z-algorithm\nprovides another way to solve the problem.\n\nA usual idea in string processing is to\nconstruct a string that consists of\nmultiple strings separated by special characters.\nIn this problem, we can construct a string\n$p$\\texttt{\\#}$s$,\nwhere $p$ and $s$ are separated by a special\ncharacter \\texttt{\\#} that does not occur\nin the strings.\nThe Z-array of $p$\\texttt{\\#}$s$ tells us the positions\nwhere $p$ occurs in $s$,\nbecause such positions contain the length of $p$.\n\nFor example, if $s=$\\texttt{HATTIVATTI} and $p=$\\texttt{ATT},\nthe Z-array is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (14,2);\n\n\\node at (0.5, 1.5) {A};\n\\node at (1.5, 1.5) {T};\n\\node at (2.5, 1.5) {T};\n\\node at (3.5, 1.5) {\\#};\n\\node at (4.5, 1.5) {H};\n\\node at (5.5, 1.5) {A};\n\\node at (6.5, 1.5) {T};\n\\node at (7.5, 1.5) {T};\n\\node at (8.5, 1.5) {I};\n\\node at (9.5, 1.5) {V};\n\\node at (10.5, 1.5) {A};\n\\node at (11.5, 1.5) {T};\n\\node at (12.5, 1.5) {T};\n\\node at (13.5, 1.5) {I};\n\n\\node at (0.5, 0.5) {--};\n\\node at (1.5, 0.5) {0};\n\\node at (2.5, 0.5) {0};\n\\node at (3.5, 0.5) {0};\n\\node at (4.5, 0.5) {0};\n\\node at (5.5, 0.5) {3};\n\\node at (6.5, 0.5) {0};\n\\node at (7.5, 0.5) {0};\n\\node at (8.5, 0.5) {0};\n\\node at (9.5, 0.5) {0};\n\\node at (10.5, 0.5) {3};\n\\node at (11.5, 0.5) {0};\n\\node at (12.5, 0.5) {0};\n\\node at (13.5, 0.5) {0};\n\n\\footnotesize\n\\node at (0.5, 2.5) {0};\n\\node at (1.5, 2.5) {1};\n\\node at (2.5, 2.5) {2};\n\\node at (3.5, 2.5) {3};\n\\node at (4.5, 2.5) {4};\n\\node at (5.5, 2.5) {5};\n\\node at (6.5, 2.5) {6};\n\\node at (7.5, 2.5) {7};\n\\node at (8.5, 2.5) {8};\n\\node at (9.5, 2.5) {9};\n\\node at (10.5, 2.5) {10};\n\\node at (11.5, 2.5) {11};\n\\node at (12.5, 2.5) {12};\n\\node at (13.5, 2.5) {13};\n\\end{tikzpicture}\n\\end{center}\n\nThe positions 5 and 10 contain the value 3,\nwhich means that the pattern \\texttt{ATT}\noccurs in the corresponding positions\nof \\texttt{HATTIVATTI}.\n\nThe time complexity of the resulting algorithm\nis linear, because it suffices to construct\nthe Z-array and go through its values.\n\n\\subsubsection{Implementation}\n\nHere is a short implementation of the Z-algorithm\nthat returns a vector that corresponds to the Z-array.\n\n\\begin{lstlisting}\nvector<int> z(string s) {\n    int n = s.size();\n    vector<int> z(n);\n    int x = 0, y = 0;\n    for (int i = 1; i < n; i++) {\n        z[i] = max(0,min(z[i-x],y-i+1));\n        while (i+z[i] < n && s[z[i]] == s[i+z[i]]) {\n            x = i; y = i+z[i]; z[i]++;\n        }\n    }\n    return z;\n}\n\\end{lstlisting}", "chapter_name": "String algorithms", "chapter_path": "cphb/chapter26.tex"}, {"section_name": "Combining algorithms", "section_content": "\\chapter{Square root algorithms}\n\n\\index{square root algorithm}\n\nA \\key{square root algorithm} is an algorithm\nthat has a square root in its time complexity.\nA square root can be seen as a ''poor man's logarithm'':\nthe complexity $O(\\sqrt n)$ is better than $O(n)$\nbut worse than $O(\\log n)$.\nIn any case, many square root algorithms are fast and usable in practice.\n\nAs an example, consider the problem of\ncreating a data structure that supports\ntwo operations on an array:\nmodifying an element at a given position\nand calculating the sum of elements in the given range.\nWe have previously solved the problem using\nbinary indexed and segment trees,\nthat support both operations in $O(\\log n)$ time.\nHowever, now we will solve the problem\nin another way using a square root structure\nthat allows us to modify elements in $O(1)$ time\nand calculate sums in $O(\\sqrt n)$ time.\n\nThe idea is to divide the array into \\emph{blocks}\nof size $\\sqrt n$ so that each block contains\nthe sum of elements inside the block.\nFor example, an array of 16 elements will be\ndivided into blocks of 4 elements as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (16,1);\n\n\\draw (0,1) rectangle (4,2);\n\\draw (4,1) rectangle (8,2);\n\\draw (8,1) rectangle (12,2);\n\\draw (12,1) rectangle (16,2);\n\n\\node at (0.5, 0.5) {5};\n\\node at (1.5, 0.5) {8};\n\\node at (2.5, 0.5) {6};\n\\node at (3.5, 0.5) {3};\n\\node at (4.5, 0.5) {2};\n\\node at (5.5, 0.5) {7};\n\\node at (6.5, 0.5) {2};\n\\node at (7.5, 0.5) {6};\n\\node at (8.5, 0.5) {7};\n\\node at (9.5, 0.5) {1};\n\\node at (10.5, 0.5) {7};\n\\node at (11.5, 0.5) {5};\n\\node at (12.5, 0.5) {6};\n\\node at (13.5, 0.5) {2};\n\\node at (14.5, 0.5) {3};\n\\node at (15.5, 0.5) {2};\n\n\\node at (2, 1.5) {21};\n\\node at (6, 1.5) {17};\n\\node at (10, 1.5) {20};\n\\node at (14, 1.5) {13};\n\n\\end{tikzpicture}\n\\end{center}\n\nIn this structure,\nit is easy to modify array elements,\nbecause it is only needed to update\nthe sum of a single block\nafter each modification,\nwhich can be done in $O(1)$ time.\nFor example, the following picture shows\nhow the value of an element and\nthe sum of the corresponding block change:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (5,0) rectangle (6,1);\n\\draw (0,0) grid (16,1);\n\n\\fill[color=lightgray] (4,1) rectangle (8,2);\n\\draw (0,1) rectangle (4,2);\n\\draw (4,1) rectangle (8,2);\n\\draw (8,1) rectangle (12,2);\n\\draw (12,1) rectangle (16,2);\n\n\\node at (0.5, 0.5) {5};\n\\node at (1.5, 0.5) {8};\n\\node at (2.5, 0.5) {6};\n\\node at (3.5, 0.5) {3};\n\\node at (4.5, 0.5) {2};\n\\node at (5.5, 0.5) {5};\n\\node at (6.5, 0.5) {2};\n\\node at (7.5, 0.5) {6};\n\\node at (8.5, 0.5) {7};\n\\node at (9.5, 0.5) {1};\n\\node at (10.5, 0.5) {7};\n\\node at (11.5, 0.5) {5};\n\\node at (12.5, 0.5) {6};\n\\node at (13.5, 0.5) {2};\n\\node at (14.5, 0.5) {3};\n\\node at (15.5, 0.5) {2};\n\n\\node at (2, 1.5) {21};\n\\node at (6, 1.5) {15};\n\\node at (10, 1.5) {20};\n\\node at (14, 1.5) {13};\n\n\\end{tikzpicture}\n\\end{center}\n\nThen, to calculate the sum of elements in a range,\nwe divide the range into three parts such that \nthe sum consists of values of single elements\nand sums of blocks between them:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (3,0) rectangle (4,1);\n\\fill[color=lightgray] (12,0) rectangle (13,1);\n\\fill[color=lightgray] (13,0) rectangle (14,1);\n\\draw (0,0) grid (16,1);\n\n\\fill[color=lightgray] (4,1) rectangle (8,2);\n\\fill[color=lightgray] (8,1) rectangle (12,2);\n\\draw (0,1) rectangle (4,2);\n\\draw (4,1) rectangle (8,2);\n\\draw (8,1) rectangle (12,2);\n\\draw (12,1) rectangle (16,2);\n\n\\node at (0.5, 0.5) {5};\n\\node at (1.5, 0.5) {8};\n\\node at (2.5, 0.5) {6};\n\\node at (3.5, 0.5) {3};\n\\node at (4.5, 0.5) {2};\n\\node at (5.5, 0.5) {5};\n\\node at (6.5, 0.5) {2};\n\\node at (7.5, 0.5) {6};\n\\node at (8.5, 0.5) {7};\n\\node at (9.5, 0.5) {1};\n\\node at (10.5, 0.5) {7};\n\\node at (11.5, 0.5) {5};\n\\node at (12.5, 0.5) {6};\n\\node at (13.5, 0.5) {2};\n\\node at (14.5, 0.5) {3};\n\\node at (15.5, 0.5) {2};\n\n\\node at (2, 1.5) {21};\n\\node at (6, 1.5) {15};\n\\node at (10, 1.5) {20};\n\\node at (14, 1.5) {13};\n\n\\draw [decoration={brace}, decorate, line width=0.5mm] (14,-0.25) -- (3,-0.25);\n\n\\end{tikzpicture}\n\\end{center}\n\nSince the number of single elements is $O(\\sqrt n)$\nand the number of blocks is also $O(\\sqrt n)$,\nthe sum query takes $O(\\sqrt n)$ time.\nThe purpose of the block size $\\sqrt n$ is\nthat it \\emph{balances} two things:\nthe array is divided into $\\sqrt n$ blocks,\neach of which contains $\\sqrt n$ elements.\n\nIn practice, it is not necessary to use the\nexact value of $\\sqrt n$ as a parameter,\nand instead we may use parameters $k$ and $n/k$ where $k$ is\ndifferent from $\\sqrt n$.\nThe optimal parameter depends on the problem and input.\nFor example, if an algorithm often goes\nthrough the blocks but rarely inspects\nsingle elements inside the blocks,\nit may be a good idea to divide the array into\n$k < \\sqrt n$ blocks, each of which contains $n/k > \\sqrt n$\nelements.\n\n\\section{Combining algorithms}\n\nIn this section we discuss two square root algorithms\nthat are based on combining two algorithms into one algorithm.\nIn both cases, we could use either of the algorithms\nwithout the other\nand solve the problem in $O(n^2)$ time.\nHowever, by combining the algorithms, the running\ntime is only $O(n \\sqrt n)$.\n\n\\subsubsection{Case processing}\n\nSuppose that we are given a two-dimensional\ngrid that contains $n$ cells.\nEach cell is assigned a letter,\nand our task is to find two cells\nwith the same letter whose distance is minimum,\nwhere the distance between cells\n$(x_1,y_1)$ and $(x_2,y_2)$ is $|x_1-x_2|+|y_1-y_2|$.\nFor example, consider the following grid:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\node at (0.5,0.5) {A};\n\\node at (0.5,1.5) {B};\n\\node at (0.5,2.5) {C};\n\\node at (0.5,3.5) {A};\n\\node at (1.5,0.5) {C};\n\\node at (1.5,1.5) {D};\n\\node at (1.5,2.5) {E};\n\\node at (1.5,3.5) {F};\n\\node at (2.5,0.5) {B};\n\\node at (2.5,1.5) {A};\n\\node at (2.5,2.5) {G};\n\\node at (2.5,3.5) {B};\n\\node at (3.5,0.5) {D};\n\\node at (3.5,1.5) {F};\n\\node at (3.5,2.5) {E};\n\\node at (3.5,3.5) {A};\n\\draw (0,0) grid (4,4);\n\\end{tikzpicture}\n\\end{center}\nIn this case, the minimum distance is 2 between the two 'E' letters.\n\nWe can solve the problem by considering each letter separately.\nUsing this approach, the new problem is to calculate\nthe minimum distance\nbetween two cells with a \\emph{fixed} letter $c$.\nWe focus on two algorithms for this:\n\n\\emph{Algorithm 1:} Go through all pairs of cells with letter $c$,\nand calculate the minimum distance between such cells.\nThis will take $O(k^2)$ time where $k$ is the number of cells with letter $c$.\n\n\\emph{Algorithm 2:} Perform a breadth-first search that simultaneously\nstarts at each cell with letter $c$. The minimum distance between\ntwo cells with letter $c$ will be calculated in $O(n)$ time.\n\nOne way to solve the problem is to choose either of the\nalgorithms and use it for all letters.\nIf we use Algorithm 1, the running time is $O(n^2)$,\nbecause all cells may contain the same letter,\nand in this case $k=n$.\nAlso if we use Algorithm 2, the running time is $O(n^2)$,\nbecause all cells may have different letters,\nand in this case $n$ searches are needed.\n\nHowever, we can \\emph{combine} the two algorithms and\nuse different algorithms for different letters\ndepending on how many times each letter appears in the grid.\nAssume that a letter $c$ appears $k$ times.\nIf $k \\le \\sqrt n$, we use Algorithm 1, and if $k > \\sqrt n$,\nwe use Algorithm 2.\nIt turns out that by doing this, the total running time\nof the algorithm is only $O(n \\sqrt n)$.\n\nFirst, suppose that we use Algorithm 1 for a letter $c$.\nSince $c$ appears at most $\\sqrt n$ times in the grid,\nwe compare each cell with letter $c$ $O(\\sqrt n)$ times\nwith other cells.\nThus, the time used for processing all such cells is $O(n \\sqrt n)$.\nThen, suppose that we use Algorithm 2 for a letter $c$.\nThere are at most $\\sqrt n$ such letters,\nso processing those letters also takes $O(n \\sqrt n)$ time.\n\n\\subsubsection{Batch processing}\n\nOur next problem also deals with\na two-dimensional grid that contains $n$ cells.\nInitially, each cell except one is white.\nWe perform $n-1$ operations, each of which first\ncalculates the minimum distance from a given white cell\nto a black cell, and then paints the white cell black.\n\nFor example, consider the following operation:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=black] (1,1) rectangle (2,2);\n\\fill[color=black] (3,1) rectangle (4,2);\n\\fill[color=black] (0,3) rectangle (1,4);\n\\node at (2.5,3.5) {*};\n\\draw (0,0) grid (4,4);\n\\end{tikzpicture}\n\\end{center}\n\nFirst, we calculate the minimum distance\nfrom the white cell marked with * to a black cell.\nThe minimum distance is 2, because we can move\ntwo steps left to a black cell.\nThen, we paint the white cell black:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=black] (1,1) rectangle (2,2);\n\\fill[color=black] (3,1) rectangle (4,2);\n\\fill[color=black] (0,3) rectangle (1,4);\n\\fill[color=black] (2,3) rectangle (3,4);\n\\draw (0,0) grid (4,4);\n\\end{tikzpicture}\n\\end{center}\n\nConsider the following two algorithms:\n\n\\emph{Algorithm 1:} Use breadth-first search\nto calculate\nfor each white cell the distance to the nearest black cell.\nThis takes $O(n)$ time, and after the search,\nwe can find the minimum distance from any white cell\nto a black cell in $O(1)$ time.\n\n\\emph{Algorithm 2:} Maintain a list of cells that have been\npainted black, go through this list at each operation\nand then add a new cell to the list.\nAn operation takes $O(k)$ time where $k$ is the length of the list.\n\nWe combine the above algorithms by\ndividing the operations into\n$O(\\sqrt n)$ \\emph{batches}, each of which consists\nof $O(\\sqrt n)$ operations.\nAt the beginning of each batch,\nwe perform Algorithm 1.\nThen, we use Algorithm 2 to process the operations\nin the batch.\nWe clear the list of Algorithm 2 between\nthe batches.\nAt each operation,\nthe minimum distance to a black cell\nis either the distance calculated by Algorithm 1\nor the distance calculated by Algorithm 2.\n\nThe resulting algorithm works in\n$O(n \\sqrt n)$ time.\nFirst, Algorithm 1 is performed $O(\\sqrt n)$ times,\nand each search works in $O(n)$ time.\nSecond, when using Algorithm 2 in a batch,\nthe list contains $O(\\sqrt n)$ cells\n(because we clear the list between the batches)\nand each operation takes $O(\\sqrt n)$ time.\n\n", "chapter_name": "Square root algorithms", "chapter_path": "cphb/chapter27.tex"}, {"section_name": "Integer partitions", "section_content": "\\section{Integer partitions}\n\nSome square root algorithms are based on\nthe following observation:\nif a positive integer $n$ is represented as\na sum of positive integers,\nsuch a sum always contains at most\n$O(\\sqrt n)$ \\emph{distinct} numbers.\nThe reason for this is that to construct\na sum that contains a maximum number of distinct\nnumbers, we should choose \\emph{small} numbers.\nIf we choose the numbers $1,2,\\ldots,k$,\nthe resulting sum is\n\\[\\frac{k(k+1)}{2}.\\]\nThus, the maximum amount of distinct numbers is $k = O(\\sqrt n)$.\nNext we will discuss two problems that can be solved\nefficiently using this observation.\n\n\\subsubsection{Knapsack}\n\nSuppose that we are given a list of integer weights\nwhose sum is $n$.\nOur task is to find out all sums that can be formed using\na subset of the weights. For example, if the weights are\n$\\{1,3,3\\}$, the possible sums are as follows:\n\n\\begin{itemize}[noitemsep]\n\\item $0$ (empty set)\n\\item $1$\n\\item $3$\n\\item $1+3=4$\n\\item $3+3=6$\n\\item $1+3+3=7$\n\\end{itemize}\n\nUsing the standard knapsack approach (see Chapter 7.4),\nthe problem can be solved as follows:\nwe define a function $\\texttt{possible}(x,k)$ whose value is 1\nif the sum $x$ can be formed using the first $k$ weights,\nand 0 otherwise.\nSince the sum of the weights is $n$,\nthere are at most $n$ weights and\nall values of the function can be calculated\nin $O(n^2)$ time using dynamic programming.\n\nHowever, we can make the algorithm more efficient\nby using the fact that there are at most $O(\\sqrt n)$\n\\emph{distinct} weights.\nThus, we can process the weights in groups\nthat consists of similar weights.\nWe can process each group\nin $O(n)$ time, which yields an $O(n \\sqrt n)$ time algorithm.\n\nThe idea is to use an array that records the sums of weights\nthat can be formed using the groups processed so far.\nThe array contains $n$ elements: element $k$ is 1 if the sum\n$k$ can be formed and 0 otherwise.\nTo process a group of weights, we scan the array\nfrom left to right and record the new sums of weights that\ncan be formed using this group and the previous groups.\n\n\\subsubsection{String construction}\n\nGiven a string \\texttt{s} of length $n$\nand a set of strings $D$ whose total length is $m$,\nconsider the problem of counting the number of ways\n\\texttt{s} can be formed as a concatenation of strings in $D$.\nFor example,\nif $\\texttt{s}=\\texttt{ABAB}$ and\n$D=\\{\\texttt{A},\\texttt{B},\\texttt{AB}\\}$,\nthere are 4 ways:\n\n\\begin{itemize}[noitemsep]\n\\item $\\texttt{A}+\\texttt{B}+\\texttt{A}+\\texttt{B}$\n\\item $\\texttt{AB}+\\texttt{A}+\\texttt{B}$\n\\item $\\texttt{A}+\\texttt{B}+\\texttt{AB}$\n\\item $\\texttt{AB}+\\texttt{AB}$\n\\end{itemize}\n\nWe can solve the problem using dynamic programming:\nLet $\\texttt{count}(k)$ denote the number of ways to construct the prefix\n$\\texttt{s}[0 \\ldots k]$ using the strings in $D$.\nNow $\\texttt{count}(n-1)$ gives the answer to the problem,\nand we can solve the problem in $O(n^2)$ time\nusing a trie structure.\n\nHowever, we can solve the problem more efficiently\nby using string hashing and the fact that there\nare at most $O(\\sqrt m)$ distinct string lengths in $D$.\nFirst, we construct a set $H$ that contains all\nhash values of the strings in $D$.\nThen, when calculating a value of $\\texttt{count}(k)$,\nwe go through all values of $p$\nsuch that there is a string of length $p$ in $D$,\ncalculate the hash value of $\\texttt{s}[k-p+1 \\ldots k]$\nand check if it belongs to $H$.\nSince there are at most $O(\\sqrt m)$ distinct string lengths,\nthis results in an algorithm whose running time is $O(n \\sqrt m)$.\n\n", "chapter_name": "Square root algorithms", "chapter_path": "cphb/chapter27.tex"}, {"section_name": "Mo's algorithm", "section_content": "\\section{Mo's algorithm}\n\n\\index{Mo's algorithm}\n\n\\key{Mo's algorithm}\\footnote{According to \\cite{cod15}, this algorithm\nis named after Mo Tao, a Chinese competitive programmer, but\nthe technique has appeared earlier in the literature \\cite{ken06}.}\ncan be used in many problems\nthat require processing range queries in \na \\emph{static} array, i.e., the array values\ndo not change between the queries.\nIn each query, we are given a range $[a,b]$,\nand we should calculate a value based on the\narray elements between positions $a$ and $b$.\nSince the array is static,\nthe queries can be processed in any order,\nand Mo's algorithm\nprocesses the queries in a special order which guarantees\nthat the algorithm works efficiently.\n\nMo's algorithm maintains an \\emph{active range}\nof the array, and the answer to a query\nconcerning the active range is known at each moment.\nThe algorithm processes the queries one by one,\nand always moves the endpoints of the\nactive range by inserting and removing elements.\nThe time complexity of the algorithm is\n$O(n \\sqrt n f(n))$ where the array contains\n$n$ elements, there are $n$ queries\nand each insertion and removal of an element\ntakes $O(f(n))$ time.\n\nThe trick in Mo's algorithm is the order\nin which the queries are processed:\nThe array is divided into blocks of $k=O(\\sqrt n)$\nelements, and a query $[a_1,b_1]$\nis processed before a query $[a_2,b_2]$\nif either \n\\begin{itemize}\n\\item $\\lfloor a_1/k \\rfloor < \\lfloor a_2/k \\rfloor$ or\n\\item $\\lfloor a_1/k \\rfloor = \\lfloor a_2/k \\rfloor$ and $b_1 < b_2$.\n\\end{itemize}\n\nThus, all queries whose left endpoints are\nin a certain block are processed one after another\nsorted according to their right endpoints.\nUsing this order, the algorithm\nonly performs $O(n \\sqrt n)$ operations,\nbecause the left endpoint moves\n$O(n)$ times $O(\\sqrt n)$ steps,\nand the right endpoint moves\n$O(\\sqrt n)$ times $O(n)$ steps. Thus, both\nendpoints move a total of $O(n \\sqrt n)$ steps during the algorithm.\n\n\\subsubsection*{Example}\n\nAs an example, consider a problem\nwhere we are given a set of queries,\neach of them corresponding to a range in an array,\nand our task is to calculate for each query\nthe number of \\emph{distinct} elements in the range.\n\nIn Mo's algorithm, the queries are always sorted\nin the same way, but it depends on the problem\nhow the answer to the query is maintained.\nIn this problem, we can maintain an array \n\\texttt{count} where $\\texttt{count}[x]$\nindicates the number of times an element $x$\noccurs in the active range.\n\nWhen we move from one query to another query,\nthe active range changes.\nFor example, if the current range is\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (1,0) rectangle (5,1);\n\\draw (0,0) grid (9,1);\n\\node at (0.5, 0.5) {4};\n\\node at (1.5, 0.5) {2};\n\\node at (2.5, 0.5) {5};\n\\node at (3.5, 0.5) {4};\n\\node at (4.5, 0.5) {2};\n\\node at (5.5, 0.5) {4};\n\\node at (6.5, 0.5) {3};\n\\node at (7.5, 0.5) {3};\n\\node at (8.5, 0.5) {4};\n\\end{tikzpicture}\n\\end{center}\nand the next range is\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=lightgray] (2,0) rectangle (7,1);\n\\draw (0,0) grid (9,1);\n\\node at (0.5, 0.5) {4};\n\\node at (1.5, 0.5) {2};\n\\node at (2.5, 0.5) {5};\n\\node at (3.5, 0.5) {4};\n\\node at (4.5, 0.5) {2};\n\\node at (5.5, 0.5) {4};\n\\node at (6.5, 0.5) {3};\n\\node at (7.5, 0.5) {3};\n\\node at (8.5, 0.5) {4};\n\\end{tikzpicture}\n\\end{center}\nthere will be three steps:\nthe left endpoint moves one step to the right,\nand the right endpoint moves two steps to the right.\n\nAfter each step, the array \\texttt{count}\nneeds to be updated.\nAfter adding an element $x$,\nwe increase the value of \n$\\texttt{count}[x]$ by 1,\nand if $\\texttt{count}[x]=1$ after this,\nwe also increase the answer to the query by 1.\nSimilarly, after removing an element $x$,\nwe decrease the value of \n$\\texttt{count}[x]$ by 1,\nand if $\\texttt{count}[x]=0$ after this,\nwe also decrease the answer to the query by 1.\n\nIn this problem, the time needed to perform\neach step is $O(1)$, so the total time complexity\nof the algorithm is $O(n \\sqrt n)$.", "chapter_name": "Square root algorithms", "chapter_path": "cphb/chapter27.tex"}, {"section_name": "Lazy propagation", "section_content": "\\chapter{Segment trees revisited}\n\n\\index{segment tree}\n\nA segment tree is a versatile data structure\nthat can be used to solve a large number of algorithm problems.\nHowever, there are many topics related to segment trees\nthat we have not touched yet.\nNow is time to discuss some more advanced variants\nof segment trees.\n\nSo far, we have implemented the operations\nof a segment tree by walking \\emph{from bottom to top}\nin the tree.\nFor example, we have calculated\nrange sums as follows (Chapter 9.3):\n\n\\begin{lstlisting}\nint sum(int a, int b) {\n    a += n; b += n;\n    int s = 0;\n    while (a <= b) {\n        if (a%2 == 1) s += tree[a++];\n        if (b%2 == 0) s += tree[b--];\n        a /= 2; b /= 2;\n    }\n    return s;\n}\n\\end{lstlisting}\n\nHowever, in more advanced segment trees,\nit is often necessary to implement the operations\nin another way, \\emph{from top to bottom}.\nUsing this approach, the function becomes as follows:\n\\begin{lstlisting}\nint sum(int a, int b, int k, int x, int y) {\n    if (b < x || a > y) return 0;\n    if (a <= x && y <= b) return tree[k];\n    int d = (x+y)/2;\n    return sum(a,b,2*k,x,d) + sum(a,b,2*k+1,d+1,y);\n}\n\\end{lstlisting}\n\nNow we can calculate any value of $\\texttt{sum}_q(a,b)$\n(the sum of array values in range $[a,b]$) as follows:\n\\begin{lstlisting}\nint s = sum(a, b, 1, 0, n-1);\n\\end{lstlisting}\n\nThe parameter $k$ indicates the current position\nin \\texttt{tree}.\nInitially $k$ equals 1, because we begin\nat the root of the tree.\nThe range $[x,y]$ corresponds to $k$\nand is initially $[0,n-1]$.\nWhen calculating the sum,\nif $[x,y]$ is outside $[a,b]$,\nthe sum is 0,\nand if $[x,y]$ is completely inside $[a,b]$,\nthe sum can be found in \\texttt{tree}.\nIf $[x,y]$ is partially inside $[a,b]$,\nthe search continues recursively to the\nleft and right half of $[x,y]$.\nThe left half is $[x,d]$\nand the right half is $[d+1,y]$\nwhere $d=\\lfloor \\frac{x+y}{2} \\rfloor$.\n\nThe following picture shows how the search proceeds\nwhen calculating the value of $\\texttt{sum}_q(a,b)$.\nThe gray nodes indicate nodes where the recursion\nstops and the sum can be found in \\texttt{tree}.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=gray!50] (5,0) rectangle (6,1);\n\\draw (0,0) grid (16,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {2};\n\\node[anchor=center] at (5.5, 0.5) {7};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\\node[anchor=center] at (8.5, 0.5) {7};\n\\node[anchor=center] at (9.5, 0.5) {1};\n\\node[anchor=center] at (10.5, 0.5) {7};\n\\node[anchor=center] at (11.5, 0.5) {5};\n\\node[anchor=center] at (12.5, 0.5) {6};\n\\node[anchor=center] at (13.5, 0.5) {2};\n\\node[anchor=center] at (14.5, 0.5) {3};\n\\node[anchor=center] at (15.5, 0.5) {2};\n\n%\\node[anchor=center] at (1,2.5) {13};\n\n\\node[draw, circle] (a) at (1,2.5) {13};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,minimum size=22pt] (b) at (3,2.5) {9};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\\node[draw, circle,minimum size=22pt] (c) at (5,2.5) {9};\n\\path[draw,thick,-] (c) -- (4.5,1);\n\\path[draw,thick,-] (c) -- (5.5,1);\n\\node[draw, circle,fill=gray!50,minimum size=22pt] (d) at (7,2.5) {8};\n\\path[draw,thick,-] (d) -- (6.5,1);\n\\path[draw,thick,-] (d) -- (7.5,1);\n\\node[draw, circle,minimum size=22pt] (e) at (9,2.5) {8};\n\\path[draw,thick,-] (e) -- (8.5,1);\n\\path[draw,thick,-] (e) -- (9.5,1);\n\\node[draw, circle] (f) at (11,2.5) {12};\n\\path[draw,thick,-] (f) -- (10.5,1);\n\\path[draw,thick,-] (f) -- (11.5,1);\n\\node[draw, circle,fill=gray!50,minimum size=22pt] (g) at (13,2.5) {8};\n\\path[draw,thick,-] (g) -- (12.5,1);\n\\path[draw,thick,-] (g) -- (13.5,1);\n\\node[draw, circle,minimum size=22pt] (h) at (15,2.5) {5};\n\\path[draw,thick,-] (h) -- (14.5,1);\n\\path[draw,thick,-] (h) -- (15.5,1);\n\n\\node[draw, circle] (i) at (2,4.5) {22};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, circle] (j) at (6,4.5) {17};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\\node[draw, circle,fill=gray!50] (k) at (10,4.5) {20};\n\\path[draw,thick,-] (k) -- (e);\n\\path[draw,thick,-] (k) -- (f);\n\\node[draw, circle] (l) at (14,4.5) {13};\n\\path[draw,thick,-] (l) -- (g);\n\\path[draw,thick,-] (l) -- (h);\n\n\\node[draw, circle] (m) at (4,6.5) {39};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\\node[draw, circle] (n) at (12,6.5) {33};\n\\path[draw,thick,-] (n) -- (k);\n\\path[draw,thick,-] (n) -- (l);\n\n\\node[draw, circle] (o) at (8,8.5) {72};\n\\path[draw,thick,-] (o) -- (m);\n\\path[draw,thick,-] (o) -- (n);\n\n\\path[draw=red,thick,->,line width=2pt] (o) -- (m);\n\\path[draw=red,thick,->,line width=2pt] (o) -- (n);\n\n\\path[draw=red,thick,->,line width=2pt] (m) -- (j);\n\\path[draw=red,thick,->,line width=2pt] (j) -- (c);\n\\path[draw=red,thick,->,line width=2pt] (j) -- (d);\n\\path[draw=red,thick,->,line width=2pt] (c) -- (5.5,1);\n\n\\path[draw=red,thick,->,line width=2pt] (n) -- (k);\n\\path[draw=red,thick,->,line width=2pt] (n) -- (l);\n\n\\path[draw=red,thick,->,line width=2pt] (l) -- (g);\n\n\\draw [decoration={brace}, decorate, line width=0.5mm] (14,-0.25) -- (5,-0.25);\n\n\\node at (5.5,-0.75) {$a$};\n\\node at (13.5,-0.75) {$b$};\n\\end{tikzpicture}\n\\end{center}\n\nAlso in this implementation,\noperations take $O(\\log n)$ time,\nbecause the total number of visited nodes is $O(\\log n)$.\n\n\\section{Lazy propagation}\n\n\\index{lazy propagation}\n\\index{lazy segment tree}\n\nUsing \\key{lazy propagation}, we can build\na segment tree that supports \\emph{both} range updates\nand range queries in $O(\\log n)$ time.\nThe idea is to perform updates and queries\nfrom top to bottom and perform updates\n\\emph{lazily} so that they are propagated\ndown the tree only when it is necessary.\n\nIn a lazy segment tree, nodes contain two types of\ninformation.\nLike in an ordinary segment tree,\neach node contains the sum or some other value\nrelated to the corresponding subarray.\nIn addition, the node may contain information\nrelated to lazy updates, which has not been\npropagated to its children.\n\nThere are two types of range updates:\neach array value in the range is either\n\\emph{increased} by some value\nor \\emph{assigned} some value.\nBoth operations can be implemented using\nsimilar ideas, and it is even possible to construct\na tree that supports both operations at the same time.\n\n\\subsubsection{Lazy segment trees}\n\nLet us consider an example where our goal is to\nconstruct a segment tree that supports\ntwo operations: increasing each value in\n$[a,b]$ by a constant and calculating the sum of\nvalues in $[a,b]$.\n\nWe will construct a tree where each node\nhas two values $s/z$:\n$s$ denotes the sum of values in the range,\nand $z$ denotes the value of a lazy update,\nwhich means that all values in the range\nshould be increased by $z$.\nIn the following tree, $z=0$ in all nodes,\nso there are no ongoing lazy updates.\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (16,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {2};\n\\node[anchor=center] at (5.5, 0.5) {7};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\\node[anchor=center] at (8.5, 0.5) {7};\n\\node[anchor=center] at (9.5, 0.5) {1};\n\\node[anchor=center] at (10.5, 0.5) {7};\n\\node[anchor=center] at (11.5, 0.5) {5};\n\\node[anchor=center] at (12.5, 0.5) {6};\n\\node[anchor=center] at (13.5, 0.5) {2};\n\\node[anchor=center] at (14.5, 0.5) {3};\n\\node[anchor=center] at (15.5, 0.5) {2};\n\n\\node[draw, circle] (a) at (1,2.5) {13/0};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,minimum size=32pt] (b) at (3,2.5) {9/0};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\\node[draw, circle,minimum size=32pt] (c) at (5,2.5) {9/0};\n\\path[draw,thick,-] (c) -- (4.5,1);\n\\path[draw,thick,-] (c) -- (5.5,1);\n\\node[draw, circle,minimum size=32pt] (d) at (7,2.5) {8/0};\n\\path[draw,thick,-] (d) -- (6.5,1);\n\\path[draw,thick,-] (d) -- (7.5,1);\n\\node[draw, circle,minimum size=32pt] (e) at (9,2.5) {8/0};\n\\path[draw,thick,-] (e) -- (8.5,1);\n\\path[draw,thick,-] (e) -- (9.5,1);\n\\node[draw, circle] (f) at (11,2.5) {12/0};\n\\path[draw,thick,-] (f) -- (10.5,1);\n\\path[draw,thick,-] (f) -- (11.5,1);\n\\node[draw, circle,minimum size=32pt] (g) at (13,2.5) {8/0};\n\\path[draw,thick,-] (g) -- (12.5,1);\n\\path[draw,thick,-] (g) -- (13.5,1);\n\\node[draw, circle,minimum size=32pt] (h) at (15,2.5) {5/0};\n\\path[draw,thick,-] (h) -- (14.5,1);\n\\path[draw,thick,-] (h) -- (15.5,1);\n\n\\node[draw, circle] (i) at (2,4.5) {22/0};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, circle] (j) at (6,4.5) {17/0};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\\node[draw, circle] (k) at (10,4.5) {20/0};\n\\path[draw,thick,-] (k) -- (e);\n\\path[draw,thick,-] (k) -- (f);\n\\node[draw, circle] (l) at (14,4.5) {13/0};\n\\path[draw,thick,-] (l) -- (g);\n\\path[draw,thick,-] (l) -- (h);\n\n\\node[draw, circle] (m) at (4,6.5) {39/0};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\\node[draw, circle] (n) at (12,6.5) {33/0};\n\\path[draw,thick,-] (n) -- (k);\n\\path[draw,thick,-] (n) -- (l);\n\n\\node[draw, circle] (o) at (8,8.5) {72/0};\n\\path[draw,thick,-] (o) -- (m);\n\\path[draw,thick,-] (o) -- (n);\n\\end{tikzpicture}\n\\end{center}\n\nWhen the elements in $[a,b]$ are increased by $u$,\nwe walk from the root towards the leaves\nand modify the nodes of the tree as follows:\nIf the range $[x,y]$ of a node is\ncompletely inside $[a,b]$,\nwe increase the $z$ value of the node by $u$ and stop.\nIf $[x,y]$ only partially belongs to $[a,b]$,\nwe increase the $s$ value of the node by $hu$,\nwhere $h$ is the size of the intersection of $[a,b]$\nand $[x,y]$, and continue our walk recursively in the tree.\n\nFor example, the following picture shows the tree after\nincreasing the elements in $[a,b]$ by 2:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[color=gray!50] (5,0) rectangle (6,1);\n\\draw (0,0) grid (16,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {2};\n\\node[anchor=center] at (5.5, 0.5) {9};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\\node[anchor=center] at (8.5, 0.5) {7};\n\\node[anchor=center] at (9.5, 0.5) {1};\n\\node[anchor=center] at (10.5, 0.5) {7};\n\\node[anchor=center] at (11.5, 0.5) {5};\n\\node[anchor=center] at (12.5, 0.5) {6};\n\\node[anchor=center] at (13.5, 0.5) {2};\n\\node[anchor=center] at (14.5, 0.5) {3};\n\\node[anchor=center] at (15.5, 0.5) {2};\n\n\\node[draw, circle] (a) at (1,2.5) {13/0};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,minimum size=32pt] (b) at (3,2.5) {9/0};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\\node[draw, circle,minimum size=32pt] (c) at (5,2.5) {11/0};\n\\path[draw,thick,-] (c) -- (4.5,1);\n\\path[draw,thick,-] (c) -- (5.5,1);\n\\node[draw, circle,fill=gray!50,minimum size=32pt] (d) at (7,2.5) {8/2};\n\\path[draw,thick,-] (d) -- (6.5,1);\n\\path[draw,thick,-] (d) -- (7.5,1);\n\\node[draw, circle,minimum size=32pt] (e) at (9,2.5) {8/0};\n\\path[draw,thick,-] (e) -- (8.5,1);\n\\path[draw,thick,-] (e) -- (9.5,1);\n\\node[draw, circle] (f) at (11,2.5) {12/0};\n\\path[draw,thick,-] (f) -- (10.5,1);\n\\path[draw,thick,-] (f) -- (11.5,1);\n\\node[draw, circle,fill=gray!50,minimum size=32pt] (g) at (13,2.5) {8/2};\n\\path[draw,thick,-] (g) -- (12.5,1);\n\\path[draw,thick,-] (g) -- (13.5,1);\n\\node[draw, circle,minimum size=32pt] (h) at (15,2.5) {5/0};\n\\path[draw,thick,-] (h) -- (14.5,1);\n\\path[draw,thick,-] (h) -- (15.5,1);\n\n\\node[draw, circle] (i) at (2,4.5) {22/0};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, circle] (j) at (6,4.5) {23/0};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\\node[draw, circle,fill=gray!50] (k) at (10,4.5) {20/2};\n\\path[draw,thick,-] (k) -- (e);\n\\path[draw,thick,-] (k) -- (f);\n\\node[draw, circle] (l) at (14,4.5) {17/0};\n\\path[draw,thick,-] (l) -- (g);\n\\path[draw,thick,-] (l) -- (h);\n\n\\node[draw, circle] (m) at (4,6.5) {45/0};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\\node[draw, circle] (n) at (12,6.5) {45/0};\n\\path[draw,thick,-] (n) -- (k);\n\\path[draw,thick,-] (n) -- (l);\n\n\\node[draw, circle] (o) at (8,8.5) {90/0};\n\\path[draw,thick,-] (o) -- (m);\n\\path[draw,thick,-] (o) -- (n);\n\n\\path[draw=red,thick,->,line width=2pt] (o) -- (m);\n\\path[draw=red,thick,->,line width=2pt] (o) -- (n);\n\n\\path[draw=red,thick,->,line width=2pt] (m) -- (j);\n\\path[draw=red,thick,->,line width=2pt] (j) -- (c);\n\\path[draw=red,thick,->,line width=2pt] (j) -- (d);\n\\path[draw=red,thick,->,line width=2pt] (c) -- (5.5,1);\n\n\\path[draw=red,thick,->,line width=2pt] (n) -- (k);\n\\path[draw=red,thick,->,line width=2pt] (n) -- (l);\n\n\\path[draw=red,thick,->,line width=2pt] (l) -- (g);\n\n\\draw [decoration={brace}, decorate, line width=0.5mm] (14,-0.25) -- (5,-0.25);\n\n\\node at (5.5,-0.75) {$a$};\n\\node at (13.5,-0.75) {$b$};\n\\end{tikzpicture}\n\\end{center}\n\nWe also calculate the sum of elements in a range $[a,b]$\nby walking in the tree from top to bottom.\nIf the range $[x,y]$ of a node completely belongs\nto $[a,b]$, we add the $s$ value of the node to the sum.\nOtherwise, we continue the search recursively\ndownwards in the tree.\n\nBoth in updates and queries,\nthe value of a lazy update is always propagated\nto the children of the node\nbefore processing the node.\nThe idea is that updates will be propagated\ndownwards only when it is necessary,\nwhich guarantees that the operations are always efficient.\n\nThe following picture shows how the tree changes\nwhen we calculate the value of $\\texttt{sum}_a(a,b)$.\nThe rectangle shows the nodes whose values change,\nbecause a lazy update is propagated downwards.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (16,1);\n\n\\node[anchor=center] at (0.5, 0.5) {5};\n\\node[anchor=center] at (1.5, 0.5) {8};\n\\node[anchor=center] at (2.5, 0.5) {6};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {2};\n\\node[anchor=center] at (5.5, 0.5) {9};\n\\node[anchor=center] at (6.5, 0.5) {2};\n\\node[anchor=center] at (7.5, 0.5) {6};\n\\node[anchor=center] at (8.5, 0.5) {7};\n\\node[anchor=center] at (9.5, 0.5) {1};\n\\node[anchor=center] at (10.5, 0.5) {7};\n\\node[anchor=center] at (11.5, 0.5) {5};\n\\node[anchor=center] at (12.5, 0.5) {6};\n\\node[anchor=center] at (13.5, 0.5) {2};\n\\node[anchor=center] at (14.5, 0.5) {3};\n\\node[anchor=center] at (15.5, 0.5) {2};\n\n\\node[draw, circle] (a) at (1,2.5) {13/0};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,minimum size=32pt] (b) at (3,2.5) {9/0};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\\node[draw, circle,minimum size=32pt] (c) at (5,2.5) {11/0};\n\\path[draw,thick,-] (c) -- (4.5,1);\n\\path[draw,thick,-] (c) -- (5.5,1);\n\\node[draw, circle,minimum size=32pt] (d) at (7,2.5) {8/2};\n\\path[draw,thick,-] (d) -- (6.5,1);\n\\path[draw,thick,-] (d) -- (7.5,1);\n\\node[draw, circle,minimum size=32pt] (e) at (9,2.5) {8/2};\n\\path[draw,thick,-] (e) -- (8.5,1);\n\\path[draw,thick,-] (e) -- (9.5,1);\n\\node[draw, circle,fill=gray!50,] (f) at (11,2.5) {12/2};\n\\path[draw,thick,-] (f) -- (10.5,1);\n\\path[draw,thick,-] (f) -- (11.5,1);\n\\node[draw, circle,fill=gray!50,minimum size=32pt] (g) at (13,2.5) {8/2};\n\\path[draw,thick,-] (g) -- (12.5,1);\n\\path[draw,thick,-] (g) -- (13.5,1);\n\\node[draw, circle,minimum size=32pt] (h) at (15,2.5) {5/0};\n\\path[draw,thick,-] (h) -- (14.5,1);\n\\path[draw,thick,-] (h) -- (15.5,1);\n\n\\node[draw, circle] (i) at (2,4.5) {22/0};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, circle] (j) at (6,4.5) {23/0};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\\node[draw, circle] (k) at (10,4.5) {28/0};\n\\path[draw,thick,-] (k) -- (e);\n\\path[draw,thick,-] (k) -- (f);\n\\node[draw, circle] (l) at (14,4.5) {17/0};\n\\path[draw,thick,-] (l) -- (g);\n\\path[draw,thick,-] (l) -- (h);\n\n\\node[draw, circle] (m) at (4,6.5) {45/0};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\\node[draw, circle] (n) at (12,6.5) {45/0};\n\\path[draw,thick,-] (n) -- (k);\n\\path[draw,thick,-] (n) -- (l);\n\n\\node[draw, circle] (o) at (8,8.5) {90/0};\n\\path[draw,thick,-] (o) -- (m);\n\\path[draw,thick,-] (o) -- (n);\n\n\\path[draw=red,thick,->,line width=2pt] (o) -- (n);\n\n\\path[draw=red,thick,->,line width=2pt] (n) -- (k);\n\\path[draw=red,thick,->,line width=2pt] (n) -- (l);\n\n\\path[draw=red,thick,->,line width=2pt] (k) -- (f);\n\\path[draw=red,thick,->,line width=2pt] (l) -- (g);\n\n\\draw [decoration={brace}, decorate, line width=0.5mm] (14,-0.25) -- (10,-0.25);\n\n\\draw[color=blue,thick] (8,1.5) rectangle (12,5.5);\n\n\\node at (10.5,-0.75) {$a$};\n\\node at (13.5,-0.75) {$b$};\n\\end{tikzpicture}\n\\end{center}\n\nNote that sometimes it is needed to combine lazy updates.\nThis happens when a node that already has a lazy update\nis assigned another lazy update.\nWhen calculating sums, it is easy to combine lazy updates,\nbecause the combination of updates $z_1$ and $z_2$\ncorresponds to an update $z_1+z_2$.\n\n\\subsubsection{Polynomial updates}\n\nLazy updates can be generalized so that it is\npossible to update ranges using polynomials of the form\n\\[p(u) = t_k u^k + t_{k-1} u^{k-1} + \\cdots + t_0.\\]\n\nIn this case, the update for a value\nat position $i$ in $[a,b]$ is $p(i-a)$.\nFor example, adding the polynomial $p(u)=u+1$\nto $[a,b]$ means that the value at position $a$\nincreases by 1, the value at position $a+1$\nincreases by 2, and so on.\n\nTo support polynomial updates,\neach node is assigned $k+2$ values,\nwhere $k$ equals the degree of the polynomial.\nThe value $s$ is the sum of the elements in the range,\nand the values $z_0,z_1,\\ldots,z_k$ are the coefficients\nof a polynomial that corresponds to a lazy update.\n\nNow, the sum of values in a range $[x,y]$ equals\n\\[s+\\sum_{u=0}^{y-x} z_k u^k + z_{k-1} u^{k-1} + \\cdots + z_0.\\]\n\nThe value of such a sum\ncan be efficiently calculated using sum formulas.\nFor example, the term $z_0$ corresponds to the sum\n$(y-x+1)z_0$, and the term $z_1 u$ corresponds to the sum\n\\[z_1(0+1+\\cdots+y-x) = z_1 \\frac{(y-x)(y-x+1)}{2} .\\]\n\nWhen propagating an update in the tree,\nthe indices of $p(u)$ change,\nbecause in each range $[x,y]$,\nthe values are\ncalculated for $u=0,1,\\ldots,y-x$.\nHowever, this is not a problem, because\n$p'(u)=p(u+h)$ is a polynomial\nof equal degree as $p(u)$.\nFor example, if $p(u)=t_2 u^2+t_1 u-t_0$, then\n\\[p'(u)=t_2(u+h)^2+t_1(u+h)-t_0=t_2 u^2 + (2ht_2+t_1)u+t_2h^2+t_1h-t_0.\\]\n\n", "chapter_name": "Segment trees revisited", "chapter_path": "cphb/chapter28.tex"}, {"section_name": "Dynamic trees", "section_content": "\\section{Dynamic trees}\n\n\\index{dynamic segment tree}\n\nAn ordinary segment tree is static,\nwhich means that each node has a fixed position\nin the array and the tree requires\na fixed amount of memory.\nIn a \\key{dynamic segment tree},\nmemory is allocated only for nodes that\nare actually accessed during the algorithm,\nwhich can save a large amount of memory.\n\nThe nodes of a dynamic tree can be represented as structs:\n\\begin{lstlisting}\nstruct node {\n    int value;\n    int x, y;\n    node *left, *right;\n    node(int v, int x, int y) : value(v), x(x), y(y) {}\n};\n\\end{lstlisting}\nHere \\texttt{value} is the value of the node,\n$[\\texttt{x},\\texttt{y}]$ is the corresponding range,\nand \\texttt{left} and \\texttt{right} point to the left\nand right subtree.\n\nAfter this, nodes can be created as follows:\n\\begin{lstlisting}\n// create new node\nnode *x = new node(0, 0, 15);\n// change value\nx->value = 5;\n\\end{lstlisting}\n\n\\subsubsection{Sparse segment trees}\n\n\\index{sparse segment tree}\n\nA dynamic segment tree is useful when\nthe underlying array is \\emph{sparse},\ni.e., the range $[0,n-1]$\nof allowed indices is large,\nbut most array values are zeros.\nWhile an ordinary segment tree uses $O(n)$ memory,\na dynamic segment tree only uses $O(k \\log n)$ memory,\nwhere $k$ is the number of operations performed.\n\nA \\key{sparse segment tree} initially has\nonly one node $[0,n-1]$ whose value is zero,\nwhich means that every array value is zero.\nAfter updates, new nodes are dynamically added\nto the tree.\nFor example, if $n=16$ and the elements\nin positions 3 and 10 have been modified,\nthe tree contains the following nodes:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\scriptsize\n\\node[draw, circle,minimum size=35pt] (1) at (0,0) {$[0,15]$};\n\\node[draw, circle,minimum size=35pt] (2) at (-4,-2) {$[0,7]$};\n\\node[draw, circle,minimum size=35pt] (3) at (-6,-4) {$[0,3]$};\n\\node[draw, circle,minimum size=35pt] (4) at (-4,-6) {$[2,3]$};\n\\node[draw, circle,minimum size=35pt] (5) at (-2,-8) {$[3]$};\n\\node[draw, circle,minimum size=35pt] (6) at (4,-2) {$[8,15]$};\n\\node[draw, circle,minimum size=35pt] (7) at (2,-4) {$[8,11]$};\n\\node[draw, circle,minimum size=35pt] (8) at (4,-6) {$[10,11]$};\n\\node[draw, circle,minimum size=35pt] (9) at (2,-8) {$[10]$};\n\n\\path[draw,thick,->] (1) -- (2);\n\\path[draw,thick,->] (2) -- (3);\n\\path[draw,thick,->] (3) -- (4);\n\\path[draw,thick,->] (4) -- (5);\n\n\\path[draw,thick,->] (1) -- (6);\n\\path[draw,thick,->] (6) -- (7);\n\\path[draw,thick,->] (7) -- (8);\n\\path[draw,thick,->] (8) -- (9);\n\\end{tikzpicture}\n\\end{center}\n\nAny path from the root node to a leaf contains\n$O(\\log n)$ nodes,\nso each operation adds at most $O(\\log n)$\nnew nodes to the tree.\nThus, after $k$ operations, the tree contains\nat most $O(k \\log n)$ nodes.\n\nNote that if we know all elements to be updated\nat the beginning of the algorithm,\na dynamic segment tree is not necessary,\nbecause we can use an ordinary segment tree with\nindex compression (Chapter 9.4).\nHowever, this is not possible when the indices\nare generated during the algorithm.\n\n\\subsubsection{Persistent segment trees}\n\n\\index{persistent segment tree}\n\nUsing a dynamic implementation,\nit is also possible to create a\n\\key{persistent segment tree} that stores\nthe \\emph{modification history} of the tree.\nIn such an implementation, we can\nefficiently access\nall versions of the tree that have\nexisted during the algorithm.\n\nWhen the modification history is available,\nwe can perform queries in any previous tree\nlike in an ordinary segment tree, because the\nfull structure of each tree is stored.\nWe can also create new trees based on previous\ntrees and modify them independently.\n\nConsider the following sequence of updates,\nwhere red nodes change\nand other nodes remain the same:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.8]\n\\node[draw, circle,minimum size=13pt] (1a) at (3,0) {};\n\\node[draw, circle,minimum size=13pt] (2a) at (2,-1) {};\n\\node[draw, circle,minimum size=13pt] (3a) at (4,-1) {};\n\\node[draw, circle,minimum size=13pt] (4a) at (1.5,-2) {};\n\\node[draw, circle,minimum size=13pt] (5a) at (2.5,-2) {};\n\\node[draw, circle,minimum size=13pt] (6a) at (3.5,-2) {};\n\\node[draw, circle,minimum size=13pt] (7a) at (4.5,-2) {};\n\\path[draw,thick,->] (1a) -- (2a);\n\\path[draw,thick,->] (1a) -- (3a);\n\\path[draw,thick,->] (2a) -- (4a);\n\\path[draw,thick,->] (2a) -- (5a);\n\\path[draw,thick,->] (3a) -- (6a);\n\\path[draw,thick,->] (3a) -- (7a);\n\n\\node[draw, circle,minimum size=13pt,fill=red] (1b) at (3+5,0) {};\n\\node[draw, circle,minimum size=13pt,fill=red] (2b) at (2+5,-1) {};\n\\node[draw, circle,minimum size=13pt] (3b) at (4+5,-1) {};\n\\node[draw, circle,minimum size=13pt] (4b) at (1.5+5,-2) {};\n\\node[draw, circle,minimum size=13pt,fill=red] (5b) at (2.5+5,-2) {};\n\\node[draw, circle,minimum size=13pt] (6b) at (3.5+5,-2) {};\n\\node[draw, circle,minimum size=13pt] (7b) at (4.5+5,-2) {};\n\\path[draw,thick,->] (1b) -- (2b);\n\\path[draw,thick,->] (1b) -- (3b);\n\\path[draw,thick,->] (2b) -- (4b);\n\\path[draw,thick,->] (2b) -- (5b);\n\\path[draw,thick,->] (3b) -- (6b);\n\\path[draw,thick,->] (3b) -- (7b);\n\n\\node[draw, circle,minimum size=13pt,fill=red] (1c) at (3+10,0) {};\n\\node[draw, circle,minimum size=13pt] (2c) at (2+10,-1) {};\n\\node[draw, circle,minimum size=13pt,fill=red] (3c) at (4+10,-1) {};\n\\node[draw, circle,minimum size=13pt] (4c) at (1.5+10,-2) {};\n\\node[draw, circle,minimum size=13pt] (5c) at (2.5+10,-2) {};\n\\node[draw, circle,minimum size=13pt] (6c) at (3.5+10,-2) {};\n\\node[draw, circle,minimum size=13pt,fill=red] (7c) at (4.5+10,-2) {};\n\\path[draw,thick,->] (1c) -- (2c);\n\\path[draw,thick,->] (1c) -- (3c);\n\\path[draw,thick,->] (2c) -- (4c);\n\\path[draw,thick,->] (2c) -- (5c);\n\\path[draw,thick,->] (3c) -- (6c);\n\\path[draw,thick,->] (3c) -- (7c);\n\n\\node at (3,-3) {step 1};\n\\node at (3+5,-3) {step 2};\n\\node at (3+10,-3) {step 3};\n\\end{tikzpicture}\n\\end{center}\nAfter each update, most nodes of the tree\nremain the same,\nso an efficient way to store the modification history\nis to represent each tree in the history as a combination\nof new nodes and subtrees of previous trees.\nIn this example, the modification history can be\nstored as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.8]\n\\path[use as bounding box] (0, 1) rectangle (16, -3.5);\n\n\\node[draw, circle,minimum size=13pt] (1a) at (3,0) {};\n\\node[draw, circle,minimum size=13pt] (2a) at (2,-1) {};\n\\node[draw, circle,minimum size=13pt] (3a) at (4,-1) {};\n\\node[draw, circle,minimum size=13pt] (4a) at (1.5,-2) {};\n\\node[draw, circle,minimum size=13pt] (5a) at (2.5,-2) {};\n\\node[draw, circle,minimum size=13pt] (6a) at (3.5,-2) {};\n\\node[draw, circle,minimum size=13pt] (7a) at (4.5,-2) {};\n\\path[draw,thick,->] (1a) -- (2a);\n\\path[draw,thick,->] (1a) -- (3a);\n\\path[draw,thick,->] (2a) -- (4a);\n\\path[draw,thick,->] (2a) -- (5a);\n\\path[draw,thick,->] (3a) -- (6a);\n\\path[draw,thick,->] (3a) -- (7a);\n\n\\node[draw, circle,minimum size=13pt,fill=red] (1b) at (3+5,0) {};\n\\node[draw, circle,minimum size=13pt,fill=red] (2b) at (2+5,-1) {};\n\\node[draw, circle,minimum size=13pt,fill=red] (5b) at (2.5+5,-2) {};\n\\path[draw,thick,->] (1b) -- (2b);\n\n\\draw[thick,->] (1b) .. controls (3+5+2,0-1) and (3+5,2.5) .. (3a);\n\n\\draw[thick,->] (2b) .. controls (2+5-0.5,-1-0.5) and (2,4.5) .. (4a);\n\n\n\\path[draw,thick,->] (2b) -- (5b);\n\n\\node[draw, circle,minimum size=13pt,fill=red] (1c) at (3+10,0) {};\n\\node[draw, circle,minimum size=13pt,fill=red] (3c) at (4+10,-1) {};\n\\node[draw, circle,minimum size=13pt,fill=red] (7c) at (4.5+10,-2) {};\n\\path[draw,thick,->] (1c) -- (2b);\n\\path[draw,thick,->] (1c) -- (3c);\n\n\\draw[thick,->] (3c) .. controls (2.5+5,-3) and (3.5,-3) .. (6a);\n\n\\path[draw,thick,->] (3c) -- (7c);\n\n\\node at (3,-3) {step 1};\n\\node at (3+5,-3) {step 2};\n\\node at (3+10,-3) {step 3};\n\\end{tikzpicture}\n\\end{center}\n\nThe structure of each previous tree can be\nreconstructed by following the pointers\nstarting at the corresponding root node.\nSince each operation\nadds only $O(\\log n)$ new nodes to the tree,\nit is possible to store the full modification history of the tree.\n\n", "chapter_name": "Segment trees revisited", "chapter_path": "cphb/chapter28.tex"}, {"section_name": "Data structures", "section_content": "\\section{Data structures}\n\nInstead of single values, nodes in a segment tree\ncan also contain \\emph{data structures} that maintain information\nabout the corresponding ranges.\nIn such a tree, the operations take\n$O(f(n) \\log n)$ time, where $f(n)$ is\nthe time needed for processing a single node during an operation.\n\nAs an example, consider a segment tree that\nsupports queries of the form\n''how many times does an element $x$ appear\nin the range $[a,b]$?''\nFor example, the element 1 appears three times\nin the following range:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\fill[lightgray] (1,0) rectangle (6,1);\n\\draw (0,0) grid (8,1);\n\n\\node[anchor=center] at (0.5, 0.5) {3};\n\\node[anchor=center] at (1.5, 0.5) {1};\n\\node[anchor=center] at (2.5, 0.5) {2};\n\\node[anchor=center] at (3.5, 0.5) {3};\n\\node[anchor=center] at (4.5, 0.5) {1};\n\\node[anchor=center] at (5.5, 0.5) {1};\n\\node[anchor=center] at (6.5, 0.5) {1};\n\\node[anchor=center] at (7.5, 0.5) {2};\n\\end{tikzpicture}\n\\end{center}\n\nTo support such queries, we build a segment tree\nwhere each node is assigned a data structure\nthat can be asked how many times any element $x$\nappears in the corresponding range.\nUsing this tree,\nthe answer to a query can be calculated\nby combining the results from the nodes\nthat belong to the range.\n\nFor example, the following segment tree\ncorresponds to the above array:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\n\\node[draw, rectangle] (a) at (1,2.5)\n{\n\\footnotesize\n\\begin{tabular}{r}\n3 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\\node[draw, rectangle] (b) at (3,2.5)\n{\n\\footnotesize\n\\begin{tabular}{r}\n1 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\\node[draw, rectangle] (c) at (5,2.5)\n{\n\\footnotesize\n\\begin{tabular}{r}\n2 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\\node[draw, rectangle] (d) at (7,2.5)\n{\n\\footnotesize\n\\begin{tabular}{r}\n3 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\\node[draw, rectangle] (e) at (9,2.5)\n{\n\\footnotesize\n\\begin{tabular}{r}\n1 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\\node[draw, rectangle] (f) at (11,2.5)\n{\n\\footnotesize\n\\begin{tabular}{r}\n1 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\\node[draw, rectangle] (g) at (13,2.5)\n{\n\\footnotesize\n\\begin{tabular}{r}\n1 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\\node[draw, rectangle] (h) at (15,2.5)\n{\n\\footnotesize\n\\begin{tabular}{r}\n2 \\\\\n\\hline\n1 \\\\\n\\end{tabular}};\n\n\\node[draw, rectangle] (i) at (2,4.5)\n{\n\\footnotesize\n\\begin{tabular}{rr}\n1 & 3 \\\\\n\\hline\n1 & 1 \\\\\n\\end{tabular}};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\node[draw, rectangle] (j) at (6,4.5)\n{\n\\footnotesize\n\\begin{tabular}{rr}\n2 & 3 \\\\\n\\hline\n1 & 1 \\\\\n\\end{tabular}};\n\\path[draw,thick,-] (j) -- (c);\n\\path[draw,thick,-] (j) -- (d);\n\\node[draw, rectangle] (k) at (10,4.5)\n{\n\\footnotesize\n\\begin{tabular}{r}\n1 \\\\\n\\hline\n2 \\\\\n\\end{tabular}};\n\\path[draw,thick,-] (k) -- (e);\n\\path[draw,thick,-] (k) -- (f);\n\\node[draw, rectangle] (l) at (14,4.5)\n{\n\\footnotesize\n\\begin{tabular}{rr}\n1 & 2 \\\\\n\\hline\n1 & 1 \\\\\n\\end{tabular}};\n\\path[draw,thick,-] (l) -- (g);\n\\path[draw,thick,-] (l) -- (h);\n\n\\node[draw, rectangle] (m) at (4,6.5)\n{\n\\footnotesize\n\\begin{tabular}{rrr}\n1 & 2 & 3 \\\\\n\\hline\n1 & 1 & 2 \\\\\n\\end{tabular}};\n\\path[draw,thick,-] (m) -- (i);\n\\path[draw,thick,-] (m) -- (j);\n\\node[draw, rectangle] (n) at (12,6.5)\n{\n\\footnotesize\n\\begin{tabular}{rr}\n1 & 2 \\\\\n\\hline\n3 & 1 \\\\\n\\end{tabular}};\n\\path[draw,thick,-] (n) -- (k);\n\\path[draw,thick,-] (n) -- (l);\n\n\\node[draw, rectangle] (o) at (8,8.5)\n{\n\\footnotesize\n\\begin{tabular}{rrr}\n1 & 2 & 3 \\\\\n\\hline\n4 & 2 & 2 \\\\\n\\end{tabular}};\n\\path[draw,thick,-] (o) -- (m);\n\\path[draw,thick,-] (o) -- (n);\n\\end{tikzpicture}\n\\end{center}\n\nWe can build the tree so\nthat each node contains a \\texttt{map} structure.\nIn this case, the time needed for processing each\nnode is $O(\\log n)$, so the total time complexity\nof a query is $O(\\log^2 n)$.\nThe tree uses $O(n \\log n)$ memory,\nbecause there are $O(\\log n)$ levels\nand each level contains\n$O(n)$ elements.\n\n", "chapter_name": "Segment trees revisited", "chapter_path": "cphb/chapter28.tex"}, {"section_name": "Two-dimensionality", "section_content": "\\section{Two-dimensionality}\n\n\\index{two-dimensional segment tree}\n\nA \\key{two-dimensional segment tree} supports\nqueries related to rectangular subarrays\nof a two-dimensional array.\nSuch a tree can be implemented as\nnested segment trees: a big tree corresponds to the\nrows of the array, and each node contains a small tree\nthat corresponds to a column.\n\nFor example, in the array\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) grid (4,4);\n\n\\node[anchor=center] at (0.5, 0.5) {8};\n\\node[anchor=center] at (1.5, 0.5) {5};\n\\node[anchor=center] at (2.5, 0.5) {3};\n\\node[anchor=center] at (3.5, 0.5) {8};\n\n\\node[anchor=center] at (0.5, 1.5) {3};\n\\node[anchor=center] at (1.5, 1.5) {9};\n\\node[anchor=center] at (2.5, 1.5) {7};\n\\node[anchor=center] at (3.5, 1.5) {1};\n\n\\node[anchor=center] at (0.5, 2.5) {8};\n\\node[anchor=center] at (1.5, 2.5) {7};\n\\node[anchor=center] at (2.5, 2.5) {5};\n\\node[anchor=center] at (3.5, 2.5) {2};\n\n\\node[anchor=center] at (0.5, 3.5) {7};\n\\node[anchor=center] at (1.5, 3.5) {6};\n\\node[anchor=center] at (2.5, 3.5) {1};\n\\node[anchor=center] at (3.5, 3.5) {6};\n\\end{tikzpicture}\n\\end{center}\nthe sum of any subarray\ncan be calculated\nfrom the following segment tree:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.4]\n\\footnotesize\n\\begin{scope}[shift={(-12,0)}]\n\\draw (-1,-1) rectangle (5,6);\n\\draw (0,0) grid (4,1);\n\\node[anchor=center,scale=0.8] at (0.5, 0.5) {7};\n\\node[anchor=center,scale=0.8] at (1.5, 0.5) {6};\n\\node[anchor=center,scale=0.8] at (2.5, 0.5) {1};\n\\node[anchor=center,scale=0.8] at (3.5, 0.5) {6};\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (a) at (1,2.5) {13};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,scale=0.8,inner sep=2.5pt] (b) at (3,2.5) {7};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (i) at (2,4.5) {20};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\end{scope}\n\\begin{scope}[shift={(-4,0)}]\n\\draw (-1,-1) rectangle (5,6);\n\\draw (0,0) grid (4,1);\n\\node[anchor=center,scale=0.8] at (0.5, 0.5) {8};\n\\node[anchor=center,scale=0.8] at (1.5, 0.5) {7};\n\\node[anchor=center,scale=0.8] at (2.5, 0.5) {5};\n\\node[anchor=center,scale=0.8] at (3.5, 0.5) {2};\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (a) at (1,2.5) {15};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,scale=0.8,inner sep=2.5pt] (b) at (3,2.5) {7};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (i) at (2,4.5) {22};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\end{scope}\n\\begin{scope}[shift={(4,0)}]\n\\draw (-1,-1) rectangle (5,6);\n\\draw (0,0) grid (4,1);\n\\node[anchor=center,scale=0.8] at (0.5, 0.5) {3};\n\\node[anchor=center,scale=0.8] at (1.5, 0.5) {9};\n\\node[anchor=center,scale=0.8] at (2.5, 0.5) {7};\n\\node[anchor=center,scale=0.8] at (3.5, 0.5) {1};\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (a) at (1,2.5) {12};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,scale=0.8,inner sep=2.5pt] (b) at (3,2.5) {8};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (i) at (2,4.5) {20};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\end{scope}\n\\begin{scope}[shift={(12,0)}]\n\\draw (-1,-1) rectangle (5,6);\n\\draw (0,0) grid (4,1);\n\\node[anchor=center,scale=0.8] at (0.5, 0.5) {8};\n\\node[anchor=center,scale=0.8] at (1.5, 0.5) {5};\n\\node[anchor=center,scale=0.8] at (2.5, 0.5) {3};\n\\node[anchor=center,scale=0.8] at (3.5, 0.5) {8};\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (a) at (1,2.5) {13};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,scale=0.8,inner sep=1pt] (b) at (3,2.5) {11};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (i) at (2,4.5) {24};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\end{scope}\n\\begin{scope}[shift={(-8,10)}]\n\\draw (-1,-1) rectangle (5,6);\n\\draw (0,0) grid (4,1);\n\\node[anchor=center,scale=0.8] at (0.5, 0.5) {15};\n\\node[anchor=center,scale=0.8] at (1.5, 0.5) {13};\n\\node[anchor=center,scale=0.8] at (2.5, 0.5) {6};\n\\node[anchor=center,scale=0.8] at (3.5, 0.5) {8};\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (a) at (1,2.5) {28};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,scale=0.8,inner sep=1pt] (b) at (3,2.5) {14};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (i) at (2,4.5) {42};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\end{scope}\n\\begin{scope}[shift={(8,10)}]\n\\draw (-1,-1) rectangle (5,6);\n\\draw (0,0) grid (4,1);\n\\node[anchor=center,scale=0.8] at (0.5, 0.5) {11};\n\\node[anchor=center,scale=0.8] at (1.5, 0.5) {14};\n\\node[anchor=center,scale=0.8] at (2.5, 0.5) {10};\n\\node[anchor=center,scale=0.8] at (3.5, 0.5) {9};\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (a) at (1,2.5) {25};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,scale=0.8,inner sep=1pt] (b) at (3,2.5) {19};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (i) at (2,4.5) {44};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\end{scope}\n\\begin{scope}[shift={(0,20)}]\n\\draw (-1,-1) rectangle (5,6);\n\\draw (0,0) grid (4,1);\n\\node[anchor=center,scale=0.8] at (0.5, 0.5) {26};\n\\node[anchor=center,scale=0.8] at (1.5, 0.5) {27};\n\\node[anchor=center,scale=0.8] at (2.5, 0.5) {16};\n\\node[anchor=center,scale=0.8] at (3.5, 0.5) {17};\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (a) at (1,2.5) {53};\n\\path[draw,thick,-] (a) -- (0.5,1);\n\\path[draw,thick,-] (a) -- (1.5,1);\n\\node[draw, circle,scale=0.8,inner sep=1pt] (b) at (3,2.5) {33};\n\\path[draw,thick,-] (b) -- (2.5,1);\n\\path[draw,thick,-] (b) -- (3.5,1);\n\n\\node[draw, circle,scale=0.8,inner sep=1pt] (i) at (2,4.5) {86};\n\\path[draw,thick,-] (i) -- (a);\n\\path[draw,thick,-] (i) -- (b);\n\\end{scope}\n\\path[draw,thick,-] (2,19) -- (-6,16);\n\\path[draw,thick,-] (2,19) -- (10,16);\n\\path[draw,thick,-] (-6,9) -- (-10,6);\n\\path[draw,thick,-] (-6,9) -- (-2,6);\n\\path[draw,thick,-] (10,9) -- (6,6);\n\\path[draw,thick,-] (10,9) -- (14,6);\n\\end{tikzpicture}\n\\end{center}\n\nThe operations of a two-dimensional segment tree\ntake $O(\\log^2 n)$ time, because the big tree\nand each small tree consist of $O(\\log n)$ levels.\nThe tree requires $O(n^2)$ memory, because each\nsmall tree contains $O(n)$ values.\n", "chapter_name": "Segment trees revisited", "chapter_path": "cphb/chapter28.tex"}, {"section_name": "Complex numbers", "section_content": "\\chapter{Geometry}\n\n\\index{geometry}\n\nIn geometric problems, it is often challenging\nto find a way to approach the problem so that\nthe solution to the problem can be conveniently implemented\nand the number of special cases is small.\n\nAs an example, consider a problem where\nwe are given the vertices of a quadrilateral\n(a polygon that has four vertices),\nand our task is to calculate its area.\nFor example, a possible input for the problem is as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.45]\n\n\\draw[fill] (6,2) circle [radius=0.1];\n\\draw[fill] (5,6) circle [radius=0.1];\n\\draw[fill] (2,5) circle [radius=0.1];\n\\draw[fill] (1,1) circle [radius=0.1];\n\\draw[thick] (6,2) -- (5,6) -- (2,5) -- (1,1) -- (6,2);\n\\end{tikzpicture}\n\\end{center}\nOne way to approach the problem is to divide\nthe quadrilateral into two triangles by a straight\nline between two opposite vertices:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.45]\n\n\\draw[fill] (6,2) circle [radius=0.1];\n\\draw[fill] (5,6) circle [radius=0.1];\n\\draw[fill] (2,5) circle [radius=0.1];\n\\draw[fill] (1,1) circle [radius=0.1];\n\n\\draw[thick] (6,2) -- (5,6) -- (2,5) -- (1,1) -- (6,2);\n\\draw[dashed,thick] (2,5) -- (6,2);\n\\end{tikzpicture}\n\\end{center}\nAfter this, it suffices to sum the areas\nof the triangles.\nThe area of a triangle can be calculated,\nfor example, using \\key{Heron's formula}\n%\\footnote{Heron of Alexandria (c. 10--70) was a Greek mathematician.}\n\\[ \\sqrt{s (s-a) (s-b) (s-c)},\\]\nwhere $a$, $b$ and $c$ are the lengths\nof the triangle's sides and\n$s=(a+b+c)/2$.\n\\index{Heron's formula}\n\nThis is a possible way to solve the problem,\nbut there is one pitfall:\nhow to divide the quadrilateral into triangles?\nIt turns out that sometimes we cannot just pick\ntwo arbitrary opposite vertices.\nFor example, in the following situation,\nthe division line is \\emph{outside} the quadrilateral:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.45]\n\n\\draw[fill] (6,2) circle [radius=0.1];\n\\draw[fill] (3,2) circle [radius=0.1];\n\\draw[fill] (2,5) circle [radius=0.1];\n\\draw[fill] (1,1) circle [radius=0.1];\n\\draw[thick] (6,2) -- (3,2) -- (2,5) -- (1,1) -- (6,2);\n\n\\draw[dashed,thick] (2,5) -- (6,2);\n\\end{tikzpicture}\n\\end{center}\nHowever, another way to draw the line works:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.45]\n\n\\draw[fill] (6,2) circle [radius=0.1];\n\\draw[fill] (3,2) circle [radius=0.1];\n\\draw[fill] (2,5) circle [radius=0.1];\n\\draw[fill] (1,1) circle [radius=0.1];\n\\draw[thick] (6,2) -- (3,2) -- (2,5) -- (1,1) -- (6,2);\n\n\\draw[dashed,thick] (3,2) -- (1,1);\n\\end{tikzpicture}\n\\end{center}\nIt is clear for a human which of the lines is the correct\nchoice, but the situation is difficult for a computer.\n                           \nHowever, it turns out that we can solve the problem using\nanother method that is more convenient to a programmer.\nNamely, there is a general formula\n\\[x_1y_2-x_2y_1+x_2y_3-x_3y_2+x_3y_4-x_4y_3+x_4y_1-x_1y_4,\\]\nthat calculates the area of a quadrilateral\nwhose vertices are\n$(x_1,y_1)$,\n$(x_2,y_2)$,\n$(x_3,y_3)$ and\n$(x_4,y_4)$.\nThis formula is easy to implement, there are no special\ncases, and we can even generalize the formula\nto \\emph{all} polygons.\n\n\\section{Complex numbers}\n\n\\index{complex number}\n\\index{point}\n\\index{vector}\n\nA \\key{complex number} is a number of the form $x+y i$,\nwhere $i = \\sqrt{-1}$ is the \\key{imaginary unit}.\nA geometric interpretation of a complex number is\nthat it represents a two-dimensional point $(x,y)$\nor a vector from the origin to a point $(x,y)$.\n\nFor example, $4+2i$ corresponds to the\nfollowing point and vector:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.45]\n\n\\draw[->,thick] (-5,0)--(5,0);\n\\draw[->,thick] (0,-5)--(0,5);\n\n\\draw[fill] (4,2) circle [radius=0.1];\n\\draw[->,thick] (0,0)--(4-0.1,2-0.1);\n\n\\node at (4,2.8) {$(4,2)$};\n\\end{tikzpicture}\n\\end{center}\n\n\\index{complex@\\texttt{complex}}\n\nThe C++ complex number class \\texttt{complex} is\nuseful when solving geometric problems.\nUsing the class we can represent points and vectors\nas complex numbers, and the class contains tools\nthat are useful in geometry.\n\nIn the following code, \\texttt{C} is the type of\na coordinate and \\texttt{P} is the type of a point or a vector.\nIn addition, the code defines macros \\texttt{X} and \\texttt{Y}\nthat can be used to refer to x and y coordinates.\n\n\\begin{lstlisting}\ntypedef long long C;\ntypedef complex<C> P;\n#define X real()\n#define Y imag()\n\\end{lstlisting}\n\nFor example, the following code defines a point $p=(4,2)$\nand prints its x and y coordinates:\n\n\\begin{lstlisting}\nP p = {4,2};\ncout << p.X << \" \" << p.Y << \"\\n\"; // 4 2\n\\end{lstlisting}\n\nThe following code defines vectors $v=(3,1)$ and $u=(2,2)$,\nand after that calculates the sum $s=v+u$.\n\n\\begin{lstlisting}\nP v = {3,1};\nP u = {2,2};\nP s = v+u;\ncout << s.X << \" \" << s.Y << \"\\n\"; // 5 3\n\\end{lstlisting}\n\nIn practice,\nan appropriate coordinate type is usually\n\\texttt{long long} (integer) or \\texttt{long double}\n(real number).\nIt is a good idea to use integer whenever possible,\nbecause calculations with integers are exact.\nIf real numbers are needed,\nprecision errors should be taken into account\nwhen comparing numbers.\nA safe way to check if real numbers $a$ and $b$ are equal\nis to compare them using $|a-b|<\\epsilon$,\nwhere $\\epsilon$ is a small number (for example, $\\epsilon=10^{-9}$).\n\n\\subsubsection*{Functions}\n\nIn the following examples, the coordinate type is\n\\texttt{long double}.\n\nThe function $\\texttt{abs}(v)$ calculates the length\n$|v|$ of a vector $v=(x,y)$\nusing the formula $\\sqrt{x^2+y^2}$.\nThe function can also be used for\ncalculating the distance between points\n$(x_1,y_1)$ and $(x_2,y_2)$,\nbecause that distance equals the length\nof the vector $(x_2-x_1,y_2-y_1)$.\n\nThe following code calculates the distance\nbetween points $(4,2)$ and $(3,-1)$:\n\\begin{lstlisting}\nP a = {4,2};\nP b = {3,-1};\ncout << abs(b-a) << \"\\n\"; // 3.16228\n\\end{lstlisting}\n\nThe function $\\texttt{arg}(v)$ calculates the\nangle of a vector $v=(x,y)$ with respect to the x axis.\nThe function gives the angle in radians,\nwhere $r$ radians equals $180 r/\\pi$ degrees.\nThe angle of a vector that points to the right is 0,\nand angles decrease clockwise and increase\ncounterclockwise.\n\nThe function $\\texttt{polar}(s,a)$ constructs a vector\nwhose length is $s$ and that points to an angle $a$.\nA vector can be rotated by an angle $a$\nby multiplying it by a vector with length 1 and angle $a$.\n\nThe following code calculates the angle of\nthe vector $(4,2)$, rotates it $1/2$ radians\ncounterclockwise, and then calculates the angle again:\n\n\\begin{lstlisting}\nP v = {4,2};\ncout << arg(v) << \"\\n\"; // 0.463648\nv *= polar(1.0,0.5);\ncout << arg(v) << \"\\n\"; // 0.963648\n\\end{lstlisting}\n\n", "chapter_name": "Geometry", "chapter_path": "cphb/chapter29.tex"}, {"section_name": "Points and lines", "section_content": "\\section{Points and lines}\n\n\\index{cross product}\n\nThe \\key{cross product} $a \\times b$ of vectors\n$a=(x_1,y_1)$ and $b=(x_2,y_2)$ is calculated\nusing the formula $x_1 y_2 - x_2 y_1$.\nThe cross product tells us whether $b$\nturns left (positive value), does not turn (zero)\nor turns right (negative value)\nwhen it is placed directly after $a$.\n\nThe following picture illustrates the above cases:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.45]\n\n\\draw[->,thick] (0,0)--(4,2);\n\\draw[->,thick] (4,2)--(4+1,2+2);\n\n\\node at (2.5,0.5) {$a$};\n\\node at (5,2.5) {$b$};\n\n\\node at (3,-2) {$a \\times b = 6$};\n\n\\draw[->,thick] (8+0,0)--(8+4,2);\n\\draw[->,thick] (8+4,2)--(8+4+2,2+1);\n\n\\node at (8+2.5,0.5) {$a$};\n\\node at (8+5,1.5) {$b$};\n\n\\node at (8+3,-2) {$a \\times b = 0$};\n\n\\draw[->,thick] (16+0,0)--(16+4,2);\n\\draw[->,thick] (16+4,2)--(16+4+2,2-1);\n\n\\node at (16+2.5,0.5) {$a$};\n\\node at (16+5,2.5) {$b$};\n\n\\node at (16+3,-2) {$a \\times b = -8$};\n\\end{tikzpicture}\n\\end{center}\n\n\\noindent\nFor example, in the first case\n$a=(4,2)$ and $b=(1,2)$.\nThe following code calculates the cross product\nusing the class \\texttt{complex}:\n\n\\begin{lstlisting}\nP a = {4,2};\nP b = {1,2};\nC p = (conj(a)*b).Y; // 6\n\\end{lstlisting}\n\nThe above code works, because\nthe function \\texttt{conj} negates the y coordinate\nof a vector,\nand when the vectors $(x_1,-y_1)$ and $(x_2,y_2)$\nare multiplied together, the y coordinate\nof the result is $x_1 y_2 - x_2 y_1$.\n\n\\subsubsection{Point location}\n\nCross products can be used to test\nwhether a point is located on the left or right\nside of a line.\nAssume that the line goes through points\n$s_1$ and $s_2$, we are looking from $s_1$\nto $s_2$ and the point is $p$.\n\nFor example, in the following picture,\n$p$ is on the left side of the line:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.45]\n\\draw[dashed,thick,->] (0,-3)--(12,6);\n\\draw[fill] (4,0) circle [radius=0.1];\n\\draw[fill] (8,3) circle [radius=0.1];\n\\draw[fill] (5,3) circle [radius=0.1];\n\\node at (4,-1) {$s_1$};\n\\node at (8,2) {$s_2$};\n\\node at (5,4) {$p$};\n\\end{tikzpicture}\n\\end{center}\n\nThe cross product $(p-s_1) \\times (p-s_2)$\ntells us the location of the point $p$.\nIf the cross product is positive,\n$p$ is located on the left side,\nand if the cross product is negative,\n$p$ is located on the right side.\nFinally, if the cross product is zero,\npoints $s_1$, $s_2$ and $p$ are on the same line.\n\n\\subsubsection{Line segment intersection}\n\n\\index{line segment intersection}\n\nNext we consider the problem of testing\nwhether two line segments\n$ab$ and $cd$ intersect. The possible cases are:\n\n\\textit{Case 1:}\nThe line segments are on the same line\nand they overlap each other.\nIn this case, there is an infinite number of\nintersection points.\nFor example, in the following picture,\nall points between $c$ and $b$ are\nintersection points:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\draw (1.5,1.5)--(6,3);\n\\draw (0,1)--(4.5,2.5);\n\\draw[fill] (0,1) circle [radius=0.05];\n\\node at (0,0.5) {$a$};\n\\draw[fill] (1.5,1.5) circle [radius=0.05];\n\\node at (6,2.5) {$d$};\n\\draw[fill] (4.5,2.5) circle [radius=0.05];\n\\node at (1.5,1) {$c$};\n\\draw[fill] (6,3) circle [radius=0.05];\n\\node at (4.5,2) {$b$};\n\\end{tikzpicture}\n\\end{center}\n\nIn this case, we can use cross products to\ncheck if all points are on the same line.\nAfter this, we can sort the points and check\nwhether the line segments overlap each other.\n\n\\textit{Case 2:}\nThe line segments have a common vertex\nthat is the only intersection point.\nFor example, in the following picture the\nintersection point is $b=c$:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\draw (0,0)--(4,2);\n\\draw (4,2)--(6,1);\n\\draw[fill] (0,0) circle [radius=0.05];\n\\draw[fill] (4,2) circle [radius=0.05];\n\\draw[fill] (6,1) circle [radius=0.05];\n\n\\node at (0,0.5) {$a$};\n\\node at (4,2.5) {$b=c$};\n\\node at (6,1.5) {$d$};\n\\end{tikzpicture}\n\\end{center}\n\nThis case is easy to check, because\nthere are only four possibilities\nfor the intersection point:\n$a=c$, $a=d$, $b=c$ and $b=d$.\n\n\\textit{Case 3:}\nThere is exactly one intersection point\nthat is not a vertex of any line segment.\nIn the following picture, the point $p$\nis the intersection point:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.9]\n\\draw (0,1)--(6,3);\n\\draw (2,4)--(4,0);\n\\draw[fill] (0,1) circle [radius=0.05];\n\\node at (0,0.5) {$c$};\n\\draw[fill] (6,3) circle [radius=0.05];\n\\node at (6,2.5) {$d$};\n\\draw[fill] (2,4) circle [radius=0.05];\n\\node at (1.5,3.5) {$a$};\n\\draw[fill] (4,0) circle [radius=0.05];\n\\node at (4,-0.4) {$b$};\n\\draw[fill] (3,2) circle [radius=0.05];\n\\node at (3,1.5) {$p$};\n\\end{tikzpicture}\n\\end{center}\n\nIn this case, the line segments intersect\nexactly when both points $c$ and $d$ are\non different sides of a line through $a$ and $b$,\nand points $a$ and $b$ are on different\nsides of a line through $c$ and $d$.\nWe can use cross products to check this.\n\n\\subsubsection{Point distance from a line}\n\nAnother feature of cross products is that\nthe area of a triangle can be calculated\nusing the formula\n\\[\\frac{| (a-c) \\times (b-c) |}{2},\\]\nwhere $a$, $b$ and $c$ are the vertices of the triangle.\nUsing this fact, we can derive a formula\nfor calculating the shortest distance between a point and a line.\nFor example, in the following picture $d$ is the\nshortest distance between the point $p$ and the line\nthat is defined by the points $s_1$ and $s_2$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.75]\n\\draw (-2,-1)--(6,3);\n\\draw[dashed] (1,4)--(2.40,1.2);\n\\node at (0,-0.5) {$s_1$};\n\\node at (4,1.5) {$s_2$};\n\\node at (0.5,4) {$p$};\n\\node at (2,2.7) {$d$};\n\\draw[fill] (0,0) circle [radius=0.05];\n\\draw[fill] (4,2) circle [radius=0.05];\n\\draw[fill] (1,4) circle [radius=0.05];\n\\end{tikzpicture}\n\\end{center}\n\nThe area of the triangle whose vertices are\n$s_1$, $s_2$ and $p$ can be calculated in two ways:\nit is both\n$\\frac{1}{2} |s_2-s_1| d$ and\n$\\frac{1}{2} ((s_1-p) \\times (s_2-p))$.\nThus, the shortest distance is\n\\[ d = \\frac{(s_1-p) \\times (s_2-p)}{|s_2-s_1|} .\\]\n\n\\subsubsection{Point inside a polygon}\n\nLet us now consider the problem of\ntesting whether a point is located inside or outside\na polygon.\nFor example, in the following picture point $a$\nis inside the polygon and point $b$ is outside\nthe polygon.\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.75]\n%\\draw (0,0)--(2,-2)--(3,1)--(5,1)--(2,3)--(1,2)--(-1,2)--(1,4)--(-2,4)--(-2,1)--(-3,3)--(-4,0)--(0,0);\n\\draw (0,0)--(2,2)--(5,1)--(2,3)--(1,2)--(-1,2)--(1,4)--(-2,4)--(-2,1)--(-3,3)--(-4,0)--(0,0);\n\n\\draw[fill] (-3,1) circle [radius=0.05];\n\\node at (-3,0.5) {$a$};\n\\draw[fill] (1,3) circle [radius=0.05];\n\\node at (1,2.5) {$b$};\n\\end{tikzpicture}\n\\end{center}\n\nA convenient way to solve the problem is to\nsend a \\emph{ray} from the point to an arbitrary direction\nand calculate the number of times it touches\nthe boundary of the polygon.\nIf the number is odd,\nthe point is inside the polygon,\nand if the number is even,\nthe point is outside the polygon.\n\n\\begin{samepage}\nFor example, we could send the following rays:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.75]\n\\draw (0,0)--(2,2)--(5,1)--(2,3)--(1,2)--(-1,2)--(1,4)--(-2,4)--(-2,1)--(-3,3)--(-4,0)--(0,0);\n\n\\draw[fill] (-3,1) circle [radius=0.05];\n\\node at (-3,0.5) {$a$};\n\\draw[fill] (1,3) circle [radius=0.05];\n\\node at (1,2.5) {$b$};\n\n\\draw[dashed,->] (-3,1)--(-6,0);\n\\draw[dashed,->] (-3,1)--(0,5);\n\n\\draw[dashed,->] (1,3)--(3.5,0);\n\\draw[dashed,->] (1,3)--(3,4);\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\nThe rays from $a$ touch 1 and 3 times\nthe boundary of the polygon,\nso $a$ is inside the polygon.\nCorrespondingly, the rays from $b$\ntouch 0 and 2 times the boundary of the polygon,\nso $b$ is outside the polygon.\n\n", "chapter_name": "Geometry", "chapter_path": "cphb/chapter29.tex"}, {"section_name": "Polygon area", "section_content": "\\section{Polygon area}\n\nA general formula for calculating the area\nof a polygon, sometimes called the \\key{shoelace formula},\nis as follows: \\index{shoelace formula}\n\\[\\frac{1}{2} |\\sum_{i=1}^{n-1} (p_i \\times p_{i+1})| =\n\\frac{1}{2} |\\sum_{i=1}^{n-1} (x_i y_{i+1} - x_{i+1} y_i)|, \\]\nHere the vertices are\n$p_1=(x_1,y_1)$, $p_2=(x_2,y_2)$, $\\ldots$, $p_n=(x_n,y_n)$\nin such an order that\n$p_i$ and $p_{i+1}$ are adjacent vertices on the boundary\nof the polygon,\nand the first and last vertex is the same, i.e., $p_1=p_n$.\n\nFor example, the area of the polygon\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\filldraw (4,1.4) circle (2pt);\n\\filldraw (7,3.4) circle (2pt);\n\\filldraw (5,5.4) circle (2pt);\n\\filldraw (2,4.4) circle (2pt);\n\\filldraw (4,3.4) circle (2pt);\n\\node (1) at (4,1) {(4,1)};\n\\node (2) at (7.2,3) {(7,3)};\n\\node (3) at (5,5.8) {(5,5)};\n\\node (4) at (2,4) {(2,4)};\n\\node (5) at (3.5,3) {(4,3)};\n\\path[draw] (4,1.4) -- (7,3.4) -- (5,5.4) -- (2,4.4) -- (4,3.4) -- (4,1.4);\n\\end{tikzpicture}\n\\end{center}\nis\n\\[\\frac{|(2\\cdot5-5\\cdot4)+(5\\cdot3-7\\cdot5)+(7\\cdot1-4\\cdot3)+(4\\cdot3-4\\cdot1)+(4\\cdot4-2\\cdot3)|}{2} = 17/2.\\]\n\nThe idea of the formula is to go through trapezoids\nwhose one side is a side of the polygon,\nand another side lies on the horizontal line $y=0$.\nFor example:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\path[draw,fill=lightgray] (5,5.4) -- (7,3.4) -- (7,0) -- (5,0) -- (5,5.4);\n\\filldraw (4,1.4) circle (2pt);\n\\filldraw (7,3.4) circle (2pt);\n\\filldraw (5,5.4) circle (2pt);\n\\filldraw (2,4.4) circle (2pt);\n\\filldraw (4,3.4) circle (2pt);\n\\node (1) at (4,1) {(4,1)};\n\\node (2) at (7.2,3) {(7,3)};\n\\node (3) at (5,5.8) {(5,5)};\n\\node (4) at (2,4) {(2,4)};\n\\node (5) at (3.5,3) {(4,3)};\n\\path[draw] (4,1.4) -- (7,3.4) -- (5,5.4) -- (2,4.4) -- (4,3.4) -- (4,1.4);\n\\draw (0,0) -- (10,0);\n\\end{tikzpicture}\n\\end{center}\nThe area of such a trapezoid is\n\\[(x_{i+1}-x_{i}) \\frac{y_i+y_{i+1}}{2},\\]\nwhere the vertices of the polygon are $p_i$ and $p_{i+1}$.\nIf $x_{i+1}>x_{i}$, the area is positive,\nand if $x_{i+1}<x_{i}$, the area is negative.\n\nThe area of the polygon is the sum of areas of\nall such trapezoids, which yields the formula\n\\[|\\sum_{i=1}^{n-1} (x_{i+1}-x_{i}) \\frac{y_i+y_{i+1}}{2}| =\n\\frac{1}{2} |\\sum_{i=1}^{n-1} (x_i y_{i+1} - x_{i+1} y_i)|.\\]\n\nNote that the absolute value of the sum is taken,\nbecause the value of the sum may be positive or negative,\ndepending on whether we walk clockwise or counterclockwise\nalong the boundary of the polygon.\n\n\\subsubsection{Pick's theorem}\n\n\\index{Pick's theorem}\n\n\\key{Pick's theorem} provides another way to calculate\nthe area of a polygon provided that all vertices \nof the polygon have integer coordinates.\nAccording to Pick's theorem, the area of the polygon is\n\\[ a + b/2 -1,\\]\nwhere $a$ is the number of integer points inside the polygon\nand $b$ is the number of integer points on the boundary of the polygon.\n\nFor example, the area of the polygon\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\filldraw (4,1.4) circle (2pt);\n\\filldraw (7,3.4) circle (2pt);\n\\filldraw (5,5.4) circle (2pt);\n\\filldraw (2,4.4) circle (2pt);\n\\filldraw (4,3.4) circle (2pt);\n\\node (1) at (4,1) {(4,1)};\n\\node (2) at (7.2,3) {(7,3)};\n\\node (3) at (5,5.8) {(5,5)};\n\\node (4) at (2,4) {(2,4)};\n\\node (5) at (3.5,3) {(4,3)};\n\\path[draw] (4,1.4) -- (7,3.4) -- (5,5.4) -- (2,4.4) -- (4,3.4) -- (4,1.4);\n\n\\filldraw (2,4.4) circle (2pt);\n\\filldraw (3,4.4) circle (2pt);\n\\filldraw (4,4.4) circle (2pt);\n\\filldraw (5,4.4) circle (2pt);\n\\filldraw (6,4.4) circle (2pt);\n\n\\filldraw (4,3.4) circle (2pt);\n\\filldraw (5,3.4) circle (2pt);\n\\filldraw (6,3.4) circle (2pt);\n\\filldraw (7,3.4) circle (2pt);\n\n\\filldraw (4,2.4) circle (2pt);\n\\filldraw (5,2.4) circle (2pt);\n\\end{tikzpicture}\n\\end{center}\nis $6+7/2-1=17/2$.\n\n", "chapter_name": "Geometry", "chapter_path": "cphb/chapter29.tex"}, {"section_name": "Distance functions", "section_content": "\\section{Distance functions}\n\n\\index{distance function}\n\\index{Euclidean distance}\n\\index{Manhattan distance}\n\nA \\key{distance function} defines the distance between\ntwo points.\nThe usual distance function is the\n\\key{Euclidean distance} where the distance between\npoints $(x_1,y_1)$ and $(x_2,y_2)$ is\n\\[\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}.\\]\nAn alternative distance function is the\n\\key{Manhattan distance}\nwhere the distance between points\n$(x_1,y_1)$ and $(x_2,y_2)$ is\n\\[|x_1-x_2|+|y_1-y_2|.\\]\n\\begin{samepage}\nFor example, consider the following picture:\n\\begin{center}\n\\begin{tikzpicture}\n\n\\draw[fill] (2,1) circle [radius=0.05];\n\\draw[fill] (5,2) circle [radius=0.05];\n\n\\node at (2,0.5) {$(2,1)$};\n\\node at (5,1.5) {$(5,2)$};\n\n\\draw[dashed] (2,1) -- (5,2);\n\n\\draw[fill] (5+2,1) circle [radius=0.05];\n\\draw[fill] (5+5,2) circle [radius=0.05];\n\n\\node at (5+2,0.5) {$(2,1)$};\n\\node at (5+5,1.5) {$(5,2)$};\n\n\\draw[dashed] (5+2,1) -- (5+2,2);\n\\draw[dashed] (5+2,2) -- (5+5,2);\n\n\\node at (3.5,-0.5) {Euclidean distance};\n\\node at (5+3.5,-0.5) {Manhattan distance};\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\nThe Euclidean distance between the points is\n\\[\\sqrt{(5-2)^2+(2-1)^2}=\\sqrt{10}\\]\nand the Manhattan distance is\n\\[|5-2|+|2-1|=4.\\]\nThe following picture shows regions that are within a distance of 1\nfrom the center point, using the Euclidean and Manhattan distances:\n\\begin{center}\n\\begin{tikzpicture}\n\n\\draw[fill=gray!20] (0,0) circle [radius=1];\n\\draw[fill] (0,0) circle [radius=0.05];\n\n\\node at (0,-1.5) {Euclidean distance};\n\n\\draw[fill=gray!20] (5+0,1) -- (5-1,0) -- (5+0,-1) -- (5+1,0) -- (5+0,1);\n\\draw[fill] (5,0) circle [radius=0.05];\n\\node at (5,-1.5) {Manhattan distance};\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection{Rotating coordinates}\n\nSome problems are easier to solve if\nManhattan distances are used instead of Euclidean distances.\nAs an example, consider a problem where we are given\n$n$ points in the two-dimensional plane\nand our task is to calculate the maximum Manhattan\ndistance between any two points.\n\nFor example, consider the following set of points:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.65]\n\\draw[color=gray] (-1,-1) grid (4,4);\n\n\\filldraw (0,2) circle (2.5pt);\n\\filldraw (3,3) circle (2.5pt);\n\\filldraw (1,0) circle (2.5pt);\n\\filldraw (3,1) circle (2.5pt);\n\n\\node at (0,1.5) {$A$};\n\\node at (3,2.5) {$C$};\n\\node at (1,-0.5) {$B$};\n\\node at (3,0.5) {$D$};\n\\end{tikzpicture}\n\\end{center}\nThe maximum Manhattan distance is 5\nbetween points $B$ and $C$:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.65]\n\\draw[color=gray] (-1,-1) grid (4,4);\n\n\\filldraw (0,2) circle (2.5pt);\n\\filldraw (3,3) circle (2.5pt);\n\\filldraw (1,0) circle (2.5pt);\n\\filldraw (3,1) circle (2.5pt);\n\n\\node at (0,1.5) {$A$};\n\\node at (3,2.5) {$C$};\n\\node at (1,-0.5) {$B$};\n\\node at (3,0.5) {$D$};\n\n\\path[draw=red,thick,line width=2pt] (1,0) -- (1,3) -- (3,3);\n\\end{tikzpicture}\n\\end{center}\n\nA useful technique related to Manhattan distances\nis to rotate all coordinates 45 degrees so that\na point $(x,y)$ becomes $(x+y,y-x)$.\nFor example, after rotating the above points,\nthe result is:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.6]\n\\draw[color=gray] (0,-3) grid (7,3);\n\n\\filldraw (2,2) circle (2.5pt);\n\\filldraw (6,0) circle (2.5pt);\n\\filldraw (1,-1) circle (2.5pt);\n\\filldraw (4,-2) circle (2.5pt);\n\n\\node at (2,1.5) {$A$};\n\\node at (6,-0.5) {$C$};\n\\node at (1,-1.5) {$B$};\n\\node at (4,-2.5) {$D$};\n\\end{tikzpicture}\n\\end{center}\nAnd the maximum distance is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.6]\n\\draw[color=gray] (0,-3) grid (7,3);\n\n\\filldraw (2,2) circle (2.5pt);\n\\filldraw (6,0) circle (2.5pt);\n\\filldraw (1,-1) circle (2.5pt);\n\\filldraw (4,-2) circle (2.5pt);\n\n\\node at (2,1.5) {$A$};\n\\node at (6,-0.5) {$C$};\n\\node at (1,-1.5) {$B$};\n\\node at (4,-2.5) {$D$};\n\n\\path[draw=red,thick,line width=2pt] (1,-1) -- (4,2) -- (6,0);\n\\end{tikzpicture}\n\\end{center}\n\nConsider two points $p_1=(x_1,y_1)$ and $p_2=(x_2,y_2)$ whose rotated\ncoordinates are $p'_1=(x'_1,y'_1)$ and $p'_2=(x'_2,y'_2)$.\nNow there are two ways to express the Manhattan distance\nbetween $p_1$ and $p_2$:\n\\[|x_1-x_2|+|y_1-y_2| = \\max(|x'_1-x'_2|,|y'_1-y'_2|)\\]\n\nFor example, if $p_1=(1,0)$ and $p_2=(3,3)$,\nthe rotated coordinates are $p'_1=(1,-1)$ and $p'_2=(6,0)$\nand the Manhattan distance is\n\\[|1-3|+|0-3| = \\max(|1-6|,|-1-0|) = 5.\\]\n\nThe rotated coordinates provide a simple way\nto operate with Manhattan distances, because we can\nconsider x and y coordinates separately.\nTo maximize the Manhattan distance between two points,\nwe should find two points whose\nrotated coordinates maximize the value of\n\\[\\max(|x'_1-x'_2|,|y'_1-y'_2|).\\]\nThis is easy, because either the horizontal or vertical\ndifference of the rotated coordinates has to be maximum.\n", "chapter_name": "Geometry", "chapter_path": "cphb/chapter29.tex"}, {"section_name": "Intersection points", "section_content": "\\chapter{Sweep line algorithms}\n\n\\index{sweep line}\n\nMany geometric problems can be solved using\n\\key{sweep line} algorithms.\nThe idea in such algorithms is to represent\nan instance of the problem as a set of events that correspond\nto points in the plane.\nThe events are processed in increasing order\naccording to their x or y coordinates.\n\nAs an example, consider the following problem:\nThere is a company that has $n$ employees,\nand we know for each employee their arrival and\nleaving times on a certain day.\nOur task is to calculate the maximum number of\nemployees that were in the office at the same time.\n\nThe problem can be solved by modeling the situation\nso that each employee is assigned two events that\ncorrespond to their arrival and leaving times.\nAfter sorting the events, we go through them\nand keep track of the number of people in the office.\nFor example, the table\n\\begin{center}\n\\begin{tabular}{ccc}\nperson & arrival time & leaving time \\\\\n\\hline\nJohn & 10 & 15 \\\\\nMaria & 6 & 12 \\\\\nPeter & 14 & 16 \\\\\nLisa & 5 & 13 \\\\\n\\end{tabular}\n\\end{center}\ncorresponds to the following events:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.6]\n\\draw (0,0) rectangle (17,-6.5);\n\\path[draw,thick,-] (10,-1) -- (15,-1);\n\\path[draw,thick,-] (6,-2.5) -- (12,-2.5);\n\\path[draw,thick,-] (14,-4) -- (16,-4);\n\\path[draw,thick,-] (5,-5.5) -- (13,-5.5);\n\n\\draw[fill] (10,-1) circle [radius=0.05];\n\\draw[fill] (15,-1) circle [radius=0.05];\n\\draw[fill] (6,-2.5) circle [radius=0.05];\n\\draw[fill] (12,-2.5) circle [radius=0.05];\n\\draw[fill] (14,-4) circle [radius=0.05];\n\\draw[fill] (16,-4) circle [radius=0.05];\n\\draw[fill] (5,-5.5) circle [radius=0.05];\n\\draw[fill] (13,-5.5) circle [radius=0.05];\n\n\\node at (2,-1) {John};\n\\node at (2,-2.5) {Maria};\n\\node at (2,-4) {Peter};\n\\node at (2,-5.5) {Lisa};\n\\end{tikzpicture}\n\\end{center}\nWe go through the events from left to right\nand maintain a counter.\nAlways when a person arrives, we increase\nthe value of the counter by one,\nand when a person leaves,\nwe decrease the value of the counter by one.\nThe answer to the problem is the maximum\nvalue of the counter during the algorithm.\n\nIn the example, the events are processed as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.6]\n\\path[draw,thick,->] (0.5,0.5) -- (16.5,0.5);\n\\draw (0,0) rectangle (17,-6.5);\n\\path[draw,thick,-] (10,-1) -- (15,-1);\n\\path[draw,thick,-] (6,-2.5) -- (12,-2.5);\n\\path[draw,thick,-] (14,-4) -- (16,-4);\n\\path[draw,thick,-] (5,-5.5) -- (13,-5.5);\n\n\\draw[fill] (10,-1) circle [radius=0.05];\n\\draw[fill] (15,-1) circle [radius=0.05];\n\\draw[fill] (6,-2.5) circle [radius=0.05];\n\\draw[fill] (12,-2.5) circle [radius=0.05];\n\\draw[fill] (14,-4) circle [radius=0.05];\n\\draw[fill] (16,-4) circle [radius=0.05];\n\\draw[fill] (5,-5.5) circle [radius=0.05];\n\\draw[fill] (13,-5.5) circle [radius=0.05];\n\n\\node at (2,-1) {John};\n\\node at (2,-2.5) {Maria};\n\\node at (2,-4) {Peter};\n\\node at (2,-5.5) {Lisa};\n\n\\path[draw,dashed] (10,0)--(10,-6.5);\n\\path[draw,dashed] (15,0)--(15,-6.5);\n\\path[draw,dashed] (6,0)--(6,-6.5);\n\\path[draw,dashed] (12,0)--(12,-6.5);\n\\path[draw,dashed] (14,0)--(14,-6.5);\n\\path[draw,dashed] (16,0)--(16,-6.5);\n\\path[draw,dashed] (5,0)--(5,-6.5);\n\\path[draw,dashed] (13,0)--(13,-6.5);\n\n\\node at (10,-7) {$+$};\n\\node at (15,-7) {$-$};\n\\node at (6,-7) {$+$};\n\\node at (12,-7) {$-$};\n\\node at (14,-7) {$+$};\n\\node at (16,-7) {$-$};\n\\node at (5,-7) {$+$};\n\\node at (13,-7) {$-$};\n\n\\node at (10,-8) {$3$};\n\\node at (15,-8) {$1$};\n\\node at (6,-8) {$2$};\n\\node at (12,-8) {$2$};\n\\node at (14,-8) {$2$};\n\\node at (16,-8) {$0$};\n\\node at (5,-8) {$1$};\n\\node at (13,-8) {$1$};\n\\end{tikzpicture}\n\\end{center}\nThe symbols $+$ and $-$ indicate whether the\nvalue of the counter increases or decreases,\nand the value of the counter is shown below.\nThe maximum value of the counter is 3\nbetween John's arrival and Maria's leaving.\n\nThe running time of the algorithm is $O(n \\log n)$,\nbecause sorting the events takes $O(n \\log n)$ time\nand the rest of the algorithm takes $O(n)$ time.\n\n\\section{Intersection points}\n\n\\index{intersection point}\n\nGiven a set of $n$ line segments, each of them being either\nhorizontal or vertical, consider the problem of\ncounting the total number of intersection points.\nFor example, when the line segments are\n\\begin{center}\n\\begin{tikzpicture}[scale=0.5]\n\\path[draw,thick,-] (0,2) -- (5,2);\n\\path[draw,thick,-] (1,4) -- (6,4);\n\\path[draw,thick,-] (6,3) -- (10,3);\n\\path[draw,thick,-] (2,1) -- (2,6);\n\\path[draw,thick,-] (8,2) -- (8,5);\n\\end{tikzpicture}\n\\end{center}\nthere are three intersection points:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.5]\n\\path[draw,thick,-] (0,2) -- (5,2);\n\\path[draw,thick,-] (1,4) -- (6,4);\n\\path[draw,thick,-] (6,3) -- (10,3);\n\\path[draw,thick,-] (2,1) -- (2,6);\n\\path[draw,thick,-] (8,2) -- (8,5);\n\n\\draw[fill] (2,2) circle [radius=0.15];\n\\draw[fill] (2,4) circle [radius=0.15];\n\\draw[fill] (8,3) circle [radius=0.15];\n\n\\end{tikzpicture}\n\\end{center}\n\nIt is easy to solve the problem in $O(n^2)$ time,\nbecause we can go through all possible pairs of line segments\nand check if they intersect.\nHowever, we can solve the problem more efficiently\nin $O(n \\log n)$ time using a sweep line algorithm\nand a range query data structure.\n\nThe idea is to process the endpoints of the line\nsegments from left to right and \nfocus on three types of events:\n\\begin{enumerate}[noitemsep]\n\\item[(1)] horizontal segment begins\n\\item[(2)] horizontal segment ends\n\\item[(3)] vertical segment\n\\end{enumerate}\n\nThe following events correspond to the example:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.6]\n\\path[draw,dashed] (0,2) -- (5,2);\n\\path[draw,dashed] (1,4) -- (6,4);\n\\path[draw,dashed] (6,3) -- (10,3);\n\\path[draw,dashed] (2,1) -- (2,6);\n\\path[draw,dashed] (8,2) -- (8,5);\n\n\\node at (0,2) {$1$};\n\\node at (5,2) {$2$};\n\\node at (1,4) {$1$};\n\\node at (6,4) {$2$};\n\\node at (6,3) {$1$};\n\\node at (10,3) {$2$};\n\n\\node at (2,3.5) {$3$};\n\\node at (8,3.5) {$3$};\n\\end{tikzpicture}\n\\end{center}\n\nWe go through the events from left to right\nand use a data structure that maintains a set of\ny coordinates where there is an active horizontal segment.\nAt event 1, we add the y coordinate of the segment\nto the set, and at event 2, we remove the\ny coordinate from the set.\n\nIntersection points are calculated at event 3.\nWhen there is a vertical segment between points\n$y_1$ and $y_2$, we count the number of active\nhorizontal segments whose y coordinate is between\n$y_1$ and $y_2$, and add this number to the total\nnumber of intersection points.\n\nTo store y coordinates of horizontal segments,\nwe can use a binary indexed or segment tree,\npossibly with index compression.\nWhen such structures are used, processing each event\ntakes $O(\\log n)$ time, so the total running\ntime of the algorithm is $O(n \\log n)$.\n\n", "chapter_name": "Sweep line algorithms", "chapter_path": "cphb/chapter30.tex"}, {"section_name": "Closest pair problem", "section_content": "\\section{Closest pair problem}\n\n\\index{closest pair}\n\nGiven a set of $n$ points, our next problem is\nto find two points whose Euclidean distance is minimum.\nFor example, if the points are\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0)--(12,0)--(12,4)--(0,4)--(0,0);\n\n\\draw (1,2) circle [radius=0.1];\n\\draw (3,1) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5.5,1.5) circle [radius=0.1];\n\\draw (6,2.5) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (9,1.5) circle [radius=0.1];\n\\draw (10,2) circle [radius=0.1];\n\\draw (1.5,3.5) circle [radius=0.1];\n\\draw (1.5,1) circle [radius=0.1];\n\\draw (2.5,3) circle [radius=0.1];\n\\draw (4.5,1.5) circle [radius=0.1];\n\\draw (5.25,0.5) circle [radius=0.1];\n\\draw (6.5,2) circle [radius=0.1];\n\\end{tikzpicture}\n\\end{center}\n\\begin{samepage}\nwe should find the following points:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0)--(12,0)--(12,4)--(0,4)--(0,0);\n\n\\draw (1,2) circle [radius=0.1];\n\\draw (3,1) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5.5,1.5) circle [radius=0.1];\n\\draw[fill] (6,2.5) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (9,1.5) circle [radius=0.1];\n\\draw (10,2) circle [radius=0.1];\n\\draw (1.5,3.5) circle [radius=0.1];\n\\draw (1.5,1) circle [radius=0.1];\n\\draw (2.5,3) circle [radius=0.1];\n\\draw (4.5,1.5) circle [radius=0.1];\n\\draw (5.25,0.5) circle [radius=0.1];\n\\draw[fill] (6.5,2) circle [radius=0.1];\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\n\nThis is another example of a problem\nthat can be solved in $O(n \\log n)$ time\nusing a sweep line algorithm\\footnote{Besides this approach,\nthere is also an\n$O(n \\log n)$ time divide-and-conquer algorithm \\cite{sha75}\nthat divides the points into two sets and recursively\nsolves the problem for both sets.}.\nWe go through the points from left to right\nand maintain a value $d$: the minimum distance\nbetween two points seen so far.\nAt each point, we find the nearest point to the left.\nIf the distance is less than $d$, it is the\nnew minimum distance and we update\nthe value of $d$.\n\nIf the current point is $(x,y)$\nand there is a point to the left\nwithin a distance of less than $d$,\nthe x coordinate of such a point must\nbe between $[x-d,x]$ and the y coordinate\nmust be between $[y-d,y+d]$.\nThus, it suffices to only consider points\nthat are located in those ranges,\nwhich makes the algorithm efficient.\n\nFor example, in the following picture, the\nregion marked with dashed lines contains\nthe points that can be within a distance of $d$\nfrom the active point:\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0)--(12,0)--(12,4)--(0,4)--(0,0);\n\n\\draw (1,2) circle [radius=0.1];\n\\draw (3,1) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5.5,1.5) circle [radius=0.1];\n\\draw (6,2.5) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (9,1.5) circle [radius=0.1];\n\\draw (10,2) circle [radius=0.1];\n\\draw (1.5,3.5) circle [radius=0.1];\n\\draw (1.5,1) circle [radius=0.1];\n\\draw (2.5,3) circle [radius=0.1];\n\\draw (4.5,1.5) circle [radius=0.1];\n\\draw (5.25,0.5) circle [radius=0.1];\n\\draw[fill] (6.5,2) circle [radius=0.1];\n\n\\draw[dashed] (6.5,0.75)--(6.5,3.25);\n\\draw[dashed] (5.25,0.75)--(5.25,3.25);\n\\draw[dashed] (5.25,0.75)--(6.5,0.75);\n\\draw[dashed] (5.25,3.25)--(6.5,3.25);\n\n\\draw [decoration={brace}, decorate, line width=0.3mm] (5.25,3.5) -- (6.5,3.5);\n\\node at (5.875,4) {$d$};\n\\draw [decoration={brace}, decorate, line width=0.3mm] (6.75,3.25) -- (6.75,2);\n\\node at (7.25,2.625) {$d$};\n\\end{tikzpicture}\n\\end{center}\n\nThe efficiency of the algorithm is based on the fact\nthat the region always contains\nonly $O(1)$ points.\nWe can go through those points in $O(\\log n)$ time\nby maintaining a set of points whose x coordinate\nis between $[x-d,x]$, in increasing order according\nto their y coordinates.\n\nThe time complexity of the algorithm is $O(n \\log n)$,\nbecause we go through $n$ points and\nfind for each point the nearest point to the left\nin $O(\\log n)$ time.\n\n", "chapter_name": "Sweep line algorithms", "chapter_path": "cphb/chapter30.tex"}, {"section_name": "Convex hull problem", "section_content": "\\section{Convex hull problem}\n\nA \\key{convex hull} is the smallest convex polygon\nthat contains all points of a given set.\nConvexity means that a line segment between\nany two vertices of the polygon is completely\ninside the polygon.\n\n\\begin{samepage}\nFor example, for the points\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\\end{tikzpicture}\n\\end{center}\n\\end{samepage}\nthe convex hull is as follows:\n\\begin{center}\n\\begin{tikzpicture}[scale=0.7]\n\\draw (0,0)--(4,-1)--(7,1)--(6,3)--(2,4)--(0,2)--(0,0);\n\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\\end{tikzpicture}\n\\end{center}\n\n\\index{Andrew's algorithm}\n\n\\key{Andrew's algorithm} \\cite{and79} provides\nan easy way to\nconstruct the convex hull for a set of points\nin $O(n \\log n)$ time.\nThe algorithm first locates the leftmost\nand rightmost points, and then\nconstructs the convex hull in two parts:\nfirst the upper hull and then the lower hull.\nBoth parts are similar, so we can focus on\nconstructing the upper hull.\n\nFirst, we sort the points primarily according to\nx coordinates and secondarily according to y coordinates.\nAfter this, we go through the points and\nadd each point to the hull.\nAlways after adding a point to the hull,\nwe make sure that the last line segment\nin the hull does not turn left.\nAs long as it turns left, we repeatedly remove the\nsecond last point from the hull.\n\nThe following pictures show how\nAndrew's algorithm works:\n\\\\\n\\begin{tabular}{ccccccc}\n\\\\\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(1,1);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(1,1)--(2,2);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,2);\n\\end{tikzpicture}\n\\\\\n1 & & 2 & & 3 & & 4 \\\\\n\\end{tabular}\n\\\\\n\\begin{tabular}{ccccccc}\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,2)--(2,4);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(3,2);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(3,2)--(4,-1);\n\\end{tikzpicture}\n\\\\\n5 & & 6 & & 7 & & 8 \\\\\n\\end{tabular}\n\\\\\n\\begin{tabular}{ccccccc}\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(3,2)--(4,-1)--(4,0);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(3,2)--(4,0);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(3,2)--(4,0)--(4,3);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(3,2)--(4,3);\n\\end{tikzpicture}\n\\\\\n9 & & 10 & & 11 & & 12 \\\\\n\\end{tabular}\n\\\\\n\\begin{tabular}{ccccccc}\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(4,3);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(4,3)--(5,2);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(4,3)--(5,2)--(6,1);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(4,3)--(5,2)--(6,1)--(6,3);\n\\end{tikzpicture}\n\\\\\n13 & & 14 & & 15 & & 16 \\\\\n\\end{tabular}\n\\\\\n\\begin{tabular}{ccccccc}\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(4,3)--(5,2)--(6,3);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(4,3)--(6,3);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(6,3);\n\\end{tikzpicture}\n& \\hspace{0.1cm} &\n\\begin{tikzpicture}[scale=0.3]\n\\draw (-1,-2)--(8,-2)--(8,5)--(-1,5)--(-1,-2);\n\\draw (0,0) circle [radius=0.1];\n\\draw (4,-1) circle [radius=0.1];\n\\draw (7,1) circle [radius=0.1];\n\\draw (6,3) circle [radius=0.1];\n\\draw (2,4) circle [radius=0.1];\n\\draw (0,2) circle [radius=0.1];\n\n\\draw (1,1) circle [radius=0.1];\n\\draw (2,2) circle [radius=0.1];\n\\draw (3,2) circle [radius=0.1];\n\\draw (4,0) circle [radius=0.1];\n\\draw (4,3) circle [radius=0.1];\n\\draw (5,2) circle [radius=0.1];\n\\draw (6,1) circle [radius=0.1];\n\n\\draw (0,0)--(0,2)--(2,4)--(6,3)--(7,1);\n\\end{tikzpicture}\n\\\\\n17 & & 18 & & 19 & & 20\n\\end{tabular}\n\n\n\n\n", "chapter_name": "Sweep line algorithms", "chapter_path": "cphb/chapter30.tex"}]